<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo-blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo-blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo-blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo-blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo-blog/css/main.css">


<link rel="stylesheet" href="/hexo-blog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cherryyang05.github.io","root":"/hexo-blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="mio是rust实现的一个轻量级的I&#x2F;O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。">
<meta property="og:type" content="website">
<meta property="og:title" content="Rust轻量级IO库">
<meta property="og:url" content="https://cherryyang05.github.io/hexo-blog/about/Rust%E8%BD%BB%E9%87%8F%E7%BA%A7IO%E5%BA%93.html">
<meta property="og:site_name" content="北极熊不吃企鹅宝宝">
<meta property="og:description" content="mio是rust实现的一个轻量级的I&#x2F;O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-28T13:46:25.000Z">
<meta property="article:modified_time" content="2024-09-09T15:45:13.561Z">
<meta property="article:author" content="Cherry">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="mio">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cherryyang05.github.io/hexo-blog/about/Rust%E8%BD%BB%E9%87%8F%E7%BA%A7IO%E5%BA%93.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Rust轻量级IO库 | 北极熊不吃企鹅宝宝
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/hexo-blog/atom.xml" title="北极熊不吃企鹅宝宝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo-blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">北极熊不吃企鹅宝宝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">为什么呢？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo-blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/hexo-blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo-blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/hexo-blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">56</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/hexo-blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/hexo-blog/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Rust轻量级IO库
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <p>mio是rust实现的一个轻量级的I/O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>，Windows下为IOCP，OS X下为<a target="_blank" rel="noopener" href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>。</p>
<span id="more"></span>
<h3 id="一、关于mio"><a href="#一、关于mio" class="headerlink" title="一、关于mio"></a>一、关于mio</h3><h4 id="1、重要特性"><a href="#1、重要特性" class="headerlink" title="1、重要特性"></a>1、重要特性</h4><ul>
<li>非阻塞TCP，UDP</li>
<li>I/O事件通知epoll,kqeue,IOCP实现</li>
<li>运行时零分配</li>
<li>平台可扩展</li>
</ul>
<h4 id="2、基础用法"><a href="#2、基础用法" class="headerlink" title="2、基础用法"></a>2、基础用法</h4><p>其使用方法与Linux中epoll差不多，mio底层封装了epoll，使用步骤思路：</p>
<ol>
<li>创建Poll</li>
<li>注册事件</li>
<li>事件循环等待与处理事件</li>
</ol>
<p>mio提供可跨平台的sytem selector访问，不同平台如下表，都可调用相同的API。不同平台使用的API开销不尽相同。由于mio是基于readiness(就绪状态)的API，与Linux epoll相似，可以看到很多API在Linux上都可以一对一映射。相比之下，Windows IOCP是基于完成（completion-based）而非基于就绪的API，所以两者间会有较多桥接。 同时mio提供自身版本的TcpListener、TcpStream、UdpSocket，这些API封装了底层平台相关API，并设为非阻塞且实现Evented trait。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>OS</th>
<th>Selector</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>epoll</td>
</tr>
<tr>
<td>OS X, iOS</td>
<td>kqueue</td>
</tr>
<tr>
<td>Windows</td>
<td>IOCP</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>kqueue</td>
</tr>
<tr>
<td>Android</td>
<td>epoll</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>mio实现的是一个单线程事件循环，并没有实现线程池及多线程事件循环，如果需要线程池及多线程事件循环等需要自己实现。</p>
</blockquote>
<h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><p>先给出mio的源码目录结构，只列出了关键的部分，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mio代码目录结构</span><br><span class="line">mio</span><br><span class="line">|---<span class="punctuation">-&gt;</span>test</span><br><span class="line">|---<span class="punctuation">-&gt;</span>src</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>deprecated			<span class="comment">//事件循环代码</span></span><br><span class="line">|-------------<span class="punctuation">-&gt;</span>event_loop.rs		<span class="comment">//EventLoop的实现，内部封装了Poll		【1】</span></span><br><span class="line">|-------------<span class="punctuation">-&gt;</span>handler.rs			<span class="comment">//供上层实现的接口</span></span><br><span class="line">|-------<span class="punctuation">-&gt;</span>net</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span><span class="keyword">mod</span>.rs</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span>tcp.rs</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span>udp.rs</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>sys						<span class="comment">//不同系统下的实现</span></span><br><span class="line">|-----------<span class="punctuation">-&gt;</span><span class="keyword">mod</span>.rs			</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span>fuchsia</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span>unix				<span class="comment">//Linux下封装的epoll</span></span><br><span class="line">|-----------------<span class="punctuation">-&gt;</span><span class="keyword">mod</span>.rs</span><br><span class="line">|-----------------<span class="punctuation">-&gt;</span>epoll.rs						【<span class="number">3</span>】</span><br><span class="line">|-----------------<span class="punctuation">-&gt;</span>awakener.rs</span><br><span class="line">|-----------<span class="punctuation">-&gt;</span>windows			<span class="comment">//windows下封装的iocp</span></span><br><span class="line">|-------<span class="punctuation">-&gt;</span>lib.rs	</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>poll.rs			<span class="comment">//定义Poll			【2】</span></span><br><span class="line">|-------<span class="punctuation">-&gt;</span>channel.rs		【<span class="number">4</span>】</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>event_imp.rs</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>timer.rs		【<span class="number">5</span>】</span><br><span class="line">|-------<span class="punctuation">-&gt;</span>......</span><br></pre></td></tr></table></figure>
<p>对涉及不同操作系统的部分代码，以Linux操作系统为例。在Linux操作系统中，mio封装了epoll。后面会给出相应的代码。</p>
<h4 id="【1】Eventloop代码分析"><a href="#【1】Eventloop代码分析" class="headerlink" title="【1】Eventloop代码分析"></a>【1】Eventloop代码分析</h4><p>结合前面的代码示例给出相应的关键代码如下：<br><code>EventLoop</code>事件循环定义，可以看到里面封装了<code>Poll</code>，以Linux系统举例，<code>Poll</code>又封装了<code>epoll</code>。在使用<code>Poll</code>或Linux中<code>epoll</code>时，最重要的代码是<code>epoll_wait()</code>等待事件<code>Event</code>并针对每个<code>Event</code>进行不同的处理。这里<code>EventLoop</code>将<code>epoll_create()</code>、<code>epoll_wait()</code>、<code>epoll_ctl()</code>进行进一步的封装，将对<code>Event</code>的处理抽象成<code>Handler</code>，供上层实现具体的逻辑处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single threaded IO event loop.		//这里是单线程事件循环，更多的时候我们需要加线程池，以此为基础，再进行一次封装，供上层使用</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EventLoop</span>&lt;H: Handler&gt; &#123;</span><br><span class="line">    run: <span class="type">bool</span>,</span><br><span class="line">    poll: Poll,		</span><br><span class="line">    events: Events,		<span class="comment">//对应epoll中的epoll_event</span></span><br><span class="line">    timer: Timer&lt;H::Timeout&gt;,</span><br><span class="line">    notify_tx: channel::SyncSender&lt;H::Message&gt;,</span><br><span class="line">    notify_rx: channel::Receiver&lt;H::Message&gt;,</span><br><span class="line">    config: Config,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象出接口供上层应用实现不同事件的逻辑处理。这里有点类似于回调函数，上层用户需要在此实现业务逻辑代码，实际运行时需要将函数指针传递给底层事件循环，底层事件循环运行时会调用用户传递过来的函数。在Rust中，可能描述的不是很精准，不过可以这样理解。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Handler</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Timeout</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Message</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when the socket represented by `token` is ready to be operated</span></span><br><span class="line">    <span class="comment">/// on. `events` indicates the specific operations that are</span></span><br><span class="line">    <span class="comment">/// ready to be performed.</span></span><br><span class="line">    <span class="comment">/// This function will only be invoked a single time per socket per event</span></span><br><span class="line">    <span class="comment">/// loop tick.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ready</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, token: Token, events: Ready) &#123;</span><br><span class="line">    &#125;		<span class="comment">//【1】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when a message has been received via the event loop&#x27;s channel.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, msg: <span class="keyword">Self</span>::Message) &#123;</span><br><span class="line">    &#125;		<span class="comment">//【2】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when a timeout has completed.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">timeout</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, timeout: <span class="keyword">Self</span>::Timeout) &#123;</span><br><span class="line">    &#125;		<span class="comment">//【3】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when `EventLoop` has been interrupted by a signal interrupt.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">interrupted</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">    &#125;		<span class="comment">//【4】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked at the end of an event loop tick.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tick</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">    &#125;		<span class="comment">//【5】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把<code>Poll</code>进行了封装，主要实现了<code>Eventloop::new()</code>——&gt;<code>Poll::new()</code>——&gt;<code>epoll_create()</code>，<code>Eventloop::run()</code>—-&gt;<code>Selecter::select()</code>——&gt;<code>epoll_wait()</code>，还有<code>register()</code>、<code>reregister()</code>、<code>deregister()</code>等等……</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;H: Handler&gt; EventLoop&lt;H&gt; &#123;</span><br><span class="line">    <span class="comment">/// Constructs a new `EventLoop` using the default configuration values.</span></span><br><span class="line">    <span class="comment">/// The `EventLoop` will not be running.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;EventLoop&lt;H&gt;&gt; &#123;</span><br><span class="line">        EventLoop::<span class="title function_ invoke__">configured</span>(Config::<span class="title function_ invoke__">default</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">configured</span>(config: Config) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;EventLoop&lt;H&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// Create the IO poller</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">poll</span> = Poll::<span class="title function_ invoke__">new</span>()?;		<span class="comment">//Linux内部调用epoll_create()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">timer</span> = timer::Builder::<span class="title function_ invoke__">default</span>()</span><br><span class="line">            .<span class="title function_ invoke__">tick_duration</span>(config.timer_tick)</span><br><span class="line">            .<span class="title function_ invoke__">num_slots</span>(config.timer_wheel_size)</span><br><span class="line">            .<span class="title function_ invoke__">capacity</span>(config.timer_capacity)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create cross thread notification queue</span></span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = channel::<span class="title function_ invoke__">sync_channel</span>(config.notify_capacity);  <span class="comment">//这里创建的是同步管道,可配置同步管道内部的buffer queue bound size.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the notification wakeup FD with the IO poller</span></span><br><span class="line">        poll.<span class="title function_ invoke__">register</span>(&amp;rx, NOTIFY, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>() | PollOpt::<span class="title function_ invoke__">oneshot</span>())?;	<span class="comment">//NOTIFY和TIMER由mio实现</span></span><br><span class="line">        poll.<span class="title function_ invoke__">register</span>(&amp;timer, TIMER, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>())?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(EventLoop &#123;</span><br><span class="line">            run: <span class="literal">true</span>,</span><br><span class="line">            poll: poll,</span><br><span class="line">            timer: timer,</span><br><span class="line">            notify_tx: tx,</span><br><span class="line">            notify_rx: rx,</span><br><span class="line">            config: config,</span><br><span class="line">            events: Events::<span class="title function_ invoke__">with_capacity</span>(<span class="number">1024</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Keep spinning the event loop indefinitely, and notify the handler whenever</span></span><br><span class="line">    <span class="comment">/// any of the registered handles are ready.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.run = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.run &#123;</span><br><span class="line">            <span class="comment">// Execute ticks as long as the event loop is running</span></span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">run_once</span>(handler, <span class="literal">None</span>)?;	<span class="comment">//Linux下调用epoll_wait()</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_once</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H, timeout: <span class="type">Option</span>&lt;Duration&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        trace!(<span class="string">&quot;event loop tick&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the registered IO handles for any new events. Each poll</span></span><br><span class="line">        <span class="comment">// is for one second, so a shutdown request can last as long as</span></span><br><span class="line">        <span class="comment">// one second before it takes effect.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">events</span> = <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">io_poll</span>(timeout) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(e) =&gt; e,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> err.<span class="title function_ invoke__">kind</span>() == io::ErrorKind::Interrupted &#123;</span><br><span class="line">                    handler.<span class="title function_ invoke__">interrupted</span>(<span class="keyword">self</span>);		<span class="comment">//调用Handler::interrupted() 【4】</span></span><br><span class="line">                    <span class="number">0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">io_process</span>(handler, events);	<span class="comment">//处理就绪的事件，handler为如何处理各种事件的实例</span></span><br><span class="line">        handler.<span class="title function_ invoke__">tick</span>(<span class="keyword">self</span>);	<span class="comment">//一轮事件处理后，最后调用Handler::tick()	调用【5】</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">io_poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, timeout: <span class="type">Option</span>&lt;Duration&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.poll.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.events, timeout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process IO events that have been previously polled</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">io_process</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H, cnt: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        trace!(<span class="string">&quot;io_process(..); cnt=&#123;&#125;; len=&#123;&#125;&quot;</span>, cnt, <span class="keyword">self</span>.events.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over the notifications. Each event provides the token</span></span><br><span class="line">        <span class="comment">// it was registered with (which usually represents, at least, the</span></span><br><span class="line">        <span class="comment">// handle that the event is about) as well as information about</span></span><br><span class="line">        <span class="comment">// what kind of event occurred (readable, writable, signal, etc.)</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; cnt &#123;		<span class="comment">//遍历所有就绪的事件，进行处理</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">evt</span> = <span class="keyword">self</span>.events.<span class="title function_ invoke__">get</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            trace!(<span class="string">&quot;event=&#123;:?&#125;; idx=&#123;:?&#125;&quot;</span>, evt, i);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// mio在epoll之上，增加了NOTIFY和TIMER</span></span><br><span class="line">            <span class="keyword">match</span> evt.<span class="title function_ invoke__">token</span>() &#123;</span><br><span class="line">                NOTIFY =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">notify</span>(handler),			<span class="comment">//channel处理 ，这个epoll中是没有的，mio实现</span></span><br><span class="line">                TIMER =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">timer_process</span>(handler),	<span class="comment">//Timer处理， 这个epoll中也是没有的，mio实现</span></span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">io_event</span>(handler, evt)		<span class="comment">//IO事件的处理， 这个epoll有</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">io_event</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H, evt: Event) &#123;</span><br><span class="line">        handler.<span class="title function_ invoke__">ready</span>(<span class="keyword">self</span>, evt.<span class="title function_ invoke__">token</span>(), evt.<span class="title function_ invoke__">readiness</span>());	<span class="comment">//调用Handler::ready() 【1】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="keyword">self</span>.config.messages_per_tick &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.notify_rx.<span class="title function_ invoke__">try_recv</span>() &#123;	<span class="comment">//从channel中接收数据，内部实现是std::sync::mpsc::sync_channel()</span></span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(msg) =&gt; handler.<span class="title function_ invoke__">notify</span>(<span class="keyword">self</span>, msg),	<span class="comment">//调用Handler::notify()	【2】</span></span><br><span class="line">                _ =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-register</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = <span class="keyword">self</span>.poll.<span class="title function_ invoke__">reregister</span>(&amp;<span class="keyword">self</span>.notify_rx, NOTIFY, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>() | PollOpt::<span class="title function_ invoke__">oneshot</span>());	<span class="comment">//PollOpt::oneshot(),必须重新reregister.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">timer_process</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, handler: &amp;<span class="keyword">mut</span> H) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(t) = <span class="keyword">self</span>.timer.<span class="title function_ invoke__">poll</span>() &#123;</span><br><span class="line">            handler.<span class="title function_ invoke__">timeout</span>(<span class="keyword">self</span>, t);	<span class="comment">//调用Handler::timeout() 【3】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Registers an IO handle with the event loop.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">        <span class="keyword">where</span> E: Evented</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.poll.<span class="title function_ invoke__">register</span>(io, token, interest, opt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Re-Registers an IO handle with the event loop.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reregister</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">        <span class="keyword">where</span> E: Evented</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.poll.<span class="title function_ invoke__">reregister</span>(io, token, interest, opt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Deregisters an IO handle with the event loop.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deregister</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, io: &amp;E) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; <span class="keyword">where</span> E: Evented &#123;</span><br><span class="line">        <span class="keyword">self</span>.poll.<span class="title function_ invoke__">deregister</span>(io)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns a sender that allows sending messages to the event loop in a</span></span><br><span class="line">    <span class="comment">/// thread-safe way, waking up the event loop if needed.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">channel</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Sender&lt;H::Message&gt; &#123;</span><br><span class="line">        Sender::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.notify_tx.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Schedules a timeout after the requested time interval. When the</span></span><br><span class="line">    <span class="comment">/// duration has been reached,</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">timeout</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, token: H::Timeout, delay: Duration) <span class="punctuation">-&gt;</span> timer::<span class="type">Result</span>&lt;Timeout&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.timer.<span class="title function_ invoke__">set_timeout</span>(delay, token)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// If the supplied timeout has not been triggered, cancel it such that it</span></span><br><span class="line">    <span class="comment">/// will not be triggered in the future.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">clear_timeout</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, timeout: &amp;Timeout) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.timer.<span class="title function_ invoke__">cancel_timeout</span>(&amp;timeout).<span class="title function_ invoke__">is_some</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Tells the event loop to exit after it is done handling all events in the current iteration.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Indicates whether the event loop is currently running. If it&#x27;s not it has either</span></span><br><span class="line">    <span class="comment">/// stopped or is scheduled to stop on the next tick.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_running</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.run</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="【2】Poll代码分析"><a href="#【2】Poll代码分析" class="headerlink" title="【2】Poll代码分析"></a>【2】Poll代码分析</h4><p><code>Poll</code>屏蔽了不同系统的实现，给出了统一的抽象。<code>Poll</code>的实现代码这里只能列出较为重要的部分代码，有一部分代码省略掉了，详细代码可查看<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mio/blob/master/src/poll.rs">mio/src/poll.rs</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Poll</span> &#123;</span><br><span class="line">    <span class="comment">// Platform specific IO selector</span></span><br><span class="line">    selector: sys::Selector,	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom readiness queue</span></span><br><span class="line">    <span class="comment">// The second readiness queue is implemented in user space by `ReadinessQueue`. It provides a way to implement purely user space `Evented` types.</span></span><br><span class="line">    readiness_queue: ReadinessQueue,	<span class="comment">//区别于系统就绪队列（sys::Selector），这是上层自己实现的就绪队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use an atomic to first check if a full lock will be required. This is a</span></span><br><span class="line">    <span class="comment">// fast-path check for single threaded cases avoiding the extra syscall</span></span><br><span class="line">    lock_state: AtomicUsize,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sequences concurrent calls to `Poll::poll`</span></span><br><span class="line">    lock: Mutex&lt;()&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wakeup the next waiter</span></span><br><span class="line">    condvar: Condvar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Poll</span> &#123;</span><br><span class="line">    <span class="comment">/// Return a new `Poll` handle.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Poll&gt; &#123;</span><br><span class="line">        is_send::&lt;Poll&gt;();</span><br><span class="line">        is_sync::&lt;Poll&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">poll</span> = Poll &#123;</span><br><span class="line">            selector: sys::Selector::<span class="title function_ invoke__">new</span>()?,</span><br><span class="line">            readiness_queue: ReadinessQueue::<span class="title function_ invoke__">new</span>()?,</span><br><span class="line">            lock_state: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            lock: Mutex::<span class="title function_ invoke__">new</span>(()),</span><br><span class="line">            condvar: Condvar::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the notification wakeup FD with the IO poller</span></span><br><span class="line">        poll.readiness_queue.inner.awakener.<span class="title function_ invoke__">register</span>(&amp;poll, AWAKEN, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>())?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(poll)</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/// Wait for readiness events</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Blocks the current thread and waits for readiness events for any of the</span></span><br><span class="line">    <span class="comment">/// `Evented` handles that have been registered with this `Poll` instance.</span></span><br><span class="line">    <span class="comment">/// The function will block until either at least one readiness event has</span></span><br><span class="line">    <span class="comment">/// been received or `timeout` has elapsed. A `timeout` of `None` means that</span></span><br><span class="line">    <span class="comment">/// `poll` will block until a readiness event has been received.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">poll</span>(&amp;<span class="keyword">self</span>, events: &amp;<span class="keyword">mut</span> Events, timeout: <span class="type">Option</span>&lt;Duration&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">poll1</span>(events, timeout, <span class="literal">false</span>)		<span class="comment">//Poll::poll()非常最重要的一个方法， poll()--&gt;poll1()--&gt;poll2()</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll1</span>(&amp;<span class="keyword">self</span>, events: &amp;<span class="keyword">mut</span> Events, <span class="keyword">mut</span> timeout: <span class="type">Option</span>&lt;Duration&gt;, interruptible: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">zero</span> = <span class="title function_ invoke__">Some</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">curr</span> = <span class="keyword">self</span>.lock_state.<span class="title function_ invoke__">compare_and_swap</span>(<span class="number">0</span>, <span class="number">1</span>, SeqCst);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> != curr &#123; ... &#125;	<span class="comment">//&#123; ... &#125;代表中间有很多代码被省略掉了.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ret</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">poll2</span>(events, timeout, interruptible);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Release the lock</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> != <span class="keyword">self</span>.lock_state.<span class="title function_ invoke__">fetch_and</span>(!<span class="number">1</span>, Release) &#123; ... &#125;	<span class="comment">//&#123; ... &#125;代表中间有很多代码被省略掉了.</span></span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll2</span>(&amp;<span class="keyword">self</span>, events: &amp;<span class="keyword">mut</span> Events, <span class="keyword">mut</span> timeout: <span class="type">Option</span>&lt;Duration&gt;, interruptible: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// Compute the timeout value passed to the system selector. If the</span></span><br><span class="line">        <span class="comment">// readiness queue has pending nodes, we still want to poll the system</span></span><br><span class="line">        <span class="comment">// selector for new events, but we don&#x27;t want to block the thread to</span></span><br><span class="line">        <span class="comment">// wait for new events.</span></span><br><span class="line">        <span class="keyword">if</span> timeout == <span class="title function_ invoke__">Some</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// If blocking is not requested, then there is no need to prepare</span></span><br><span class="line">            <span class="comment">// the queue for sleep</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// The sleep_marker should be removed by readiness_queue.poll().</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>.readiness_queue.<span class="title function_ invoke__">prepare_for_sleep</span>() &#123;</span><br><span class="line">            <span class="comment">// The readiness queue is empty. The call to `prepare_for_sleep`</span></span><br><span class="line">            <span class="comment">// inserts `sleep_marker` into the queue. This signals to any</span></span><br><span class="line">            <span class="comment">// threads setting readiness that the `Poll::poll` is going to</span></span><br><span class="line">            <span class="comment">// sleep, so the awakener should be used.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The readiness queue is not empty, so do not block the thread.</span></span><br><span class="line">            timeout = <span class="title function_ invoke__">Some</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//poll系统就绪队列</span></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">now</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">            <span class="comment">// First get selector events</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">self</span>.selector.<span class="title function_ invoke__">select</span>(&amp;<span class="keyword">mut</span> events.inner, AWAKEN, timeout);	<span class="comment">//Linux下调用epoll_wait(),就绪事件放入events中</span></span><br><span class="line">            <span class="keyword">match</span> res &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Some awakeners require reading from a FD.</span></span><br><span class="line">                    <span class="keyword">self</span>.readiness_queue.inner.awakener.<span class="title function_ invoke__">cleanup</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>) =&gt; <span class="keyword">break</span>,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(<span class="keyword">ref</span> e) <span class="keyword">if</span> e.<span class="title function_ invoke__">kind</span>() == io::ErrorKind::Interrupted &amp;&amp; !interruptible =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Interrupted by a signal; update timeout if necessary and retry</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(to) = timeout &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">elapsed</span> = now.<span class="title function_ invoke__">elapsed</span>();</span><br><span class="line">                        <span class="keyword">if</span> elapsed &gt;= to &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            timeout = <span class="title function_ invoke__">Some</span>(to - elapsed);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll custom event queue</span></span><br><span class="line">        <span class="keyword">self</span>.readiness_queue.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> events.inner);	<span class="comment">//Poll用户就绪队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return number of polled events</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(events.inner.<span class="title function_ invoke__">len</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register an `Evented` handle with the `Poll` instance.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">self</span>, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">        <span class="keyword">where</span> E: Evented &#123;</span><br><span class="line">        <span class="title function_ invoke__">validate_args</span>(token)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register interests for this socket</span></span><br><span class="line">        handle.<span class="title function_ invoke__">register</span>(<span class="keyword">self</span>, token, interest, opts)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Re-register an `Evented` handle with the `Poll` instance.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reregister</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">self</span>, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">        <span class="keyword">where</span> E: Evented &#123;</span><br><span class="line">        <span class="title function_ invoke__">validate_args</span>(token)?;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register interests for this socket</span></span><br><span class="line">        handle.<span class="title function_ invoke__">reregister</span>(<span class="keyword">self</span>, token, interest, opts)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Deregister an `Evented` handle with the `Poll` instance.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deregister</span>&lt;E: ?<span class="built_in">Sized</span>&gt;(&amp;<span class="keyword">self</span>, handle: &amp;E) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt;</span><br><span class="line">        <span class="keyword">where</span> E: Evented &#123;</span><br><span class="line">        <span class="comment">// Deregister interests for this socket</span></span><br><span class="line">        handle.<span class="title function_ invoke__">deregister</span>(<span class="keyword">self</span>)?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="【3】Selector代码分析"><a href="#【3】Selector代码分析" class="headerlink" title="【3】Selector代码分析"></a>【3】Selector代码分析</h4><p>下面这段代码出自<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mio/blob/v0.6.16/src/sys/unix/epoll.rs">mio/src/sys/unix/epoll.rs</a>是对底层Linux系统epoll的封装抽象，可以看到<code>Selector::new()</code>内部实际上调用了<code>epoll_create()</code>，<code>Selector::select()</code>内部实际上调用了<code>epoll_wait()</code>，<code>register()</code>、<code>reregister()</code>、<code>deregister()</code>实内部实际上调用了<code>epoll_ctl()</code>。如果你非常熟悉<code>epoll</code>，就会感觉下面的代码很熟悉，详细代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Selector</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    epfd: RawFd,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Selector</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Selector&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">epfd</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// Emulate `epoll_create` by using `epoll_create1` if it&#x27;s available</span></span><br><span class="line">            <span class="comment">// and otherwise falling back to `epoll_create` followed by a call to</span></span><br><span class="line">            <span class="comment">// set the CLOEXEC flag.</span></span><br><span class="line">            dlsym!(<span class="keyword">fn</span> <span class="title function_">epoll_create1</span>(c_int) <span class="punctuation">-&gt;</span> c_int);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> epoll_create1.<span class="title function_ invoke__">get</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(epoll_create1_fn) =&gt; &#123;</span><br><span class="line">                    <span class="title function_ invoke__">cvt</span>(<span class="title function_ invoke__">epoll_create1_fn</span>(libc::EPOLL_CLOEXEC))?</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">fd</span> = <span class="title function_ invoke__">cvt</span>(libc::<span class="title function_ invoke__">epoll_create</span>(<span class="number">1024</span>))?;</span><br><span class="line">                    <span class="title function_ invoke__">drop</span>(<span class="title function_ invoke__">set_cloexec</span>(fd));</span><br><span class="line">                    fd</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// offset by 1 to avoid choosing 0 as the id of a selector</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">id</span> = NEXT_ID.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Selector &#123;</span><br><span class="line">            id: id,</span><br><span class="line">            epfd: epfd,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">id</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Wait for events from the OS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">select</span>(&amp;<span class="keyword">self</span>, evts: &amp;<span class="keyword">mut</span> Events, awakener: Token, timeout: <span class="type">Option</span>&lt;Duration&gt;) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">timeout_ms</span> = timeout</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|to| cmp::<span class="title function_ invoke__">min</span>(<span class="title function_ invoke__">millis</span>(to), <span class="type">i32</span>::MAX <span class="keyword">as</span> <span class="type">u64</span>) <span class="keyword">as</span> <span class="type">i32</span>)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap_or</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for epoll events for at most timeout_ms milliseconds</span></span><br><span class="line">        evts.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cnt</span> = <span class="title function_ invoke__">cvt</span>(libc::<span class="title function_ invoke__">epoll_wait</span>(<span class="keyword">self</span>.epfd,</span><br><span class="line">                                           evts.events.<span class="title function_ invoke__">as_mut_ptr</span>(),</span><br><span class="line">                                           evts.events.<span class="title function_ invoke__">capacity</span>() <span class="keyword">as</span> <span class="type">i32</span>,</span><br><span class="line">                                           timeout_ms))?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cnt</span> = cnt <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">            evts.events.<span class="title function_ invoke__">set_len</span>(cnt);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..cnt &#123;</span><br><span class="line">                <span class="keyword">if</span> evts.events[i].<span class="type">u64</span> <span class="keyword">as</span> <span class="type">usize</span> == awakener.<span class="title function_ invoke__">into</span>() &#123;</span><br><span class="line">                    evts.events.<span class="title function_ invoke__">remove</span>(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register event interests for the given IO handle with the OS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register</span>(&amp;<span class="keyword">self</span>, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">info</span> = libc::epoll_event &#123;</span><br><span class="line">            events: <span class="title function_ invoke__">ioevent_to_epoll</span>(interests, opts),</span><br><span class="line">            <span class="type">u64</span>: <span class="type">usize</span>::<span class="title function_ invoke__">from</span>(token) <span class="keyword">as</span> <span class="type">u64</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">cvt</span>(libc::<span class="title function_ invoke__">epoll_ctl</span>(<span class="keyword">self</span>.epfd, libc::EPOLL_CTL_ADD, fd, &amp;<span class="keyword">mut</span> info))?;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register event interests for the given IO handle with the OS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reregister</span>(&amp;<span class="keyword">self</span>, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">info</span> = libc::epoll_event &#123;</span><br><span class="line">            events: <span class="title function_ invoke__">ioevent_to_epoll</span>(interests, opts),</span><br><span class="line">            <span class="type">u64</span>: <span class="type">usize</span>::<span class="title function_ invoke__">from</span>(token) <span class="keyword">as</span> <span class="type">u64</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">cvt</span>(libc::<span class="title function_ invoke__">epoll_ctl</span>(<span class="keyword">self</span>.epfd, libc::EPOLL_CTL_MOD, fd, &amp;<span class="keyword">mut</span> info))?;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Deregister event interests for the given IO handle with the OS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deregister</span>(&amp;<span class="keyword">self</span>, fd: RawFd) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// The &amp;info argument should be ignored by the system,</span></span><br><span class="line">        <span class="comment">// but linux &lt; 2.6.9 required it to be not null.</span></span><br><span class="line">        <span class="comment">// For compatibility, we provide a dummy EpollEvent.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">info</span> = libc::epoll_event &#123;</span><br><span class="line">            events: <span class="number">0</span>,</span><br><span class="line">            <span class="type">u64</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">cvt</span>(libc::<span class="title function_ invoke__">epoll_ctl</span>(<span class="keyword">self</span>.epfd, libc::EPOLL_CTL_DEL, fd, &amp;<span class="keyword">mut</span> info))?;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="【4】Notify-channel代码分析"><a href="#【4】Notify-channel代码分析" class="headerlink" title="【4】Notify channel代码分析"></a>【4】Notify channel代码分析</h4><p>这个涉及的代码比较多，比较杂，也较为难以理解。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ReadinessQueue` is backed by a MPSC queue that supports reuse of linked</span></span><br><span class="line"><span class="comment">// list nodes. This significantly reduces the number of required allocations.</span></span><br><span class="line"><span class="comment">// Each `Registration` / `SetReadiness` pair allocates a single readiness node</span></span><br><span class="line"><span class="comment">// that is used for the lifetime of the registration.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The readiness node also includes a single atomic variable, `state` that</span></span><br><span class="line"><span class="comment">// tracks most of the state associated with the registration. This includes the</span></span><br><span class="line"><span class="comment">// current readiness, interest, poll options, and internal state. When the node</span></span><br><span class="line"><span class="comment">// state is mutated, it is queued in the MPSC channel. A call to</span></span><br><span class="line"><span class="comment">// `ReadinessQueue::poll` will dequeue and process nodes. The node state can</span></span><br><span class="line"><span class="comment">// still be mutated while it is queued in the channel for processing.</span></span><br><span class="line"><span class="comment">// Intermediate state values do not matter as long as the final state is</span></span><br><span class="line"><span class="comment">// included in the call to `poll`. This is the eventually consistent nature of</span></span><br><span class="line"><span class="comment">// the readiness queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The readiness node is ref counted using the `ref_count` field. On creation,</span></span><br><span class="line"><span class="comment">// the ref_count is initialized to 3: one `Registration` handle, one</span></span><br><span class="line"><span class="comment">// `SetReadiness` handle, and one for the readiness queue. Since the readiness queue</span></span><br><span class="line"><span class="comment">// doesn&#x27;t *always* hold a handle to the node, we don&#x27;t use the Arc type for</span></span><br><span class="line"><span class="comment">// managing ref counts (this is to avoid constantly incrementing and</span></span><br><span class="line"><span class="comment">// decrementing the ref count when pushing &amp; popping from the queue). When the</span></span><br><span class="line"><span class="comment">// `Registration` handle is dropped, the `dropped` flag is set on the node, then</span></span><br><span class="line"><span class="comment">// the node is pushed into the registration queue. When Poll::poll pops the</span></span><br><span class="line"><span class="comment">// node, it sees the drop flag is set, and decrements it&#x27;s ref count.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The MPSC queue is a modified version of the intrusive MPSC node based queue</span></span><br><span class="line"><span class="comment">// described by 1024cores [1].</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReadinessQueue</span> &#123;</span><br><span class="line">    inner: Arc&lt;ReadinessQueueInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReadinessQueueInner</span> &#123;</span><br><span class="line">    <span class="comment">// Used to wake up `Poll` when readiness is set in another thread.</span></span><br><span class="line">    awakener: sys::Awakener,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Head of the MPSC queue used to signal readiness to `Poll::poll`.</span></span><br><span class="line">    head_readiness: AtomicPtr&lt;ReadinessNode&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tail of the readiness queue.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Only accessed by Poll::poll. Coordination will be handled by the poll fn</span></span><br><span class="line">    tail_readiness: UnsafeCell&lt;*<span class="keyword">mut</span> ReadinessNode&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fake readiness node used to punctuate the end of the readiness queue.</span></span><br><span class="line">    <span class="comment">// Before attempting to read from the queue, this node is inserted in order</span></span><br><span class="line">    <span class="comment">// to partition the queue between nodes that are &quot;owned&quot; by the dequeue end</span></span><br><span class="line">    <span class="comment">// and nodes that will be pushed on by producers.</span></span><br><span class="line">    end_marker: <span class="type">Box</span>&lt;ReadinessNode&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Similar to `end_marker`, but this node signals to producers that `Poll`</span></span><br><span class="line">    <span class="comment">// has gone to sleep and must be woken up.</span></span><br><span class="line">    sleep_marker: <span class="type">Box</span>&lt;ReadinessNode&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Similar to `end_marker`, but the node signals that the queue is closed.</span></span><br><span class="line">    <span class="comment">// This happens when `ReadyQueue` is dropped and signals to producers that</span></span><br><span class="line">    <span class="comment">// the nodes should no longer be pushed into the queue.</span></span><br><span class="line">    closed_marker: <span class="type">Box</span>&lt;ReadinessNode&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Node shared by a `Registration` / `SetReadiness` pair as well as the node</span></span><br><span class="line"><span class="comment">/// queued into the MPSC channel.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReadinessNode</span> &#123;</span><br><span class="line">    <span class="comment">// Node state, see struct docs for `ReadinessState`</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This variable is the primary point of coordination between all the</span></span><br><span class="line">    <span class="comment">// various threads concurrently accessing the node.</span></span><br><span class="line">    state: AtomicState,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The registration token cannot fit into the `state` variable, so it is</span></span><br><span class="line">    <span class="comment">// broken out here. In order to atomically update both the state and token</span></span><br><span class="line">    <span class="comment">// we have to jump through a few hoops.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// First, `state` includes `token_read_pos` and `token_write_pos`. These can</span></span><br><span class="line">    <span class="comment">// either be 0, 1, or 2 which represent a token slot. `token_write_pos` is</span></span><br><span class="line">    <span class="comment">// the token slot that contains the most up to date registration token.</span></span><br><span class="line">    <span class="comment">// `token_read_pos` is the token slot that `poll` is currently reading from.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When a call to `update` includes a different token than the one currently</span></span><br><span class="line">    <span class="comment">// associated with the registration (token_write_pos), first an unused token</span></span><br><span class="line">    <span class="comment">// slot is found. The unused slot is the one not represented by</span></span><br><span class="line">    <span class="comment">// `token_read_pos` OR `token_write_pos`. The new token is written to this</span></span><br><span class="line">    <span class="comment">// slot, then `state` is updated with the new `token_write_pos` value. This</span></span><br><span class="line">    <span class="comment">// requires that there is only a *single* concurrent call to `update`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When `poll` reads a node state, it checks that `token_read_pos` matches</span></span><br><span class="line">    <span class="comment">// `token_write_pos`. If they do not match, then it atomically updates</span></span><br><span class="line">    <span class="comment">// `state` such that `token_read_pos` is set to `token_write_pos`. It will</span></span><br><span class="line">    <span class="comment">// then read the token at the newly updated `token_read_pos`.</span></span><br><span class="line">    token_0: UnsafeCell&lt;Token&gt;,</span><br><span class="line">    token_1: UnsafeCell&lt;Token&gt;,</span><br><span class="line">    token_2: UnsafeCell&lt;Token&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used when the node is queued in the readiness linked list. Accessing</span></span><br><span class="line">    <span class="comment">// this field requires winning the &quot;queue&quot; lock</span></span><br><span class="line">    next_readiness: AtomicPtr&lt;ReadinessNode&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensures that there is only one concurrent call to `update`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Each call to `update` will attempt to swap `update_lock` from `false` to</span></span><br><span class="line">    <span class="comment">// `true`. If the CAS succeeds, the thread has obtained the update lock. If</span></span><br><span class="line">    <span class="comment">// the CAS fails, then the `update` call returns immediately and the update</span></span><br><span class="line">    <span class="comment">// is discarded.</span></span><br><span class="line">    update_lock: AtomicBool,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer to Arc&lt;ReadinessQueueInner&gt;</span></span><br><span class="line">    readiness_queue: AtomicPtr&lt;()&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracks the number of `ReadyRef` pointers</span></span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handle to a user space `Poll` registration.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// `Registration` allows implementing [`Evented`] for types that cannot work</span></span><br><span class="line"><span class="comment">/// with the [system selector]. A `Registration` is always paired with a</span></span><br><span class="line"><span class="comment">/// `SetReadiness`, which allows updating the registration&#x27;s readiness state.</span></span><br><span class="line"><span class="comment">/// When [`set_readiness`] is called and the `Registration` is associated with a</span></span><br><span class="line"><span class="comment">/// [`Poll`] instance, a readiness event will be created and eventually returned</span></span><br><span class="line"><span class="comment">/// by [`poll`].</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Registration</span> &#123;</span><br><span class="line">    inner: RegistrationInner,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Updates the readiness state of the associated `Registration`.</span></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SetReadiness</span> &#123;</span><br><span class="line">    inner: RegistrationInner,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完，待续……</p>
<blockquote>
<p>参考文档：<a target="_blank" rel="noopener" href="http://www.1024cores.net/home/lock-free-algorithms/queues/intrusive-mpsc-node-based-queue">Intrusive MPSC node-based queue</a></p>
</blockquote>
<h4 id="【5】Timer定时器代码分析"><a href="#【5】Timer定时器代码分析" class="headerlink" title="【5】Timer定时器代码分析"></a>【5】Timer定时器代码分析</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Timer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// Size of each tick in milliseconds</span></span><br><span class="line">    tick_ms: <span class="type">u64</span>,</span><br><span class="line">    <span class="comment">// Slab of timeout entries</span></span><br><span class="line">    entries: Slab&lt;Entry&lt;T&gt;&gt;,</span><br><span class="line">    <span class="comment">// Timeout wheel. Each tick, the timer will look at the next slot for</span></span><br><span class="line">    <span class="comment">// timeouts that match the current tick.</span></span><br><span class="line">    wheel: <span class="type">Vec</span>&lt;WheelEntry&gt;,</span><br><span class="line">    <span class="comment">// Tick 0&#x27;s time instant</span></span><br><span class="line">    start: Instant,</span><br><span class="line">    <span class="comment">// The current tick</span></span><br><span class="line">    tick: Tick,</span><br><span class="line">    <span class="comment">// The next entry to possibly timeout</span></span><br><span class="line">    next: Token,</span><br><span class="line">    <span class="comment">// Masks the target tick to get the slot</span></span><br><span class="line">    mask: <span class="type">u64</span>,</span><br><span class="line">    <span class="comment">// Set on registration with Poll</span></span><br><span class="line">    inner: LazyCell&lt;Inner&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完，待续……</p>
<h3 id="三、mio用法示例"><a href="#三、mio用法示例" class="headerlink" title="三、mio用法示例"></a>三、mio用法示例</h3><p>下面的2个示例都很简单，其实直接看mio的<a target="_blank" rel="noopener" href="https://github.com/tokio-rs/mio/tree/master/test">测试代码mio/test/</a>就好了，不用看下面的2个示例。</p>
<h4 id="1、代码示例1"><a href="#1、代码示例1" class="headerlink" title="1、代码示例1"></a>1、代码示例1</h4><p>直接使用<code>Poll</code>示例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> simple_logger;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> mio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> mio::*;</span><br><span class="line"><span class="keyword">use</span> mio::tcp::&#123;TcpListener, TcpStream&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Read,Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    simple_logger::<span class="title function_ invoke__">init</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup some tokens to allow us to identify which event is for which socket.</span></span><br><span class="line">    <span class="keyword">const</span> SERVER: Token = <span class="title function_ invoke__">Token</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> CLIENT: Token = <span class="title function_ invoke__">Token</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">addr</span> = <span class="string">&quot;127.0.0.1:12345&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup the server socket</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">server</span> = TcpListener::<span class="title function_ invoke__">bind</span>(&amp;addr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a poll instance</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">poll</span> = Poll::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start listening for incoming connections</span></span><br><span class="line">    poll.<span class="title function_ invoke__">register</span>(&amp;server, SERVER, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup the client socket</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sock</span> = TcpStream::<span class="title function_ invoke__">connect</span>(&amp;addr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the socket</span></span><br><span class="line">    poll.<span class="title function_ invoke__">register</span>(&amp;sock, CLIENT, Ready::<span class="title function_ invoke__">readable</span>(), PollOpt::<span class="title function_ invoke__">edge</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create storage for events</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">events</span> = Events::<span class="title function_ invoke__">with_capacity</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        poll.<span class="title function_ invoke__">poll</span>(&amp;<span class="keyword">mut</span> events, <span class="literal">None</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">event</span> <span class="keyword">in</span> events.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">match</span> event.<span class="title function_ invoke__">token</span>() &#123;</span><br><span class="line">                SERVER =&gt; &#123;</span><br><span class="line">                    <span class="comment">// Accept and drop the socket immediately, this will close</span></span><br><span class="line">                    <span class="comment">// the socket and notify the client of the EOF.</span></span><br><span class="line">                    <span class="keyword">let</span> (stream,addr) = server.<span class="title function_ invoke__">accept</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                    info!(<span class="string">&quot;Listener accept &#123;:?&#125;&quot;</span>,addr);</span><br><span class="line">                &#125;,</span><br><span class="line">                CLIENT =&gt; &#123;</span><br><span class="line">                    <span class="comment">// The server just shuts down the socket, let&#x27;s just exit</span></span><br><span class="line">                    <span class="comment">// from our event loop.</span></span><br><span class="line">                    info!(<span class="string">&quot;client response.&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码示例1，我们可以看到其用法与<code>epoll</code>非常相似。</p>
<h4 id="2、代码示例2"><a href="#2、代码示例2" class="headerlink" title="2、代码示例2"></a>2、代码示例2</h4><p>上面的代码编程时较为麻烦，下面使用事件循环<code>EventLoop</code>的方式，代码能看起来更清晰一些（相对的）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> simple_logger;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> mio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> mio::*;</span><br><span class="line"><span class="keyword">use</span> mio::timer::&#123;Timeout&#125;;</span><br><span class="line"><span class="keyword">use</span> mio::deprecated::&#123;EventLoop, Handler, Sender, EventLoopBuilder&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    simple_logger::<span class="title function_ invoke__">init</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">event_loop</span>=EventLoop::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">channel_sender</span>=event_loop.<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> ||&#123;</span><br><span class="line">        channel_sender.<span class="title function_ invoke__">send</span>(IoMessage::Notify);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep_ms</span>(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        channel_sender.<span class="title function_ invoke__">send</span>(IoMessage::End);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">timeout</span> = event_loop.<span class="title function_ invoke__">timeout</span>(<span class="title function_ invoke__">Token</span>(<span class="number">123</span>), Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">3000</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handler</span>=MioHandler::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span> = event_loop.<span class="title function_ invoke__">run</span>(&amp;<span class="keyword">mut</span> handler).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">IoMessage</span>&#123;</span><br><span class="line">    Notify,</span><br><span class="line">    End,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MioHandler</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MioHandler</span>&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>()<span class="punctuation">-&gt;</span><span class="keyword">Self</span>&#123;</span><br><span class="line">        MioHandler&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Handler</span> <span class="keyword">for</span> <span class="title class_">MioHandler</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Timeout</span> = Token;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Message</span> = IoMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when the socket represented by `token` is ready to be operated on.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">ready</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, token: Token, events: Ready) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when a message has been received via the event loop&#x27;s channel.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">notify</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, msg: <span class="keyword">Self</span>::Message) &#123;</span><br><span class="line">        <span class="keyword">match</span> msg &#123;</span><br><span class="line">            IoMessage::Notify=&gt;info!(<span class="string">&quot;channel notify&quot;</span>),</span><br><span class="line">            IoMessage::End=&gt;&#123;</span><br><span class="line">                info!(<span class="string">&quot;shutdown eventloop.&quot;</span>);</span><br><span class="line">                event_loop.<span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when a timeout has completed.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">timeout</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;, timeout: <span class="keyword">Self</span>::Timeout) &#123;</span><br><span class="line">        <span class="keyword">match</span> timeout&#123;</span><br><span class="line">            <span class="title function_ invoke__">Token</span>(<span class="number">123</span>)=&gt;info!(<span class="string">&quot;time out.&quot;</span>),</span><br><span class="line">            <span class="title function_ invoke__">Token</span>(_)=&gt;&#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked when `EventLoop` has been interrupted by a signal interrupt.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">interrupted</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invoked at the end of an event loop tick.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tick</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, event_loop: &amp;<span class="keyword">mut</span> EventLoop&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例说明了超时及channel，围绕<code>EventLoop</code>编程，其实与上一个例子没有什么不同，只是<code>EventLoop</code>对<code>Poll</code>做了封装。</p>
<blockquote>
<p>参考文档：<br><a target="_blank" rel="noopener" href="https://blog.techbridge.cc/2018/01/05/tokio-internal/">【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aad78343249a">使用mio开发web framework - base</a><br><a target="_blank" rel="noopener" href="https://hermanradtke.com/2015/07/12/my-basic-understanding-of-mio-and-async-io.html">My Basic Understanding of mio and Asynchronous IO</a><br><a target="_blank" rel="noopener" href="https://legacy.gitbook.com/book/wycats/mio-book/details">MIO for Rust</a><br><a target="_blank" rel="noopener" href="https://github.com/carllerche/mio">mio-github</a>     </p>
</blockquote>

      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8Emio"><span class="nav-text">一、关于mio</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-text">1、重要特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-text">2、基础用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">二、源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%901%E3%80%91Eventloop%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">【1】Eventloop代码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%902%E3%80%91Poll%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">【2】Poll代码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%903%E3%80%91Selector%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">【3】Selector代码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%904%E3%80%91Notify-channel%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">【4】Notify channel代码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%905%E3%80%91Timer%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">【5】Timer定时器代码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81mio%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">三、mio用法示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B1"><span class="nav-text">1、代码示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B2"><span class="nav-text">2、代码示例2</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cherry"
      src="/hexo-blog/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Cherry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo-blog/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo-blog/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/hexo-blog/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CherryYang05" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CherryYang05" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_42650988" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_42650988" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cherry版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">214k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"I0GaPlLWJSoCb0ieY9V3Vd7Q-gzGzoHsz","app_key":"sye9GNy0K7KNBHd69HYFsPzV","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo-blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/hexo-blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo-blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo-blog/js/utils.js"></script>

<script src="/hexo-blog/js/motion.js"></script>


<script src="/hexo-blog/js/schemes/muse.js"></script>


<script src="/hexo-blog/js/next-boot.js"></script>

<script src="/hexo-blog/js/bookmark.js"></script>




  




  
<script src="/hexo-blog/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/hexo-blog/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://cherryyang05.github.io/hexo-blog/about/Rust%E8%BD%BB%E9%87%8F%E7%BA%A7IO%E5%BA%93.html',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'I0GaPlLWJSoCb0ieY9V3Vd7Q-gzGzoHsz',
      appKey     : 'sye9GNy0K7KNBHd69HYFsPzV',
      placeholder: "评论支持 MarkDown 语法",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '5' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
