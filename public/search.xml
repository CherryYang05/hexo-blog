<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++常用函数整理</title>
    <url>/37079a34.html</url>
    <content><![CDATA[<h2 id="C-C-中常用函数"><a href="#C-C-中常用函数" class="headerlink" title="C/C++ 中常用函数"></a>C/C++ 中常用函数</h2><!-- toc --> <span id="more"></span>
<h3 id="1-time"><a href="#1-time" class="headerlink" title="1. time"></a>1. time</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">clock_t</span> <span class="title">clock</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单而言，就是该程序从启动到函数调用占用 CPU 的时间。这个函数返回从“开启这个程序进程”到“程序中调用 clock()函数”时之间的 CPU 时钟计时单元(clock tick)数，在 MSDN 中称之为挂钟时间(wal-clock)；若挂钟时间不可取，则返回-1。其中 clock_t 是用来保存时间的数据类型。<br>在 time.h 文件中，我们可以找到对 clock_t()的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CLOCK_T_DEFINED</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">clock_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CLOCK_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> time_begin = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="type">int</span> time_end = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; (time_end - time_begin) / CLOCKS_PER_SEC &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="2-fill"><a href="#2-fill" class="headerlink" title="2. fill"></a>2. fill</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), val); <span class="comment">//将容器中每个元素被重置为val</span></span><br></pre></td></tr></table></figure>
<p>fill 函数作用是将一个区间的元素赋值为 val，该 val 可以非零，包含在 <code>algorithm</code> 头文件里。</p>
<p><strong>和 memset 函数区别：</strong><br>我们定义数组时通常喜欢用 <code>memset</code> 函数赋初值 <code>0</code>，但是实际上 <code>memset</code> 也只能赋值为 <code>0</code>。函数原型如下：</p>
<p><code>void *memset(void *s, int ch, size_t n);</code></p>
<p>函数功能是：将 <code>s</code> 所指向的某一块内存中的前 n 个字节的内容全部设置为 <code>ch</code> 指定的 ASCII 值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为指向 s 的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。</p>
<p>但是要注意的是， <code>memset</code> 是按照一个一个字节进行初始化的，如果初始化的值为 0，则结果是对的，但是如果将一个 <code>int</code> 型变量初始化为 1，则不能使用 memset，因为初始化后该变量会变成 <code>00000001 00000001 00000001 00000001</code>，这样的值便是错误的。</p>
<p>这是和 <code>fill</code> 最根本的区别。</p>
<p><a href="https://blog.csdn.net/Xiao2018428/article/details/101268398">参考博客</a></p>
<h3 id="3-next-permutation"><a href="#3-next-permutation" class="headerlink" title="3. next_permutation"></a>3. next_permutation</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(iterator start,iterator end)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数是获得容器内序列的下一个排列组合，包含在头文件 <code>algorithm</code> 中。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure>
<p>此外，next_permutation(v, v + n, cmp)可以对结构体 num 按照自定义的排序方式 cmp 进行排序</p>
<p>若要求的字典序是 <code>&#39;A&#39;&lt;&#39;a&#39;&lt;&#39;B&#39;&lt;&#39;b&#39;&lt;...&lt;&#39;Z&#39;&lt;&#39;z&#39;</code>，则可以自定义 cmp 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                 <span class="comment">//poj 1256 Anagram</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">tolower</span>(a) != <span class="built_in">tolower</span>(b))     <span class="comment">//tolower 是将大写字母转化为小写字母.</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">tolower</span>(a) &lt; <span class="built_in">tolower</span>(b);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">        <span class="built_in">sort</span>(ch, ch + <span class="built_in">strlen</span>(ch), cmp);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ch);</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(ch, ch + <span class="built_in">strlen</span>(ch), cmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_43488547/article/details/100032724">参考博客</a></p>
<h3 id="4-stoi"><a href="#4-stoi" class="headerlink" title="4. stoi"></a>4. stoi</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stoi</span>(string, pos, n进制)</span><br></pre></td></tr></table></figure>
<p>stoi(string to int)，表示将 n 进制的字符串转化为十进制</p>
<p>和 atoi 的比较：</p>
<p>相同点：</p>
<p>① 都是 C++的字符处理函数，把数字字符串转换成 int 输出<br>② 头文件都是 <code>#include&lt;cstring&gt;</code></p>
<p>不同点：</p>
<p>① atoi()的参数是 const char<em>，因此对于一个字符串 str 我们必须调用 c_str() 的方法把这个 string 转换成 const char</em> 类型的,而 stoi()的参数是 const string<em>，不需要转化为 const char</em>；</p>
<p>② stoi()会做范围检查，默认范围是在 int 的范围内的，如果超出范围的话则会 runtime error.<br>而 atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界。</p>
<h3 id="5-GetTickCount"><a href="#5-GetTickCount" class="headerlink" title="5. GetTickCount"></a>5. GetTickCount</h3><p>GetTickCount 是一种函数。GetTickCount 返回(retrieve)从操作系统启动所经过(elapsed)的毫秒数，它的返回值是 DWORD。<br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetTickCount</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>头文件：<br>C/C++头文件：winbase.h<br>windows 程序设计中可以使用头文件 windows.h</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DWORD startTime = <span class="built_in">GetTickCount</span>();<span class="comment">//计时开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2147483640</span>; i++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD endTime = <span class="built_in">GetTickCount</span>();<span class="comment">//计时结束</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The run time is:&quot;</span> &lt;&lt; endTime - startTime &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetTickcount 函数：它返回从操作系统启动到当前所经过的毫秒数，常常用来判断某个方法执行的时间，其函数原型是 DWORD GetTickCount(void)，返回值以 32 位的双字类型 DWORD 存储，因此可以存储的最大值是(2^32-1) ms 约为 49.71 天，因此若系统运行时间超过 49.71 天时，这个数就会归 0，MSDN 中也明确的提到了:”Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.”。因此，如果是编写服务器端程序，此处一定要万分注意，避免引起意外的状况。</p>
<p>特别注意：这个函数并非实时发送，而是由系统每 18ms 发送一次，因此其最小精度为 18ms。当需要有小于 18ms 的精度计算时，应使用 StopWatch 方法进行。<br>用 clock()函数计算运行时间，表示范围一定大于 GetTickCount()函数，所以，建议使用 clock()函数。</p>
<p><a href="https://www.cnblogs.com/didiaodidiao/p/9194702.html">参考网站</a></p>
<h3 id="6-C-中的可变参数"><a href="#6-C-中的可变参数" class="headerlink" title="6. C 中的可变参数"></a>6. C 中的可变参数</h3><p>包含在头文件 <code>stdarg.h</code> 中</p>
<p>例：求若干个数的和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;        <span class="comment">//省略号前面有无逗号都可以</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="comment">//在stdarg.h 头文件中</span></span><br><span class="line">    va_list list;</span><br><span class="line">    <span class="comment">//为 num 个参数初始化 valist</span></span><br><span class="line">    <span class="built_in">va_start</span>(list, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(list, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li>
<li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li>
</ul>
<p><a href="https://www.cnblogs.com/pengdonglin137/p/3345911.html">详细介绍</a></p>
<h3 id="7-sprintf"><a href="#7-sprintf" class="headerlink" title="7. sprintf"></a>7. sprintf</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>1. 把整数 123 打印成一个字符串保存在 s 中</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, <span class="number">123</span>); <span class="comment">//产生&quot;123&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 格式对齐</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%08X&quot;</span>, <span class="number">4567</span>);<span class="comment">//产生：000011D7</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%-8x&quot;</span>, <span class="number">4567</span>);<span class="comment">//产生：11D7，小写16进制，左对齐</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%8X&quot;</span>, <span class="number">4567</span>);<span class="comment">//产生：11D7，大写十六进制，右对齐</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. 取对应个数的字符</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.7s%.7s&quot;</span>, a1, a2);</span><br><span class="line"><span class="comment">//产生：&quot;ABCDEFGHIJKLMN&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这可以类比打印浮点数的 <code>&quot;%m.nf&quot;</code>，在 <code>&quot;%m.ns&quot;</code> 中，<code>m</code> 表示占用宽度（字符串长度不足时补空格，超出了则按照实际宽度打印），<code>n</code> 才表示从相应的字符串中最多取用的字符数。通常在打印字符串时 <code>m</code> 没什么大用，还是点号后面的 <code>n</code> 用的多。自然，也可以前后都只取部分字符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.6s%.5s&quot;</span>, a1, a2);<span class="comment">//产生：&quot;ABCDEFHIJKL&quot;</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.*s%.*s&quot;</span>, <span class="number">7</span>, a1, <span class="number">7</span>, a2);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.*s%.*s&quot;</span>, <span class="built_in">sizeof</span>(a1), a1, <span class="built_in">sizeof</span>(a2), a2);</span><br></pre></td></tr></table></figure>
<p><strong>4. 实际上，前面介绍的打印字符、整数、浮点数等都可以动态指定那些常量值</strong><br>比如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%-*d&quot;</span>, <span class="number">4</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">//产生&quot;65 &quot;</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%#0*X&quot;</span>, <span class="number">8</span>, <span class="number">128</span>); <span class="comment">//产生&quot;0X000080&quot;，&quot;#&quot;产生0X</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%*.*f&quot;</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3.1415926</span>); <span class="comment">//产生&quot; 3.14&quot;</span></span><br><span class="line"><span class="comment">//这里 (%*.*f) 相当于 (%10.2f), 表示该浮点数保留 2 位小数，并且向右靠齐占位 10 个字符</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5. sprintf(s, “%p”, &amp;i);</strong></p>
<p><strong>6. strlen 便已经知道了结果字符串的长度</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, i);</span><br></pre></td></tr></table></figure><br>对于正整数来说，<code>len</code> 便等于整数 <code>i</code> 的 <code>10</code> 进制位数。</p>
<p><code>sprintf</code> 函数属于 C 库函数，功能是将标准输出到字符串 <code>buffer</code> 中(C 语言的中的字符数组)，若写入成功则返回写入的字符数量，否则返回负值，除了第一个参数外，其他参数同 <code>printf</code></p>
<h3 id="8-sscanf"><a href="#8-sscanf" class="headerlink" title="8. sscanf"></a>8. sscanf</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sscanf</code> 与 <code>scanf</code> 等价，所不同的是，前者的输入字符来源于字符串 <code>s</code>，而 <code>scanf</code> 以 <code>stdin</code> 作为输入源</p>
<p><strong>1. %<em>d, %</em>s: * 号表示此数据不读入，忽略掉</strong></p>
<p>比如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ch = <span class="string">&quot;MemTotal:2028248 kB&quot;</span></span><br><span class="line"><span class="built_in">sscanf</span>(ch, <span class="string">&quot;%*s%d&quot;</span>, &amp;total);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, total);</span><br><span class="line">输出结果：<span class="number">2028248</span></span><br></pre></td></tr></table></figure>
<p><strong>[注意] sprintf 中的 <code>*</code> 号表示占位符，类似于 JDBC 中的 ?，而 sscanf 中的 <code>*</code> 号表示跳过对应格式的数据不读入</strong></p>
<p><strong>2. 取指定长度的字符串</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456 &quot;</span>, <span class="string">&quot;%4s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">结果为：<span class="number">1234</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3. 取到指定字符为止的字符串</strong><br>在下例中，取遇到空格为止的字符串<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;123456 abcdedf&quot;</span>, <span class="string">&quot;%[^ ]&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">结果为：<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. sscanf(ch, “%*<sup><a href="#fn_e" id="reffn_e">e</a></sup>%<sup><a href="#fn_2" id="reffn_2">2</a></sup>“, ch1)</strong><br>寻找e到2之间的数，包括e但不包括2<br>如果中间有空格，包括空格。</p>
<p><strong>5. 给定一个字符串”hello, world”，仅保留world（注意：”，”之后有一空格）</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(“hello, world”, <span class="string">&quot;%*s%s&quot;</span>, buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">结果为：world</span><br></pre></td></tr></table></figure><br><code>%*s</code> 表示第一个匹配到的 <code>%s</code> 被过滤掉，即 <code>hello</code> 被过滤了<br>如果没有空格则结果为<code>NULL</code></p>
<p><strong>6. 分割字符串</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;2006:03:18&quot;</span>, <span class="string">&quot;%d:%d:%d&quot;</span>, a, b, c);</span><br><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;2006:03:18 - 2006:04:18&quot;</span>, <span class="string">&quot;%s - %s&quot;</span>, sztime1, sztime2);</span><br></pre></td></tr></table></figure><br>如果 <code>2006:03:18 - 2006:04:18</code> 间没有空格<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(<span class="string">&quot;2006:03:18 - 2006:04:18&quot;</span>, <span class="string">&quot;%[0-9,:] - %[0-9,:]&quot;</span>, sztime1, sztime2);</span><br></pre></td></tr></table></figure></p>
<h3 id="9-c-str"><a href="#9-c-str" class="headerlink" title="9. c_str"></a>9. c_str</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>c_str() 函数返回一个指向正规 C 字符串的指针常量，内容与本 string 串相同。<br>这是为了与 c 语言兼容，在 c 语言中没有 string 类型，故必须通过 string 类对象的成员函数 c_str()把 string 对象转换成 c 中的字符串样式。</p>
<ol>
<li>c_str 是一个内容为字符串指向字符数组的临时指针；</li>
<li>c_str 返回的是一个可读不可改的常指针；</li>
</ol>
<p>注意：一定要使用 strcpy() 函数等来操作方法 c_str() 返回的指针 。</p>
<p>比如：最好不要这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* c;</span><br><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">c = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>
<p>c 最后指向的内容是垃圾，因为 s 对象被析构，其内容被处理，同时，编译器也将报错——将一个 const char 赋与一个 char 。</p>
<p>应该这样用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(c, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>
<p>这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作。</p>
<h3 id="10-用-scanf-读入-string"><a href="#10-用-scanf-读入-string" class="headerlink" title="10. 用 scanf 读入 string"></a>10. 用 scanf 读入 string</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a;</span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">100</span>);          <span class="comment">//需要预先分配空间</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">puts</span>(a.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="11-5-种读入整行字符串的操作"><a href="#11-5-种读入整行字符串的操作" class="headerlink" title="11. 5 种读入整行字符串的操作"></a>11. 5 种读入整行字符串的操作</h3><p><strong>1. scanf()读入 char[]</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, &amp;str);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure>
<p>说明：在 scanf 函数中，可以使用 <code>%c</code>来读取一个字符，使用 <code>%s</code> 读取一个字符串，但是读取字符串时不忽略空格，读字符串时忽略开始的空格，并且读到空格为止，因此只能读取一个单词，而不是整行字符串。</p>
<p>其实 scanf 函数也可完成这样的功能，而且还更强大。这里主要介绍一个参数:<code>%[]</code>，这个参数的意义是读入一个字符集合。<code>[]</code> 是个集合的标志，因此 <code>%[]</code> 特指读入此集合所限定的那些字符，比如 <code>%[A-Z]</code> 是输入大写字母，一旦遇到不在此集合的字符便停止。如果集合的第一个字符是 <code>&quot;^&quot;</code>，这说明读取不在 <code>&quot;^&quot;</code> 后面集合的字符，即遇到 <code>&quot;^&quot;</code> 后面集合的字符便停止。注意此时读入的字符串是可以含有空格的，而且会把开头的空格也读进来。</p>
<p>注意：如果要循环的多次从屏幕上读取一行的话，就要在读取一行后，在用 <code>%c</code> 读取一个字符，将输入缓冲区中的换行符给读出来。否则的话，在下一次读取一行的时候，第一个就遇到<code>&#39;\n&#39;</code>，匹配不成功就直接返回了。这里可以用 <code>scanf()</code> 或者 <code>getchar()</code> 函数读取换行符。</p>
<p><strong>2. getchar() 读入 char[]</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((str[i] = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    i++;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure>
<p>说明：这样一个一个读也可以，也会把开头的空格读进来。最后也需要考虑换行符，使用 <code>getchar()</code> 读出来。</p>
<p><strong>3. gets()读入 char[]</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">gets</span>(str);</span><br></pre></td></tr></table></figure>
<p>说明：感觉这个就是多个 <code>getchar</code> 的集合函数，很好用。功能是从标准输入键盘上读入一个完整的行（从标准输入读，一直读到遇到换行符），把读到的内容存入括号中指定的字符数组里，并用空字符 <code>&#39;\0&#39;</code> 取代行尾的换行符 <code>&#39;\n&#39;</code>。读入时不需要考虑换行符。</p>
<p><strong>4. getline() 读入 string 或 char[]</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);          <span class="comment">//读入string</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str2[<span class="number">1024</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(str2, <span class="number">1024</span>);    <span class="comment">//读入char数组</span></span><br></pre></td></tr></table></figure>
<p>说明：这是比较常用的方法，<code>cin.getline</code> 第三个参数表示间隔符，默认为换行符<code>&#39;\n&#39;</code>。读入不需要考虑最后的换行符。</p>
<p><strong>5. get() 读入 char[]</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str3[<span class="number">1024</span>];</span><br><span class="line">cin.<span class="built_in">get</span>(str3, <span class="number">1024</span>);         <span class="comment">//读入char数组</span></span><br></pre></td></tr></table></figure>
<p>说明：get 函数读入时需要考虑最后的换行符，也就是说，如果用 <code>get</code> 读入多行数据，要把 <code>&#39;\n&#39;</code> 另外读出来，一般使用 <code>cin.get(str, 1024).get();</code> 来读入多组数据。</p>
<h3 id="12-reverse"><a href="#12-reverse" class="headerlink" title="12. reverse"></a>12. reverse</h3><p>reverse 这个函数功能非常强大，作用是将序列[first,last)的元素在原容器中翻转，包含在<code>algorithm</code>库中</p>
<ul>
<li>reverse()函数无返回值，时间复杂度<code>O(n)</code></li>
<li>注意区间是 <code>[begin, end)</code>，左闭右开</li>
<li>可以作用于 <code>vector</code>，<code>string</code>，普通数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v));</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(<span class="built_in">begin</span>(a), <span class="built_in">end</span>(a));</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;My name is Cherry.&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="13-sort-lamda表达式"><a href="#13-sort-lamda表达式" class="headerlink" title="13. sort(lamda表达式)"></a>13. sort(lamda表达式)</h3><p>这个函数应该很熟悉了，这里我们主要介绍他的<a href="https://www.cnblogs.com/ye-ming/p/9310997.html">lamda 表达式的用法</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">stu</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">stu</span>(string _name, <span class="type">int</span> _id) : <span class="built_in">name</span>(_name), <span class="built_in">id</span>(_id) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">stu s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sort</span>(s, s + <span class="number">10</span>, [](stu s1, stu s2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.name == s2.name) <span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s1.name &lt; s2.name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成下面这样，因为根据return可清楚的知道返回类型为bool，便不用显式声明了</span></span><br><span class="line"><span class="built_in">sort</span>(s, s + <span class="number">10</span>, [](stu s1, stu s2) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.name == s2.name) <span class="keyword">return</span> s1.id &lt; s2.id;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s1.name &lt; s2.name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里 sort 函数的第三个参数，<code>[]</code>叫做捕获说明符，表示一个 lamda 表达式的开始，接下来是参数列表，即这个 lamda 函数的参数。</p>
<p><code>[]</code> 表示该 lambda 表达式是不能访问任何外部变量的，即表达式的函数体内无法访问当前作用域下的变量。<br><code>[=]</code> 表示按值访问， <code>[&amp;]</code> 表示按引用访问变量之间用逗号分隔，比如 <code>[=factor, &amp;total]</code> 表示按值访问变量 <code>factor</code>，而按引用访问 <code>total</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> test = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> fl = [test](<span class="type">int</span> x, <span class="type">int</span> y) &#123;    <span class="comment">//这里要传入test才能在lamda表达式中访问</span></span><br><span class="line">    <span class="keyword">return</span> test + x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL函数</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言代码规范</title>
    <url>/d5e60d4a.html</url>
    <content><![CDATA[<h2 id="C-语言代码规范"><a href="#C-语言代码规范" class="headerlink" title="C 语言代码规范"></a>C 语言代码规范</h2><span id="more"></span>
<h3 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h3><p><strong>1. 变量命名</strong></p>
<p>小驼峰式：<code>firstName</code>，<code>hexToBinary</code><br>下划线式：<code>first_name</code>，<code>hex_to_binary</code><br>不要使用非常见单词的缩写，类似 FTL 这种可以缩写，但是 hexToBinary 不要写成 htb</p>
<p><strong>2. 常量命名</strong></p>
<p>全部大写，单词之间用下划线分隔，<code>OUT_OF_BOUND_EXCEPTION_CODE</code>，也不要使用缩写</p>
<p><strong>3. 函数及结构体命名</strong></p>
<p>下划线式？小驼峰式？</p>
<p>小驼峰式：<code>firstName</code>，<code>hexToBinary</code><br>下划线式：<code>first_name</code>，<code>hex_to_binary</code></p>
<h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><h4 id="1-文件开头注释"><a href="#1-文件开头注释" class="headerlink" title="1. 文件开头注释"></a>1. 文件开头注释</h4><p>类似这样的注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Date: *** </span></span><br><span class="line"><span class="comment"> * Author: *** </span></span><br><span class="line"><span class="comment"> * Version: ***</span></span><br><span class="line"><span class="comment"> * Description: ***</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="2-变量声明注释"><a href="#2-变量声明注释" class="headerlink" title="2. 变量声明注释"></a>2. 变量声明注释</h4><p>和变量声明同一行，用 <code>//</code> 注释，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cacheCapacity = <span class="number">1024</span>;   <span class="comment">// cache 容量</span></span><br><span class="line"><span class="type">bool</span> isEndState = <span class="literal">false</span>;    <span class="comment">// 是否到了终止状态</span></span><br></pre></td></tr></table></figure>
<p>注释尽量用 tab 全对齐</p>
<h4 id="3-函数功能注释"><a href="#3-函数功能注释" class="headerlink" title="3. 函数功能注释"></a>3. 函数功能注释</h4><p>函数体前对函数进行注释，注明函数功能，参数类型及含义，返回值类型及含义，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param parm1 该参数的含义</span></span><br><span class="line"><span class="comment"> * @return 若有返回值，则注明返回值含义或其他说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> parm1)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-代码块注释"><a href="#4-代码块注释" class="headerlink" title="4. 代码块注释"></a>4. 代码块注释</h4><p>在函数内对某一个代码块进行注释，使用 <code>/*</code> 注释，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代码块功能说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (statement) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当循环或条件判断嵌套过多时，在代码块的结束部分加上注释标记，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; MAX_INDEX) &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125; <span class="comment">// 结束 while (index &lt; MAX_INDEX)</span></span><br><span class="line">&#125; <span class="comment">// 结束if (...)</span></span><br></pre></td></tr></table></figure>
<h3 id="三、排版"><a href="#三、排版" class="headerlink" title="三、排版"></a>三、排版</h3><h4 id="1-空格和换行"><a href="#1-空格和换行" class="headerlink" title="1. 空格和换行"></a>1. 空格和换行</h4><p>if, while 等和后面的括号之间要有一个空格，当有多个参数时，逗号后面也要有一个空格。<br>所有的二元运算符，除了”.”，应该使用空格将之与操作数分开，一元操作符和操作数之间不要加空格。<br>注释和注释标记之间需要一个空格，空行中不要有空格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; LinkList;             <span class="comment">// 注意这里 &#125; 后面有一个空格 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;         <span class="comment">// 注意 if 与 &#x27;(&#x27; 之间有一个空格，元素 &#x27;1&#x27; 和 num 与操作符 &#x27;==&#x27; 之间有一个空格</span></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释与双斜杠中间需要一个空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种类型的注释与 &#x27;/*&#x27; 中间也需要一个空格 */</span></span><br></pre></td></tr></table></figure>
<p>另外，函数体内逻辑相关的功能的某些代码中间可以加上空行进行区分，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> hex[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> bin[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    hex = getHex();</span><br><span class="line">    hexToBinary(hex, bin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一行代码太长时需要换行，尽量在运算符前换行，并且缩进是八个空格（两个 tab），比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((condition1 &amp;&amp; condition2) </span><br><span class="line">        || (condition3 &amp;&amp; condition4) </span><br><span class="line">        || !(condition5 &amp;&amp; condition6)) &#123; </span><br><span class="line">    doSomethingAboutIt(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-花括号形式"><a href="#2-花括号形式" class="headerlink" title="2. 花括号形式"></a>2. 花括号形式</h4><p>花括号在函数名在同一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不在同一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><ol>
<li>尽量不使用全局变量，尽量将变量作用域限定到最小，例如局部变量或者静态全局变量，重要全局变量尽量使用 getter 及 setter 调用。局部变量最好要初始化。</li>
<li>将指针释放后要将指针置空，否则可能会导致野指针，例如</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3. </p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>BAT批处理文件的使用（二）</title>
    <url>/58ced44c.html</url>
    <content><![CDATA[<h2 id="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等"><a href="#BAT批处理（二）：批量删除指定文件以及相关简单的语法结构-if-for-，系统变量errorlevel，变量延迟等" class="headerlink" title="BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等"></a>BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等</h2><p>前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 <code>bat</code> 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。<br><span id="more"></span><br>首先就是一条简单的 <code>del</code>：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">del F:\Code\C++\*.exe</span><br></pre></td></tr></table></figure><br>但是发现只能删除掉 <code>C++</code> 那个文件夹根目录下的 exe 文件，然后发现，在后面加上 <code>/s</code>，表示在当前目录递归删除指定文件，就是还要进入子目录寻找文件。</p>
<blockquote>
<p>/a 根据百属性选择要删除的文件<br>/f 强制删除只读度文件<br>/s 从所有子目录删除指定文件<br>/q 安静模式。删除全局通配符时，不要求确知</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">del F:\Code\C++\*.exe /s</span><br></pre></td></tr></table></figure>
<p>运行之后，哗啦啦，全删掉了(在其他盘里测试一下)：<br><img src="https://img-blog.csdnimg.cn/20200509172606608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>本来其实这样就可以了，把这个批处理脚本放到 C++ 文件夹根目录就行了，但是如果多次执行的时候，本来已经没有 exe 文件了，还要执行，就会提示 <code>找不到 G:\test\*.exe</code>，对于强迫症的我当然不能忍受起码提示一个 <code>exe文件已经删完啦</code> 之类的。要这样写势必要进行条件判断，然后，又去找了很多资料。<br>一开始搜到一个 <code>errorlevel</code> 的系统变量，会判断你当前这条语句是否执行，如果成功执行该变量的值为 <code>0</code>， 否则是 <code>1-255</code> 之间的某一个值，这里的值主要是根据语句未能成功执行的原因（其实就是跟中断类型差不多）来决定的，一般是 <code>1</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line">if ERRORLEVEL 1 goto fail</span><br><span class="line">if ERRORLEVEL 0 goto success</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>运行后发现了中文乱码，于是改一下编码为 <code>ANSI</code><img src="https://img-blog.csdnimg.cn/20200509174008621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再次执行，发现不管 <code>exe</code> 文件是否被删掉，都会执行 <code>success</code> 标号的语句，说明 <code>del</code> 语句都被执行了，只是找不到文件而已。<br><img src="https://img-blog.csdnimg.cn/20200509174405846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种方法不行那就试试其他方法，用 <code>if exist</code> 条件判断应该可以吧<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line">::if ERRORLEVEL 1 goto fail</span><br><span class="line">::if ERRORLEVEL 0 goto success</span><br><span class="line">if exist F:\Code\C++\*.exe (goto success) else (goto fail)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del F:\Code\C++\*.exe /s</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br>这里的 <code>::</code>是注释，当然注释还有其他写法</p>
<blockquote>
<p>1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>    2、rem 注释内容（不能出现重定向符号和管道符号）<br>    3、echo 注释内容（不能出现重定向符号和管道符号）〉nul<br>    4、if not exist nul 注释内容（不能出现重定向符号和管道符号）<br>    5、:注释内容（注释文本不能与已有标签重名）<br>    6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）<br>    7、goto 标签 注释内容（可以用作说明goto的条件和执行内容）<br>    8、:标签 注释内容（可以用作标签下方段的执行内容</p>
</blockquote>
<p>完美执行。<br>然后在之后的其他测试中，若 <code>C++</code> 根目录下没有 <code>exe</code> 文件，而在其子文件夹下有 <code>exe</code> 文件的话，就出问题了，因为 <code>if exist</code> 那行语句只是判断当前文件夹根目录下是否存在 <code>exe</code> 文件。那该怎么办呢？<br>应该要对 <code>C++</code> 根目录进行递归查找，便是 <code>for</code> 语句：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe	</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">	::echo %%s</span><br><span class="line">	set /a cnt=%cnt%+1</span><br><span class="line">)</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del *.exe /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br></pre></td></tr></table></figure><br><code>for</code> 循环后面的 <code>/R</code> 便是对当前文件夹进行递归查找，若存在后缀名为 <code>.exe</code> 文件，便把计数值+1.然后运行，又出错了。。。<br>cnt的值始终为1，这又是为什么呢？<br>又查了许多资料，发现 批处理语法中还有叫什么 <code>变量延迟</code> 的语法，具体就是 <strong>当我们准备执行一条命令的时候，命令解释器会先将命令读取，如果命令中有环境变量，那么就会将变量的值先读取来出，然后在运行这条命令</strong>，如：<code>echo %cnt%</code>，当我们执行这条命令的时候，命令解释器会先读出 <code>%cnt%</code> 的值，然后执行echo，得到的结果是屏幕上显示出 <code>cnt的值</code>。但是，有的时候，我们在执行一条命令的时候，命令解释器将环境变量的值读出来以后，我们的环境变量的值发生了改变，这时个再执行命令就是使用的变量改变前的值，这就不是我们想要的结果了。<br>也就是，当 <code>for</code> 语句执行时，命令解释器首先把它变成<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /R %s in (*.exe) do (set /a cnt=0+1 )</span><br></pre></td></tr></table></figure><br>因此在这个循环里面 <code>cnt</code> 就全是0了，这里我们就需要用到 <code>变量延迟</code> 了，设置 <code>setlocal enabledelayedexpansion</code>，然后将需要使用变量延迟的变量两边用 <code>!</code> 表示，即 <code>set /a cnt=!cnt!+1</code>.<br>关闭变量延迟的话就是 <code>setlocal disabledelayedexpansion</code>.<br>全部修改完了 <code>bat</code> 程序如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cls</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">set PATH=F:\Code\C++\</span><br><span class="line">set FILE=*.exe	</span><br><span class="line">set cnt=0</span><br><span class="line">for /R %PATH% %%s in (%FILE%) do (</span><br><span class="line">	::echo %%s</span><br><span class="line">	set /a cnt=!cnt!+1</span><br><span class="line">)</span><br><span class="line">if %cnt% EQU 0 (goto fail) else (goto success)</span><br><span class="line">goto done</span><br><span class="line">:fail</span><br><span class="line">echo exe文件已经没有啦，别删啦~</span><br><span class="line">goto done</span><br><span class="line">:success</span><br><span class="line">echo 正在删除所有烦人的exe文件...</span><br><span class="line">del %PATH%%FILE% /s</span><br><span class="line">echo 删除了%cnt%个文件！</span><br><span class="line">goto done</span><br><span class="line">:done</span><br><span class="line">echo 执行完成</span><br><span class="line">endlocal</span><br></pre></td></tr></table></figure>
<p>大功告成！！</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>BAT</tag>
        <tag>批处理</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的可变参数详解(va_list, va_start...)</title>
    <url>/9c76e862.html</url>
    <content><![CDATA[<h1 id="详解C语言中的可变参数-头文件stdarg-h"><a href="#详解C语言中的可变参数-头文件stdarg-h" class="headerlink" title="详解C语言中的可变参数(头文件stdarg.h)"></a>详解C语言中的可变参数(头文件stdarg.h)</h1><h2 id="1-获取函数的变长参数-va-list-va-start-va-arg-va-end"><a href="#1-获取函数的变长参数-va-list-va-start-va-arg-va-end" class="headerlink" title="1. 获取函数的变长参数(va_list, va_start, va_arg, va_end)"></a>1. 获取函数的变长参数(va_list, va_start, va_arg, va_end)</h2><p><a href="https://www.cnblogs.com/pengdonglin137/p/3345911.html">详细介绍</a></p>
<p>例：求若干个数的和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;        <span class="comment">//省略号前面有无逗号都可以</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="comment">//在stdarg.h 头文件中</span></span><br><span class="line">    va_list list;</span><br><span class="line">    <span class="comment">//为 num 个参数初始化 valist</span></span><br><span class="line">    <span class="built_in">va_start</span>(list, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(list, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li>
<li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li>
</ul>
<p>va_start 宏，获取可变参数列表的第一个参数的地址（list 是类型为 va_list 的指针，param1 是最后一个显式声明的参数）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(list, param1) (list = (va_list)&amp;param1 + sizeof(param1))</span></span><br></pre></td></tr></table></figure>
<p>va_arg 宏，返回变长参数的值，第二个参数是该变长参数的类型，返回指定类型并将指针指向下一参数（mode 参数描述了当前参数的类型）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(list, mode) ((mode *) (list += sizeof(mode)))[-1]</span></span><br></pre></td></tr></table></figure>
<p>va_end宏，清空va_list可变参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(list) (list = (va_list)0)</span></span><br></pre></td></tr></table></figure>
<p>注：以上 sizeof() 只是为了说明工作原理，实际实现中，增加的字节数需保证为为 int 的整数倍</p>
<p><strong>注意事项：</strong></p>
<p>a）他们都是宏，因此不能做运算和求地址等操作；</p>
<p>b）变长参数的类型和数目不能通过宏来获取，只能通过自己写程序控制；</p>
<p>c）编译器对变长参数函数的原型检查不够严格，会影响代码质量。</p>
<p>C中的 <code>printf</code> 函数实际上就使用了变长参数，实现原理如下所示(参考前文博客链接中代码)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format...)</span></span>&#123;</span><br><span class="line">    va_list argptr;</span><br><span class="line">    <span class="built_in">va_start</span>(argptr, format);        <span class="comment">//va_start</span></span><br><span class="line">      </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (ch = *(format++)) &#123;       <span class="comment">//逐个遍历format字符串</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            ch = *(format++);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> *name = <span class="built_in">va_arg</span>(argptr, <span class="type">char</span> *);    <span class="comment">//va_arg</span></span><br><span class="line">                cout&lt;&lt;name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> age = <span class="built_in">va_arg</span>(argptr, <span class="type">int</span>);    <span class="comment">//va_arg</span></span><br><span class="line">             cout&lt;&lt;age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">va_end</span>(argptr);        <span class="comment">//va_end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myprintf</span>(<span class="string">&quot;My name is %s, age %d.&quot;</span>, <span class="string">&quot;AnnieKim&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-va-list-的用法"><a href="#2-va-list-的用法" class="headerlink" title="2. va_list 的用法"></a>2. va_list 的用法</h2><p>C语言的 printf, scanf 函数不同于我们写的那种只能接受固定参数个数的函数，他们可以接受任意多个参数。C 语言允许定义这样的接受变参的函数, 它的机制就是 va_list , 使用它 , 我们也可以定义自己的变参个数的函数.</p>
<p>首先, 看下 printf 函数的声明:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">char</span> * format, ... )</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>变参处的定义或声明, 用 <code>...</code> 代替参数类型.</li>
<li>变参 <code>...</code> 只能放在参数列表最末尾.</li>
</ol>
<p>这里我们写一个小程序, 来演示 va_list 的用法, 定义一个 barycentre 函数, 计算 n 个点的重心并返回, 声明如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="built_in">Point</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> _x, <span class="type">double</span> _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> <span class="built_in">barycentre</span>(<span class="type">int</span> n...) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> p;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> sum = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    va_list list;</span><br><span class="line">    <span class="built_in">va_start</span>(list, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p = <span class="built_in">va_arg</span>(list, Point);</span><br><span class="line">        sum.x += p.x;</span><br><span class="line">        sum.y += p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    sum.x /= n;</span><br><span class="line">    sum.y /= n;</span><br><span class="line">    <span class="built_in">va_end</span>(list);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point P1 = <span class="built_in">Point</span>(<span class="number">1.25</span>, <span class="number">3.0</span>);</span><br><span class="line">    Point P2 = <span class="built_in">Point</span>(<span class="number">3.0</span>, <span class="number">5.2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">barycentre</span>(<span class="number">2</span>, P1, P2).x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 va 的实现可以看出，指针的合理运用，把C语言简洁、灵活的特性表现得淋漓尽致，叫人不得不佩服 C 的强大和高效。不可否认的是，给编程人员太多自由空间必然使程序的安全性降低。va 中，为了得到所有传递给函数的参数，需要用va_arg依次遍历。其中存在两个隐患：</p>
<p>1）如何确定参数的类型。</p>
<p>va_arg 在类型检查方面与其说非常灵活，不如说是很不负责，因为是强制类型转换，va_arg 都把当前指针所指向的内容强制转换到指定类型；</p>
<p>2） 结束标志。如果没有结束标志的判断，va将按默认类型依次返回内存中的内容，直到访问到非法内存而出错退出。例2中 SqSum() 求的是自然数的平方和，所以我把负数和0作为它的结束标志。例如 scanf 把接收到的回车符作为结束标志，<code>大家熟知的 printf() 对字符串的处理用 &#39;\0&#39; 作为结束标志</code>，无法想象C中的字符串如果没有<code>&#39;\0&#39;</code>，代码将会是怎样一番情景，估计那时最流行的可能是字符数组，或者是 malloc/free。</p>
<p>允许对内存的随意访问，会留给不怀好意者留下攻击的可能。当处理 cracker 精心设计好的一串字符串后，程序将跳转到一些恶意代码区域执行，以使 cracker 达到其攻击目的。(常见的 exploit 攻击)所以，必需禁止对内存的随意访问和严格控制内存访问边界。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>可变参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言进阶学习</title>
    <url>/1d66df69.html</url>
    <content><![CDATA[<h1 id="C语言进阶学习"><a href="#C语言进阶学习" class="headerlink" title="C语言进阶学习"></a>C语言进阶学习</h1><span id="more"></span>
<h2 id="1-typedef、void-和-sizeof-的使用"><a href="#1-typedef、void-和-sizeof-的使用" class="headerlink" title="1. typedef、void 和 sizeof 的使用"></a>1. typedef、void 和 sizeof 的使用</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ol>
<li>简化 struct 关键字</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将struct Student类型简化成Stu，就是少写一个struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> Stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更简单的写法就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> s1 = &#123;Cherry, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">//可以直接用Stu定义一个结构体变量</span></span><br><span class="line">    Stu s2 = &#123;Alice, <span class="number">23</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>区分数据类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里p1是char*类型，而p2是char类型</span></span><br><span class="line">    <span class="type">char</span> *p1, p2;</span><br><span class="line">    <span class="comment">//为了做更好的区分，可以使用typedef定义char*</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">    <span class="comment">//这样两个变量都是char指针类型，这样等价于 char *p1, *p2;</span></span><br><span class="line">    PCHAR p1, p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>提高移植性</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> MYTYPE</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写成</span></span><br><span class="line">MYTYPE a = <span class="number">10</span>;</span><br><span class="line">MYTYPE b = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ol>
<li>无类型，不能通过无类型创建变量，因为不知道分配多少内存空间</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样是错误的，编译器会报错</span></span><br><span class="line"><span class="type">void</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以限定函数的返回值，限定函数参数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段 <code>C</code> 代码，看似有很多问题：func 函数没有返回类型，返回了 10，并且函数没有传入参数，调用函数时还传入了参数，但是该 C 语言代码依旧可以运行，可以看出 C 语言并不严谨。</p>
<p>这时将 func 函数改成下面这样，编译器就会报出警告</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>void* 万能指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pInt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *pChar = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同类型指针之间需要强制转换才不会报警告</span></span><br><span class="line">pChar = (<span class="type">char</span>*)pInt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 void* 万能指针，就不会报警告了</span></span><br><span class="line">pChar = p;</span><br></pre></td></tr></table></figure>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><ol>
<li>首先 <code>sizeof</code> 本质上不是一个函数，而是一个运算符，类似于 <code>+-*/</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof int = %d\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//对于统计变量的时候，可以不加小括号，所以他不是函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof d = %d\n&quot;</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>sizeof</code> 返回一个无符号整型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (a - <span class="number">20</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大于0&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码输出结果为 <code>大于0</code>，因为一个无符号整数和有符号整数做运算，最后统一转换为无符号整数。</p>
<p>同理可以验证 sizeof 返回的也是无符号整数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">int</span>) - <span class="number">5</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大于0&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后得到的结果也是 <code>大于0</code>。</p>
<ol>
<li><code>sizeof</code> 其他用法</li>
</ol>
<p>统计数组占用内存空间大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##sizeof arr = %d\n&quot;</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof arr = %d\n&quot;</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    <span class="built_in">test</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof arr = 16</span><br><span class="line">##sizeof arr = 8</span><br></pre></td></tr></table></figure>
<p>这是因为当数组以参数的形式传递时，将得到的是数组的指针，即数组的第一个元素所在的位置，这时打印出的大小便是指针的大小。</p>
<h2 id="2-C语言-d-等输出格式意义"><a href="#2-C语言-d-等输出格式意义" class="headerlink" title="2. C语言 %d 等输出格式意义"></a>2. C语言 %d 等输出格式意义</h2><ol>
<li><p>%d整型输出，%ld长整型输出。</p>
</li>
<li><p><strong>%p指针变量地址，如果输出数据不够8位数，则左边补零。</strong></p>
</li>
<li><p>%o以八进制数形式输出整数。</p>
</li>
<li><p>%x以十六进制数形式输出整数。</p>
</li>
<li><p>%u以十进制数输出unsigned型数据(无符号数)。</p>
</li>
<li><p>%c用来输出一个字符。</p>
</li>
<li><p>%s用来输出一个字符串。</p>
</li>
<li><p>%f用来输出实数，以小数形式输出。</p>
</li>
<li><p>%e以指数形式输出实数。</p>
</li>
<li><p>%g根据大小自动选f格式或e格式，且不输出无意义的零。</p>
</li>
</ol>
<h2 id="3-内存的四个区域"><a href="#3-内存的四个区域" class="headerlink" title="3. 内存的四个区域"></a>3. 内存的四个区域</h2><ul>
<li>代码区<ul>
<li>共享</li>
<li>只读</li>
</ul>
</li>
<li>数据区<ul>
<li>静态变量，全局变量，常量</li>
<li>已初始化（data段）</li>
<li>未初始化（bss段）</li>
</ul>
</li>
<li>栈区<ul>
<li>编译器自动分配释放，存放函数的参数值、返回值、局部变量等</li>
<li>局部变量的生存周期为函数内部申请到释放该段栈空间</li>
</ul>
</li>
<li>堆区<ul>
<li>容量远大于栈</li>
<li>用于动态内存分配</li>
<li>堆在内存中位于 bss 段和栈区之间，一般由程序员分配和释放，程序结束后由 OS 释放</li>
</ul>
</li>
</ul>
<p><strong>局部变量在栈空间创建空间举例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="built_in">getString</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是无法正确输出 <code>Hello World</code> 的，因为在 <code>getString</code> 中创建的是局部变量 <code>str</code>，是在栈空间中创建空间，而在函数 <code>getString</code> 运行结束后，栈空间将被释放，因此获得的 <code>str</code> 指针为空。</p>
<p><em>即不要返回局部变量的地址</em></p>
<p><strong>堆区举例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">getSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开辟4*5=20B空间，开辟到了堆区</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        p[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">getSpace</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);        <span class="comment">//释放掉p指向的内存区域</span></span><br><span class="line">    p = <span class="literal">NULL</span>;       <span class="comment">//释放掉之后将p指向空，避免p成为野指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>堆区分配内存注意点</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区注意点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(<span class="type">char</span> *pp)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *temp = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    pp = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">allocateSpace</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码输出结果实际上是 null，并不会输出字符串 <code>Hello World</code></p>
<p>因为在 <code>test04</code> 中，传入的参数是 <code>char</code> 指针，是一个局部变量，在栈中分配内存。函数 <code>allocateSpace</code> 中的参数也是在栈中分配内存，只不过 <code>p</code> 是在 <code>test04</code> 的栈中，而 <code>pp</code> 是在 <code>allocateSpace</code> 的栈中。而用 <code>malloc</code> 在堆中分配内存时，返回的首地址指针赋值给了一个局部变量 <code>temp</code>，然后在这个堆空间中复制字符串 <code>Hello World</code>，最后这个首地址指针又赋值给了 <code>pp</code>。因此自始至终都未修改 <code>test04</code> 栈中的 <code>p</code> 指针的值，所以最后输出的是 <code>null</code>。</p>
<p>要想修改 <code>p</code> 指针的值，需要用更高级别的指针进行修改，这时传入函数 <code>allocateSpace</code> 的参数应该是 <code>p</code> 指针的地址，即 <code>p</code> 指针的指针（二级指针），这样才能完成对 <code>p</code> 指针的赋值操作。</p>
<p>将代码改成下面这样，就可以正确输出结果了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace2</span><span class="params">(<span class="type">char</span> **pp)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *temp = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    *pp = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">allocateSpace2</span>(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s&quot;</span>, p);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-静态变量和全局变量"><a href="#4-静态变量和全局变量" class="headerlink" title="4. 静态变量和全局变量"></a>4. 静态变量和全局变量</h2><p>数据区中存放<strong>全局变量、静态变量、常量</strong></p>
<p><strong>静态变量</strong></p>
<p>静态变量在程序运行前分配内存，生命周期在程序结束时死亡。默认属于内部链接属性，只能在该文件内部使用。</p>
<p><strong>全局变量</strong></p>
<p>默认在 C 语言下，全局变量前加了关键字 <code>extern</code>。属于外部链接属性。</p>
<h2 id="5-常量"><a href="#5-常量" class="headerlink" title="5. 常量"></a>5. 常量</h2><p><strong>const修饰的常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2022</span>;     <span class="comment">//放在数据区的常量区中，受到保护，无法修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无法直接修改一个 const 修饰的常量</span></span><br><span class="line">    <span class="comment">// a = 333;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用指针修改，实际上也是无法成功，在解引用的时候会出现异常</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局常量是无法被直接或间接修改的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部常量也无法被直接修改</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">421</span>;</span><br><span class="line">    <span class="comment">// b = 2022;</span></span><br><span class="line">    <span class="comment">//但是可以被间接修改，因为局部变量存放在栈中，不受常量区保护</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;b;</span><br><span class="line">    *p = <span class="number">145</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是局部常量可以被间接修改，因为局部变量存放在栈中，不受常量区保护。</p>
<p><strong>字符串常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p1 = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们输出的指针是同一个，说明同样的字符串常量在内存中只保留一份，节省了内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串常量也是不可以修改的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p1 = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    p1[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有些编译器支持修改字符串常量。而且对于相同的字符串常量是否共享，不同的编译器会有不同的结果。</p>
<h2 id="6-函数调用流程"><a href="#6-函数调用流程" class="headerlink" title="6. 函数调用流程"></a>6. 函数调用流程</h2><h3 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h3><p>将一些频繁使用且短小的函数定义成宏函数，定义宏函数时要注意函数的完整性。</p>
<p>优点：<strong>以空间换时间</strong>，这里的时间就是将宏函数当做普通函数时参数的入栈出栈操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x, y) ((x) + (y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2017</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">ADD</span>(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用惯例"><a href="#函数调用惯例" class="headerlink" title="函数调用惯例"></a>函数调用惯例</h3><p>对于下面这一段代码，分析程序调用的流程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _a = a;</span><br><span class="line">    <span class="type">int</span> _b = b;</span><br><span class="line">    <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将主函数中 <code>ret</code> 进栈，然后调用 <code>sum</code> 函数，将改行的返回地址进栈。接着进入到 <code>sum</code> 函数中，将参数 <code>b</code> 和 <code>a</code> 依次进栈，再在栈中为 <code>_a</code> 和 <code>_b</code> 开辟空间，最后返回两者的和存到一个临时变量中，这个变量也是在栈中，然后函数执行完毕，释放掉栈中的变量，回到返回地址处继续执行代码。</p>
<p>注意点：</p>
<ol>
<li>参数入栈是从右到左</li>
<li>由主调函数负责出栈</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>调用惯例</th>
<th>出栈方</th>
<th>参数传递</th>
<th>名字修饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>cdecl（C和C++默认）</td>
<td>函数调用方（主调函数）</td>
<td>从右到左参数入栈</td>
<td>下划线+函数名</td>
</tr>
<tr>
<td>stdcall</td>
<td>函数本身（被调函数）</td>
<td>从右到左参数入栈</td>
<td>下划线+函数名+@+参数字节数</td>
</tr>
<tr>
<td>fastcall</td>
<td>函数本身（被调函数）</td>
<td>前两个参数由寄存器传递，其余参数通过栈传递</td>
<td>@+函数名+@+参数字节数</td>
</tr>
<tr>
<td>pascal</td>
<td>函数本身（被调函数）</td>
<td>从左到右参数入栈</td>
<td>较为复杂，略</td>
</tr>
</tbody>
</table>
</div>
<h3 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h3><p>main -&gt; 子函数1 -&gt; 子函数2</p>
<ul>
<li>main 函数在栈区开辟的内存，所有子函数都可以使用</li>
<li>main 函数在堆区开辟的内存，所有子函数都可以使用</li>
<li>子函数 1 在栈区开辟的内存，子函数 1 和 2 都可以使用</li>
<li>子函数 1 在堆区开辟的内存，所有函数都可以使用</li>
<li>子函数 2 在全局区开辟的内存，子函数 1 和 main 函数都可以使用</li>
</ul>
<h3 id="栈扩展方向"><a href="#栈扩展方向" class="headerlink" title="栈扩展方向"></a>栈扩展方向</h3><p>通过下面的代码可以得到栈顶在低地址，栈底在高地址，是从高地址向低地址扩展的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%p\n&quot;</span>, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%p\n&quot;</span>, &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000001041FE00</span><br><span class="line">0x000000001041FE08</span><br><span class="line">0x000000001041FE10</span><br></pre></td></tr></table></figure>
<h2 id="7-野指针和空指针"><a href="#7-野指针和空指针" class="headerlink" title="7. 野指针和空指针"></a>7. 野指针和空指针</h2><p><strong>空指针</strong>指向 <code>NULL</code>，而<strong>野指针</strong>指向一个已经删除的对象或未申请访问受限区域的指针。野指针只能通过良好的代码习惯来避免，而空指针可以通过判断语句来避免。</p>
<p><strong>野指针的三种情况</strong></p>
<ul>
<li>指针变量未初始化<ul>
<li>指针创建时不会自动设置为 NULL，需要手动置为空或指向有效内存</li>
</ul>
</li>
<li>指针释放后未置空<ul>
<li>指针释放后只是释放掉了当前指针指向的内存，并没有修改指针的值</li>
</ul>
</li>
<li>指针变量超出了作用域<ul>
<li>即在函数中返回局部变量的地址</li>
</ul>
</li>
</ul>
<p>对于指针 <code>free</code> 后未置空的情况，下面有个例子可以说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;I want to swim...&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <code>printf</code> 输出的是正确的字符串，而第二个 <code>printf</code> 输出却是不正确的值，因为 <code>free</code> 操作释放掉了原来指针指向的内存，那片内存可以被计算机中其他程序使用，因此数据成了脏数据（尽管可能那段内存没有被使用，数据还和原来一样，但是从逻辑上指针已经失去了对那片内存的控制权）。对于野指针，可以读取（编译器不会报错），但是要写入的话就会报错。</p>
<p>对于函数中返回局部变量的地址，因为在函数中的局部变量是在栈中开辟的，函数调用完后将会清空栈中的变量，这样指针指向的地址也就失去了意义，成为了野指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码两句输出理论上都是无法输出正确结果的，但是代码运行结果确是第一个能正确输出，第二个无法正确输出。这是因为编译器的缘故，编译器会保留一次栈中的变量供之后访问。（不同的编译器可能会有不同的结果，但是尽量不要这样写）</p>
<p>另外：空指针可以重复释放，而野指针不能重复释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这样不会报错</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样会报错</span></span><br><span class="line">    <span class="type">int</span> *pp = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(pp);</span><br><span class="line">    <span class="built_in">free</span>(pp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-指针的步长"><a href="#8-指针的步长" class="headerlink" title="8. 指针的步长"></a>8. 指针的步长</h2><p>指针步长指的是指针变量 +1 后跳跃的字节数，也是指指针解引用的时候取出的字节数。下面的例子很好的帮助理解指针的步长：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2022</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + <span class="number">1</span>, &amp;a, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span>*)(buf + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以成功输出 2022。</p>
<p>下面以一个结构体作为例子，进一步说明指针步长：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;         <span class="comment">//0~3</span></span><br><span class="line">    <span class="type">int</span> b;          <span class="comment">//4~7</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];   <span class="comment">//8~71</span></span><br><span class="line">    <span class="type">int</span> d;          <span class="comment">//72~76</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pointer</span> p = &#123;<span class="string">&#x27;B&#x27;</span>, <span class="number">2022</span>, <span class="string">&quot;I will go to Beijing soon...&quot;</span>, <span class="number">8013</span>&#125;;</span><br><span class="line">    <span class="comment">//p中d字段的偏移量？(包含在 stddef.h 头文件中)</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     *  #define offsetof(s, m) (size_t)&amp;(((s*)0)-&gt;m)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d&#x27;s offset =  %d\n&quot;</span>, <span class="built_in">offsetof</span>(<span class="keyword">struct</span> Pointer, d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">int</span>*)((<span class="type">char</span>*)(&amp;p) + <span class="built_in">offsetof</span>(<span class="keyword">struct</span> Pointer, d)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码要输出结构体中字段 <code>d</code>，我们首先获取 <code>d</code> 的偏移量：<code>offsetof(struct Pointer, d)</code>，然后取得结构体首地址，将指针类型转成 <code>char*</code>，然后加上偏移量之后再转成 <code>int*</code>，最后再解引用，输出结果 <code>8013</code>。</p>
<h2 id="9-指针做函数参数"><a href="#9-指针做函数参数" class="headerlink" title="9. 指针做函数参数"></a>9. 指针做函数参数</h2><p>指针做函数参数，具有<strong>输入</strong>和<strong>输出</strong>两种特性</p>
<p><strong>输入特性</strong>：在主调函数分配内存，被调函数中使用<br><strong>输出特性</strong>：在被调函数分配内存，主调函数中使用（被调函数中要用比主调函数更高级的指针去修改）</p>
<h2 id="10-字符串基本操作"><a href="#10-字符串基本操作" class="headerlink" title="10. 字符串基本操作"></a>10. 字符串基本操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当未定义字符数组的长度时，会输出乱码，因为输出直到出现 &#x27;\0&#x27; 为止</span></span><br><span class="line">    <span class="type">char</span> str1[] = &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 = %s\n\n&quot;</span>, str1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当定义了字符数组的长度时，对字符数组初始化后会在后面默认用 0 填充</span></span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 = %s\n\n&quot;</span>, str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若以字符串初始化，编译器会默认在字符串最后添加 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> str3[] = <span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3 = %s\n&quot;</span>, str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof str3 = %d\n&quot;</span>, <span class="built_in">sizeof</span>(str3));      <span class="comment">// 8 sizeof 计算 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen str3 = %d\n\n&quot;</span>, <span class="built_in">strlen</span>(str3));    <span class="comment">// 7 strlen 不计算 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str4[<span class="number">20</span>] = <span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4 = %s\n&quot;</span>, str4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof str4 = %d\n&quot;</span>, <span class="built_in">sizeof</span>(str4));      <span class="comment">// 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen str4 = %d\n\n&quot;</span>, <span class="built_in">strlen</span>(str4));    <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str5[] = <span class="string">&quot;Beijing\0Welcome&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str5 = %s\n&quot;</span>, str5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof str5 = %d\n&quot;</span>, <span class="built_in">sizeof</span>(str5));      <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen str5 = %d\n\n&quot;</span>, <span class="built_in">strlen</span>(str5));    <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str6[] = <span class="string">&quot;Beijing\012Welcome&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str6 = %s\n&quot;</span>, str6);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof str6 = %d\n&quot;</span>, <span class="built_in">sizeof</span>(str6));      <span class="comment">// 16 \012 是用八进制表示的转义字符，表示换行，再加上末尾的 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen str6 = %d\n\n&quot;</span>, <span class="built_in">strlen</span>(str6));    <span class="comment">// 15  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str1 = Beijing爅€       <span class="comment">//后面为乱码</span></span><br><span class="line"></span><br><span class="line">str2 = Beijing</span><br><span class="line"></span><br><span class="line">str3 = Beijing</span><br><span class="line"><span class="keyword">sizeof</span> str3 = <span class="number">8</span></span><br><span class="line">strlen str3 = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">str4 = Beijing</span><br><span class="line"><span class="keyword">sizeof</span> str4 = <span class="number">20</span></span><br><span class="line">strlen str4 = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">str5 = Beijing</span><br><span class="line"><span class="keyword">sizeof</span> str5 = <span class="number">16</span></span><br><span class="line">strlen str5 = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">str6 = Beijing</span><br><span class="line">Welcome</span><br><span class="line"><span class="keyword">sizeof</span> str6 = <span class="number">16</span></span><br><span class="line">strlen str6 = <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2 id="11-字符串拷贝"><a href="#11-字符串拷贝" class="headerlink" title="11. 字符串拷贝"></a>11. 字符串拷贝</h2><p>这里实现了字符串拷贝的三种实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyString01</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用下标方式拷贝</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dest[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyString02</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*(src + i) != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *(dest + i) = *(src + i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    *(dest + i) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyString03</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*dest++ = *src++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第三种实现只有一行代码 <code>while (*dest++ = *src++);</code>，在 <code>while</code> 循环中，当 <code>*src</code> 取到 <code>\0</code> 时，就把它当做 <code>0</code> 看待，因此 <code>while</code> 循环条件中出现 <code>0</code> 便不会继续循环下去，因此会一直拷贝 <code>src</code> 直到遇到 <code>\0</code>，结束循环时，<code>src</code> 指向 <code>\0</code> 的下一个位置。</p>
<p>字符串翻转实现同理。</p>
<h2 id="12-字符串格式化"><a href="#12-字符串格式化" class="headerlink" title="12. 字符串格式化"></a>12. 字符串格式化</h2><ol>
<li><strong>sprintf 函数</strong></li>
</ol>
<p>函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数的参数是可变参数。若成功则返回实际格式化的字符个数，否则返回 -1</p>
<p>具体用法参考 <strong>《C++常用函数整理》</strong> 这篇博客。</p>
<ol>
<li><strong>sscanf 函数</strong></li>
</ol>
<p>函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：<br>从 str 指定的字符串读取数据，并根据参数 format 字符串来转换并格式化数据</p>
<p>返回值：<br>成功返回参数数目，失败返回 -1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%<em>d 或 %</em>s</td>
<td>跳过数据</td>
</tr>
<tr>
<td>%[width]s</td>
<td>读取指定宽度的数据</td>
</tr>
<tr>
<td>%[a-z]</td>
<td>匹配所有小写字母</td>
</tr>
<tr>
<td>%<sup><a href="#fn_a" id="reffn_a">a</a></sup></td>
<td>匹配非字符a的任意字符</td>
</tr>
</tbody>
</table>
</div>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;http://192.168.3.107:8080&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// char *str = &quot;1234ABCD&quot;;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%*[^/]//%[^:]%*s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// char *str = &quot;ABCD2022&quot;;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// sscanf(str, &quot;%*s%d&quot;, buf);      //这样写的话在 %*s 的时候就已经忽略掉整个 str 了</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应该像下面这样</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;ABCD 2022&quot;</span>;        <span class="comment">//加上一个空格</span></span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%*s%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%15s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一次匹配失败，后续都不再进行匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;ccherry20221314&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%[chery]&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;abcde12345&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%[^e]&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">30</span>] = &#123;<span class="string">&quot;http://192.168.3.107:8080&quot;</span>&#125;, ss[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> protocol[<span class="number">20</span>], host[<span class="number">20</span>], port[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(s,<span class="string">&quot;%[^:]://%[^:]:%[1-9]&quot;</span>, protocol, host, port);</span><br><span class="line">    <span class="comment">/*这样可以把协议名称，IP名称和端口号分别取出*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.3</span><span class="number">.107</span></span><br><span class="line"><span class="number">2022</span></span><br><span class="line">http:<span class="comment">//192.168.</span></span><br><span class="line">ccherry</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>
<p>要注意的一点是：<strong>如果第一次匹配失败，后续将不再匹配。</strong></p>
<p><strong>sscanf 的练习</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sscanf练习</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *ip = <span class="string">&quot;192.168.1.109&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>, num4 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(ip, <span class="string">&quot;%d.%d.%d.%d&quot;</span>, &amp;num1, &amp;num2, &amp;num3, &amp;num4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d\n&quot;</span>, num1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num2 = %d\n&quot;</span>, num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num3 = %d\n&quot;</span>, num3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num4 = %d\n&quot;</span>, num4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;GMY#baominyang@hrsoft.net&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sscanf</span>(str, <span class="string">&quot;%*[^#]#%[^@]&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My name is %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-malloc、calloc、realloc"><a href="#13-malloc、calloc、realloc" class="headerlink" title="13. malloc、calloc、realloc"></a>13. malloc、calloc、realloc</h2><p><strong>calloc</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：在内存动态存储区中分配 <code>nmemb</code> 块长度为 <code>size</code> 字节的连续区域，<strong><code>calloc</code> 自动将分配的内存置零。</strong></p>
<p>参数：</p>
<ul>
<li>nmenb：所需内存单元数量</li>
<li>size：每个内存单元的大小（字节）</li>
</ul>
<p>返回值：内存起始地址，错误则返回 NULL.</p>
<p><strong>realloc</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<p>重新分配用 <code>malloc</code> 和 <code>calloc</code> 分配的空间。<br>realloc不会自动清理增加的内存（即新增加的内存不会赋值为0），需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，否则就会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。</p>
<p>参数：</p>
<ul>
<li>ptr: 为之前分配的内存的起始地址，若为 NULL，则功能和 <code>malloc</code> 一致</li>
<li>size: 重新分配的内存的大小</li>
</ul>
<h2 id="14-const"><a href="#14-const" class="headerlink" title="14. const"></a>14. const</h2><p>全局 const 无法被修改，局部 const 当做局部变量使用，可以被间接修改。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言预处理器和宏的高级用法</title>
    <url>/aaaac292.html</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍 C 语言中类似 <code>#define</code>, <code>#if</code>, <code>#ifdef</code> 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。<br>本篇文章将不会介绍简单的宏用法，例如 <code>#define ADD(a, b) ((a)+(b))</code><br>本篇文章大部分参考《C Primer Plus 第六版》第 16 章</p>
</blockquote>
<span id="more"></span>
<h2 id="一、预处理及宏"><a href="#一、预处理及宏" class="headerlink" title="一、预处理及宏"></a>一、预处理及宏</h2><h3 id="1-1-“-”-运算符"><a href="#1-1-“-”-运算符" class="headerlink" title="1.1 “#” 运算符"></a>1.1 “#” 运算符</h3><p><code>#</code> 是一个预处理运算符，可以将记号转化成字符串。例如 <code>#define TYPE(x) #x</code>，若使用宏 <code>TYPE(int)</code>，则将其替换成<strong>字符串</strong> <code>&quot;int&quot;</code>，<code>#x</code> 就是转换为 <code>x</code> 的形参名。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The num 3 is an &quot;</span>TYPE(<span class="type">int</span>)<span class="string">&quot; type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<code>The num 3 is an int type</code></p>
<h3 id="1-2-“-”-运算符"><a href="#1-2-“-”-运算符" class="headerlink" title="1.2 “##” 运算符"></a>1.2 “##” 运算符</h3><p>与 <code>#</code> 运算符类似，<code>##</code> 运算符可以用于类函数宏的替换部分，而且还可以用于对象宏的替换部分。<code>##</code> 运算符将两个记号组合成一个记号，例如 <code>#define TEST(n) TEST_##n</code>，然后宏 <code>TEST1</code> 将其展开为 <code>TEST_1</code>。</p>
<p>下面是一个具体的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_XN(n) printf(<span class="string">&quot;x&quot;</span>#n<span class="string">&quot; = %d\n&quot;</span>, x##n) </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">14</span>;      <span class="comment">// 展开成 int x1 = 14;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">2</span>)</span> = <span class="number">20</span>;      <span class="comment">// 展开成 int x2 = 20;</span></span><br><span class="line">    <span class="type">int</span> x3 = <span class="number">30</span>;</span><br><span class="line">    PRINT_XN(<span class="number">1</span>);            <span class="comment">// 展开成 printf(&quot;x1 = %d\n&quot;, x1);</span></span><br><span class="line">    PRINT_XN(<span class="number">2</span>);            <span class="comment">// 展开成 printf(&quot;x2 = %d\n&quot;, x2);</span></span><br><span class="line">    PRINT_XN(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，<code>#</code> 运算符组合成<strong>字符串</strong>，而 <code>##</code> 运算符组合成为一个新的<strong>标识符</strong>。</p>
</blockquote>
<h3 id="1-3-undef-指令"><a href="#1-3-undef-指令" class="headerlink" title="1.3 #undef 指令"></a>1.3 #undef 指令</h3><p><code>#undef</code> 指令用于取消已定义的 <code>#define</code> 指令。若之前没有定义某个宏，取消对其的定义也是有效的，如果想使用一个名称，但不确定之前是否已经用过，使用 <code>#undef</code> 先取消定义是一个安全的方法。</p>
<h3 id="1-4-条件编译指令"><a href="#1-4-条件编译指令" class="headerlink" title="1.4 条件编译指令"></a>1.4 条件编译指令</h3><h4 id="1-4-1-ifdef、-else-和-endif-指令"><a href="#1-4-1-ifdef、-else-和-endif-指令" class="headerlink" title="1.4.1 #ifdef、#else 和 #endif 指令"></a>1.4.1 #ifdef、#else 和 #endif 指令</h4><p>先用一个简单的例子来说明这三个条件编译指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;horse.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cow.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码理解起来应该挺简单，若用 <code>#define</code> 定义了 <code>MAVIS</code>，就引入 <code>horse.h</code> 头文件，若没有定义 <code>MAVIS</code> 就引入头文件 <code>cow.h</code>。</p>
<p><code>#ifdef</code> 测试的宏可以是对象宏，也可以是函数宏。</p>
<h4 id="1-4-2-ifndef"><a href="#1-4-2-ifndef" class="headerlink" title="1.4.2 #ifndef"></a>1.4.2 #ifndef</h4><p><code>#ifndef</code> 用法和 <code>#ifdef</code> 类似，但是意思相反。除此之外 <code>#ifndef</code> 还可以防止相同的宏被重复定义，例如下面的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MATH_H_</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>#ifndef</code> 也可以避免头文件被引入多次。</p>
<h4 id="1-4-3-if、-elif"><a href="#1-4-3-if、-elif" class="headerlink" title="1.4.3 #if、#elif"></a>1.4.3 #if、#elif</h4><p><code>#if</code> 和 <code>#elif</code> 后面跟一个常量表达式，如果表达式的值为非零，则表达式为真，类似于 C 语言中的 if else，可以使用关系运算符和逻辑运算符。</p>
<p><code>#if</code> 和 <code>#elif</code> 后面的宏只能是对象宏，不能是函数宏。</p>
<h4 id="1-4-4-defined"><a href="#1-4-4-defined" class="headerlink" title="1.4.4 #defined"></a>1.4.4 #defined</h4><p><code>#defined</code> 用于判断宏是否已经被定义，可以是对象宏，也可以是函数宏，可以和 <code>#elif</code> 嵌套使用。</p>
<p>条件编译可以让程序更容易移植，改变文件开头的几个关键定义，可以根据不同的架构或系统设置不同的值和包含不同的文件。</p>
<h3 id="1-5-预定义宏"><a href="#1-5-预定义宏" class="headerlink" title="1.5 预定义宏"></a>1.5 预定义宏</h3><p>C 标准规定了一些预定义宏，如下列表格所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATE</strong></td>
<td>预处理的日期（“Mmm dd yyyy”形式的字面量，如 Nov 12 2023）</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>表示当前源代码文件名的字符串字面量</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>表示当前源代码文件中行号的整型量</td>
</tr>
<tr>
<td><strong>STDC</strong></td>
<td>设置为 1 时表示遵循 C 标准</td>
</tr>
<tr>
<td><strong>STDC_HOSTED</strong></td>
<td>本机环境设置为 1，否则设置为 0</td>
</tr>
<tr>
<td><strong>STDC_VERSION</strong></td>
<td>支持 C99 标准，设置为 199901L；支持 C11标准，设置为 201112L</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>翻译代码的时间，格式为 “hh:mm:ss”</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-6-line-和-error"><a href="#1-6-line-和-error" class="headerlink" title="1.6 #line 和 #error"></a>1.6 #line 和 #error</h3><p><code>#line</code> 指令重置 <code>__LINE__</code> 和 <code>__FILE__</code> 宏报告的行号和文件名，用法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 1000          <span class="comment">// 将当前行号重置为 1000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 cool.c     <span class="comment">// 将当前行号重置为 10，文件名重置为 cool.c</span></span></span><br></pre></td></tr></table></figure>
<p><code>#error</code> 指令让预处理器发出一条错误信息，该消息包含指令中的文本，用法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译上述代码将会产生 error，并且提示 <code>Not C11</code>。</p>
<h3 id="1-7-变参宏-…-和-VAARGS"><a href="#1-7-变参宏-…-和-VAARGS" class="headerlink" title="1.7 变参宏 … 和 __VAARGS_"></a>1.7 变参宏 … 和 __VA<em>ARGS_</em></h3><p>一些函数可以接受数量可变的参数，例如 <code>printf</code>，在头文件 <code>stdvar.h</code> 中提供了相关操作。</p>
<p>同样，宏定义中也可以实现可变参数，通过将宏列表中最后的参数写成 <code>...</code> 来实现这一功能。这样，预定义宏 <code>__VA_ARGS__</code> 可用在替换部分中，用来表示省略号代表什么。例如定义 <code>#define PRINT(...) printf(__VA_ARGS__)</code>，调用宏 <code>PRINT(&quot;Hello&quot;)</code>，<code>__VA_ARGS__</code> 展开为一个参数 <code>Hello</code>，调用宏 <code>PRINT(&quot;My name is %s&quot;, name)</code>，<code>__VA_ARGS__</code> 展开为两个参数 <code>&quot;My name is %s&quot;</code> 和 <code>name</code>。</p>
<h3 id="1-8-attribute"><a href="#1-8-attribute" class="headerlink" title="1.8 attribute"></a>1.8 <strong>attribute</strong></h3><p>GNU C 的一大特色就是 <code>__attribute__</code> 机制。<code>__attribute__</code> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute）。</p>
<p>具体内容请参见链接 <a href="https://blog.csdn.net/qlexcel/article/details/92656797">C语言<strong>attribute</strong>的使用</a>、<a href="https://blog.csdn.net/weaiken/article/details/88085360"><strong>attribute</strong> 机制详解</a></p>
<h2 id="二、宏模板"><a href="#二、宏模板" class="headerlink" title="二、宏模板"></a>二、宏模板</h2><p>由于 C 语言中库比较少，而一些比较基础的操作又无需通过函数实现，因此可以将一些基础功能写成宏进行展开，并集成到头文件中，在今后的项目中可以很方便的进行调用。</p>
<p>在这里我自己总结并整理了若干个常用的宏。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOG</td>
<td>打印调试信息（带颜色）</td>
</tr>
<tr>
<td>UPPERCASE</td>
<td>转化为大写字母</td>
</tr>
<tr>
<td>LOWERCASE</td>
<td>转化为小写字母</td>
</tr>
<tr>
<td>FPOS</td>
<td>获取结构体成员偏移量</td>
</tr>
<tr>
<td>FSIZ</td>
<td>获取结构体成员所占用字节数</td>
</tr>
<tr>
<td>container_of</td>
<td>根据成员指针、结构体类型、结构体成员名称获取结构体起始地址</td>
</tr>
<tr>
<td>offsetof</td>
<td>获取结构体成员偏移量</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-1-打印调试信息"><a href="#2-1-打印调试信息" class="headerlink" title="2.1 打印调试信息"></a>2.1 打印调试信息</h3><p>调试信息是任何项目必不可少的内容，下面的宏可以在终端中输出带颜色的调试标签，方便观察错误和警告信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LOG_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR_STYLE <span class="string">&quot;\x1b[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO_STYLE <span class="string">&quot;\x1b[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING_STYLE <span class="string">&quot;\x1b[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_STYLE_CLEAR <span class="string">&quot;\x1b[0m &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) printf(LOG_ERROR_STYLE<span class="string">&quot;[ERROR]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) printf(LOG_INFO_STYLE<span class="string">&quot;[INFO]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING(...) printf(LOG_WARNING_STYLE<span class="string">&quot;[WARN]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(TYPE, ...) LOG_##TYPE(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>调用上面的 <code>LOG</code> 宏，可以看到结果如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LOG(ERROR, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is an error msg...\n&quot;</span>);</span><br><span class="line">    LOG(INFO, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is an info msg...\n&quot;</span>);</span><br><span class="line">    LOG(WARNING, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is a warning msg...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/20230122232752.png" alt="LOG宏实现效果"></p>
<h3 id="2-2-大小写转化"><a href="#2-2-大小写转化" class="headerlink" title="2.2 大小写转化"></a>2.2 大小写转化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UPPERCASE(c) (c &amp; 0xdf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWERCASE(c) (c | 0x20)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量"><a href="#2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量" class="headerlink" title="2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量"></a>2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FPOS(type, member) (&amp;((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-得到一个结构体中某个成员字段-member-所占用的字节数"><a href="#2-4-得到一个结构体中某个成员字段-member-所占用的字节数" class="headerlink" title="2.4 得到一个结构体中某个成员字段 member 所占用的字节数"></a>2.4 得到一个结构体中某个成员字段 member 所占用的字节数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSIZ(type, member) sizeof(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-container-of"><a href="#2-5-container-of" class="headerlink" title="2.5 container_of"></a>2.5 container_of</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;              \</span></span><br><span class="line"><span class="meta">const typeof(((type *)0)-&gt;member) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">(type *)((char *)__mptr - __offsetof(type,member)); &#125;)</span></span><br></pre></td></tr></table></figure>
<p><code>container_of</code> 宏函数的作用是 <strong>已知结构体 type 的成员 member 的地址 ptr，得到结构体 type 的起始地址</strong>。</p>
<p>第一行用于“类型检查”。它确保 type 有一个名为 member 的成员（不过我认为这也是由 offsetof 宏完成的），并且如果 ptr 不是指向正确类型（成员的类型）的指针，编译器将打印警告，这对调试很有用。</p>
<p>在上述宏的第三行，用了 <code>char *</code> 进行指针转化，这是因为 <code>offsetof</code> 指针偏移量是按照字节计算的，同时 <code>char *</code> 的指针也是以字节计算的，若转化为例如 <code>int *</code> 等类型，则 C 的指针算法将会计算 <code>sizeof(int) * offsetof</code> 作为最终的结果，也就是 4 字节乘以偏移量。</p>
<p>具体说明参考链接 <a href="https://blog.csdn.net/s2603898260/article/details/79371024">container of()函数简介</a> 和 <a href="https://zhuanlan.zhihu.com/p/54932270">linux 内核宏container_of剖析</a></p>
<h3 id="2-6-offsetof"><a href="#2-6-offsetof" class="headerlink" title="2.6 offsetof"></a>2.6 offsetof</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp; ((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>
<p><code>offsetof</code> 宏函数的作用是 <strong>得到结构体 type 的成员 member 所在的内存偏移量</strong></p>
<p>对于 <code>container of</code> 以及 <code>offsetof</code> 我会单独用一篇博客进行详细讲解。</p>
<h3 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h3><h3 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h3><h3 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h3><h3 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h3><h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3>]]></content>
      <categories>
        <category>编程语言</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP 主机动态配置协议详解</title>
    <url>/2a5bb25d.html</url>
    <content><![CDATA[<h2 id="一、DHCP介绍"><a href="#一、DHCP介绍" class="headerlink" title="一、DHCP介绍"></a>一、DHCP介绍</h2><h3 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1. 简要介绍"></a>1. 简要介绍</h3><p>DHCP 协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了 WiFi，当你离开了屋子，又自动断开了 WiFi…… 这一系列的幕后都是DHCP协议在默默工作。</p>
<p>DHCP 协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。</p>
<p>该协议的最大作用是动态的为加入网络的设备分配 IP 地址，在该协议出现前，IP 地址的分配基于静态模式，你把设备的 mac 地址手动在路由器设置，然后路由器自动生成一个 IP 与你的 mac 地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配 IP 的做法不再适合。</p>
<p>DHCP 协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配 IP 地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。</p>
<p>DHCP 最重要功能显然是动态分配 IP 地址，当我们的设备连接上网络之后里面获得一个可用的 IP 地址，就得感谢该协议的执行，现在我们大多数设备都依靠 DHCP 来从路由器动态获得 IP<br><span id="more"></span></p>
<h3 id="2-DHCP-的-IP-租借"><a href="#2-DHCP-的-IP-租借" class="headerlink" title="2. DHCP 的 IP 租借"></a>2. DHCP 的 IP 租借</h3><p>DHCP 协议能够维护一个动态的 IP 池，根据设备加入和离开网络回收或分发可用 IP，它甚至能实现多个设备共享相同 IP。DHCP 协议的实现基于 UDP，需要 IP 的设备和具备分配 IP 能力的设备根据 DHCP 协议的方式封装数据包，然后通过 UDP 协议发送给对方。有了该协议后，我们上网时不再麻烦的去配置各种信息，设备和路由器之间相互通信后，自动配置好相应信息，我们只要等着配置完毕然后上网就行。</p>
<p>DHCP 支持三种地址分配方式，一种是手动分配，由管理员手动将指定 IP 地址分发给特定设备；第二种是自动分配，它从当前可用的 IP 地址池中选出一个，永久的分发给某一台特定设备；第三种是动态分配，它从 IP 地址池中选出一个分发给某台设备一段时间，时间到了后收回，或者设备离开网络后通知路由器主动收回，由此可见，第二种和第三种区别不大</p>
<p>使用动态分配方式时，管理员指定一系列可以分配的 IP，然后 DHCP 服务器会自动维护哪些 IP 已经分配，哪些 IP 可以使用。同时服务器指定分配的 IP 使用时长，一旦超时后，客户必须主动向服务器请求续租，例如上图就有对应按钮，或者请求重新从服务器获得一个新的 IP 地址，这个请求应答过程将是我们研究和实现的重点。</p>
<p>DHCP 协议动态分配 IP 的好处显而易见，首先是自动化，省却了管理员耗时耗力的维护，其次是集中管理，从服务器就可以得知IP的使用情况，由此有效防止 IP 冲突。而且还能实现地址的共享和重用，如果一台设备不活跃，例如关机或离开网络，协议可以及时收回 IP，分发给在网络中的其他设备。</p>
<p>在 DHCP 协议管理下，所有设备只能“租借” IP 而不能“拥有” IP。有租借就必须有管理，DHCP 协议的主要内容就在这里。租借时常根据设备的使用情况而定，作为服务器的设备租借时间必须很长，而对于手持设备而言，租借时间可以很短。在很多情况下，管理员为了防止 IP 被长时间无效占用，例如某台设备计划租借一个月，但它运行一天就关机了，那么这个 IP 就会在余下 29 天浪费掉，因此管理员会强制设备租借短时期，时期到了后再跟服务器请求延长租借期。</p>
<p>管理员一般把 IP 池划分为若干类别，不同类别对应不同租期，然后根据接入设备的类型赋予不同类别的IP。一旦租期抵达一半时，设备就开始于服务器协商以便延长租期。</p>
<p>下面是IP租借的流程图：</p>
<p><img src="/2a5bb25d/DHCP租借.png" alt="IP租借"></p>
<p>上图描述了设备向 DHCP 服务器租借 IP 8 天流程，其中在第 4 天要与服务器协商续租。租借 IP 的设备需要保持两个时钟，时钟 T1 在租借期过了一半时触发，此时设备向服务器请求续租；如果续租不成功，第二个时钟在租期 87.5% 时触发，设备向另一个 DHCP 服务器发起租借 IP 的请求。我们后面用代码实现协议时，主要通过构造数据包完成上面所述流程。</p>
<p>DHCP 协议时典型的服务器客户端应用模式。需要 IP 的设备是客户端，分发 IP 的设备是服务器，两者通过互发消息完成一项任务。他们之间的交互可以由下图表达：</p>
<p><img src="/2a5bb25d/DHCP握手.jpg" alt="DHCP握手"></p>
<p>类似于 <code>TCP</code> 的握手，但是又比 TCP 简单不少。</p>
<h2 id="二、DHCP主机动态配置协议解析和数据包格式说明"><a href="#二、DHCP主机动态配置协议解析和数据包格式说明" class="headerlink" title="二、DHCP主机动态配置协议解析和数据包格式说明"></a>二、DHCP主机动态配置协议解析和数据包格式说明</h2><h3 id="1-查看DHCP数据包"><a href="#1-查看DHCP数据包" class="headerlink" title="1. 查看DHCP数据包"></a>1. 查看DHCP数据包</h3><p>打开网络封包分析软件 WireShack，输入过滤条件 <code>bootp.option.type == 53</code> (或者 <code>dhcp.option.type == 53</code> 也可)，在命令行中输入 <code>ipconfig/renew</code>，表示续租 DHCP 服务器，我们获取这样的数据包：</p>
<p><img src="/2a5bb25d/DHCP数据包介绍.png" alt="DHCP数据包介绍"></p>
<p>点开一个数据包，看到：</p>
<p><img src="/2a5bb25d/具体格式.png" alt="具体格式"></p>
<p>我们看到 DHCP 协议数据包的组成格式为 <code>IP数据包-&gt;UDP数据包-&gt;Boostrap Protocoal数据包(也就是DHCP数据包)</code></p>
<p><strong>【注】Boostrap 是DHCP协议的前身，它叫主机静态配置协议。DHCP其实是它的扩展，将原来静态配置的过程动态化，于是配置起来更加灵活方便，只不过DHCP数据包的依然以Boostrap协议数据包为基础。</strong></p>
<p>我们点开 DHCP 看看具体内容：</p>
<p><img src="/2a5bb25d/DHCP具体内容.png" alt="DHCP具体内容"></p>
<p>通过观察，我们大概可以知道 DHCP 数据包大概有哪些字段，要了解这些字段的作用，我们还得充分了解协议的具体交互流程。DHCP 协议以客户端&lt;-&gt;服务器的方式进行交互，整个过程由客户端主导，服务器被动回应，因此掌握客户端的运行状态，我们就可以掌握 DHCP 的协议交互流程。</p>
<h3 id="2-DHCP流程"><a href="#2-DHCP流程" class="headerlink" title="2. DHCP流程"></a>2. DHCP流程</h3><p>DHCP 在执行时维护了一个状态机，该状态机由八个状态组成。</p>
<p>客户端在运行时维护一个内部状态机，其运行过程如下：</p>
<ol>
<li><code>INIT</code> 状态。客户端创建一个DHCPDISCOVER消息在局域网内广播，查询可用的 DHCP 服务器，然后进入<code>SELECTING</code>状态。</li>
<li><code>SELECTING</code> 状态。局域网内的DHCP收到广播消息后，发送<code>DHCPOFFER</code>消息，客户端会收到一个或多个 DHCP 服务器的回应，然后它从众多回应中选取一个服务器，向它发送<code>DHCPREQUEST</code>消息，然后进入<code>REQUESTING</code>状态。</li>
<li><code>REQUESTING</code> 状态。客户端向服务器发送 <code>DHCPREQUEST</code> 消息中包含了它对服务器的数据请求，例如可用IP地址以及各类配置参数，请求发送出去后它等待服务器回应。服务器会返回<code>DHCPACK</code> 消息，里面包含了客户端想要的可用IP以及配置参数等信息。<br>收到消息后，客户端检测服务器返回的 IP 地址是否可用，可用的话进入使用状态并像上一节描述的那样设置两个超时时钟。如果客户端发现 IP 地址不可用，它向服务器发送 <code>DHCPDECLINE</code>消息，然后转入状态1。<br>如果客户端从服务器收到的是DHCPNAK消息，它表示服务器拒绝向客户端提供服务，因此客户端重新进入状态1.</li>
<li><code>INIT-REBOOT</code> 状态。如果客户端已经租借到IP，它重启后进入该状态。此时它会向服务器发送 DHCPREQUEST 消息，重新确定它对IP的使用权，然后客户端进入 REBOOTING 状态，等待服务器反应。</li>
<li><code>REBOOTING</code> 状态。此时客户正在等待服务器返回确认消息，此时会有 3 种情况。一是客户端收到服务器发来的 DHCPACK 消息，表明可以继续使用它当前 IP,于是客户端进入 BOUND 状态；二是，客户端得到 DHCPACK 回应，然后发现它原来使用的 IP 在自己关机或重启时，被其他设备抢夺了，于是他想服务器发送 DHCPDECLINE 消息，然后进入状态 1；三是收到服务器发来的 DHCPNAK 消息，这表明服务器告诉客户端 IP 不能再继续使用，于是客户端进入状态 1.</li>
<li><code>BOUND</code> 状态。此时客户端得到可用IP地址，并进入使用状态。此时它启动两个时钟，T1 和 T2。当 T1 超时时，它进入状态 RENEWING。如果客户端主动要放弃使用当前 IP，它会向服务器发送 DHCPRELEASE 消息，然后进入状态 1.</li>
<li><code>RENEWING</code> 状态。此时客户端希望续租当前 IP，于是他想客户端发送 DHCPREQUEST 消息，然后等待服务器确认。此时客户端要面临三种情况，一是服务器返回 DHCPACK 消息，它可以继续使用当前 IP；二是收到 DHCPNAK 消息，服务器拒绝客户端继续租用当前 IP；三是客户端的 T2 时钟超时，客户端进入 REBINGDING 状态。</li>
<li><code>REBIDING</code> 状态。此时客户端无法继续续租原有 IP，于是它持续向局域网广播 DHCPREQUEST 消息，直到有服务器响应它为止。此时客户端又面临三种情况。一是有服务器向客户端返回 DHCPACK 消息，于是客户端可以使用新分配的 IP；二是服务器返回 DHCPNAK 消息，这表明服务器希望客户端重新启动租借流程，于是客户端进入 INIT 状态；第三是，在收到回应前，客户端当前租用的 IP 到期，它重新进入 INIT 状态。</li>
</ol>
<p>为了简单起见，我们将以客户端的方式编写代码，上面的流程状态可以使用下图统一描述：</p>
<p><img src="/2a5bb25d/状态机.png" alt="状态机"></p>
<h3 id="3-字段详解"><a href="#3-字段详解" class="headerlink" title="3. 字段详解"></a>3. 字段详解</h3><p>首先完成第一步，客户端向局域网广播消息，然后收到服务器应答。下面是 DHCP 消息的具体格式：</p>
<p><img src="/2a5bb25d/DHCP具体格式.png" alt="DHCP具体格式"></p>
<p>上面的是前面抓包时对应的 DHCP 部分，依次解析各个字段：</p>
<ul>
<li><code>op</code> 字段 1 字节，它表明消息类型，请求消息使用数值1，回应消息使用数值2</li>
<li><code>HType</code> 1 字节，它表明消息发送所使用的网络类型，由于我们默认使用互联网，因此它的值固定为 1</li>
<li><code>HLen</code> 字段 1 字节，它表明设备硬件地址的长度，由于我们默认使用 mac 地址，因此该字段固定为 6</li>
<li><code>Hops</code> 字段 1 字节，它表明数据包可以跨越几个不同网络，该字段的作用我们在前面 traceroute 程序中了解过，由于我们希望限制消息在当前局域网内流通，因此设置为 0</li>
<li><code>XID</code> 字段 4 字节。它与 ICMP 消息中的 session 作用一样，用来标志一次对话过程</li>
<li><code>Secs</code> 字段 2 字节。它用来表明客户端发出请求后等待的时间，一般该字段不常使用，我们将它固定为 0</li>
<li><code>Flags</code> 字段 2 字节，取值 0 或 1，如果设置为 1，客户端要求服务器以广播的方式发送回应消息，因为此时客户端可能还没有 IP 地址</li>
<li><code>CIAddr</code> 字段 4 字节，它存放客户端当前 IP 地址，如果客户端当前有 IP，而且进入状态 BOUND,RENEWING 状态，其他情况下统一设置为 0</li>
<li><code>YIAddr</code> 字段 4 字节，这是服务器返回给客户端使用的IP</li>
<li><code>SIAddr</code> 字段 4 字节，服务器 IP 地址，它有点特殊，这个 IP 是不一定是当前交互的服务器 IP，而是设备下次启动时去获取IP地址的服务器IP</li>
<li><code>GIAddr</code> 字段 4 字节，网关 IP，当 DHCP 服务器不在本地局域网时，设备将通过该 IP 将数据包转发给处于另一个局域网的服务器，通常情况下使用不到</li>
<li><code>CHAddr</code> 字段 16 字节，设备的硬件地址。由于我们默认设备使用 mac 地址，因此只使用到 6 个字节，其余 10 个字节用 0 填充</li>
<li><code>SName</code> 字段 64 个字节，该字段用做 DHCP 服务器的字符串名称</li>
<li><code>File</code> 字段 128 字节，该字段用于在设备和服务器间交换特定信息</li>
<li><code>Options</code> 字段，可变长。该字段用于设备和服务器间交换多种配置信息</li>
</ul>
<p>接下来我们看看 <code>Options</code> 字段，由于所有信息的交互都存储在该字段，因此我们需搞清楚它的结构。在该字段开始前是4个字节的 <code>魔术字</code>，固定为 <code>99.130.83.99</code>(十六进制：63 82 53 63)，然后才是一系列 Option 数据结构，Option 数据结构组成如下。</p>
<p><img src="/2a5bb25d/option组成.png" alt="option组成"></p>
<p>每个 <code>Option</code> 由三字段组成，第一字段是 <code>Code</code>,用来表明当前 <code>Option</code> 类型，它有两个特殊值，一个是 <code>0</code>，它表示当前 <code>Option</code> 只有这一个字节，另一个特殊值是 <code>255</code>，它表示后续不再含有 <code>Option</code>结构体；第二字段是 <code>len</code>，用来标志数据段的长度；第三字段是 <code>Data</code>，用来存储数据。</p>
<p>由于 Option 结构体用于客户端与服务器进行数据交换，因此它的种类相当繁杂。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>TCP/IP协议</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP协议</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>用 gdb 调试程序</title>
    <url>/1ea0c606.html</url>
    <content><![CDATA[<blockquote>
<p>学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～</p>
</blockquote>
<span id="more"></span>
<h2 id="1-gdb-调试-run-和-start-的区别"><a href="#1-gdb-调试-run-和-start-的区别" class="headerlink" title="1. gdb 调试 run 和 start 的区别"></a>1. gdb 调试 run 和 start 的区别</h2><p>一般来说，在启动 gdb 之后，执行 <code>r</code> 或者 <code>run</code> 之后，就开始执行程序了，直到遇到第一个断点。</p>
<p><code>start</code> 指令会执行程序至 <code>main()</code> 主函数的起始位置，即在主函数的第一行停止执行（改行代码还没有执行）。</p>
<p>另外，程序执行过程中使用 <code>run</code> 或 <code>start</code> 指令，表示重新启动程序。</p>
<h2 id="2-gdb-tui：在-gdb-中显示程序源码"><a href="#2-gdb-tui：在-gdb-中显示程序源码" class="headerlink" title="2. gdb tui：在 gdb 中显示程序源码"></a>2. gdb tui：在 gdb 中显示程序源码</h2><p>我们使用 gdb 的时候，想要看源码，需要输入 <code>list</code> 命令查看断点前后的代码，但是 <code>list</code> 没有代码高亮，也无法实时跟踪。用 gdb tui 自带的界面可以方便的查看并跟踪源码。输入命令 <code>gdb -tui</code> 打开窗口。</p>
<p>gdb 还有其他窗口类型，输入如下命令可以打开相应的窗口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">layout cmd  // 命令窗口，可以输入调试命令</span><br><span class="line">layout src  // 源代码窗口，显示当前行、断点等信息</span><br><span class="line">layout asm  // 汇编代码窗口</span><br><span class="line">layout reg  // 寄存器窗口</span><br></pre></td></tr></table></figure>
<p>要想使用这些窗口，需要通过源码编译 gdb，在编译时添加参数 <code>--enable-tui</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/gdb-11.2</span><br><span class="line">make -j32</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>在编译安装时可能会出现如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: no enhanced curses library found; disable TUI</span><br></pre></td></tr></table></figure>
<p>在 CentOS 下需要安装 <code>ncurses-devel</code> 包，Ubuntu 下安装 <code>libncurses5-dev</code></p>
<h1 id="Log-的使用"><a href="#Log-的使用" class="headerlink" title="Log 的使用"></a>Log 的使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ logger <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">➜  ~ <span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line">2022-10-04 22:42:30.438584+0800 0x81a171   Default     0x0                  47131  0    logger: Hello World</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS协议原理实现</title>
    <url>/47ec812d.html</url>
    <content><![CDATA[<h2 id="DNS-域名解析协议-基本原理介绍"><a href="#DNS-域名解析协议-基本原理介绍" class="headerlink" title="DNS(域名解析协议)基本原理介绍"></a>DNS(域名解析协议)基本原理介绍</h2><p>我们这章开始研究和实现一个体系较为复杂的协议，也就是域名解析协议，简写为DNS。该协议几乎也是我们”日用而不知”的幕后英雄，没有它肯定就没有现在的互联网繁荣。</p>
<p>当我们在浏览器上输入网址，例如<code>www.baidu.com</code>时，浏览器先通过DNS协议找到与该网址对应的IP地址，然后再使用IP去向服务器获取网页信息。也就是说互联网上的设备其实有两种辨认方法，一种是IP，一种是域名。就如同人的身份证，人有名字，同时也有几十位数字组成的身份证号。</p>
<p>人与人相互识别时，使用的都是名字，几乎没有人使用身份证号来识别他人的，即使身份证号相对于名字而言更加唯一和准确。说到底是因为人对数字识别很费劲，而记住名字很容易。<br><span id="more"></span><br>对计算机的访问也是如此。在互联网发展早期，计算机只是在局域网内互联，并且联网的机器非常有限，因此当时使用IP直接定位不同的机器。但是随着网络的发展，联网的机器越来越多，使用数字辨别每一台计算机变得越来越困难，于是人们开始想用更方便的记忆方式，于是自然就想到用字符串来替代难以记忆的数字。</p>
<p>然而对程序而言，它只能识别数字，于是字符串仅仅用作于方便记忆，在运行机制上，程序就得把字符串与IP数字进行转换。最早使用的转换机制很简单，甚至到现在还在使用，那就是hosts文件，它使用文本的方式将IP与字符串名字对应起来，如下图：</p>
<p><img src="/47ec812d/host.png" alt="host"></p>
<p>程序在运行时，先将该文件内容读入内存，当用户输入网址时，它先从里面的对应关系中，将网址直接转换成对应的IP地址。这种方法在主机数量少时适用，但现在网络上的主机数量数以千万计，如此我们得在文件中维护几万个对应关系，这显然不合情理，随着联网的设备越来越多，适用这种静态配置的方式越来越不合时宜，因此全网使用一种统一的IP字符串映射方式是势在必行。</p>
<p>如今能满足这种域名转换成IP需要机制，就是我们要研究和实现的DNS协议，它是极佳的分布式系统设计案例，互联网发展几十年来，接入网络的设备呈指数级增长，需要进行域名解析的请求自然也指数级增长，DNS自设计完成以来就具备了极佳的扩展性，因此它在没有大变动的情况下，满足日益增长的需求，可见其设计思路之巧妙。</p>
<h3 id="DNS协议系统"><a href="#DNS协议系统" class="headerlink" title="DNS协议系统"></a>DNS协议系统</h3><p>相比于其他网络协议，DNS协议本身更像是一个系统。它主要包含以下三种系统功能：</p>
<p><img src="/47ec812d/DNS协议.png" alt="DNS协议"></p>
<p>显然我们不可能实现全部功能，但我们会选择一些重要模块进行研究和实现，事实上抓住局部原理，对整体功能的把握也就能做到心中有数。DNS分为三大块，紫色部分是名字空间，它规定了域名的层级构造标准，第二部分是名字注册，它负责添加新设备的名称并防止名字冲突，第三部分是名字解析，它负责将域名转换为对应IP。</p>
<p>在了解DNS协议时，我们需要掌握一个很重要的概念叫域名。”域名”其实是对一个特定领域的统一称呼。例如我的大学名叫”北京化工大学”，于是对于我母校而言，它是一级域名，在下面又分很多个学院，例如理学院，化工学院，文法学院等，这些学院名称就是二级”域名”，学院内又有很多个系，像我所在的理学院有：数学系，物理系，化工系，这些系的名称就是三级域名，系下面又分班，比如我所在的数学系分为1，2，3，4班，这四个班名称对应的是四级域名，每个班内的人都有自己的名字，于是就对应五级域名。</p>
<h3 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h3><p>DNS中的域名以拓扑树的方式存在，如下图：</p>
<p><img src="/47ec812d/DNS域名.png" alt="DNS域名"></p>
<p>它以一个根节点开始，派生出一级域名，一级域名下面是二级域名，二级域名之后全都叫子域名。每一级域名可以使用数字和字符组合成的字符串来表示，其中字符串不区分大小写，同时一个域名下面的子域名不能相同，假设有一个一级域名叫<code>Black</code>,那么它下层的子域名可以是<code>white</code>，但必须只有一个，如果有另一个子域名叫<code>WHITE</code>，由于域名不区分大小写，因此两个域名被认为相同，这是不允许的。</p>
<p>由此域名设定时可以从根到叶子节点，中间以符号<code>.</code>隔开。上图中的Root始终对应空字符串，所以<code>www.baidu.com</code>对应于上图而言，第一级域名就是<code>com</code>，第二级域名就是<code>baidu</code>，第三级域名就是<code>www</code>，在解析的时候，该字符串域名就要倒转变成<code>www.baidu.com</code>。如果是百度知道，那么域名就是<code>zhidao.baidu.com</code>.</p>
<p>一级域名由特定机构控制例如IANA这类互联网管理机构，而二级域名往往对应一个特定组织或团体，例如baidu对应百度公司，三级域名则由组织自己控制。域名对公司而言是非常重要的信息资产，早期有很多聪明人通过域名碰瓷，也就曾大公司或机构不注意，用他们的名字注册域名，结果这些公司想用时只能从他们手中高价购买，很多人就靠这种手段发了大财。</p>
<h3 id="域名解析流程"><a href="#域名解析流程" class="headerlink" title="域名解析流程"></a>域名解析流程</h3><p>接下来我们看看域名解析的基本流程。首先要解析域名，我们先找到含有相关域名信息的服务器，然后向该服务器发送信息请求。问题在于，域名信息不是存储在固定服务器中，为了系统鲁棒性和扩展性，域名信息以分布式的形式存储在不同服务器里，因此第一步要查询哪个服务器包含了域名对应的信息。</p>
<p>假设我们要解析域名<code>C.B.A</code>，首先我们将请求发送给所谓的根域名服务器，该服务器会把拥有域名A的服务器地址返回给我们，返回的服务器可能知道域名B.A的信息或者它把关于A的信息返回后，再给我们一个知道域名B的服务器地址，返回的服务器可能知道域名C的信息，或者返回域名B的信息后，再告诉我们哪个服务器知道域名C的信息，因此我们在解析过程中要根据服务器返回信息进行选择。</p>
<h2 id="DNS协议系统运行流程及数据包解析"><a href="#DNS协议系统运行流程及数据包解析" class="headerlink" title="DNS协议系统运行流程及数据包解析"></a>DNS协议系统运行流程及数据包解析</h2><h3 id="域名信息存储"><a href="#域名信息存储" class="headerlink" title="域名信息存储"></a>域名信息存储</h3><p>DNS协议的运转需要客户端和服务器进行交互。由于服务器端需要存储大量的域名信息，同时每天需要应答海量的解析请求，因此它的设计必须遵循<code>分布式系统</code>。客户端向一台服务器请求解析服务时，对方可能没有相应的域名信息，于是它会向上一层查询，获得拥有给定域名信息的服务器，然后把对应服务器的信息归还给客户端，然后客户端再重新发起请求。</p>
<p>我们还需要关注域名信息如何在服务器上存储。在域名服务器上，信息存储有两种方式，一种是域名信息以二进制格式存储，这种格式对应的名称叫<code>Resource Record Filed Format</code>，同时为了方便管理员管理，这些信息又通过文本形式展现出来，对应的格式称为<code>Master File Representation</code>,管理员通过修改后者就能使得对应的二进制信息进行相应变换：</p>
<p><img src="/47ec812d/域名信息存储.png" alt="域名信息存储"></p>
<p>Resource Record 是一种特定数据结构，专门用于存储域名解析相关信息，例如域名对应的服务器IP，域名解析服务器地址等，在后面我们解析数据包时再深入探讨。</p>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名解析其实有三种形式：</p>
<ul>
<li>第一种是我们熟悉的，将域名发给服务器然后获得域名对应IP；</li>
<li>第二种叫反向解析，将IP发给服务器然后获得对应域名；</li>
<li>第三种叫电子邮件解析，将邮件地址发给服务器然后获得邮件的接收对象IP.</li>
</ul>
<p>我们将主要关注第一种形式的原理和实现。</p>
<p>当我们执行第一种域名解析时，首先要做的是获得域名服务器地址。这个过程并非一撮而就，有可能我们查询第一个服务器时，它给我们返回另一个服务器的地址，然后我们继续查询；第二步是确定服务器后，我们要解析它返回来的数据内容。在这个过程中，第二步相对容易，而第一步则比较棘手。</p>
<p>在查询对应域名服务器时有两种方式，一种是<code>循环式</code>，第一个域名没有对应信息，但返回另一个它认为有对应信息的服务器，接着客户端向第二个服务器请求，第二个服务器又返回另一个服务器信息，该过程依次循环直到找到对应服务器为止：</p>
<p><img src="/47ec812d/域名解析：循环式.png" alt="域名解析：循环式"></p>
<p>第二种叫<code>递归式</code>，它与一种的区别在于，服务器承担起客户端查找对应服务器的职责，服务器会反复向其他服务器查询，直到拿到对应域名信息后，直接返回给客户端：</p>
<p><img src="/47ec812d/域名解析：递归式.png" alt="域名解析：递归式"></p>
<p>一般担任root服务器的角色的是路由器</p>
<h3 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h3><p>接下来我们看看DNS数据包的基本格式，首先第一部分叫<code>Header</code>，用于描述消息类型，以及后续数据结构的相关信息；第二部分叫<code>Question</code>，它用来包含客户端想向服务器查询的信息；第三部分叫<code>Answer</code>，是服务器用于回复客户端查询；第四部分叫<code>Authority</code>，如果请求没有得到全部答复，这部分内容告诉客户端向哪个服务器进行查询；第五部分叫<code>Additional</code>，这部分包含客户端查询信息的附加说明，它并非必须，所以数据包的基本结构如下：</p>
<p><img src="/47ec812d/DNS数据包.png" alt="DNS数据包"></p>
<p>我们用wireshark抓取DNS有关的消息包后，对照上面描述的条目进行解析。启动wireshark，然后使用关键词DNS过滤，然后在浏览器里输入一个你以前没有访问过的网址，如果输入已经访问过的，浏览器会有缓存，因此不会走dns协议。以下是我抓取到的一个DNS解析请求包：</p>
<p><img src="/47ec812d/DNS数据包格式.png" alt="DNS数据包具体格式(查询)"></p>
<p><img src="/47ec812d/DNS数据包格式（回复）.png" alt="DNS数据包格式（回复）"></p>
<p>首先是头部，它包含12字节，从<code>Transaction ID</code> 到 <code>Additional RRs</code>，每个字段2字节。ID用来标志一次会话，一个会话内的数据包拥有相同ID。Flags分为两部分，第一部分一字节叫做<code>QR(query &amp; response)</code>，用来表示该数据包是查询还是回答，如果是查询就设置为0，如果是回答就设置为1.如果是查询，那么第二个字节就是OpCode，进一步表明具体查询，它分为若干部分，前四个比特位用于表明查询类型，0表示查询域名对应IP，1不再使用；2表示查询域名服务器状态；3目前不使用，4用于服务器之间的交互；5也是用于服务器之间的交互。</p>
<p>第五个比特位叫<code>AA(Authoritative)</code>,它只在回复包中设置，用于表明回复的权威性，只有在最后能够获得完整的IP的服务器上，才会返回1，其他中间的服务器只是起到代理作用，返回0.第六个比特位叫<code>TC(Truncated)</code>，它用于表明数据是否被截断，用于DNS支持UDP和TCP，但使用UDP时数据包不能超过512字节，如果超过数据包就得截断成多个小数据包，如果该位设置成1，它表明双方需要通过TCP来建立连接。第八位叫<code>RD(Recursion desired)</code>，如果设置成1，它意味着客户端<code>请求递归式查询</code>，也就是让服务器帮忙向其他服务器询问，得到最终消息后再返还给客户端。<strong>根据此比特位可以判断下面的信息是不是最终信息，如果该比特位为0，那么还需要根据下面的信息解析其他服务器传递过来的内容。</strong></p>
<p>接下来字节的比特位是<code>RA</code>，如果设置为1表示服务器支持递归式查询，也就是服务器把所有累活都承担了，0则是不支持。接下来三个比特位必须设置为0，接着4个比特位表示返回码，如果值为0表示返回数据正常，非0表示出现错误，其中取值1表示查询数据包格式错误；2表示服务器自身故障；3表示解析错误；4表示不支持所要求的查询；5表示拒绝查询请求；其他值我们暂时忽略。</p>
<p>接下来用于表示相应条目的数量，<code>Questions</code>表示有几个查询条目，<code>Answer RRs</code>表示有几个回复条目，<code>Authority RRs</code>表示有几个权威信息条目，所谓”权威”是指真正能够解析域名的服务器，如果当前服务器不能解析域名请求，它需要把请求转发给其他服务器时，它自己就不是Authoritive，我们家用路由器其实承担域名解析服务器的职责，但是它本身不可能包含所需要的域名信息，它会把请求转发给上一层服务器，因此路由器就不是”权威”域名解析服务器。由此一个DNS域名解析数据包的轮廓如下：</p>
<p><img src="/47ec812d/DNS域名解析数据包.png" alt="DNS域名解析数据包"></p>
<p>返回的问题段的数据结构：</p>
<p><img src="/47ec812d/Answer段数据结构.png" alt="问题段数据结构"></p>
<p>数据包：</p>
<p><img src="/47ec812d/Answer段数据包.png" alt="答案段数据包"></p>
<p>首先是答案名字，这个字段长度可变，存储的是要查询的域名，以00作为结尾。第二个是问题类型(Type)，它是2字节，用于表明查询的类型，取值1表示查询域名对应IP，取值2查询服务器名称，具体类型在后面我们用到时再详细讨论。最后是问题类别，一般而言写死为1(IN,表明查询媒介类型为因特网)。</p>
<p>这里我们讲解一下查询的域名(Queries Name)对应的字符串结构，例如对于字符串：www.baidu.com，它的对应格式为<code>[3]www[5]baidu[3]com</code>,其中[]内表示接下来字符个数，例如[3]表示后面跟着3个字符www,[5]表示接下来跟着5个字符，<strong>注意到这些数字所在位置正好对应字符串中符号点所在位置。</strong> 最后以<code>00</code>结尾。</p>
<p>接下来我们看<code>Answer Resource Records</code>的结构，服务器收到客户端请求，完成解析工作后，把解析信息存储在该结构里发回给客户端。它的结构如下，第一个是名字字符串，可变长，它对应要解析的域名或服务器名称。接着是资源类型，2字节，表明资源的类型，如果取值是5，那么接下来对应着域名服务器对应的字符串名称，接着是资源类别，2字节，一般设置成1；接着是TTL(Time To Live)，4字节，表明这些信息能在缓存中存储多久；接着是RDLength，2字节，用于表明接下来内容的长度；最后是相应内容，如果资源类型是5，那么内容就是字符串，如果是1，那么内容就是4字节的IP地址，该数据类型对应的格式轮廓如下：</p>
<p><img src="/47ec812d/Answer段完整数据结构.png" alt="答案段完整数据结构"></p>
<p>这里值得提到的是，如果资源类型5，那么对应的字符串才是”真正”域名，例如下面显示内容：</p>
<p><img src="/47ec812d/资源类型5.png" alt="资源类型5"></p>
<p>它显示的是，一开始我们使用域名<code>pan.baidu.com</code>去进行域名解析，此时解析服务器没有直接返回该域名对应的IP，而是返回另一个域名<code>yiyun.n.shifen.com</code>，前面<code>pan.baidu.com</code>其实是一个别名，打个比方，一个人可以使用假名和真名，假名可以随时变，真名则要跟身份证绑定。同样的道理，<code>pan.baidu.com</code>这个域名可以根据需要随时变化，例如以后它可以变成<code>pen.baidu.com</code>，但是第二个域名就唯一绑定一台服务器，我们只有拿这个域名去查询才能找到对应的IP。</p>
<p>为了简单起见，其他两种资源的数据格式我们暂时放一放，以后需要的时候才研究，在下一节我们将使用代码实现本节描述的DNS域名解析流程。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> protocol.IProtocol;</span><br><span class="line"><span class="keyword">import</span> protocol.ProtocolManager;</span><br><span class="line"><span class="keyword">import</span> protocol.UDPProtocolLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Cherry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span> 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Brief</span> DNS 域名解析协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DNSApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] resolve_server_ip = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">domainName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] dnsHeader = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] dnsQuestion = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">short</span> <span class="variable">transition_id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">QUESTION_TYPE_LENGTH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">QUESTION_CLASS_LENGTH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="variable">QUESTION_TYPE_A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="variable">QUESTION_CLASS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">DNS_SERVER_PORT</span> <span class="operator">=</span> <span class="number">53</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该类型表示服务器返回域名的类型号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="variable">DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">short</span> <span class="variable">DNS_ANSWER_HOST_ADDRESS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，一般将域名交给路由器让其查询IP</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destIP     要查询域名的服务器IP，一般为该局域网的路由器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> domainName 域名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DNSApplication</span><span class="params">(<span class="type">byte</span>[] destIP, String domainName)</span> &#123;</span><br><span class="line">        resolve_server_ip = destIP;</span><br><span class="line">        <span class="built_in">this</span>.domainName = domainName;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        transition_id = (<span class="type">short</span>) random.nextInt();</span><br><span class="line">        <span class="comment">//随机选择一个发送端口，这个没有具体要求</span></span><br><span class="line">        <span class="built_in">this</span>.port = (<span class="type">short</span>) random.nextInt();</span><br><span class="line">        constructDNSPacketHeader();</span><br><span class="line">        constructDNSPacketQuestion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 DNS 首部，12B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">constructDNSPacketHeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] header = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">12</span>];</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(header);</span><br><span class="line">        <span class="comment">//会话Id,2B</span></span><br><span class="line">        buffer.putShort(transition_id);</span><br><span class="line">        <span class="comment">//2字节操作码</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">opCode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是查询数据包，第16个比特位要将最低位设置为0,接下来的4个比特位表示查询类型，如果是查询ip则设置为0，</span></span><br><span class="line"><span class="comment">         * 第11个比特位由服务器在回复数据包中设置，用于表明信息是它拥有的还是从其他服务器查询而来，</span></span><br><span class="line"><span class="comment">         * 第10个比特位表示消息是否有分割，有的话设置为1，由于我们使用UDP，因此消息不会有分割。</span></span><br><span class="line"><span class="comment">         * 第9个比特位表示是否使用递归式查询请求，我们设置成1表示使用递归式查询,</span></span><br><span class="line"><span class="comment">         * 第8个比特位由服务器返回时设置，表示它是否接受递归式查询</span></span><br><span class="line"><span class="comment">         * 第7,6,5，3个比特位必须保留为0，</span></span><br><span class="line"><span class="comment">         * 最后四个比特由服务器回复数据包设置，0表示正常返回数据，1表示请求数据格式错误，2表示服务器出问题，3表示不存在给定域名等等</span></span><br><span class="line"><span class="comment">         * 我们发送数据包时只要将第9个比特位设置成1即可(从1开始向左数第9位)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        opCode = (<span class="type">short</span>) (opCode | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>));</span><br><span class="line">        buffer.putShort(opCode);</span><br><span class="line">        <span class="comment">//接下来是2字节的question count,由于我们只有1个请求，因此它设置成1</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">questionCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        buffer.putShort(questionCount);</span><br><span class="line">        <span class="comment">//剩下的默认设置成0</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">answerRRCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(answerRRCount);</span><br><span class="line">        <span class="type">short</span> <span class="variable">authorityRRCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(authorityRRCount);</span><br><span class="line">        <span class="type">short</span> <span class="variable">additionalRRCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        buffer.putShort(additionalRRCount);</span><br><span class="line">        <span class="built_in">this</span>.dnsHeader = buffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造DNS数据包中包含域名的查询数据结构</span></span><br><span class="line"><span class="comment">     * 首先是要查询的域名，它的结构是是：字符个数+是对应字符，</span></span><br><span class="line"><span class="comment">     * 例如域名字符串pan.baidu.com对应的内容为</span></span><br><span class="line"><span class="comment">     * [3]pan[5]baidu[3]com也就是把 &#x27;.&#x27;换成它后面跟着的字母个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">constructDNSPacketQuestion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//解析域名结构，按照 &#x27;.&#x27; 进行分解,第一个1用于记录&quot;pan&quot;的长度，第二个1用0表示字符串结束</span></span><br><span class="line">        dnsQuestion = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> + <span class="number">1</span> + domainName.length() + QUESTION_TYPE_LENGTH + QUESTION_CLASS_LENGTH];</span><br><span class="line">        String[] domain = domainName.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(dnsQuestion);</span><br><span class="line">        <span class="keyword">for</span> (String str : domain) &#123;</span><br><span class="line">            <span class="comment">//先填写字符个数</span></span><br><span class="line">            buffer.put((<span class="type">byte</span>) str.length());</span><br><span class="line">            <span class="comment">//填写字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">                buffer.put((<span class="type">byte</span>) str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用0表示域名表示结束</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        buffer.put(end);</span><br><span class="line">        <span class="comment">//填写查询问题的类型和级别</span></span><br><span class="line">        buffer.putShort(QUESTION_TYPE_A);</span><br><span class="line">        buffer.putShort(QUESTION_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务器发送查询请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryDomain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] dnsPacketBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[dnsHeader.length + dnsQuestion.length];</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(dnsPacketBuffer);</span><br><span class="line">        buffer.put(dnsHeader);</span><br><span class="line">        buffer.put(dnsQuestion);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] udpHeader = createUDPHeader(dnsPacketBuffer);</span><br><span class="line">        <span class="type">byte</span>[] ipHeader = createIP4Header(udpHeader.length);</span><br><span class="line">        <span class="type">byte</span>[] dnsPacket = <span class="keyword">new</span> <span class="title class_">byte</span>[ipHeader.length + udpHeader.length];</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer = ByteBuffer.wrap(dnsPacket);</span><br><span class="line">        buffer.put(ipHeader);</span><br><span class="line">        buffer.put(udpHeader);</span><br><span class="line">        <span class="comment">//将消息发给路由器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProtocolManager.getInstance().sendData(dnsPacket, resolve_server_ip);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 UDP 包头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] createUDPHeader(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="type">IProtocol</span> <span class="variable">udpProtocol</span> <span class="operator">=</span> ProtocolManager.getInstance().getProtocol(<span class="string">&quot;udp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (udpProtocol == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Object&gt; headerInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> <span class="variable">udpPort</span> <span class="operator">=</span> (<span class="type">char</span>) <span class="built_in">this</span>.port;</span><br><span class="line">        headerInfo.put(<span class="string">&quot;source_port&quot;</span>, udpPort);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;dest_port&quot;</span>, DNS_SERVER_PORT);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> udpProtocol.createHeader(headerInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组装 IP 包头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] createIP4Header(<span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="type">IProtocol</span> <span class="variable">ipPrtocol</span> <span class="operator">=</span> ProtocolManager.getInstance().getProtocol(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ipPrtocol == <span class="literal">null</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;String, Object&gt; headerInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerInfo.put(<span class="string">&quot;data_length&quot;</span>, length);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">destIP</span> <span class="operator">=</span> ByteBuffer.wrap(resolve_server_ip);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;destination_ip&quot;</span>, destIP.getInt());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">protocol</span> <span class="operator">=</span> UDPProtocolLayer.PROTOCOL_UDP;</span><br><span class="line">        headerInfo.put(<span class="string">&quot;protocol&quot;</span>, protocol);</span><br><span class="line">        headerInfo.put(<span class="string">&quot;identification&quot;</span>, transition_id);</span><br><span class="line">        <span class="keyword">return</span> ipPrtocol.createHeader(headerInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析服务器回发的数据包，首先读取头2字节判断 transition_id 是否与我们发送时使用的一致</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headerInfo data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleData</span><span class="params">(HashMap&lt;String, Object&gt; headerInfo)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==================== DNS START ====================&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] data = (<span class="type">byte</span>[]) headerInfo.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Empty data...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(data);</span><br><span class="line">        <span class="type">short</span> <span class="variable">transitionID</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        <span class="keyword">if</span> (transitionID != transition_id) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TransitionID is different!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取2字节flag各个比特位的含义</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">flag</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        readFlags(flag);</span><br><span class="line">        <span class="comment">//下面两个字节表示请求数量(Questions)</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">questionCount</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client send &quot;</span> + questionCount + <span class="string">&quot; requests.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示服务器回复信息的数量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">answerCount</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + answerCount + <span class="string">&quot; answers.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示数据拥有属性信息的数量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">authorityCount</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + authorityCount + <span class="string">&quot; authority resources.&quot;</span>);</span><br><span class="line">        <span class="comment">//两字节表示附加信息的数量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">additionalInfoCount</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server return &quot;</span> + additionalInfoCount + <span class="string">&quot; additional info.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理回复包中的Question部分，这部分湖人查询包中的内容一模一样</span></span><br><span class="line">        readQuestions(questionCount, buffer);</span><br><span class="line">        <span class="comment">//处理服务器返回的信息</span></span><br><span class="line">        readAnswers(answerCount, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分析 flag 字段各个比特位的含义</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readFlags</span><span class="params">(<span class="type">short</span> flag)</span> &#123;</span><br><span class="line">        <span class="comment">//最高字节为1表示该数据包为回复数据包</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is packet returned from server...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第9个比特位为1表示客户端请求递归式查询</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Client requests recursive query!(客户端请求递归查询)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第8个比特位为1表示服务器接受递归式查询请求</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server accept recursive query request!(服务器接受递归查询)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第6个比特位表示服务器是否拥有解析信息</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sever own the domain info!(拥有解析信息)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server query domain info from other servers!(无解析信息)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Question 部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> questionCount question 部分的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data          buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readQuestions</span><span class="params">(<span class="type">int</span> questionCount, ByteBuffer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n=============== Queries ===============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; questionCount; i++) &#123;</span><br><span class="line">            readStringContent(data);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//查询问题的类型</span></span><br><span class="line">            <span class="type">short</span> <span class="variable">type</span> <span class="operator">=</span> data.getShort();</span><br><span class="line">            <span class="keyword">if</span> (type == QUESTION_TYPE_A) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request IP for given domain name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查询问题的级别</span></span><br><span class="line">            <span class="type">short</span> <span class="variable">clasz</span> <span class="operator">=</span> data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;The class of the request is &quot;</span> + clasz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Answer 部分</span></span><br><span class="line"><span class="comment">     * 回复信息的格式如下：</span></span><br><span class="line"><span class="comment">     * 第一个字段是 name，它的格式如同请求数据中的域名字符串</span></span><br><span class="line"><span class="comment">     * 第二个字段是类型，2字节</span></span><br><span class="line"><span class="comment">     * 第三字段是级别，2字节</span></span><br><span class="line"><span class="comment">     * 第4个字段是 Time to live, 4字节，表示该信息可以缓存多久</span></span><br><span class="line"><span class="comment">     * 第5个字段是数据内容长度，2字节</span></span><br><span class="line"><span class="comment">     * 第6个字段是内如数组，长度如同第5个字段所示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> answerCount 服务器返回的 answer 部分的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data        buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readAnswers</span><span class="params">(<span class="type">int</span> answerCount, ByteBuffer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n=============== Answers ===============&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在读取name字段时，要注意它是否使用了压缩方式，如果是那么该字段的第一个字节就一定大于等于192，</span></span><br><span class="line"><span class="comment">         * 也就是它会把第一个字节的最高2比特设置成11，接下来的1字节表示数据在dns数据段中的偏移，</span></span><br><span class="line"><span class="comment">         * 即从DNS报文段开头开始偏移。</span></span><br><span class="line"><span class="comment">         * 因为规定字符串长度不能超过63，即6位，因此若发现字符串的长度超过(或等于)192，就是采用了压缩</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; answerCount; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="number">1</span> + <span class="string">&quot;: Name content in answer filed is:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (isNameCompression(data.get())) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">int</span>) data.get();</span><br><span class="line">                <span class="type">byte</span>[] array = data.array();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">dup_buffer</span> <span class="operator">=</span> ByteBuffer.wrap(array);</span><br><span class="line">                <span class="comment">//从指定偏移处读取</span></span><br><span class="line">                dup_buffer.position(offset);</span><br><span class="line">                readStringContent(dup_buffer);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                readStringContent(data);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//类型</span></span><br><span class="line">            <span class="type">short</span> <span class="variable">type</span> <span class="operator">=</span> data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;Answer type is : &quot;</span> + type);</span><br><span class="line">            <span class="keyword">if</span> (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This answer contains server string name...&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;(该答复中包含了服务器的字符串名称)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//级别</span></span><br><span class="line">            <span class="type">short</span> <span class="variable">clasz</span> <span class="operator">=</span> data.getShort();</span><br><span class="line">            System.out.println(<span class="string">&quot;Answer class: &quot;</span> + clasz);</span><br><span class="line">            <span class="comment">//接下来4个字节是TTL存活时间</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ttl</span> <span class="operator">=</span> data.getInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;This content can cache (该域名生存时间为):&quot;</span> + ttl + <span class="string">&quot; seconds(秒)...&quot;</span>);</span><br><span class="line">            <span class="comment">//接下来2字节表示数据长度，长度为4表示IP，其他长度为服务器字符串名称</span></span><br><span class="line">            <span class="type">short</span> <span class="variable">length</span> <span class="operator">=</span> data.getShort();</span><br><span class="line">            <span class="keyword">if</span> (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123;</span><br><span class="line">                readStringContent(data);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == DNS_ANSWER_HOST_ADDRESS) &#123;</span><br><span class="line">                <span class="comment">//打印服务器的IP</span></span><br><span class="line">                <span class="type">byte</span>[] ip = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    ip[j] = data.get();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByAddress(ip);</span><br><span class="line">                    System.out.println(<span class="string">&quot;IP for domain name is(域名解析得到的IP为): &quot;</span> +</span><br><span class="line">                            inetAddress.getHostAddress());</span><br><span class="line">                    System.out.println(<span class="string">&quot;==================== DNS END ====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析域名字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readStringContent</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">charCount</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">        <span class="comment">//如果字符第一个数正确或者使用压缩方式，输出字符串内容</span></span><br><span class="line">        <span class="keyword">while</span> (charCount != <span class="number">0</span> || isNameCompression(charCount)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNameCompression(charCount)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">                <span class="type">byte</span>[] array = buffer.array();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">dup_buffer</span> <span class="operator">=</span> ByteBuffer.wrap(array);</span><br><span class="line">                dup_buffer.position(offset);</span><br><span class="line">                readStringContent(dup_buffer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charCount; ++i) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            charCount = buffer.get();</span><br><span class="line">            <span class="keyword">if</span> (charCount != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串是否使用压缩</span></span><br><span class="line"><span class="comment">     * 若 7.8位 为 1，则采用压缩，因为允许的字符串长度最长为 64，即 6位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 字符串本串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNameCompression</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (b &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span> &amp;&amp; (b &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>稍后进行代码讲解…</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>TCP/IP协议</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP协议</tag>
        <tag>DNS协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用</title>
    <url>/3645f6a9.html</url>
    <content><![CDATA[<h1 id="Git-的使用"><a href="#Git-的使用" class="headerlink" title="Git 的使用"></a>Git 的使用</h1><span id="more"></span>
<h2 id="1-分支命令"><a href="#1-分支命令" class="headerlink" title="1. 分支命令"></a>1. 分支命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;new-branch-name&gt;   //新建分支并切换到该分支</span><br><span class="line">git branch &lt;new branch name&gt;        //新建分支</span><br><span class="line">git branch -D &lt;branch name&gt;         //删除分支</span><br><span class="line">git branch -m oldName newName       //修改分支名称</span><br><span class="line">git branch -vv                      //参数 `vv` 表示显示更多冗余信息</span><br><span class="line"></span><br><span class="line">git rebase</span><br></pre></td></tr></table></figure>
<h2 id="2-git-config-配置"><a href="#2-git-config-配置" class="headerlink" title="2. git config 配置"></a>2. git config 配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config [--global] user.name &lt;&quot;Your-Name&quot;&gt;   //设置git的用户名和邮箱密码等</span><br><span class="line">git config --global core.pager &quot;less -FRSX&quot;     //设置不要将结果输出到新窗口，并且进行less分页显示</span><br></pre></td></tr></table></figure>
<p><code>less</code> 的功能比 <code>more</code> 更多，前者可以上下滚屏，后者不可以。<code>core-pager</code> 默认参数为 <code>less</code>，会在新的窗口中输出信息，按 <code>q</code> 键退出后终端将不显示刚刚的信息，这样有点不太方便。或者是添加参数 <code>--no-pager</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --all --graph --decorate --oneline</span><br></pre></td></tr></table></figure>
<p>展示git的树形提交记录，<code>oneline</code> 表示展示的信息在一行中表示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<p>显示指定的两次 commit 中的 file-name 文件的不同，默认 commit 为最新 commit</p>
<h2 id="3-remote操作"><a href="#3-remote操作" class="headerlink" title="3. remote操作"></a>3. remote操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init --bare</span><br><span class="line"></span><br><span class="line">git remote add &lt;name&gt; &lt;url&gt;     // url可以是本地地址，也可以是远程仓库地址(例如github)</span><br><span class="line">git remote add origin ../remote</span><br><span class="line"></span><br><span class="line">git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</span><br><span class="line">git push origin master:master</span><br><span class="line"></span><br><span class="line">git clone &lt;url&gt; &lt;folder name&gt;</span><br><span class="line">git clone ./gitDemo demo2</span><br><span class="line"></span><br><span class="line">//创建本地和远端分支的关联关系</span><br><span class="line">git branch --set-upstream-to &lt;remote&gt;/&lt;remote branch&gt;</span><br><span class="line"></span><br><span class="line">git pull = git fetch; git merge</span><br><span class="line">git pull --all                          // 拉取远程所有分支</span><br><span class="line"></span><br><span class="line">git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;   // 将远程指定分支拉取到本地指定分支上</span><br><span class="line">git pull origin &lt;远程分支名&gt;              // 将远程指定分支拉取到本地当前分支上</span><br><span class="line"></span><br><span class="line">git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;   // 将本地当前分支推送到远程指定分支上（注意：pull 是远程在前本地在后，push 相反）</span><br><span class="line">git push origin &lt;本地分支名&gt;              // 将本地当前分支推送到与本地当前分支同名的远程分支上</span><br><span class="line"></span><br><span class="line">git push -u origin &lt;本地分支名&gt;           // 将本地分支与远程同名分支相关联</span><br></pre></td></tr></table></figure>
<p>注意远程仓库的初始化一定是“裸”的，即 <code>git init --bare</code>，因为远程仓库中不允许进行 git 操作，不包含工作区。</p>
<p><code>git fetch</code> 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中，而 <code>git pull</code> 是直接合并。</p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add -p &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">git clone --shallow         //浅克隆，不会保留仓库原有的提交记录</span><br><span class="line"></span><br><span class="line">git show &lt;commit id&gt;        //展示某次提交的具体内容(通过diff展示)</span><br><span class="line"></span><br><span class="line">git stash                   //暂时移除工作目录下的修改内容</span><br><span class="line">git stash pop               //移除隐藏</span><br></pre></td></tr></table></figure>
<p>参数 <code>-p</code> 表示交互式暂存，可以自定义某些修改是否要提交</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>git init</td>
<td>在本地的当前目录里初始化git仓库</td>
</tr>
<tr>
<td>git status</td>
<td>查看当前仓库的状态</td>
</tr>
<tr>
<td>git add -A</td>
<td>增加目录中所有的文件到缓存区</td>
</tr>
<tr>
<td>git add file</td>
<td>增加相应文件到缓存区</td>
</tr>
<tr>
<td>git commit -m “msg”</td>
<td>将缓存区中更改提交到本地仓库</td>
</tr>
<tr>
<td>git log</td>
<td>查看当前版本之前的提交记录</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看HEAD的变更记录，包括回退</td>
</tr>
<tr>
<td>git branch -b branch_name</td>
<td>建立一个新的分支</td>
</tr>
<tr>
<td>git diff</td>
<td>查看当前文件与缓存区文件的差异</td>
</tr>
<tr>
<td>git checkout —file</td>
<td>取消更改，将缓存区的文件提取覆盖当前文件</td>
</tr>
<tr>
<td>git reset —hard ver_num</td>
<td>回退到相应版本号，同样也可以回退到未来的版本号</td>
</tr>
<tr>
<td>git clean -xf</td>
<td>删除当前目录中所有未追踪的文件</td>
</tr>
<tr>
<td>git config —global core.quotepath false</td>
<td>处理中文文件名</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-git-reset-命令及用-amend-提交合并"><a href="#5-git-reset-命令及用-amend-提交合并" class="headerlink" title="5. git reset 命令及用 amend 提交合并"></a>5. git reset 命令及用 amend 提交合并</h2><p>当我们提交一版代码后，发现有一个小问题需要重新修改一下，但是又不想重新再提交一次，因为这样会多一次无用的提交记录，不方便整体的管理和日志的查看。我们首先使用 <code>git reset</code> 进行回退。</p>
<p><code>git reset</code> 命令有几个参数</p>
<ul>
<li><code>--soft</code> 参数表示撤销到某次提交，保留<strong>暂存区</strong>（<code>add</code> 操作之后保存到的地方）里的内容，如果要再提交只要再执行 <code>commit</code> 即可</li>
<li><code>--mixed</code> 会撤销某次提交，但是工作目录下修改的内容不会被存到暂存区中，需要重新执行 <code>add</code> 命令才能存入暂存区</li>
<li><code>--hard</code> 会直接回退到某一提交，任何修改都不会被保存，这个参数要谨慎使用，很可能会造成本地文件丢失。</li>
</ul>
<p>若是不小心使用 <code>git reset --hard</code> 误操作了可以先使用 <code>git reflog</code> 查看所有操作记录，找到要回退的版本号（ <code>HEAD</code> 指针或 <code>commitId</code>），然后指定具体的版本号进行回退即可。</p>
<p>另一种避免重复提交的方法就是 <code>git --amend</code> 命令，在第二次提交时，若我们想合并上一次提交，可以使用 <code>git commit --amend -m &quot;xxx&quot;</code>，这样新一次的提交会覆盖上一次的提交。</p>
<p>但是在使用 <code>--amend</code> 时候不能进行 <code>push</code> 提交，否则会提</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。</span><br><span class="line">提示：再次推送前，先与远程变更合并（如 &#x27;git pull ...&#x27;）。详见</span><br><span class="line">提示：&#x27;git push --help&#x27; 中的 &#x27;Note about fast-forwards&#x27; 小节`</span><br></pre></td></tr></table></figure>
<p>若 <code>push</code> 了之后应该使用 <code>--force-with-lease</code> 参数。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files                // 查看暂存区中的文件</span><br><span class="line">git restore --staged        // 撤销在暂存区提交的文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机知识总结（二）</title>
    <url>/7a3f40e8.html</url>
    <content><![CDATA[<h2 id="三、GC算法和收集器"><a href="#三、GC算法和收集器" class="headerlink" title="三、GC算法和收集器"></a>三、GC算法和收集器</h2><p>本文参考：<br>Oracle Java JVM Standard Options：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a><br>HotSpot Glossary of Terms：<a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a><br>周志明《深入理解Java虚拟机》第二版</p>
<h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机知识总结(一)</title>
    <url>/bc4fb6eb.html</url>
    <content><![CDATA[<h2 id="Java虚拟机介绍"><a href="#Java虚拟机介绍" class="headerlink" title="Java虚拟机介绍"></a>Java虚拟机介绍</h2><p>Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上<br>不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。<br><span id="more"></span></p>
<h2 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h2><p><img src="/bc4fb6eb/JVM基本结构.png" alt="JVM基本结构"></p>
<p>JVM由三个主要的子系统构成</p>
<ul>
<li>类加载子系统</li>
<li>运行时数据区（内存结构）</li>
<li>执行引擎</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><img src="/bc4fb6eb/类加载机制.png" alt="类的生命周期"></p>
<ol>
<li>加载<br>将<code>.class</code>文件从磁盘读到内存</li>
<li>链接<ol>
<li>验证<br>验证字节码文件的正确性</li>
<li>准备<br>给类的静态变量分配内存</li>
<li>解析<br>类加载器装入类所引用的其他所有类(静态链接)<br>静态链接：解析阶段，由符号引用转化为直接引用<br>动态链接：程序运行期间，由符号引用转化为直接引用</li>
</ol>
</li>
<li>初始化<br>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序<br>编写者为变量分配的真正的初始值，执行静态代码块</li>
<li>使用</li>
<li>卸载</li>
</ol>
<h3 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h3><ul>
<li>启动类加载器(Bootstrap ClassLoader)<br>负责加载JRE的核心类库，如JRE目标下的<code>rt.jar</code>,<code>charsets.jar</code>等</li>
<li>扩展类加载器(Extension ClassLoader)<br>负责加载JRE扩展目录<code>ext</code>中jar类包</li>
<li>系统类加载器(Application ClassLoader)<br>负责加载<code>ClassPath</code>路径下的类包</li>
<li>用户自定义加载器(User ClassLoader)<br>负责加载用户自定义路径下的类包</li>
</ul>
<p><img src="/bc4fb6eb/加载器.png" alt="加载器"></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h4 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h4><p>当一个<code>ClassLoader</code>加载一个类的时候，除非显式的使用另一个<code>ClassLoader</code>,该类所依赖和引用的类也由这个<code>ClassLoader</code>载入</p>
<h4 id="双亲委派机制-1"><a href="#双亲委派机制-1" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类。实际上<code>双亲委派机制</code>实则<code>父类委派机制</code>。</p>
<h5 id="双亲委派模式的优势"><a href="#双亲委派模式的优势" class="headerlink" title="双亲委派模式的优势"></a>双亲委派模式的优势</h5><ul>
<li>沙箱安全机制：比如自己写的<code>String.class</code>类不会被加载，这样可以防止核心库被随意篡改</li>
<li>避免类的重复加载：当父<code>ClassLoader</code>已经加载了该类的时候，就不需要子<code>ClassLoader</code>再加载一次</li>
</ul>
<p><em>要确定一个类的唯一性，要获得该类的类加载器实例以及类的全限定名。</em></p>
<p>不同的类加载器加载同一个<code>class</code>文件是不同的类模板信息</p>
<p>为什么要打破双亲委派机制？<br>Tomcat为了做wap包隔离</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="/bc4fb6eb/运行时数据区.png" alt="运行时数据区"></p>
<p>堆：用来放类的实例对象<br>栈：栈帧，用来存放方法，线程</p>
<h4 id="方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间"><a href="#方法区（Method-Area）-永久代-持久代jdk1-8以前，元空间" class="headerlink" title="方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)"></a>方法区（Method Area）(永久代/持久代jdk1.8以前，元空间)</h4><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p>
<h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><ul>
<li>YoungGC/MinorGC</li>
<li>CMS OldGC</li>
<li>MajorGC/FullGC</li>
</ul>
<p>虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出<code>OutOfMemoryError(OOM)</code>异常。同时也是垃圾收集器管理的主要区域。</p>
<p><img src="/bc4fb6eb/堆.png" alt="堆"></p>
<p>当年龄到15时，转入老年代</p>
<h5 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h5><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分：伊甸区<code>（Eden space）</code>和幸存者区<code>（Survivor space）</code>，所有的类都是在伊甸区被new出来的。<br>幸存区又分为<code>From</code>和<code>To</code>区。当<code>Eden</code>区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将<code>Eden</code>区进行垃圾回<br>收<code>（Minor GC）</code>，将<code>Eden</code>区中的不再被其它对象应用的对象进行销毁。然后将<code>Eden</code>区中剩余的对象移到<code>From Survivor</code>区。若<code>From Survivor</code>区也满了，再对该区进行垃圾回收，然后移动到<code>To Survivor</code>区。</p>
<h5 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h5><p>新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生<code>Major GC</code>（也可以叫<code>Full GC</code>），进行老年区的内存清理。若老年区执行了<code>Full GC</code>之后发现依然无法进行对象的保存，就会抛出<code>OOM（OutOfMemoryError）</code>异常</p>
<h5 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h5><p>在<code>JDK1.8</code>之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p>
<p><strong>为什么移除了永久代？</strong><br>参考官方解释 <strong><a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></strong></p>
<p>大概意思是移除永久代是为融合<code>HotSpot</code>与<code>JRockit</code>而做出的努力，因为<code>JRockit</code>没有永久代，不需要配置永久代。</p>
<p><img src="/bc4fb6eb/堆和GC.png" alt="新生代和老年代转化"></p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h4><p>Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致.</p>
<h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h4><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记<code>native</code>方法，在<code>Execution Engine</code>执行时加载本地方法库</p>
<h4 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h4><p>就是一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p>
<hr>
<h6 id="将下面代码编译生成Class字节码并反汇编："><a href="#将下面代码编译生成Class字节码并反汇编：" class="headerlink" title="将下面代码编译生成Class字节码并反汇编："></a>将下面代码编译生成<code>Class</code>字节码并反汇编：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">math</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) * <span class="number">10</span>;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">JVM</span> <span class="variable">jvm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVM</span>();</span><br><span class="line">      System.out.println(jvm.math());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编后：<code>(javap -c JVM.class &gt; JVM.txt)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;JVM.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">JVM</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">math</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_1</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_5</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">14</span>: iload_1</span><br><span class="line">      <span class="number">15</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">18</span>: iload_3</span><br><span class="line">      <span class="number">19</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class JVM</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method math:()I</span></span><br><span class="line">      <span class="number">15</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多其实都是编译原理的知识，下面是数据区：</p>
<p><img src="/bc4fb6eb/数据区.png" alt="数据区"></p>
<p>反汇编之后前面的数字序号便是程序计数器<code>PC</code></p>
<p>目前市面上大部分虚拟机都是用<code>C/C++</code>实现的，实际上最后启动线程都是通过<code>C/C++</code>库来调用操作系统内核函数实现。</p>
<p>利用<code>javap -v JVM.class &lt; dynamicLink.txt</code>查看动态链接详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /G:/JVM.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">5</span>-<span class="number">24</span>; size <span class="number">493</span> bytes</span><br><span class="line">  MD5 checksum 5cdaa7b4d5fb74c45c86c10186ae5c8c</span><br><span class="line">  Compiled from <span class="string">&quot;JVM.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVM</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">7.</span>#<span class="number">18</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">19.</span>#<span class="number">20</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">21.</span>#<span class="number">22</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// JVM</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">18</span>         <span class="comment">// JVM.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">4.</span>#<span class="number">24</span>         <span class="comment">// JVM.math:()I</span></span><br><span class="line">   #<span class="number">7</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">8</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">9</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">10</span> = Utf8               Code</span><br><span class="line">  #<span class="number">11</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               math</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">17</span> = Utf8               JVM.java</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">8</span>:#<span class="number">9</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">26</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">27</span>:#<span class="number">28</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">21</span> = Class              #<span class="number">29</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">30</span>:#<span class="number">31</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">23</span> = Utf8               JVM</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// math:()I</span></span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">27</span> = Utf8               out</span><br><span class="line">  #<span class="number">28</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">29</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">30</span> = Utf8               println</span><br><span class="line">  #<span class="number">31</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">JVM</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">math</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_5</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">9</span>: imul</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">14</span>: iload_1</span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class JVM</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">11</span>: aload_1</span><br><span class="line">        <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method math:()I</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;JVM.java&quot;</span></span><br></pre></td></tr></table></figure>
<p>第一段的<code>Constant pool</code>是符号引用</p>
]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解（一）</title>
    <url>/33fe21e.html</url>
    <content><![CDATA[<h3 id="LeetCode-热题-Hot-100"><a href="#LeetCode-热题-Hot-100" class="headerlink" title="LeetCode 热题 Hot 100"></a><a href="https://leetcode-cn.com/problemset/leetcode-hot-100/">LeetCode 热题 Hot 100</a></h3><!-- toc -->
<span id="more"></span>
<h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1. 两数相加"></a>1. 两数相加</h2><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            v[<span class="number">1</span>] = map[target - nums[i]];</span><br><span class="line">            v[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，若 map 中没有元素，用 if 条件判断时会自动调用构造函数添加该元素。判断是否有该元素课用<code>map.count()</code>或<code>map.find()</code>.<code>map.count()</code>找到返回<code>1</code>，否则返回<code>0</code>。<code>map.find()</code>找到返回元素位置，找不到返回<code>map.end()</code>迭代器指针。</p>
<h2 id="2-两数相加-链表"><a href="#2-两数相加-链表" class="headerlink" title="2. 两数相加(链表)"></a>2. 两数相加(链表)</h2><blockquote>
<p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *temp = p;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> val1 = l1 != <span class="literal">nullptr</span> ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> val2 = l2 != <span class="literal">nullptr</span> ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = val1 + val2 + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        ListNode *sumNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        temp-&gt;next = sumNode;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-滑动窗口"><a href="#3-无重复字符的最长子串-滑动窗口" class="headerlink" title="3. 无重复字符的最长子串(滑动窗口)"></a>3. 无重复字符的最长子串(滑动窗口)</h2><blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">不重复最长子串</a></p>
<p>思路：</p>
<ul>
<li>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复<br>我们定义不重复子串的开始位置为 start，结束位置为 end</li>
<li>随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符</li>
<li>无论是否更新 start，都会更新其 map 数据结构和结果 ans。</li>
<li>时间复杂度：O(n)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(s[right]) == <span class="number">0</span>) &#123;</span><br><span class="line">            map[s[right]] = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; map[s[right]]) &#123;     <span class="comment">//若出现的字符不在当前窗口内</span></span><br><span class="line">                map[s[right]] = right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = map[s[right]] + <span class="number">1</span>;</span><br><span class="line">                map[s[right]] = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        len = ((right - left) &gt; len) ? (right - left) : len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-搜索旋转排序数组"><a href="#4-搜索旋转排序数组" class="headerlink" title="4. 搜索旋转排序数组"></a>4. 搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值互不相同。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1<br>要求时间复杂度为 O(log(n))</p>
</blockquote>
<p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p>
<p>这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p>
<p>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。<br>如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</p>
<p><img src="/33fe21e/搜索旋转排序数组.png" alt="搜索排序数组"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> target == nums[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;                          <span class="comment">//前面有序，后面无序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) &#123;  <span class="comment">//target在前半部分</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                        <span class="comment">//target在后半部分</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-最大数"><a href="#5-最大数" class="headerlink" title="5. 最大数"></a>5. 最大数</h2><blockquote>
<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数.</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/largest-number/">题目</a></p>
<p><a href="https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-by-leetcode-solution-sid5/">题解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="type">int</span> sx = <span class="number">10</span>, sy = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (sx &lt;= x) &#123;</span><br><span class="line">            sx *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sy &lt;= y) &#123;</span><br><span class="line">            sy *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * sy + y &gt; y * sx + x;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        str += <span class="built_in">to_string</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">78</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">largestNumber</span>(v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-盛最多水的容器"><a href="#6-盛最多水的容器" class="headerlink" title="6. 盛最多水的容器"></a>6. 盛最多水的容器</h2><blockquote>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<p>思路：双指针，从两端往中间遍历，每次将两端较小的指针向中间移动，直到相遇。</p>
<p>证明如下：<br>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p>
<p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p>
<p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p>
<p>考虑第一步，假设当前左指针和右指针指向的数分别为 $x$ 和 $y$，不失一般性，我们假设 $x \leq y$。同时，两个指针之间的距离为 $t$。那么，它们组成的容器的容量为：</p>
<script type="math/tex; mode=display">min(x, y)*t =x*t</script><p>我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x*t$ 了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。</p>
<p>我们任意向左移动右指针，指向的数为 $y_1$，两个指针之间的距离为 $t_1$，那么显然有 $t_1 &lt; t$，并且 $min(x, y_1) \leq \min(x, y)$</p>
<ul>
<li><p>如果 $y_1 \leq y$，那么 $min(x, y_1) \leq \min(x, y)$</p>
</li>
<li><p>如果 $y_1 &gt; y$，那么 $min(x, y_1) = x = min(x, y)$</p>
</li>
</ul>
<p>因此有：</p>
<script type="math/tex; mode=display">min(x, y_t) * t_1 < min(x, y) * t</script><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p>
<p>这样一来，我们将问题的规模减小了 1，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界。便按照上述思路继续解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11.盛水最多的容器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        res = (height[l] &lt; height[r] ? height[l] : height[r]) * (r - l);</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; MAX) MAX = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArea</span>(v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Hot 100</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中sed、awk、grep命令详解</title>
    <url>/574c20f6.html</url>
    <content><![CDATA[<h1 id="Linux中sed、awk、grep命令详解"><a href="#Linux中sed、awk、grep命令详解" class="headerlink" title="Linux中sed、awk、grep命令详解"></a>Linux中sed、awk、grep命令详解</h1><p>在开始介绍 <code>sed</code>、<code>awk</code>、<code>grep</code> 命令之前，先简单介绍一下 <code>bash</code>.</p>
<h2 id="一、bash-及一些特性"><a href="#一、bash-及一些特性" class="headerlink" title="一、bash 及一些特性"></a>一、bash 及一些特性</h2><h3 id="1-命令行展开"><a href="#1-命令行展开" class="headerlink" title="1. 命令行展开"></a>1. 命令行展开</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">echo</span> change1 change2 change3 change4 change5</span><br><span class="line">change1 change2 change3 change4 change5</span><br><span class="line">➜  ~ <span class="built_in">echo</span> change&#123;1..5&#125;</span><br><span class="line">change1 change2 change3 change4 change5</span><br><span class="line">➜  ~ <span class="built_in">echo</span> change&#123;1..10..2&#125;</span><br><span class="line">change1 change3 change5 change7 change9</span><br><span class="line">➜  ~ <span class="built_in">echo</span> change&#123;01..10..2&#125;</span><br><span class="line">change01 change03 change05 change07 change09</span><br></pre></td></tr></table></figure>
<p><code>echo</code> 命令后面加上 <code>&#123;&#125;</code> 表示命令行展开，例如上例中 <code>&#123;1..5&#125;</code> 表示从 <code>1</code> 展开到 <code>5</code>，如果后面再加上一个参数，则表示步长，<code>&#123;1..10..2&#125;</code> 表示输出 1 到 10 的奇数，若在参数前面加上 0，则表示用 0 补全。</p>
<h3 id="2-alias"><a href="#2-alias" class="headerlink" title="2. alias"></a>2. alias</h3><p>输出命令 <code>alias</code> 表示查看当前的命令别名，输入 <code>unalias</code> 可以取消已经设定的命令别名。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&quot;rm -i&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-历史命令"><a href="#3-历史命令" class="headerlink" title="3. 历史命令"></a>3. 历史命令</h3><p><code>history</code> 可以查看所有时间内该机器输入过的命令，可以通过 <code>!行号</code> 快捷输入曾经输过的命令，<code>!!</code> 表示上一次输入的命令。</p>
<h3 id="4-快捷键"><a href="#4-快捷键" class="headerlink" title="4. 快捷键"></a>4. 快捷键</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + a 光标移动到行首</span><br><span class="line">ctrl + e 光标移动到行尾</span><br><span class="line">ctrl + u 删除光标之前的字符</span><br><span class="line">ctrl + k 删除光标之后的字符</span><br><span class="line">ctrl + l 清屏，相当于 clear</span><br></pre></td></tr></table></figure>
<h2 id="二、Linux-正则表达式"><a href="#二、Linux-正则表达式" class="headerlink" title="二、Linux 正则表达式"></a>二、Linux 正则表达式</h2><p>正则表达式 <code>REGEXP</code> 分为两类</p>
<ul>
<li>基本正则表达式 <code>BRE</code></li>
<li>扩展正则表达式 <code>ERE</code></li>
</ul>
<p>Linux 下只有 <code>sed</code>、<code>grep</code>、<code>awk</code> 三个命令可以使用正则表达式，其他命令都无法使用</p>
<p><strong>Linux 三剑客</strong></p>
<ul>
<li><code>grep</code>：文本过滤工具，模式工具</li>
<li><code>sed</code>：stream editor，流编辑器，文本编辑工具</li>
<li><code>awk</code>：Linux 的文本报告生成器（格式化文本），实际上是链接到 <code>gawk</code> 上</li>
</ul>
<h3 id="正则表达式的分类"><a href="#正则表达式的分类" class="headerlink" title="正则表达式的分类"></a>正则表达式的分类</h3><ul>
<li>基本正则表达式对应元字符有：<code>^$.[]*</code></li>
<li>扩展正则表达式在基本正则表达式基础上增加了 <code>()&#123;&#125;?+|</code> 等字符</li>
</ul>
<p>基本功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>用于模式最左侧，如 <code>^abc</code> 表示以 <code>abc</code> 开头的行</td>
</tr>
<tr>
<td>$</td>
<td>用于模式最右侧，如 <code>abc$</code> 表示以 <code>abc</code> 结尾的行</td>
</tr>
<tr>
<td>^$</td>
<td>组合符，表示空行</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符，不包括空行</td>
</tr>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>^.*</td>
<td>匹配任意多个字符开头的行</td>
</tr>
<tr>
<td>.*$</td>
<td>匹配任意多个字符结尾的行</td>
</tr>
<tr>
<td>[abc]</td>
<td>匹配集合内任意一个字符</td>
</tr>
<tr>
<td><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup></td>
<td>匹配除了集合中任意一个字符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="扩展正则表达式-ERE-集合"><a href="#扩展正则表达式-ERE-集合" class="headerlink" title="扩展正则表达式 ERE 集合"></a>扩展正则表达式 ERE 集合</h3><p>扩展正则必须用 <code>grep -E</code> 才能生效</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>匹配前一个字符一次或多次</td>
</tr>
<tr>
<td>[a]+</td>
<td>匹配集合中的符号至少一次或多次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前一个字符 0 次或 1 次</td>
</tr>
<tr>
<td>()</td>
<td>在括号中的符号表示一个整体</td>
</tr>
<tr>
<td>a{n,m}</td>
<td>匹配前一个字符至少 n 次，至多 m 次</td>
</tr>
<tr>
<td>a{n,}</td>
<td>匹配前一个字符至少 n 次</td>
</tr>
<tr>
<td>a{n}</td>
<td>匹配前一个字符正好 n 次</td>
</tr>
<tr>
<td>a{,m}</td>
<td>匹配前一个字符至多 m 次</td>
</tr>
</tbody>
</table>
</div>
<h3 id="一些正则表达式的例子"><a href="#一些正则表达式的例子" class="headerlink" title="一些正则表达式的例子"></a>一些正则表达式的例子</h3><h2 id="三、grep"><a href="#三、grep" class="headerlink" title="三、grep"></a>三、grep</h2><ul>
<li><code>grep</code> 英文全称是 <code>Global search REgular expression and Print out the line.</code></li>
<li>作用：文本搜索工具，根据用户指定的模式过滤条件，对目标文本逐行进行匹配检查，打印匹配到的行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">grep [options] [pattern] file</span><br><span class="line">命令   参数      匹配模式   文件数据</span><br><span class="line">                -i: ignorecase，忽略字符的大小写</span><br><span class="line">                -o: 仅显示匹配到的字符串本身</span><br><span class="line">                -v, --invert-match: 显示不能被模式匹配到的行</span><br><span class="line">                -E: 支持使用扩展的正则表达式元字符</span><br><span class="line">                -q, --quiet, --silent: 静默模式，即不输出任何信息</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数选项</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>排除匹配结果</td>
</tr>
<tr>
<td>-i</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>-n</td>
<td>显示匹配行与行号</td>
</tr>
<tr>
<td>-c</td>
<td>只统计匹配的行数</td>
</tr>
<tr>
<td>-E</td>
<td>使用拓展正则</td>
</tr>
<tr>
<td>—color=auto</td>
<td>为过滤结果添加颜色</td>
</tr>
<tr>
<td>-w</td>
<td>只匹配过滤的单词</td>
</tr>
<tr>
<td>-o</td>
<td>只输出匹配到的内容</td>
</tr>
</tbody>
</table>
</div>
<p><strong>例子 1：找出文本文件 <code>bre</code> 中的空行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk grep -n -E <span class="string">&#x27;^$&#x27;</span> bre</span><br><span class="line">2:</span><br><span class="line">5:</span><br><span class="line">6:</span><br><span class="line">➜  ~/code/awk grep -n -E <span class="string">&#x27;^$&#x27;</span> bre -c</span><br><span class="line">3</span><br><span class="line">➜  ~/code/awk <span class="built_in">cat</span> -n bre</span><br><span class="line">     1  abc is a simple word.</span><br><span class="line">     2</span><br><span class="line">     3  What is the answer?</span><br><span class="line">     4  I am 23 years old.</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7  I come from JiangSu...</span><br></pre></td></tr></table></figure>
<p><strong>例子 2：在上面的文件中增加以 <code>#</code> 开头的注释行，并筛选出非空行和注释行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk <span class="built_in">cat</span> -n bre</span><br><span class="line">     1  abc is a simple word.</span><br><span class="line">     2</span><br><span class="line">     3  What is the answer?</span><br><span class="line">     4  I am 23 years old.</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7  I come from JiangSu...</span><br><span class="line">     8  <span class="comment">#这是一个注释行</span></span><br><span class="line">➜  ~/code/awk grep <span class="string">&#x27;^$&#x27;</span> bre -v</span><br><span class="line">abc is a simple word.</span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br><span class="line">I come from JiangSu...</span><br><span class="line">8:<span class="comment">#这是一个注释行</span></span><br><span class="line">➜  ~/code/awk grep <span class="string">&#x27;^$&#x27;</span> bre -v | grep -E <span class="string">&#x27;#&#x27;</span> -v</span><br><span class="line">abc is a simple word.</span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br><span class="line">I come from JiangSu...</span><br></pre></td></tr></table></figure>
<p>用管道符将两个命令连接起来。</p>
<p><strong>例子3：匹配以 <code>.</code> 结尾的行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk grep <span class="string">&#x27;\.$&#x27;</span> bre</span><br><span class="line">abc is a simple word.</span><br><span class="line">I am 23 years old.</span><br><span class="line">I come from JiangSu...</span><br></pre></td></tr></table></figure>
<p><code>.</code> 前要用转义符 <code>\</code> 进行转义</p>
<p><strong>【注】：在 Linux 下，所有文件每一行的结尾最后都有一个 <code>$</code>，可以加上参数 <code>-E</code> 查看，如下所示：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk <span class="built_in">cat</span> -En bre</span><br><span class="line">     1  abc is a simple word.$</span><br><span class="line">     2  $</span><br><span class="line">     3  What is the answer?$</span><br><span class="line">     4  I am 23 years old.$</span><br><span class="line">     5  $</span><br><span class="line">     6  $</span><br><span class="line">     7  I come from JiangSu...$</span><br><span class="line">     8  <span class="comment">#这是一个注释行$</span></span><br></pre></td></tr></table></figure>
<p><strong>例子4：在 <code>bre</code> 文件中找到以 <code>a</code> 或 <code>w</code> 开头的行，忽略大小写</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk grep -E -n -i <span class="string">&#x27;^[a|w]&#x27;</span> bre</span><br><span class="line">1:abc is a simple word.</span><br><span class="line">3:What is the answer?</span><br></pre></td></tr></table></figure>
<p><code>grep</code> 整体比较简单，主要是正则表达式的使用。</p>
<h2 id="四、sed"><a href="#四、sed" class="headerlink" title="四、sed"></a>四、sed</h2><p><code>sed</code> 是 <code>Stream Editor</code>（字符流编辑器）的缩写，简称流编辑器。</p>
<p><code>sed</code> 是操作、过滤和转换文本内容的强大工具，常用功能包括结合正则表达式对文件实现快速增删改查，较为重要的两个功能是提取富川和提取整行。</p>
<h3 id="4-1-sed-语法"><a href="#4-1-sed-语法" class="headerlink" title="4.1 sed 语法"></a>4.1 sed 语法</h3><p><code>sed</code> 语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [选项] [sed内置命令字符] [输入文件]</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数选项</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>取消默认 <code>sed</code> 的输出，常与 <code>sed</code> 内置命令 <code>p</code> 一起用</td>
</tr>
<tr>
<td>-i</td>
<td>直接将修改结果写入文件,不用 <code>-i</code>，<code>sed</code> 修改的是内存数据</td>
</tr>
<tr>
<td>-e</td>
<td>多次编辑,不需要管道符了</td>
</tr>
<tr>
<td>-r</td>
<td>支持正则扩展</td>
</tr>
</tbody>
</table>
</div>
<p><strong>内置命令字符</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内置命令字符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>append，对文本追加，在指定行后面添加一行/多行文本</td>
</tr>
<tr>
<td>d</td>
<td>Delete，删除匹配行</td>
</tr>
<tr>
<td>i</td>
<td>insert，表示插入文本,在指定行前添加一行/多行文本</td>
</tr>
<tr>
<td>p</td>
<td>Print，打印匹配行的内容,通常 p 与 -n 一起用</td>
</tr>
<tr>
<td>s/正则/替换内容/g</td>
<td>匹配正则内容，然后替换内容(支持正则)，结尾g代表全局匹配</td>
</tr>
</tbody>
</table>
</div>
<p><strong>匹配范围</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配范围</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>空地址</td>
<td>全文处理</td>
</tr>
<tr>
<td>单地址</td>
<td>指定文件某一行</td>
</tr>
<tr>
<td>/pattern/</td>
<td>被模式匹配到的每一行</td>
</tr>
<tr>
<td>范围区间</td>
<td>10, 20 十到二十行，10,+5 第10行向下5行, /pattern1/ ,/pattern2/</td>
</tr>
<tr>
<td>步长</td>
<td>1~2，表示1、3、5、7、9行，2~2两个步长，表示 2、4、6、8、10、偶数行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-2-sed-例子"><a href="#4-2-sed-例子" class="headerlink" title="4.2 sed 例子"></a>4.2 sed 例子</h3><p>下列所有例子都将使用如下测试用例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk <span class="built_in">cat</span> -n bre</span><br><span class="line">     1  abc is a simple word.</span><br><span class="line">     2</span><br><span class="line">     3  What is the answer?</span><br><span class="line">     4  I am 23 years old.</span><br><span class="line">     5</span><br><span class="line">     6  My tel is 12345678999</span><br><span class="line">     7  My favirate food is hamburger.</span><br><span class="line">     8  I come from JiangSu...</span><br><span class="line">     9</span><br><span class="line">    10</span><br><span class="line">    11  <span class="comment">#这是一个注释行</span></span><br><span class="line">    12  xxxx</span><br><span class="line">    13  xxxxxxx</span><br></pre></td></tr></table></figure>
<h4 id="1-输出文件第3、4行"><a href="#1-输出文件第3、4行" class="headerlink" title="1. 输出文件第3、4行"></a>1. 输出文件第3、4行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&quot;3,4p&quot;</span> -n  bre</span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br></pre></td></tr></table></figure>
<p><code>sed</code> 默认输出是所有的，因此要加上 <code>-n</code> 参数，<code>p</code> 表示打印。</p>
<h4 id="2-过滤含有-My-的字符串行"><a href="#2-过滤含有-My-的字符串行" class="headerlink" title="2. 过滤含有 My 的字符串行"></a>2. 过滤含有 My 的字符串行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&quot;/My/p&quot;</span> -n  bre</span><br><span class="line">My tel is 12345678999</span><br><span class="line">My favirate food is hamburger.</span><br></pre></td></tr></table></figure>
<p>这里要匹配字符串 <code>My</code>，因此要用 <code>/My/</code> 进行模式匹配，同样要用 <code>-n</code> 参数。</p>
<h4 id="3-删除有-is-的行"><a href="#3-删除有-is-的行" class="headerlink" title="3. 删除有 is 的行"></a>3. 删除有 is 的行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&quot;/is/d&quot;</span> bre</span><br><span class="line"></span><br><span class="line">I am 23 years old.</span><br><span class="line"></span><br><span class="line">I come from JiangSu...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一个注释行</span></span><br><span class="line">xxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>
<p>我们这里用参数 <code>d</code>，表示删除匹配到的行，然后不用加 <code>-n</code> 参数，但是 <code>bre</code> 文件中的内容并不会被改变，因为 <code>sed</code> 是将文件内容读到内存中进行操作的。如果要对源文件进行修改，则要加上 <code>-i</code> 参数。</p>
<h4 id="4-删除第-5-行之后的行"><a href="#4-删除第-5-行之后的行" class="headerlink" title="4. 删除第 5 行之后的行"></a>4. 删除第 5 行之后的行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&#x27;5,$d&#x27;</span> bre</span><br><span class="line">abc is a simple word.</span><br><span class="line"></span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br></pre></td></tr></table></figure>
<p>这里模式是 <code>5,$d</code>，<code>$</code> 表示文件末尾。</p>
<h4 id="5-将文件中的-is-全部替换成-IS，并打印前-5-行"><a href="#5-将文件中的-is-全部替换成-IS，并打印前-5-行" class="headerlink" title="5. 将文件中的 is 全部替换成 IS，并打印前 5 行"></a>5. 将文件中的 is 全部替换成 IS，并打印前 5 行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&#x27;s/is/IS/g&#x27;</span> bre | sed <span class="string">&#x27;1,5p&#x27;</span> -n    </span><br><span class="line">abc IS a simple word.</span><br><span class="line"></span><br><span class="line">What IS the answer?</span><br><span class="line">I am 23 years old.</span><br></pre></td></tr></table></figure>
<p>替换模式为 <code>s/is/IS/g</code>，这里 <code>/</code> 也可以换成 <code>#</code> 或 <code>@</code>。两个命令用管道连接，后面的 <code>sed</code> 无需指定文件名。</p>
<h4 id="6-将文件中的-is-全替换成-IS，同时将-23-替换成-35"><a href="#6-将文件中的-is-全替换成-IS，同时将-23-替换成-35" class="headerlink" title="6. 将文件中的 is 全替换成 IS，同时将 23 替换成 35"></a>6. 将文件中的 is 全替换成 IS，同时将 23 替换成 35</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed -e <span class="string">&#x27;s/is/IS/g&#x27;</span> -e <span class="string">&#x27;s#23#35#g&#x27;</span> bre</span><br><span class="line">abc IS a simple word.</span><br><span class="line"></span><br><span class="line">What IS the answer?</span><br><span class="line">I am 35 years old.</span><br><span class="line"></span><br><span class="line">My tel IS 13545678999</span><br><span class="line">My favirate food IS hamburger.</span><br><span class="line">I come from JiangSu...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一个注释行</span></span><br><span class="line">xxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>
<p>5 中的例子中有两个操作，是用管道符进行操作的，但是 <code>sed</code> 参数中提供了 <code>-e</code> 进行多次编辑，因此就不需要使用管道了。5 也可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed -e <span class="string">&#x27;s/is/IS/g&#x27;</span> -e <span class="string">&#x27;1,5p&#x27;</span> -n bre  </span><br><span class="line">abc IS a simple word.</span><br><span class="line"></span><br><span class="line">What IS the answer?</span><br><span class="line">I am 23 years old.</span><br></pre></td></tr></table></figure>
<h4 id="7-在文件第-4-行后追加一行-Linux-is-funny"><a href="#7-在文件第-4-行后追加一行-Linux-is-funny" class="headerlink" title="7. 在文件第 4 行后追加一行 Linux is funny.."></a>7. 在文件第 4 行后追加一行 Linux is funny..</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&#x27;4a ##Today is Wednesday##&#x27;</span> bre   </span><br><span class="line">abc is a simple word.</span><br><span class="line"></span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br><span class="line">Linux is funny.. </span><br><span class="line"></span><br><span class="line">My tel is 12345678999</span><br><span class="line">My favirate food is hamburger.</span><br><span class="line">I come from JiangSu...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一个注释行</span></span><br><span class="line">xxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>
<h4 id="8-在文件第-1-行后追加一行-Today-is-Wednesday"><a href="#8-在文件第-1-行后追加一行-Today-is-Wednesday" class="headerlink" title="8. 在文件第 1 行后追加一行 ##Today is Wednesday"></a>8. 在文件第 1 行后追加一行 ##Today is Wednesday</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&#x27;1i ##Today is Wednesday##&#x27;</span> bre</span><br><span class="line"><span class="comment">##Today is Wednesday##</span></span><br><span class="line">abc is a simple word.</span><br><span class="line"></span><br><span class="line">What is the answer?</span><br><span class="line">I am 23 years old.</span><br><span class="line"></span><br><span class="line">My tel is 12345678999</span><br><span class="line">My favirate food is hamburger.</span><br><span class="line">I come from JiangSu...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一个注释行</span></span><br><span class="line">xxxx</span><br><span class="line">xxxxxxx</span><br></pre></td></tr></table></figure>
<p>加上 <code>-i</code> 参数将会直接修改文件，且不会输出。</p>
<p>若是不加地址，则表示全文范围，如要在每一行后面加上 <code>------------</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk sed <span class="string">&#x27;a ---------------&#x27;</span> bre</span><br><span class="line">abc is a simple word.</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">What is the answer?</span><br><span class="line">---------------</span><br><span class="line">I am 23 years old.</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">My tel is 12345678999</span><br><span class="line">---------------</span><br><span class="line">My favirate food is hamburger.</span><br><span class="line">---------------</span><br><span class="line">I come from JiangSu...</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"><span class="comment">#这是一个注释行</span></span><br><span class="line">---------------</span><br><span class="line">xxxx</span><br><span class="line">---------------</span><br><span class="line">xxxxxxx</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure>
<h3 id="4-3-sed-进阶例子：取出-Linux-的-IP-地址"><a href="#4-3-sed-进阶例子：取出-Linux-的-IP-地址" class="headerlink" title="4.3 sed 进阶例子：取出 Linux 的 IP 地址"></a>4.3 sed 进阶例子：取出 Linux 的 IP 地址</h3><p>以下例子将用 <code>sed</code> 配合正则表达式进行处理文本。</p>
<p>首先输入 <code>ifconfig</code> 命令打印出网络信息，我们要提取出 <code>eth0</code> 网卡中的 <code>inet</code> 后的 IP 地址信息，然后保存到文件 <code>IP_eth0</code> 中。</p>
<p>我们首先打印 <code>eth0</code> 网卡信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0              </span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.19.194.137  netmask 255.255.240.0  broadcast 172.19.207.255</span><br><span class="line">        inet6 fe80::215:5dff:feeb:1353  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:eb:13:53  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 127  bytes 60337 (60.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 109  bytes 13475 (13.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>然后打印出第二行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0 | sed <span class="string">&#x27;2p&#x27;</span> -n </span><br><span class="line">        inet 172.19.194.137  netmask 255.255.240.0  broadcast 172.19.207.255</span><br></pre></td></tr></table></figure>
<p>然后用正则匹配将 IP 地址前后内容替换为空：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0 | sed <span class="string">&#x27;2p&#x27;</span> -n | sed <span class="string">&#x27;s/^.*inet //&#x27;</span> | sed <span class="string">&#x27;s/ netmask.*$//&#x27;</span></span><br><span class="line">172.19.194.137</span><br></pre></td></tr></table></figure>
<p>这样便提取出了 IP 地址，然后再写入文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0 | sed <span class="string">&#x27;2p&#x27;</span> -n | sed <span class="string">&#x27;s/^.*inet //&#x27;</span> | sed <span class="string">&#x27;s/ netmask.*$//&#x27;</span> | <span class="built_in">tee</span> IP_eth0</span><br><span class="line">172.19.194.137</span><br></pre></td></tr></table></figure>
<p>当然也可以用 <code>-e</code> 参数进行多次编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0 | sed -e <span class="string">&#x27;2s/^.*inet //&#x27;</span> -e  <span class="string">&#x27;2s/ netmask.*$//p&#x27;</span> -n | <span class="built_in">tee</span> IP_eth0 </span><br><span class="line">172.19.194.137</span><br></pre></td></tr></table></figure>
<p>注意哪些地方有 <code>p</code> 参数，哪些地方没有，如果两次匹配加了 <code>p</code>，那么就会打印两次信息，一次是删掉前面之后的剩余部分，一次是删掉前后剩下的部分。</p>
<h2 id="五、awk"><a href="#五、awk" class="headerlink" title="五、awk"></a>五、awk</h2><p>awk 有强大的文本格式化功能，它更像是一门编程语言，支持条件判断、数组、循环等功能。</p>
<p>awk 语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [option] <span class="string">&#x27;pattern[action]&#x27;</span> file</span><br><span class="line">     可选参数  模式     动作      文件/数据</span><br></pre></td></tr></table></figure>
<p>action 指的是动作，awk 擅长文本格式化，且输出格式化之后的结果，因此最常见的动作就是 <code>pirnt</code> 和 <code>printf</code>。</p>
<p>若我们执行的命令是 <code>awk &#39;&#123;print $2&#125;&#39;</code>，没有使用参数和模式，<code>$2</code> 表示输出文本的第二列信息。<code>awk</code> 默认以空格为分隔符，且多个空格也识别为一个空格，作为分隔符。</p>
<p><code>awk</code> 是按行处理文件，一行处理完毕，处理下一行，根据用户指定的分割符去工作，没有指定则默认空格。</p>
<p><code>$0</code> 表示整行信息，<code>$1</code> 表示文本第一列信息，<code>$NF</code> 表示当前分割后的最后一列，倒数第二列可以写成 <code>$(NF-1)</code>。</p>
<h3 id="1-awk-变量"><a href="#1-awk-变量" class="headerlink" title="1. awk 变量"></a>1. awk 变量</h3><p><code>awk</code> 分为内置变量和自定义变量。</p>
<h4 id="1-1-内置变量"><a href="#1-1-内置变量" class="headerlink" title="1.1 内置变量"></a>1.1 内置变量</h4><p>一些常用的内置变量如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内置变量</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>指定分隔符后，当前记录的第n个字段</td>
</tr>
<tr>
<td>$0</td>
<td>完整的输入记录</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认是空格</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认是空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符（输入换行符），指定输入时的换行符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符（输入换行符），指定输入时的换行符</td>
</tr>
<tr>
<td>NF(Number of fields)</td>
<td>分割后，当前行一共有多少个字段</td>
</tr>
<tr>
<td>NR(Number of records)</td>
<td>当前记录数，行数</td>
</tr>
<tr>
<td>FNR</td>
<td>各文件分别计数的行号</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前文件名</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数的个数</td>
</tr>
<tr>
<td>ARGV</td>
<td>数组，存储命令行所给定的各个参数</td>
<td></td>
</tr>
<tr>
<td>更多内置变量可以man手册查看</td>
<td>man awk</td>
</tr>
</tbody>
</table>
</div>
<p>例子，一次性输出多列信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1,$2&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>
<p>其中参数之间的逗号表示默认分隔符，在输出时每列之间会有一个空格。</p>
<p>再如，自定义输出内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print &quot;第一列&quot;,$1,&quot;第二列&quot;,$2&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>
<p>【注】：awk 必须外层单引号，内层双引号，并且内置变量 <code>$n</code> 不可以加引号，否则会被识别为字符串。</p>
<p>awk 的内置变量 <code>NR</code>、<code>NF</code> 是不用加 <script type="math/tex">` 的，但是例如 `$0`、`$1` 等是需要加 `</script> 的。</p>
<h5 id="NR-和-NF"><a href="#NR-和-NF" class="headerlink" title="NR 和 NF"></a>NR 和 NF</h5><p>有如下测试文件 <code>awk1</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cherry 25 19990101</span><br><span class="line">James 35 19850422</span><br><span class="line">Anna 22 20000322</span><br><span class="line">ChrisTim 48 19731225</span><br><span class="line">Qiang 23 19990103</span><br><span class="line">Sue 6 20160505</span><br><span class="line">Paul 37 19850428</span><br><span class="line">Steve 0 00000000</span><br></pre></td></tr></table></figure>
<p>现在要输出第二行内容，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;NR==2&#x27;</span> awk1 </span><br><span class="line">James 35 19850422</span><br></pre></td></tr></table></figure>
<p>注意这里是 <code>==</code>。如果要输出第二到第五行，则命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;NR==2,NR==5&#x27;</span> awk1</span><br><span class="line">James 35 19850422</span><br><span class="line">Anna 22 20000322</span><br><span class="line">ChrisTim 48 19731225</span><br><span class="line">Qiang 23 19990103</span><br></pre></td></tr></table></figure>
<p>给每一行内容添加行号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;&#123;print NR,$0&#125;&#x27;</span> awk1</span><br><span class="line">1 Cherry 25 19990101</span><br><span class="line">2 James 35 19850422</span><br><span class="line">3 Anna 22 20000322</span><br><span class="line">4 ChrisTim 48 19731225</span><br><span class="line">5 Qiang 23 19990103</span><br><span class="line">6 Sue 6 20160505</span><br><span class="line">7 Paul 37 19850428</span><br><span class="line">8 Steve 0 00000000</span><br></pre></td></tr></table></figure>
<p>输出第一列和最后一列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;&#123;print $1,$(NF)&#125;&#x27;</span> awk1</span><br><span class="line">Cherry 19990101</span><br><span class="line">James 19850422</span><br><span class="line">Anna 20000322</span><br><span class="line">ChrisTim 19731225</span><br><span class="line">Qiang 19990103</span><br><span class="line">Sue 20160505</span><br><span class="line">Paul 19850428</span><br><span class="line">Steve 00000000</span><br></pre></td></tr></table></figure>
<h5 id="处理多个文件显示行号"><a href="#处理多个文件显示行号" class="headerlink" title="处理多个文件显示行号"></a>处理多个文件显示行号</h5><p>若我们想对多个文件使用 <code>awk</code> 进行处理并输出每一行的行号，<code>awk</code> 会将所有文件放在一起显示行号，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v FS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print NR,$1&#125;&#x27;</span> passwd awk1 </span><br><span class="line">1 root</span><br><span class="line">2 daemon</span><br><span class="line">3 bin</span><br><span class="line">4 sys</span><br><span class="line">5 <span class="built_in">sync</span></span><br><span class="line">6 games</span><br><span class="line">7 root</span><br><span class="line">8 lp</span><br><span class="line">9 root</span><br><span class="line">10 news</span><br><span class="line">11 Cherry 25 19990101</span><br><span class="line">12 James 35 19850422</span><br><span class="line">13 Anna 22 20000322</span><br><span class="line">14 ChrisTim 48 19731225</span><br><span class="line">15 Qiang 23 19990103</span><br><span class="line">16 Sue 6 20160505</span><br><span class="line">17 Paul 37 19850428</span><br><span class="line">18 Steve 0 00000000</span><br></pre></td></tr></table></figure>
<p>但是我们希望对每个文件分别打印行号，则可以将变量 <code>NR</code> 改为 <code>FNR</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v FS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print FNR,$1&#125;&#x27;</span> passwd awk1</span><br><span class="line">1 root</span><br><span class="line">2 daemon</span><br><span class="line">3 bin</span><br><span class="line">4 sys</span><br><span class="line">5 <span class="built_in">sync</span></span><br><span class="line">6 games</span><br><span class="line">7 root</span><br><span class="line">8 lp</span><br><span class="line">9 root</span><br><span class="line">10 news</span><br><span class="line">1 Cherry 25 19990101</span><br><span class="line">2 James 35 19850422</span><br><span class="line">3 Anna 22 20000322</span><br><span class="line">4 ChrisTim 48 19731225</span><br><span class="line">5 Qiang 23 19990103</span><br><span class="line">6 Sue 6 20160505</span><br><span class="line">7 Paul 37 19850428</span><br><span class="line">8 Steve 0 00000000</span><br></pre></td></tr></table></figure>
<h5 id="RS-和-ORS"><a href="#RS-和-ORS" class="headerlink" title="RS 和 ORS"></a>RS 和 ORS</h5><p>我们看这个文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;&#123;print NR,$1&#125;&#x27;</span> awk1 </span><br><span class="line">1 Cherry</span><br><span class="line">2 James</span><br><span class="line">3 Anna</span><br><span class="line">4 ChrisTim</span><br><span class="line">5 Qiang</span><br><span class="line">6 Sue</span><br><span class="line">7 Paul</span><br><span class="line">8 Steve</span><br></pre></td></tr></table></figure>
<p>这个文件一共有 8 行，默认是以换行符为每一行的分隔，若我们要修改其默认的输入换行符，则可以修改参数 <code>RS</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v RS=<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print NR,$0&#125;&#x27;</span> awk1</span><br><span class="line">1 Cherry</span><br><span class="line">2 25</span><br><span class="line">3 19990101</span><br><span class="line">James</span><br><span class="line">4 35</span><br><span class="line">5 19850422</span><br><span class="line">Anna</span><br><span class="line">6 22</span><br><span class="line">7 20000322</span><br><span class="line">ChrisTim</span><br><span class="line">8 48</span><br><span class="line">9 19731225</span><br><span class="line">Qiang</span><br><span class="line">10 23</span><br><span class="line">11 19990103</span><br><span class="line">Sue</span><br><span class="line">12 6</span><br><span class="line">13 20160505</span><br><span class="line">Paul</span><br><span class="line">14 37</span><br><span class="line">15 19850428</span><br><span class="line">Steve</span><br><span class="line">16 0</span><br><span class="line">17 00000000</span><br></pre></td></tr></table></figure>
<p>我们看到最终将以空格进行每一行的分隔，而不是换行符。我们还可以修改 <code>ORS</code> 修改默认的输出分隔符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v ORS=<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print NR,$1&#125;&#x27;</span> awk1</span><br><span class="line">1 Cherry 2 James 3 Anna 4 ChrisTim 5 Qiang 6 Sue 7 Paul 8 Steve</span><br></pre></td></tr></table></figure>
<h5 id="FILENAME"><a href="#FILENAME" class="headerlink" title="FILENAME"></a>FILENAME</h5><p>该变量显示正在处理文件的名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;&#123;print FILENAME,$1&#125;&#x27;</span> awk1</span><br><span class="line">awk1 Cherry</span><br><span class="line">awk1 James</span><br><span class="line">awk1 Anna</span><br><span class="line">awk1 ChrisTim</span><br><span class="line">awk1 Qiang</span><br><span class="line">awk1 Sue</span><br><span class="line">awk1 Paul</span><br><span class="line">awk1 Steve</span><br></pre></td></tr></table></figure>
<h5 id="变量-ARGV、ARGC"><a href="#变量-ARGV、ARGC" class="headerlink" title="变量 ARGV、ARGC"></a>变量 ARGV、ARGC</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk <span class="string">&#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;一共有&quot;,ARGC,&quot;个参数&quot;&#125;&#x27;</span> awk1</span><br><span class="line">AWK Start!</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line">一共有 2 个参数</span><br><span class="line"></span><br><span class="line">➜  ~/code/awk awk <span class="string">&#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;第一个awk参数为:&quot;,ARGV[0]&#125;&#x27;</span> awk1</span><br><span class="line">AWK Start!</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line">第一个awk参数为: awk</span><br><span class="line"></span><br><span class="line">➜  ~/code/awk awk <span class="string">&#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;第一个awk参数为:&quot;,ARGV[1]&#125;&#x27;</span> awk1</span><br><span class="line">AWK Start!</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br><span class="line">第一个awk参数为: awk1</span><br></pre></td></tr></table></figure>
<p>我们发现该命令一共有 2 个参数，分别输出为 <code>awk</code> 和 <code>awk1</code>。</p>
<h4 id="1-2-自定义变量"><a href="#1-2-自定义变量" class="headerlink" title="1.2 自定义变量"></a>1.2 自定义变量</h4><h3 id="2-awk-参数"><a href="#2-awk-参数" class="headerlink" title="2. awk 参数"></a>2. awk 参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>指定分割字段符</td>
</tr>
<tr>
<td>-v</td>
<td>定义或修改一个awk内部的变量</td>
</tr>
<tr>
<td>-f</td>
<td>从脚本文件中读取awk命令</td>
</tr>
</tbody>
</table>
</div>
<p>更改分隔符见下一节内容。</p>
<h3 id="3-awk-分隔符"><a href="#3-awk-分隔符" class="headerlink" title="3. awk 分隔符"></a>3. awk 分隔符</h3><p>在 <code>awk</code> 中，默认是以空格进行分隔的，在 <code>sed</code> 命令中，我们要获取网卡 <code>eth0</code> 的 IP 地址信息，采用正则表达式将前后部分删掉来实现。但是我们发现 <code>ifconfig</code> 信息都是用空格进行分隔的，因此在 <code>awk</code> 中，可以利用其特点，直接取出对应行的对应列，从而直接取出 IP 地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk ifconfig eth0 | awk <span class="string">&#x27;NR==2&#123;print $2&#125;&#x27;</span></span><br><span class="line">192.168.202.82</span><br></pre></td></tr></table></figure>
<p><code>awk</code> 的分隔符有两种</p>
<ul>
<li>一种是输入分隔符，默认是空格，叫 <code>field separator</code>，变量名为 <code>FS</code></li>
<li>一种是输出分隔符，<code>output field separator</code>，简称 <code>OFS</code></li>
</ul>
<h4 id="3-1-FS-输入分隔符"><a href="#3-1-FS-输入分隔符" class="headerlink" title="3.1 FS 输入分隔符"></a>3.1 FS 输入分隔符</h4><p><code>awk</code> 逐行处理文本的时候，以输入分割符为准，把文本切成多个片段，默认符号是空格。</p>
<p>例如下面的 <code>passwd</code> 文件，输出其第一列和最后一列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">root:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">root:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> passwd </span><br><span class="line">root /bin/bash</span><br><span class="line">daemon /usr/sbin/nologin</span><br><span class="line">bin /usr/sbin/nologin</span><br><span class="line">sys /usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span> /bin/sync</span><br><span class="line">games /usr/sbin/nologin</span><br><span class="line">root /usr/sbin/nologin</span><br><span class="line">lp /usr/sbin/nologin</span><br><span class="line">root /usr/sbin/nologin</span><br><span class="line">news /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>这里使用了 <code>-F</code> 变量修改了默认分隔符，除了使用这种方法之外，还可以使用变量的形式，指定分隔符，使用 <code>-v</code> 选项搭配，修改 <code>FS</code> 变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v FS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> passwd  </span><br><span class="line">root /bin/bash</span><br><span class="line">daemon /usr/sbin/nologin</span><br><span class="line">bin /usr/sbin/nologin</span><br><span class="line">sys /usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span> /bin/sync</span><br><span class="line">games /usr/sbin/nologin</span><br><span class="line">root /usr/sbin/nologin</span><br><span class="line">lp /usr/sbin/nologin</span><br><span class="line">root /usr/sbin/nologin</span><br><span class="line">news /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<h4 id="3-2-输出分隔符"><a href="#3-2-输出分隔符" class="headerlink" title="3.2 输出分隔符"></a>3.2 输出分隔符</h4><p>上面的例子我们发现，第一列和最后一列之间默认输出是用空格分隔，若我们想自定义该输出分隔符，可以更改 <code>OFS</code> 变量修改默认输出分隔符，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~/code/awk awk -v FS=<span class="string">&#x27;:&#x27;</span> -v OFS=<span class="string">&#x27;==&gt;&#x27;</span> <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> passwd </span><br><span class="line">root==&gt;/bin/bash</span><br><span class="line">daemon==&gt;/usr/sbin/nologin</span><br><span class="line">bin==&gt;/usr/sbin/nologin</span><br><span class="line">sys==&gt;/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>==&gt;/bin/sync</span><br><span class="line">games==&gt;/usr/sbin/nologin</span><br><span class="line">root==&gt;/usr/sbin/nologin</span><br><span class="line">lp==&gt;/usr/sbin/nologin</span><br><span class="line">root==&gt;/usr/sbin/nologin</span><br><span class="line">news==&gt;/usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>这样就修改了默认的输出分隔符。</p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>sed</tag>
        <tag>awk</tag>
        <tag>grep</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/d0edc1ed.html</url>
    <content><![CDATA[<h1 id="Linux常用的命令总结"><a href="#Linux常用的命令总结" class="headerlink" title="Linux常用的命令总结"></a>Linux常用的命令总结</h1><h2 id="1-du"><a href="#1-du" class="headerlink" title="1. du"></a>1. du</h2><p>查看文件大小<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure></p>
<p><code>du</code> 是 <code>disk usage</code> 磁盘使用的缩写，<code>-s</code> 是查看总用量，<code>-h</code> 是以 <code>M</code> 为单位</p>
<p><img src="/d0edc1ed/du%20-sh.png" alt="du"></p>
<h2 id="2-tail"><a href="#2-tail" class="headerlink" title="2. tail"></a>2. tail</h2><p>输出文件的最后若干行内容<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l / | tail -n2</span><br></pre></td></tr></table></figure></p>
<p>表示查看根目录列表的最后两行信息</p>
<h2 id="3-管道"><a href="#3-管道" class="headerlink" title="3. 管道"></a>3. 管道</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stdin | stdout</span><br></pre></td></tr></table></figure>
<p>管道的表示是一条竖杠 <code>|</code>，将竖杠的左边的输出作为右边的输入，<strong>他们是两个程序</strong>。</p>
<p>例如<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --head www.baidu.com | grep -i content-length</span><br></pre></td></tr></table></figure><br>就是将请求百度的 HTTP 报头，传送到 <code>grep</code> 程序中，计算字符个数，最终显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Content-Length: 277</span><br></pre></td></tr></table></figure>
<p>再例如<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --head www.baidu.com | grep -i content-length | cut --delimiter=&#x27; &#x27; -f2</span><br></pre></td></tr></table></figure><br>表示将上述结果以空格进行切分，输出第二个参数，显然最终应该输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">277</span><br></pre></td></tr></table></figure>
<h2 id="4-tee"><a href="#4-tee" class="headerlink" title="4. tee"></a>4. tee</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;welcome ysyx&quot; | tee ysyx.txt</span><br></pre></td></tr></table></figure>
<p>从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。<br>上述命令将字符串 <code>welcome ysyx</code> 输入到 <code>ysyx.txt</code> 文件中，并在命令行中输出该字符串</p>
<p>参数：<br><code>-a</code>： append，not overwrite</p>
<h2 id="5-xdg-open"><a href="#5-xdg-open" class="headerlink" title="5. xdg-open"></a>5. xdg-open</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdg-open &#123;file | URL&#125;</span><br></pre></td></tr></table></figure>
<p>用用户默认的程序打开对应的文件和链接，比如链接就用网页打开，txt文件就用文本编辑器打开等。</p>
<h2 id="6-find"><a href="#6-find" class="headerlink" title="6. find"></a>6. find</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo find /sys -name capacity -exec cat &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p><code>\</code>表转义，在不同的脚本中 <code>;</code> 有不同的含义，因此要转义</p>
<h2 id="7-shell脚本"><a href="#7-shell脚本" class="headerlink" title="7. shell脚本"></a>7. shell脚本</h2><h3 id="创建自定义的命令："><a href="#创建自定义的命令：" class="headerlink" title="创建自定义的命令："></a>创建自定义的命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim mcd.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mcd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source mcd.sh</span><br><span class="line">mcd a/b/c</span><br></pre></td></tr></table></figure>
<ul>
<li>$0 - 脚本名</li>
<li>$1 到 $9 - 脚本的参数。$1 是第一个参数，依此类推</li>
<li>$@ - 所有参数</li>
<li>$# - 参数个数</li>
<li>$? - 前一个命令的返回值</li>
<li>$$ - 当前脚本的进程识别码</li>
<li>!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。</li>
<li>$_ - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 Esc 之后键入 . 来获取这个值。</li>
</ul>
<p>命令通常使用 STDOUT来返回输出值，使用STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生</p>
<h3 id="使用-表明复用上一个执行的命令"><a href="#使用-表明复用上一个执行的命令" class="headerlink" title="使用 !! 表明复用上一个执行的命令"></a>使用 <code>!!</code> 表明复用上一个执行的命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /sys/new</span><br><span class="line">sudo !!</span><br></pre></td></tr></table></figure>
<h3 id="lt-CMD"><a href="#lt-CMD" class="headerlink" title="&lt;(CMD)"></a>&lt;(CMD)</h3><p>进程替换（process substitution）， <code>&lt;(CMD)</code> 会执行 CMD 并将结果输出到一个临时文件中，并将 <code>&lt;(CMD)</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<h3 id="bash脚本编写"><a href="#bash脚本编写" class="headerlink" title="bash脚本编写"></a>bash脚本编写</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # 如果模式没有找到，则grep退出状态为1</span><br><span class="line">    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="shellcheck"><a href="#shellcheck" class="headerlink" title="shellcheck"></a>shellcheck</h3><p>shell脚本分析工具</p>
<h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>能够可视化查看 CPU 占用和内存占用情况，并显示所有进程信息</p>
<h2 id="8-alias"><a href="#8-alias" class="headerlink" title="8. alias"></a>8. alias</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ll=&quot;ls -alh&quot;</span><br></pre></td></tr></table></figure>
<p>该命令将 <code>ll</code> 映射为 <code>ls -alh</code></p>
<p>注意后面的命令 <code>=</code> 前后没有空格，因为它只接收一个参数，加上空格便会解析成多个参数</p>
<p>但是，但是这样的映射在 <code>shell</code> 关闭之后将失效，要想让他们每次都生效，将命令写入 <code>~/.bashrc</code> 中。</p>
<p>例 <code>.bashrc</code>:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias ll=&quot;ls -alh&quot;  //列表显示所有文件，大小以单位显示</span><br><span class="line">alias mv=&quot;mv -i&quot;    //让 mv 操作有提示信息</span><br><span class="line">PS1=&quot;&gt; &quot;            //让 bash 命令行以 &quot;&gt; &quot;开头</span><br></pre></td></tr></table></figure></p>
<h2 id="9-rsync"><a href="#9-rsync" class="headerlink" title="9. rsync"></a>9. rsync</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avP . name@ip:folder</span><br></pre></td></tr></table></figure>
<p><code>rsync</code> 支持断点下载，并保留原文件的权限，是一种比 <code>scp</code> 更有效的拷贝文件的方式</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器配置</title>
    <url>/3472be8b.html</url>
    <content><![CDATA[<h3 id="实验内容介绍"><a href="#实验内容介绍" class="headerlink" title="实验内容介绍"></a>实验内容介绍</h3><p>Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 <code>WAMP(Windows+Apache+MySQL+PHP)</code> 和 <code>LAMP(Linux+Apache+MySQL+PHP)</code>架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。<br>Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。<br>本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。</p>
<span id="more"></span>
<h3 id="卸载系统原有Apache、MySQL、PHP"><a href="#卸载系统原有Apache、MySQL、PHP" class="headerlink" title="卸载系统原有Apache、MySQL、PHP"></a>卸载系统原有Apache、MySQL、PHP</h3><p>sudo apt-get remove apache2<br>sudo apt-get remove mysql-*<br>sudo apt-get remove php</p>
<h3 id="在线安装Apache-服务器"><a href="#在线安装Apache-服务器" class="headerlink" title="在线安装Apache 服务器"></a>在线安装Apache 服务器</h3><p>输入命令：<code>sudo apt-get install apache2</code></p>
<p><img src="/3472be8b/在线安装Apache服务器.png" alt="在线安装Apache服务器"></p>
<p>输入命令：<code>sudo /etc/init.d/apache2 start</code> 手动启动服务</p>
<p><img src="/3472be8b/启动Apache服务.png" alt="启动Apache服务"></p>
<p>以上页面详细介绍了 Debian 发行版 Linux 中 Apache 基本信息，其中：</p>
<p><strong>Apache 根目录：</strong><br><code>/var/www/html</code></p>
<p><strong>Apache 配置目录和文件：</strong><br><code>/etc/apache2</code>: Apache 主配置目录， Apache 所有配置文件均在此目录下；<br><code>/etc/apache2/apache2.conf</code>: 主配置文件，可配置 Apache 全局配置；<br><code>/etc/apache2/ports.conf</code>: 端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。<br>其它文件略。</p>
<p><strong>Apache 日志文件：</strong><br><code>/var/log/apache2/access.log</code>: 服务请求日志<br><code>/var/log/apache2/error.log</code>: 服务错误日志</p>
<p><strong>Apache 基本操作：</strong><br>服务启动：<code>/etc/init.d/apache2 start</code><br>服务停止：<code>/etc/init.d/apache2 stop</code><br>服务重启：<code>/etc/init.d/apache2 restart</code><br>部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。在浏览器找那个输入虚拟机的IP，看到：</p>
<p><img src="/3472be8b/Apache服务启动成功.png" alt="Apache服务启动成功"></p>
<p>说明服务器配置成功！</p>
<h3 id="安装-MySQL-MariaDB"><a href="#安装-MySQL-MariaDB" class="headerlink" title="安装 MySQL/MariaDB"></a>安装 MySQL/MariaDB</h3><p>本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。</p>
<p>安装 MariaDB 服务：<br><code>sudo apt-get install mariadb-server</code><br><code>sudo apt-get install mariadb-client</code></p>
<p><img src="/3472be8b/安装mariadb.png" alt="安装mariadb"></p>
<p><img src="/3472be8b/安装mariadb2.png" alt="安装mariadb2"></p>
<h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><h5 id="首先就是提示没有mariadb-server软件包，类似于这样"><a href="#首先就是提示没有mariadb-server软件包，类似于这样" class="headerlink" title="首先就是提示没有mariadb-server软件包，类似于这样"></a>首先就是提示没有<code>mariadb-server</code>软件包，类似于这样</h5><p><img src="/3472be8b/提示没有mariadb软件包.png" alt="提示没有mariadb软件包"></p>
<p>这个可能是apt版本不够，需要执行<code>sudo apt-get update</code> 进行更新，但是更新实在太慢，我更新了33分钟才更新好，这时候已经快下课了。</p>
<p><img src="/3472be8b/apt-get-update.png" alt="apt-get-update"></p>
<h5 id="然后就是出现域名无法解析的错误"><a href="#然后就是出现域名无法解析的错误" class="headerlink" title="然后就是出现域名无法解析的错误"></a>然后就是出现域名无法解析的错误</h5><p>这个错误困扰了我好久，按照网上的方法试了很多，但是还是不行。最后发现是<code>/etc/network/interfaces</code>文件中网关写错了，写成了<code>192.168.1.0</code>，正确的应该是<code>192.168.1.1</code><br>然后修改<code>/etc/resolv.conf</code>文件，增加字段：<code>nameserver 8.8.8.8（好像是谷歌的DNS服务器）</code>，然后执行<code>ifdown -a</code>关闭网卡，<code>ifup -a</code>启动网卡，然后就可以了。</p>
<p>至于为什么会出现DNS解析错误，一开始我的虚拟机的网络是用的NAT（虚拟地址转换），在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。在NAT模式下，宿主计算机相当于一台开启了DHCP功能的路由器，而虚拟机则是内网中的一台真实主机，通过路由器(宿主计算机)DHCP动态获得网络参数。因此在NAT模式下，虚拟机可以访问外部网络，反之则不行，因为虚拟机属于内网。</p>
<p>而改成了桥接模式后，虚拟机和宿主计算机处于同等地位（同处一个局域网），虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。<br>但是修改<code>/etc/resolv.conf</code>，重启过后就没有了，我们需要安装<code>resolvconfig</code>应用组件：<code>sudo apt-get install resolvconf</code>，在<code>/etc/resolvconf/resolv.conf.d/base</code>文件中添加DNS信息<code>（nameserver 8.8.8.8）</code>，就可以了。</p>
<p>然后再次重新启动，刚刚的问题解决！</p>
<p><img src="/3472be8b/resolvconfig应用.png" alt="resolvconfig应用"></p>
<p><img src="/3472be8b/apt-get更新成功.png" alt="apt-get更新成功"></p>
<p><strong>配置 Mariadb 的安全选项:</strong><br><code>sudo mysql_secure_installation</code></p>
<p>此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认：</p>
<ol>
<li>Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)；</li>
<li>Set root password? [Y/n] 回车，默认为输入 Y；</li>
<li>New password: 输入新密码；</li>
<li>Re-enter new password 确认密码；</li>
<li>Remove anonymous users? [Y/n] 移除匿名用户；</li>
<li>Disallow root login remotely? [Y/n] 禁止 root 远程登录；</li>
<li>Remove test database and access to it? [Y/n] 移除测试数据库；</li>
<li>Reload privilege tables now? [Y/n] 重新加载权限表。</li>
</ol>
<p><strong>测试数据库:</strong><br>如图所示，若进入数据库则表示数据库安装成功，<code>sudo mysql -u root -p</code></p>
<p><img src="/3472be8b/MySQL.png" alt="MySQL"></p>
<h3 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h3><p>安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.2 版本，对应扩展包可通过以下命令模糊查询：<br><code>sudo apt-cache search php7</code><br>从查询结果可知，php7.3对应Apache、MySQL扩展包分别为 ：<code>libapahe2-mod-php7.2，php7.2-mysql</code>.如下图所示为安装 PHP 相关软件包。<br><code>sudo apt-get install php7.2 libapahe2-mod-php7.2 php7.2-mysql
PHP</code> 安装完毕后需重启 Apache</p>
<h3 id="测试PHP页面"><a href="#测试PHP页面" class="headerlink" title="测试PHP页面"></a>测试PHP页面</h3><p>编辑测试文件，如下图所示，在 <code>/var/www/html</code> 目录下新建 <code>test.php</code> 文件，并输入如下所示的测试代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器中访问如下：</p>
<p><img src="/3472be8b/安装PHP.png" alt="安装PHP"></p>
<p><strong>注意：我修改了Apache的端口为8080，因此访问时要在URL后面加上8080端口。</strong></p>
<h3 id="创建文件上传页面"><a href="#创建文件上传页面" class="headerlink" title="创建文件上传页面"></a>创建文件上传页面</h3><p>文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在根目录下创建<code>upload.html</code>文件，编辑表单</p>
<p><img src="/3472be8b/upload.html.png" alt="upload.html"></p>
<p>在根目录下创建 <code>upload.php</code> 脚本文件，编写文件上传功能代码：</p>
<p><img src="/3472be8b/upload.php.png" alt="upload.php"></p>
<p>在根目录下创建“upload”目录，用于保存上传的图片<br>然后访问<code>192.168.1.120:8080/upload.html</code></p>
<p><img src="/3472be8b/访问html.png" alt="访问html"></p>
<p>选择一个不超过200K的图片文件：</p>
<p><img src="/3472be8b/链接php.png" alt="链接php"></p>
<p>先修改upload文件夹的权限，上传之后查看服务器中upload文件夹：</p>
<p><img src="/3472be8b/upload文件夹.png" alt="upload文件夹"></p>
<p>或者查看Apache的属主：<code>ps -ef | grep apache</code>，发现是<code>www-data</code></p>
<p><img src="/3472be8b/Apache属主.png" alt="Apache属主"></p>
<p>然后更改修改目录的所有者：</p>
<p><img src="/3472be8b/chown更改属主.png" alt="chown更改属主"></p>
<p>结果和上述一样，大功告成！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile的简单使用</title>
    <url>/31dce7e5.html</url>
    <content><![CDATA[<h2 id="Makefile-的简单使用"><a href="#Makefile-的简单使用" class="headerlink" title="Makefile 的简单使用"></a>Makefile 的简单使用</h2><blockquote>
<p>makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。</p>
</blockquote>
<span id="more"></span>
<h3 id="一、环境及样例源代码"><a href="#一、环境及样例源代码" class="headerlink" title="一、环境及样例源代码"></a>一、环境及样例源代码</h3><p>本机环境： MacBook M1<br>测试用源代码：</p>
<ul>
<li>main.cpp</li>
<li>print.cpp</li>
<li>add.cpp</li>
<li>func.h</li>
<li>makefile</li>
</ul>
<p><strong>main.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printHappyNewYear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_one</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>print.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Happy New Year!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>add.cpp</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>func.h</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _FUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="二、编译方式"><a href="#二、编译方式" class="headerlink" title="二、编译方式"></a>二、编译方式</h3><h4 id="2-1-手动编译"><a href="#2-1-手动编译" class="headerlink" title="2.1 手动编译"></a>2.1 手动编译</h4><p>这种方式很简单，直接输入下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp add.cpp print.cpp -o main</span><br></pre></td></tr></table></figure>
<p>但这种显然不是我们想要的。</p>
<h4 id="2-2-makefile-脚本编译"><a href="#2-2-makefile-脚本编译" class="headerlink" title="2.2 makefile 脚本编译"></a>2.2 makefile 脚本编译</h4><p>如果我们只让他编译但是不链接，可以使用 <code>-c</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -c</span><br></pre></td></tr></table></figure>
<p>结果可以看到生成一个 <code>main.o</code> 文件，<code>.o</code> 文件便是 Unix 下的中间目标文件（Objective File）</p>
<p>然后我们逐个编译每个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ add.cpp -c</span><br><span class="line">g++ print.cpp -c</span><br></pre></td></tr></table></figure>
<p>然后将所有 <code>.o</code> 文件链接到一起，生成可执行文件 <code>main</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure>
<p>当我们只修改某个源文件时，只需要单独编译某个文件而不需要重新编译所有文件。最后重新链接即可。但是当源文件太多的时候，这样也是不方便的，于是使用 makefile 脚本实现自动化。</p>
<h4 id="Makefile（Version-1）"><a href="#Makefile（Version-1）" class="headerlink" title="Makefile（Version 1）"></a>Makefile（Version 1）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## VERSION 1</span></span><br><span class="line">main: main.cpp print.cpp add.cpp</span><br><span class="line">	@g++ main.cpp add.cpp print.cpp -o main</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	<span class="built_in">rm</span> *.o main</span><br></pre></td></tr></table></figure>
<p>语法格式：main 这个文件依赖于后面的三个 cpp 文件，下一行的命令前面必须是一个 tab，否则语法错误。</p>
<p>运行 <code>make</code> 运行 <code>makefile</code> 脚本，或 <code>make -f Makefile</code> 根据指定文件名运行脚本。</p>
<p>首先脚本先去找 main，如果 main 不存在，则尝试生成 main。若已经生成了 main，则根据后面的依赖项判断该 main 是不是最新的，若不是最新的，则重新生成，否则不做任何操作。</p>
<p>第一个版本的缺点是若源文件太多，则命令显得很冗长。</p>
<h4 id="Makefile（Version-2）"><a href="#Makefile（Version-2）" class="headerlink" title="Makefile（Version 2）"></a>Makefile（Version 2）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) $(OBJ) -o $(TARGET)</span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line">	$(CXX) -c main.cpp</span><br><span class="line">print.o: print.cpp</span><br><span class="line">	$(CXX) -c print.cpp</span><br><span class="line">add.o: add.cpp</span><br><span class="line">	$(CXX) -c add.cpp</span><br></pre></td></tr></table></figure>
<p>第二个版本中使用了 <code>CXX</code>，<code>TARGET</code>，<code>OBJ</code> 变量，依次查找依赖，只编译已经修改过的文件，而不会编译所有文件。</p>
<h4 id="Makefile（Version-3）"><a href="#Makefile（Version-3）" class="headerlink" title="Makefile（Version 3）"></a>Makefile（Version 3）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">	$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	<span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>符号说明：</p>
<p><code>$@</code>: 目标文件，<code>$^</code>: 所有的依赖文件，<code>$&lt;</code>: 第一个依赖文件</p>
<p><code>.PHONY</code> 表示的意思：若在该目录下有一个名叫 <code>clean</code> 的文件，那么脚本便无需生成该文件，也就不会执行相应的命令，但是这跟我们期望的不一致。加上 <code>.PHONY</code> 之后，依赖 <code>clean</code>，因此就会去执行 <code>clean</code>。</p>
<p><code>.PHONY</code> 是一个伪目标，可以有效防止在 Makefile 文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突的问题。</p>
<p>第三个版本中，若将来有其他新的源文件加入之后，只需要在 <code>OBJ</code> 变量后面加入新的源文件即可。</p>
<h4 id="Makefile（Version-4）"><a href="#Makefile（Version-4）" class="headerlink" title="Makefile（Version 4）"></a>Makefile（Version 4）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">SRC = $(wildcard *.cpp)</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o, $(SRC))</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">	$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">	$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	<span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure>
<p>在 Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code>，它的用法是：<code>$(wildcard PATTERN...)</code></p>
<p><code>wildcard</code>: 扩展通配符<br><code>patsubst</code>：替换通配符<br><code>notdir</code>：去除路径</p>
<p><code>SRC = $(wildcard *.cpp)</code> 表示获得工作目录下所有 <code>.cpp</code> 文件并生成列表 <code>SRC</code>。<br><code>OBJ = $(patsubst %.cpp, %.o, $(SRC))</code> 表示将所有 <code>.cpp</code> 后缀替换为 <code>.o</code> 并生成文件列表 <code>OBJ</code>。</p>
<p>这样下来，makefile 文件就相对比较智能化了，新增加文件之后也无需修改脚本了，</p>
<p>总之，脚本使你越懒惰，这个脚本的功能就越强大。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust中Clap库的使用</title>
    <url>/8ce3ab1f.html</url>
    <content><![CDATA[<h1 id="Clap-库的使用"><a href="#Clap-库的使用" class="headerlink" title="Clap 库的使用"></a>Clap 库的使用</h1><blockquote>
<p>Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、版权及说明"><a href="#一、版权及说明" class="headerlink" title="一、版权及说明"></a>一、版权及说明</h2><p>该文参考了 Rust 语言中文社区的 <a href="https://rustcc.cn/article?id=921ad2c0-09af-4271-ae62-4b21ce281a2b">每周一库</a>，同时参考了官方 <a href="https://crates.io/crates/clap">crate</a> 以及 <a href="https://docs.rs/clap/latest/clap/">clap 官方文档</a> 的用例及介绍</p>
<p>对于命令行解析使用最多的库，可以在 <a href="https://crates.io">crates.io</a> 首页搜索关键词 Command Line，下载量最多的库便是 clap</p>
<h2 id="二、关于命令行解析"><a href="#二、关于命令行解析" class="headerlink" title="二、关于命令行解析"></a>二、关于命令行解析</h2><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>clap 用于解析并验证用户在运行命令行程序时提供的命令行参数字符串。 你所需要做的只是提供有效参数的列表，clap 会自动处理其余的繁杂工作。 这样工程师可以把时间和精力放在实现程序功能上，而不是参数的解析和验证上。</p>
<p>当 clap 解析了用户提供的参数字符串，它就会返回匹配项以及任何适用的值。 如果用户输入了错误或错字，clap 会通知他们错误并退出（或返回 Result 类型，并允许您在退出前执行任何清理操作）。这样，工程师可以在代码中对参数的有效性做出合理的假设。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA Basic 部分题解</title>
    <url>/a74ee18.html</url>
    <content><![CDATA[<!-- toc -->
<span id="more"></span>
<h1 id="1025-反转链表"><a href="#1025-反转链表" class="headerlink" title="1025. 反转链表"></a>1025. 反转链表</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805296180871168">题目链接</a><br><img src="/a74ee18/1025%20反转链表.png" alt="1025 反转链表"></p>
<p>这个题目第一眼看上去不知道怎么处理链表结点的地址，以及不知道如何用简便的方法将链表反转过来，如果用常规的设置链表的结构体来逆置链表，会比较麻烦。而且输入的结点并不是按照链表顺序给出的，并且地址是人为设定的，因此用结构体的方法会非常麻烦，因此考虑用数组来存储链表相关地址信息和顺序关系。</p>
<p>并且，翻转链表可以使用algorithm头文件中的reverse函数，会非常简便。</p>
<p>要注意输入的结点可能是一个完整的链表，他可以从中间断开，此时我们只要找到以头结点开始的那个链表就可以了。</p>
<p>完整代码参考了柳婼的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> first, n, k, temp;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">100005</span>], next[<span class="number">100005</span>], list[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(list, <span class="number">0</span>, <span class="built_in">sizeof</span>(list));</span><br><span class="line">    <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">    cin &gt;&gt; first &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        cin &gt;&gt; data[temp];</span><br><span class="line">        cin &gt;&gt; next[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;  <span class="comment">//除去断开的链表，获得完整的链表长度</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="number">-1</span>) &#123;</span><br><span class="line">        list[sum++] = first;</span><br><span class="line">        first = next[first];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= sum; i += k) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">begin</span>(list) + i, <span class="built_in">begin</span>(list) + i + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, list[i], data[list[i]], list[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//注意这里是list[i + 1],一开始写成了next[list[i]]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, list[sum - <span class="number">1</span>], data[list[sum - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1035-插入与归并"><a href="#1035-插入与归并" class="headerlink" title="1035. 插入与归并"></a>1035. 插入与归并</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805286714327040">题目链接</a><br><img src="/a74ee18/1035%20插入与归并.png" alt="插入与归并"></p>
<p>分析：先将 <code>i</code> 指向中间序列列中满⾜足从左到右是从⼩小到⼤大顺序的最后⼀一个下标，再将 <code>j</code> 指向从 <code>i+1</code> 开始，第一个不不满⾜足 <code>a[j] == b[j]</code> 的下标，如果 <code>j</code> 顺利利到达了了下标<code>n</code>，说明是插⼊入排序，再下⼀一次的序列列是 <code>sort(a, a+i+2);</code>否则说明是归并排序。归并排序就别考虑中间序列列了了，直接对原来的序列列进⾏行行模拟归并时候的归并过程，<code>i</code> 从<code>0</code> 到 <code>n/k</code>，每次一段段得 <code>sort(a + i * k, a + (i + 1) * k);</code> 最后别忘记还有最后剩余部分的 <code>sort(a + n / k * k, a + n);</code> 这样是一次归并的过程。直到有一次发现<code>a</code>的顺序和<code>b</code>的顺序相同，则再归并一次，然后退出循环</p>
<p><strong>AC代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">105</span>], b[<span class="number">105</span>], n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        cin &gt;&gt; b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; b[i] &lt;= b[i + <span class="number">1</span>]; i++);</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n &amp;&amp; a[j] == b[j]; j++);</span><br><span class="line">    <span class="type">int</span> pow = <span class="number">2</span>, flag = <span class="number">0</span>;  <span class="comment">//标记当前趟是否为目标趟</span></span><br><span class="line">    <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Insertion Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + i + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Merge Sort&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n / pow; i++) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(a + i * pow, a + (i + <span class="number">1</span>) * pow);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(a + (n / pow) * pow, a + n);</span><br><span class="line">            <span class="comment">//比较当前趟是否为目标趟</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pow *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n / pow; i++) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(a + i * pow, a + (i + <span class="number">1</span>) * pow);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + (n / pow) * pow, a + n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1040-有几个PAT（25-逻辑题"><a href="#1040-有几个PAT（25-逻辑题" class="headerlink" title="1040. 有几个PAT（25) [逻辑题]"></a>1040. 有几个PAT（25) [逻辑题]</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805282389999616">题目链接</a><br><img src="/a74ee18/1040%20有几个PAT.png" alt="有几个PAT"></p>
<p>这是一道思维题，要想知道构成多少个PAT，那么遍历字符串串后对于每一A，它前⾯面的P的个数和它后⾯面的T的个数的乘积就是能构成的PAT的个数。然后把对于每一个A的结果相加即可。只需要先遍历字符串串数一数有多少个T，然后每遇到一个T，便countT–-;每遇到一个P呢， countP++;然后一遇到字⺟母A呢就countT * countP，把这个结果累加到result中～～最后输出结果就好啦~~对了了别忘记要对10000000007取余哦～～</p>
<p>穷举遍历显然会超时～～</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="type">int</span> countP = <span class="number">0</span>, countA = <span class="number">0</span>, countT = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>) countT++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>) countT--;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;P&#x27;</span>) countP++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            res += countP * countT % M;</span><br><span class="line">            res %= M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res % M &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//033510010</span></span><br></pre></td></tr></table></figure>
<h1 id="1045-快速排序（25）"><a href="#1045-快速排序（25）" class="headerlink" title="1045. 快速排序（25）"></a>1045. 快速排序（25）</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192">题目链接</a><br><img src="/a74ee18/1045%20快速排序.png" alt="快速排序"></p>
<p>分析：先看数据规模，1e5，如果用穷举，平方之后就是1e10，肯定超时，于是要想其他方法。<br>对原序列sort排序，逐个比较，当当前元素没有变化并且它左边的所有值的最大值都比它小的时候就可以认为它一定是主元（证明正确性：因为无论如何当前这个数要满足左边都比他大右边都比他小，那它的排名【当前数在序列中处在第几个，也就是相对位置】一定不会变）</p>
<p>一开始测试点 2 段错误，后来才想到如果没有主元存在的话，v[0]非法访问，改正后发现格式错误，然后加了句换行才正确。</p>
<p><code>AC</code>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, cnt = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100005</span>], b[<span class="number">100005</span>];</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(b, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i] &amp;&amp; b[i] &gt; max) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; max) &#123;</span><br><span class="line">            max = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v[v.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1049-数列的片段和-20"><a href="#1049-数列的片段和-20" class="headerlink" title="1049 数列的片段和 (20)"></a>1049 数列的片段和 (20)</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805275792359424">题目链接</a><br><img src="/a74ee18/1049%20数列的片段和.png" alt="数列的片段和"></p>
<p>总结 <code>printf()</code> 和 <code>scanf()</code> 函数：如果输入的是 <code>float</code> 型数据,那么用 <code>%f</code> 来接收；如果输入的是 <code>double</code> 型数据，那么用 <code>%lf</code> 来接收；如果输入的是 <code>long double</code> 型数据，那么用 <code>%llf</code> 来接收。<br>但后来这道题的测试点 2 数据进行了更精细地改动，大概是将 N 改为 10 的 5 次方，此时会用 double 类型数据进行大量的计算，而由于数组中的每个数都小于 1.0，因此很有可能出现 double 小数精度不够用的情况而导致精度丢失，这时候计算出来的结果有可能会有偏差了。</p>
<p>查阅资料后得出以下两种方法：</p>
<ol>
<li>对每个输入的数据都先乘1000（只能乘以1000，可能乘多了就会导致整数部分精度丢失了，可以把这个结果想象成 63 位的队列，队接近队头部分是整数，接近队尾部分是小数，那么小数位数多了就会从队尾“丢出”丢失了的精度，整数位数多了就会从队头“丢出”丢失了的精度），这样就降低了小数位数，最后再对累加的结果除以之前乘的数字即可。</li>
<li>这个方法就更简单了，每当我们用 <code>int</code> 型发现范围不够的时候会怎么办？难道会先去把这个数除以 1000，再把最后的结果乘以之前除掉的数字吗？当然不会，一般都是把 <code>int</code> 类型改成 <code>long long</code> 类型（为啥不是 <code>long</code> 类型，而是 <code>long long</code> 类型呢，这就涉及到另一个需要记忆的内容了：因为 <code>long int、long、int</code> 这三者都是 4 字节的，一样长，想不到吧？）说了那么多没有用。。。正解就是把 <code>total</code> 的类型改成 <code>long double</code> 就行了，这时候 <code>total</code> 的小数精度范围更大，就能完美解决测试点 2 出现的精度丢失问题。</li>
<li><code>double</code> 类型占8字节，用 <code>%lf</code> 或 <code>%f</code> 控制输出，<code>long double</code> 一般占 12 字节用 <code>%Le %Lf %Lg</code> 控制输出</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a[<span class="number">100005</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        c[i] = (<span class="type">long</span> <span class="type">long</span>)i * (n - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum += a[i] * <span class="number">1000</span> * c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2Lf&quot;</span>, sum / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1095-解码PAT准考证-25"><a href="#1095-解码PAT准考证-25" class="headerlink" title="1095 解码PAT准考证 (25)"></a>1095 解码PAT准考证 (25)</h1><p>纯模拟题，细心即可<br>[注]：<code>ios::sync_with_stdio(0);</code>可以加速 <code>cin</code> 和 <code>cout</code> 的输入输出速度，还有 <code>cin.tie(0);</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PAT</span> &#123;</span><br><span class="line">    string NUM, room, date, stuNum;</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="built_in">PAT</span>(string _NUM, <span class="type">int</span> _score) : <span class="built_in">NUM</span>(_NUM), <span class="built_in">score</span>(_score) &#123;</span><br><span class="line">        level = _NUM[<span class="number">0</span>];</span><br><span class="line">        room = _NUM.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        date = _NUM.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        stuNum = _NUM.<span class="built_in">substr</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;PAT&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(PAT a, PAT b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score == b.score) <span class="keyword">return</span> a.NUM &lt; b.NUM;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_score</span><span class="params">(<span class="type">int</span> cases, <span class="type">int</span> type, <span class="type">char</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %c\n&quot;</span>, cases, type, level);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].level == level) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, p[i].NUM.<span class="built_in">c_str</span>(), p[i].score);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_room</span><span class="params">(<span class="type">int</span> cases, <span class="type">int</span> type, string room)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>, cases, type, room.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].room == room) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum += p[i].score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_date</span><span class="params">(<span class="type">int</span> cases, <span class="type">int</span> type, string date)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>, cases, type, date.<span class="built_in">c_str</span>());</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].date == date) &#123;</span><br><span class="line">            m[p[i].room]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; <span class="built_in">room_order</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(room_order.<span class="built_in">begin</span>(), room_order.<span class="built_in">end</span>(), [=](pair&lt;string, <span class="type">int</span>&gt; p1, pair&lt;string, <span class="type">int</span>&gt; p2) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.second == p2.second) <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (room_order.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; room_order.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, room_order[i].first.<span class="built_in">c_str</span>(), room_order[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; score;</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">PAT</span>(s, score));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    string room, date;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; type;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cin &gt;&gt; c;</span><br><span class="line">                <span class="built_in">print_score</span>(i + <span class="number">1</span>, type, c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cin &gt;&gt; room;</span><br><span class="line">                <span class="built_in">print_room</span>(i + <span class="number">1</span>, type, room);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cin &gt;&gt; date;</span><br><span class="line">                <span class="built_in">print_date</span>(i + <span class="number">1</span>, type, date);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1099-性感素数-20"><a href="#1099-性感素数-20" class="headerlink" title="1099 性感素数 (20)"></a>1099 性感素数 (20)</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/1478633879405998080">题目链接</a></p>
<p>这题的主要问题是当给定的数不是 Sexy Prime 时，要找比他大的最小符合条件的数，可以与比他小 6 的组成一对，并不一定是比他大 6 的数组成一对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPrime</span>(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(n - <span class="number">6</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; n - <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(n + <span class="number">6</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; n + <span class="number">6</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i) &amp;&amp; <span class="built_in">isPrime</span>(i + <span class="number">6</span>) || <span class="built_in">isPrime</span>(i) &amp;&amp; <span class="built_in">isPrime</span>(i - <span class="number">6</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Judge</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1100-校庆-20"><a href="#1100-校庆-20" class="headerlink" title="1100 校庆 (20)"></a>1100 校庆 (20)</h1><p>这题问题还是超时，用 map 进行查找可以将数量级压缩在 O(n).</p>
<h1 id="1104-天长地久-20"><a href="#1104-天长地久-20" class="headerlink" title="1104 天长地久 (20)"></a>1104 天长地久 (20)</h1><p>这题主要就是要注意超时问题，可以推出来末尾一定是 99（我感觉题目“天长地久”已经有暗示了），然后在末尾 99 的基础上每次加 100 就行了，这样循环数量级变成 1e7，就不会超时了。</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>上机</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（七）：生命周期</title>
    <url>/3e05ea36.html</url>
    <content><![CDATA[<h1 id="Rust入门教程（七）：生命周期"><a href="#Rust入门教程（七）：生命周期" class="headerlink" title="Rust入门教程（七）：生命周期"></a>Rust入门教程（七）：生命周期</h1><blockquote>
<p>Rust 生命周期机制是与所有权机制同等重要的资源管理机制。生命周期，简而言之就是引用的有效作用域，之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算，但引用往往导致极其复杂的资源管理问题。</p>
</blockquote>
<span id="more"></span>
<p>[toc]</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>Rust 的每个引用都有自己的生命周期</li>
<li>生命周期：引用保持有效的作用域</li>
<li>大多数情况：生命周期是隐式的、可被推断的</li>
<li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</li>
</ul>
<p>生命周期的主要目标：避免悬垂引用（dangling reference）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码会在 <code>r = &amp;x;</code> 处报错，因为当打印 <code>r</code> 的值的时候，<code>x</code> 已经离开了他的作用域，这时 <code>r</code> 指向的 <code>x</code> 的内存已经被释放，因此会报错。</p>
<p>Rust 实际上是通过<strong>借用检查器</strong>来检查一些变量的生命周期。</p>
<h3 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h3><p>Rust 编译器的借用检查器（borrow checker），用来比较作用域来判断所有的借用是否合法</p>
<p>在上例中，借用检查器检测到 <code>r</code> 的生命周期大于 <code>x</code>，即被引用者的生命周期小于引用者的生命周期，因此编译会报错。</p>
<h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/life_cycle git:(master) ✗ cargo run           </span><br><span class="line">   Compiling life_cycle v0.<span class="number">1.0</span> (/home/cherry/Code/rust/life_cycle)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">24</span>:<span class="number">33</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">24</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">   |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line"><span class="number">24</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br></pre></td></tr></table></figure>
<p>我们发现编译器会提示<strong>缺少一个命名的生命周期参数</strong>，这个函数返回一个借用的值，但是没有声明这个借用的值是来自 <code>x</code> 还是来自 <code>y</code>。值得说明的是，这个返回值的借用跟函数体的逻辑没有关系，要从函数签名就要看出返回值借用的值来自哪一个参数。</p>
<p>根据编译器提示，我们声明一个泛型生命周期 <code>&#39;a</code>，代码修改如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h3><ul>
<li>生命周期的标注不会改变引用的生命周期长度</li>
<li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li>
<li>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期</li>
</ul>
<p>生命周期参数名语法如下：</p>
<ul>
<li>以 <code>&#39;</code> 开头</li>
<li>通常全小写且非常短</li>
<li>习惯以 <code>&#39;a</code> 表示</li>
</ul>
<p>生命周期标注的位置：</p>
<ul>
<li>在引用符号 <code>&amp;</code> 后面标注</li>
<li>使用空格将标注和引用类型区分开</li>
</ul>
<p>生命周期标注的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，单个生命周期标注本身没有意义，我们再看上面的 <code>longest</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型的生命周期参数声明在函数名和参数列表之间的 <code>&lt;&gt;</code> 中。</p>
<p>我们仔细分析这个函数：</p>
<p><code>longest</code> 函数的两个参数都声明了生命周期，就要求这两个引用必须和泛型的生命周期存活相同的时间，而且函数所返回的字符串切片的存活时长也不能小于 <code>&#39;a</code> 这个生命周期。为引用指明生命周期，是要确保当引用失去了所有权后而被移出内存。当在函数参数中指明生命周期时，我们并没有改变参数和返回值的生命周期，只是向调用检查器指出了一些可用于检查非法调用的约束。而 <code>longest</code> 函数本身并不需要知道参数 <code>x</code> 和 <code>y</code> 具体的存活时长，只需要某个可以代替 <code>&#39;a</code> 的作用域，同时满足函数的签名约束。实际上，若函数引用其外部的代码或者被外部代码引用，只靠 rust 本身确定参数和返回值的生命周期时不可能的，这样的话，函数所使用的生命周期在每次调用中都会发生变化，正因为如此，我们才需要手动对生命周期进行标注。</p>
<p>当我们将两个引用传入函数时，<code>x</code> 和 <code>y</code> 作用域重叠的部分将用来代替 <code>&#39;a</code> 这个生命周期的作用域，换句话说，这个泛型生命周期得到的具体的生命周期就是 <code>x</code> 和 <code>y</code> 两者生命周期较短的那个，因为返回值也标注了相同的生命周期，因此返回值的引用在两者比较短的生命周期内都是有效的。</p>
<p>那么生命周期标注是如何对 <code>longest</code> 函数进行限制的？我么修改一下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 string1 下面三行代码放到一个单独的作用域里，string2 是一个字符串字面值（字符串切片），他的生命周期相当于是一个静态的生命周期，在整个程序运行期间都存活，而 result 引用也会在 Line 7 大括号结束之前保持有效，因此代码不会报错。</p>
<p>【注】：<code>&amp;str</code> 是直接在可执行文件中加载的，即这块内存直接放到可执行文件里面的，所以整个程序运行期间，这块内存比较特殊，不会由于所有权而消失，所以指这块内存的引用，一定会一直指向一个合法内存，所以其引用的生命周期是 <code>&#39;static</code>，也就是全局静态，也不可能出现什么悬垂引用。</p>
<p>再改一下代码，将 result 声明放到外面，然后将 print 也放到外面，将 string2 改成 String 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;fantastic&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 Line 6 报错了。string1 的生命周期为 Line 2~9，string2 的生命周期为 Line 5~7，所以 <code>&#39;a</code> 所表示的生命周期为 Line 5~7，而 result 的生命周期为 Line 3~9，不在 <code>&#39;a</code> 的范围内，因此编译报错，我们来看一下编译具体的错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/life_cycle git:(master) ✗ cargo run</span><br><span class="line">   Compiling life_cycle v0.<span class="number">1.0</span> (/home/cherry/Code/rust/life_cycle)</span><br><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">30</span>:<span class="number">44</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">30</span> |         result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">   |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">31</span> |     &#125;</span><br><span class="line">   |     - `string2` dropped here <span class="keyword">while</span> still borrowed</span><br><span class="line"><span class="number">32</span> |     <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">   |                                          ------ borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0597`.</span><br><span class="line">error: could not compile `life_cycle` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个报错的含义是，为了让 result 这个变量在打印时是有效的，那么 string2 必须在外部作用域结束之前一直保持有效，因为在函数声明中参数和返回值都使用了相同的生命周期。</p>
<p>在上例中，尽管 string1 的长度大于 string2 的长度，函数返回的是 string1 的引用，但是编译器并不知道这一点，编译器只知道 <code>longest</code> 函数返回引用的生命周期是 <code>x</code> 和 <code>y</code> 生命周期比较短的那个。</p>
<h2 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h2><ul>
<li>指定生命周期参数的方式依赖于函数所做的事情，在上面的例子中，若 <code>longest</code> 函数改为：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，函数只返回变量 <code>x</code>，而与 <code>y</code> 无关，因此无需为 <code>y</code> 指定生命周期。</p>
<ul>
<li>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配</li>
<li>如果返回的引用没有指向任何参数，那么他只能引用函数内创建的值<ul>
<li>这就是<strong>悬垂引用</strong>，该值在函数结束时就走出了作用域，见下面的例子</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    res.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>longest</code> 函数中返回了局部变量 <code>res</code>，当函数执行完毕时，局部变量 <code>res</code> 所指向的内存已经被释放掉，因此 <code>test02</code> 中的 <code>result</code> 变量指向的 <code>res</code> 内存已经被清理，这就造成了<strong>悬垂引用</strong>，非常类似于 <code>C/C++</code> 的野指针。</p>
<p>那么我就是想返回函数中的局部变量，应该怎么办呢？解决办法也很简单，就是直接返回这个值而不是返回引用，这样就将变量的所有权移交出去了，如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因此从根本上讲，生命周期这种语法规则，是用来关联函数的不同参数及返回值之间的生命周期，一旦他们取得了某种联系，rust 就会获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其他违反内存安全的行为。</strong></p>
<h2 id="Struct-定义中的生命周期标注"><a href="#Struct-定义中的生命周期标注" class="headerlink" title="Struct 定义中的生命周期标注"></a>Struct 定义中的生命周期标注</h2><p>struct 里可以包括：</p>
<ul>
<li>自持有类型（类似于 i32 等）</li>
<li>引用：需要在每个引用上添加生命周期标注</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Today is Tuesday. And I will take part in a meeting.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Can&#x27;t find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h2><p>每个引用都有生命周期，需要为使用生命周期的函数或 struct 指定生命周期参数</p>
<p>但是下面这个例子，没有任何生命周期的标注，仍然可以通过编译：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> byte.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照原来的 rust 规范，函数声明、参数和返回类型前都是要加上生命周期标注的，但是 rust 团队发现程序员总是一遍又一遍地标注同样的生命周期，而且这些场景是可以预测的，有着明确的模式，因此 rust 团队就将这些模式写入了编译器，使得借用检查器可以自动对这些模式进行推导而无需显式标注。</p>
<p><strong>生命周期省略规则</strong></p>
<ul>
<li>在 Rust 引用分析中所编入的模式称为<strong>生命周期省略规则</strong><ul>
<li>这些规则无需开发者来遵守</li>
<li>它们是一些特殊情况，由编译器来考虑</li>
<li>如果你的代码符合这些情况，那么就无需显式标注生命周期</li>
</ul>
</li>
<li>生命周期省略规则不会提供完整的推断：<ul>
<li>如果应用规则后，引用的生命周期仍然模糊不清→编译错误</li>
<li>解决办法：添加生命周期标注，表明引用间的相互关系</li>
</ul>
</li>
</ul>
<h3 id="输入、输出生命周期"><a href="#输入、输出生命周期" class="headerlink" title="输入、输出生命周期"></a>输入、输出生命周期</h3><p>生命周期在：</p>
<ul>
<li>函数/方法的参数中，叫做输入生命周期</li>
<li>函数/方法的返回值中，叫输出生命周期</li>
</ul>
<h3 id="生命周期省略的三个规则"><a href="#生命周期省略的三个规则" class="headerlink" title="生命周期省略的三个规则"></a>生命周期省略的三个规则</h3><p>编译器使用三个规则在没有显式标注生命周期的情况下，来确定引用的生命周期</p>
<ul>
<li>规则 1 应用于输入生命周期</li>
<li>规则 2、3 应用于输出生命周期</li>
<li>如果编译器应用完三个规则后，仍然无法确定有效的生命周期，则报错</li>
<li>这些规则适用于 fn 和 impl 块</li>
</ul>
<p><strong>规则 1：</strong> 每个引用类型都有自己的生命周期<br><strong>规则 2：</strong> 如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数<br><strong>规则 3：</strong> 如果有多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期会被赋给所有的输出生命周期参数</p>
<p><strong>生命周期省略的三个规则-例子</strong></p>
<p>假设我们是编译器:</p>
<p><code>fn first_word(s: &amp;str) -&gt; &amp;str &#123;&#125;</code><br><code>fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str &#123;&#125;</code><br><code>fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;&#125;</code></p>
<p><code>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;&#125;</code><br><code>fn longest&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str &#123;&#125;</code></p>
<h3 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h3><ul>
<li>在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样</li>
<li>在哪声明和使用生命周期参数，依赖于：<ul>
<li>生命周期参数是否和字段、方法的参数或返回值有关</li>
</ul>
</li>
<li>struct 字段的生命周期名：<ul>
<li>在 impl 后声明</li>
<li>在 struct 名后使用</li>
<li>这些生命周期是 struct 类型的一部分</li>
</ul>
</li>
<li>impl 块内的方法签名中<ul>
<li>引用必须绑定于 struct 字段引用的生命周期，或者引用是独立的也可以</li>
<li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">printSome</span>(&amp;<span class="keyword">self</span>, words: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;There are some words: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.part);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><ul>
<li><code>&#39;static</code> 是一个特殊的生命周期：整个程序的持续时间<ul>
<li>例如：所有的字符串字面值都拥有 <code>&#39;static</code> 生命周期<ul>
<li><code>let s: &amp;&#39;static str = &quot;I have a static lifetime.&quot;;</code></li>
<li>字符串字面值是存在二进制程序中，总是可用</li>
</ul>
</li>
</ul>
</li>
<li>为引用指定 <code>&#39;static</code> 之前要三思<ul>
<li>是否需要引用在整个生命周期内都存活</li>
</ul>
</li>
</ul>
<h3 id="一个泛型参数类型，Trait-Bound-和生命周期的综合例子"><a href="#一个泛型参数类型，Trait-Bound-和生命周期的综合例子" class="headerlink" title="一个泛型参数类型，Trait Bound 和生命周期的综合例子"></a>一个泛型参数类型，Trait Bound 和生命周期的综合例子</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an</span> announcement&lt;<span class="symbol">&#x27;a</span>,T&gt;</span><br><span class="line">    (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> <span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要注意的是，生命周期也是泛型的一种。</strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（一）</title>
    <url>/5c3fd875.html</url>
    <content><![CDATA[<h1 id="Rust入门教程（一）"><a href="#Rust入门教程（一）" class="headerlink" title="Rust入门教程（一）"></a>Rust入门教程（一）</h1><h2 id="Rust基本介绍"><a href="#Rust基本介绍" class="headerlink" title="Rust基本介绍"></a>Rust基本介绍</h2><blockquote>
<p>Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。    ——来自菜鸟教程</p>
<p>高性能 - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。<br>可靠性 - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。<br>生产力 - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息，还集成了一流的工具——包管理器和构建工具，智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</blockquote>
<span id="more"></span>
<p>[toc]</p>
<h2 id="一、变量与可变性"><a href="#一、变量与可变性" class="headerlink" title="一、变量与可变性"></a>一、变量与可变性</h2><p>声明变量用 <code>let</code> 关键字，默认情况下该变量是不可变的(immutable)</p>
<p>声明变量时在前面添加一个 <code>mut</code> 关键字，便可以使得该关键字可以被修改</p>
<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>常量(constant)在绑定值之后也是不可变的，但是它与不可变变量有很多区别：</p>
<ul>
<li>不可以使用 <code>mut</code> 修饰，常量永远都是不可变的</li>
<li>声明常量用 <code>const</code> 关键字，它的类型必须被标注</li>
<li>常量可以在任何作用域内被声明，包括全局作用域</li>
<li>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值</li>
</ul>
<p>在程序运行期间，常量在其声明的作用域内一直有效.</p>
<p>命名规范：Rust 中使用全大写字符，每个单词之间用下划线分隔，例如：<code>MAX_NUM</code>。一个声明的例子：<code>const MAX_NUM: u32 = 100_000</code>。（注：数字中也可以添加下划线增强数字的可读性）</p>
<h3 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h3><p>可以使用相同的名字声明新的变量，新的变量会 <code>Shadowing(隐藏)</code> 之前声明的同名变量。</p>
<p><code>shadow</code> 和把变量标记为 <code>mut</code> 是不一样的：</p>
<ul>
<li>如果不使用 <code>let</code> 关键字，那么重新给非 <code>mut</code> 变量赋值就会编译错误</li>
<li>而使用 <code>let</code> 声明的新变量，也是不可变的</li>
<li>使用 <code>let</code> 声明的同名变量，<strong>类型可以改变</strong></li>
</ul>
<p>例：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = <span class="string">&quot;STRING&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">string</span> = string.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure></p>
<p>这样将字符串提取出他的长度，而不用单独再开一个新的变量。</p>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p><code>Rust</code> 是静态语言，在编译时必须知道所有变量的类型</p>
<ul>
<li>基于使用的值，编译器通常能够推断出他的具体类型</li>
<li>但是如果可能的类型很多，（比如 <code>String</code> 转为整数的 <code>parse</code> 方法）那么就要添加类型的标注，否则会报错</li>
</ul>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>一个标量类型代表一个单独的值</p>
<p>一共有 <strong>整数类型，浮点类型，布尔类型，字符类型</strong> 四种类型</p>
<p><strong>整数类型：</strong></p>
<p>没有小数部分，如 <code>u32</code>，<code>i32</code>，<code>i64</code>等，表格如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
</div>
<p>其中 <code>isize</code> 和 <code>usize</code> 由计算机架构的位数所决定，主要使用场景是对某种集合进行索引操作</p>
<p>除了 <code>byte</code> 类型外，所有数值的字面值都可以加上类型后缀，例如：<code>58u8</code>。其中 <code>Rust</code> 中整数默认值为 <code>i32</code></p>
<p><strong>整数溢出</strong></p>
<p>将一个 <code>u8</code> 类型的值设置为 <code>256</code>，在调试模式下编译会发生 <code>panic</code>，但是在发布模式(—release)下，编译器不会检查可能导致 <code>panic</code> 的溢出，如果溢出，将会执行 “环绕”，即 256 为 0，257 为 1，不会导致 <code>panic</code></p>
<p><strong>浮点类型：</strong></p>
<p>包含 <code>f32</code>（单精度） 和 <code>f64</code>（双精度）两种浮点类型，统一采用 <code>IEEE-754</code> 标准。</p>
<p>浮点类型的默认类型为 <code>f64</code>.</p>
<p><strong>数值操作：</strong></p>
<p>和其他语言一致</p>
<p><strong>布尔类型：</strong></p>
<p>布尔类型有 <code>true</code> 和 <code>false</code> 两个值，占用 1 字节，符号是 <code>bool</code></p>
<p><strong>字符类型：</strong></p>
<p><code>Rust</code> 语言中使用 <code>char</code> 来表示单个字符，字符的字面值采用单引号，占用 4 字节大小，是 <code>Unicode</code> 的标量值，可以表示比 <code>ASCII</code> 码多得多的内容，例如中文，日文，emoji表情等</p>
<p><code>Unicode</code> 标量值的范围是从 <code>U+0000</code> 到 <code>U+D7FF</code>，<code>U+E0000</code> 到 <code>U+10FFFF</code></p>
<p>但 Unicode 中没有字符的概念，所以直觉上认为的字符也许与 <code>Rust</code> 中的概念并不相符</p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>复合类型可以将多个值放在一个类型里</p>
<p>Rust 提供了两种基础的复合类型：元组（Tuple），数组</p>
<p><strong>Tuple</strong></p>
<p>Tuple 可以将多个类型的多个值放在一个类型里</p>
<p>Tuple 长度是固定的，一旦声明就无法改变</p>
<p>创建和调用举例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>:(<span class="type">u32</span>, <span class="type">i64</span>, <span class="type">f32</span>) = (<span class="number">2022</span>, -<span class="number">461</span>, <span class="number">6.2</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>数组</strong></p>
<p>数组是在栈（Stack）上分配的单个块的内存</p>
<p>数组也可以将多个值放在一个类型里，但是数组中每个元素类型必须一致，数组长度也是固定，一旦声明不能改变</p>
<p>创建和调用举例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>如果想将数据存放在栈中而不是堆中，或者想保留固定数量的元素，可以使用数组。</p>
<p>当然如果希望数组长度变得灵活，可以使用 <code>vector</code></p>
<p><strong>数组的类型</strong></p>
<p>用 <code>[类型; 长度]</code> 这样的形式表示</p>
<p>例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>若数组中元素都相同，则有另一种声明数组的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line"><span class="comment">//这就相当于</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>在中括号里先指定初始值，然后是分号，然后是元素个数。</p>
<p>使用索引来访问数组元素，如果访问的索引超过数组范围，编译会通过，运行时会报错，<strong>但是 Rust 中不允许继续访问越界的地址</strong>（在 C 语言中是允许的，只不过会输出乱码）</p>
<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p>声明函数使用 <code>fn</code> </p>
<p>依照惯例，针对函数和变量名，Rust 使用 <code>snake case</code> 命名规范</p>
<ul>
<li>所有字母都是小写，单词之间用下划线隔开</li>
<li>Rust 的函数调用不按照声明顺序执行，即在后面声明的函数也可以在前面调用（这点与 C 语言不同）</li>
</ul>
<p><strong>函数的参数</strong></p>
<p>parameter（定义函数的参数），arguments（调用函数的参数）</p>
<p>必须声明每个参数的类型</p>
<p><strong>函数体中的语句和表达式</strong></p>
<ul>
<li>语句 <code>statement</code> 和表达式 <code>expression</code></li>
<li>函数体由一系列语句组成，可选的由一个表达式结束</li>
<li>Rust 是一个基于表达式的语言</li>
<li>语句是执行一些动作的指令</li>
<li>表达式会计算产生一个值</li>
<li>函数的定义也是语句</li>
<li>语句不返回值，因此不能用 let 将一个语句赋值个一个变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">        x + <span class="number">2</span>       </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br></pre></td></tr></table></figure>
<p>这里 let y 后面定义了一个代码块，这个块就是一个表达式，<code>x + 2</code> 后面没有分号，是一个表达式，相当于这个块表达式的返回值，因此最后输出的结果为 <code>y = 6</code>.</p>
<p>而如果 <code>x + 2</code> 后面加了分号，这就是一个语句了，语句返回一个空的元组，即返回 <code>()</code>，则输出一个空的元组将会报错</p>
<p><strong>函数的返回值</strong></p>
<p>在 <code>-&gt;</code> 符号后面声明函数返回值的类型，但是不可以为返回值命名</p>
<p>在 Rust 中，返回值通常就是函数体中最后一个表达式的值（大多数函数都是默认使用最后一个表达式作为返回值）</p>
<p>若想提前返回，需要使用 <code>return</code> 关键字，并指定一个值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_five</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The function return a num &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_five</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件判断</strong></p>
<p>只有一点说明：<code>if</code> 条件判断中表达式<strong>必须</strong>是 <code>bool</code> 类型，（C 语言等语言可以将类型转成 bool 再判断，Rust 中不可以）</p>
<p>当使用了超过一个 <code>else-if</code> 时，最好使用 <code>match</code> 语句进行重构。例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">condition_match</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">match</span> x % <span class="number">4</span> &#123;</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The number &#123;&#125; can be divided by 4&quot;</span>, x),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The number &#123;&#125; can be divided by 3&quot;</span>, x),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The number &#123;&#125; can be divided by 2&quot;</span>, x),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The number &#123;&#125; can&#x27;t be divided by 4; 3 and 2&quot;</span>, x)    <span class="comment">//_ 表示 default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 let 语句中使用 if</strong></p>
<p>因为 <code>if</code> 是一个表达式，因此可以将其放在 <code>let</code> 语句等号的右边</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>
<p>最后返回 x 的值为 5</p>
<h2 id="四、-控制流"><a href="#四、-控制流" class="headerlink" title="四、 控制流"></a>四、 控制流</h2><p>Rust 提供三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code></p>
<h3 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h3><p>loop 关键字将反复执行一块代码，直到手动停止，或者使用 <code>break</code> 停止</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">branch</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of counter is &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出结果为 20</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_while</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;MOVE! NOW!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_for</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">elem</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value is &#123;&#125;&quot;</span>, elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 for 循环实现 while 循环</strong></p>
<p><code>Range</code> 由标准库提供，指定一个开始数字和结束数字，<code>Range</code> 可以生成他们之间的一个数字（左闭右开），<code>rev</code> 方法可以翻转 <code>Range</code>。例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_range_for</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">elem</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、所有权"><a href="#五、所有权" class="headerlink" title="*五、所有权"></a>*五、所有权</h2><h3 id="所有权和堆栈"><a href="#所有权和堆栈" class="headerlink" title="所有权和堆栈"></a>所有权和堆栈</h3><p>所有权是 Rust 中最独特的特性，它让 Rust 无需 GC 就可以保证内存安全。</p>
<p><strong>什么是所有权</strong></p>
<ul>
<li>Rust 的核心就是所有权</li>
<li>所有程序在运行时都必须管理它们使用计算机内存的方式<ul>
<li>有些语言有垃圾收集机制(GC)，在程序运行时，它们会不断寻找不再使用的内存</li>
<li>在其他例如 C/C++ 语言中，程序员必须显式地分配和释放内存</li>
</ul>
</li>
<li>Rust 采用了第三种方式<ul>
<li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则</li>
<li>当程序运行时，所有权特性不会减慢程序的运行速度，因为 Rust 对内存的管理相关的工作都提前到了编译时</li>
</ul>
</li>
</ul>
<p><strong>堆内存和栈内存</strong></p>
<ul>
<li>所有存储在 Stack 上的数据必须拥有已知的固定的大小</li>
<li>编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 Heap 上</li>
<li>Heap 的分配和 C 语言类似，在内存空间中找到一块足够大的空间，然后返回一个指针。这叫做“分配”</li>
<li>把值压到 Stack 上不叫“分配”</li>
<li>将值压到 Stack 上比在 Heap 上快得多，因为操作系统不需要找用来存储数据的空间，那个位置永远在 Stack 最顶端</li>
</ul>
<p><strong>访问数据</strong></p>
<ul>
<li>访问 Heap 的速度比 Stack 慢，因为要通过指针才能找到</li>
<li>在 Heap 上分配大量空间也是需要很多时间的</li>
</ul>
<p><strong>所有权解决的问题</strong></p>
<ul>
<li>跟踪代码的哪些部分正在使用 Heap 的哪些数据</li>
<li>最小化 Heap 上的重复数据量</li>
<li>清理 Heap 上未使用的空间以避免空间不足</li>
</ul>
<p><strong>所有权规则</strong></p>
<ul>
<li>每个值都有一个变量，这个变量是这个值的所有者</li>
<li>每个值同时只能拥有一个所有者</li>
<li>当所有者超出作用域(Scope)时，该值将被删除</li>
</ul>
<p><strong>String</strong></p>
<ul>
<li>在 Heap 上分配，能够存储在编译时未知数量的文本</li>
<li>使用 <code>from</code> 函数从字符串字面值创建出 <code>String</code> 类型</li>
<li><code>let s = String::from(&quot;Cherry&quot;);</code></li>
<li>这类字符串是可以被修改的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    s += <span class="string">&quot;, Rust&quot;</span>;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, Rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里——速度快、高效。是因为其不可变性。</li>
<li>String类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容:操作系统必须在运行时来请求内存。这步通过调用<code>String:from</code> 来实现</li>
<li>当用完String 之后，需要使用某种方式将内存返回给操作系统这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存。没有 GC，就需要我们去识别内存何时不再使用，并调用代码将它返回。―如果忘了，那就浪费内存。<ul>
<li>如果提前做了，变量就会非法</li>
<li>如果做了两次，也是 Bug。必须一次分配对应一次释放</li>
</ul>
</li>
</ul>
<p>但是 Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域时，内存会自动交还给操作系统</p>
<p><code>drop</code> 函数，当变量走出作用域时，会调用这个函数</p>
<p><strong>变量与数据交互的方式：Move</strong></p>
<ul>
<li><p>String 的组成由三部分组成：指向数据的指针、长度和容量</p>
</li>
<li><p>这些数据放在 Stack 中</p>
</li>
<li>字符串数据存放在 Heap 中</li>
<li>长度 len，就是存放字符串内容所需的字节数</li>
<li>容量 capacity 指的是 String 从系统中获得内存的总字节数</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220511181243.png" alt="String的组成"></p>
<p>当把 s1 赋值给 s2 时，String 的数据被复制了一份，这实际上只复制了指针、长度和容量这一数据，在堆中的数据并没有被复制。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220511202210.png" alt="String浅拷贝"></p>
<p>因此当变量离开作用域的时候，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放掉。而在 s1 和 s2 都离开作用域的时候，它们都会尝试释放相同的内存，这时就出现了严重的<code>二次释放(double free)bug</code></p>
<p>为了保证内存安全，Rust 中没有尝试复制堆中被分配的内存，Rust 让 s1 失效：当 s1 离开作用域的时候，Rust 不需要释放任何东西</p>
<p>当 s2 创建之后再使用 s1 的效果由下例展示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Owner of Rust#&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当创建 s2 之后，将 s1 的值赋值给 s2 之后，编译器会报如下的错：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/owner git:(master) ✗ cargo run</span><br><span class="line">   Compiling owner v0.<span class="number">1.0</span> (/home/cherry/Code/rust/owner)</span><br><span class="line">warning: unused variable: `s2`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">22</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">   |         ^^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_s2`</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="meta">#[warn(unused_variables)]</span>` on by default</span><br><span class="line"></span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">24</span>:<span class="number">20</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">20</span> |     <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Owner of Rust#&quot;</span>);</span><br><span class="line">   |         -- <span class="keyword">move</span> occurs because `s1` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">21</span> | </span><br><span class="line"><span class="number">22</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">   |              -- value moved here</span><br><span class="line"><span class="number">23</span> |     </span><br><span class="line"><span class="number">24</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">   |                    ^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">warning: `owner` (bin <span class="string">&quot;owner&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">error: could not compile `owner` due to previous error; <span class="number">1</span> warning emitted</span><br></pre></td></tr></table></figure>
<p>也许这跟浅拷贝（shadow copy）比较类似，但是 Rust 同时还让 s1 失效了，因此用一个新的术语 <code>move</code> 来形容。同时 Rust 也隐含了一个设计原则：即 Rust 不会自动创建数据的深拷贝，通俗的说就是一块内存只能有一个变量进行操作。就运行时性能而言，任何自动赋值操作都是廉价的。</p>
<p><strong>变量与数据交互的方式：Clone</strong></p>
<p>要想对 heap 上面的数据进行深拷贝，可以使用 <code>clone</code> 方法，<code>clone</code> 是 <code>copy</code> 子集。例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Owner of Rust#&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.clone; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stack上的数据:复制</p>
<ul>
<li>Copy trait，可以用于像整数这样完全存放在stack上面的类型</li>
<li>如果一个类型实现了 Copy 这个 trait，那么旧的变量在赋值后仍然可用</li>
<li>如果一个类型或者该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了</li>
</ul>
<p>标准库文档里有说，std::ops::Drop 这个 trait 与 Copy_trait 无法共存于一个类型，因为在 Move 时，若发生 Copy 行为，Copy 行为是隐式的，因为是隐式的，编译器很难预测什么时候调用 Drop 函数，而实现了 Clone_trait 的，因为 clone 是显式的，需要 a.clone() 这样，那么编译器就能通过这种显式的 clone，确定被 clone 的变量的位置，决定何时调用 drop 函数。</p>
<p><strong>一些拥有 Copy trait 的类型</strong></p>
<ul>
<li>任何简单标量的组合类型都可以是 Copy 的</li>
<li>任何需要分配内存或某种资源的都不是 Copy 的</li>
<li>一些拥有 Copy trait 的类型:–所有的整数类型<ul>
<li>例如 u32-bool</li>
<li>char</li>
<li>所有的浮点类型，例如 f64</li>
<li>Tuple(元组），如果其所有的字段都是 Copy 的<ul>
<li>(i32, i32) 是</li>
<li>(i32, String) 不是</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Owner of Rust#&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">take_ownership</span>(s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);     <span class="comment">//报错，因为 s1 被 take_ownership 调用过后就会释放掉</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_ownership</span>(string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(num: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回值与作用域</strong></p>
<p>函数在返回值的过程中也会发生所有权的转移，下面的例子可以很好的帮助理解所有权这一概念：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">take_and_give_ownership</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;$Rust$&quot;</span>);</span><br><span class="line">    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_and_give_ownership</span>(string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 s2 在函数 <code>take_and_give_ownership</code> 调用后，所有权转移到了函数中，随着函数执行完，s2 的所有权也没有了。实际上函数的作用就是获得 s2 的所有权，然后这个所有权又返回给了 s3.</p>
<p>一个变量的所有权总是遵循同样的模式:</p>
<ul>
<li>把一个值赋给其它变量时就会发生移动</li>
<li>当一个包含 heap 数据的变量离开作用域时，它的值就会被drop 函数清理，除非数据的所有权移动到另一个变量上</li>
</ul>
<p>那么如何让函数使用某个值，而不获得其所有权？例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Welcome!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calc_len</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calc_len</span>(<span class="type">str</span>: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="type">str</span>.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    (<span class="type">str</span>, len)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 s1 作为参数传递进去，返回一个包含 String 和 usize 类型的元组，这样就将 s1 的所有权转移给了 s2。</p>
<p>那么如果不要传递参数能做到吗？下一节进行介绍。</p>
<h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;引用与借用&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calc_len_2</span>(&amp;s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;</span>, s, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calc_len_2</span>(<span class="type">str</span>: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数类型是 <code>&amp;String</code> 而不是 <code>String</code></li>
<li><code>&amp;</code>就表示引用，允许引用某些值而不得到其所有权</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220512190841.png" alt="引用"></p>
<p>注：Rust 中解引用的符号和 C/C++ 中是一样的，都是 <code>*</code>.</p>
<ul>
<li>把引用作为函数参数的行为就叫<strong>借用</strong></li>
<li>和变量一样，引用也是默认不能被修改的</li>
<li>若要使其能够修改，需要加上 <code>mut</code> 关键字</li>
</ul>
<p>例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;引用&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calc_len_2</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;</span>, s, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calc_len_2</span>(<span class="type">str</span>: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;与借用&quot;</span>);</span><br><span class="line">    <span class="type">str</span>.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若修改了一个引用对象，则会报这样的错误：</p>
<p><code>cannot borrow *str as mutable, as it is behind a &amp; reference</code></p>
<p><strong>可变引用</strong></p>
<p>可变引用有一个重要的限制:在特定作用域内，对某一块数据，只能有一个可变的引用。</p>
<ul>
<li>这样做的好处是可在编译时防止数据竞争</li>
</ul>
<p>以下三种行为下会发生数据竞争:</p>
<ul>
<li>两个或多个指针同时访问同一个数据一至少有一个指针用于写入数据</li>
<li>没有使用任何机制来同步对数据的访问</li>
<li>可以通过创建新的作用域，来允许非同时的创建多个可变引用</li>
</ul>
<p>例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 s1 和 s2 同时对可变变量 s 进行了引用，就会报这样的错误：<code>cannot borrow s as mutable more than once at a time</code></p>
<p>通过创建新的作用域，可以允许非同时的创建多个可变引用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一个限制</strong></p>
<ul>
<li>不可以同时拥有一个可变引用和一个不变的引用（因为不可变引用的作用就是不让值改变，被可变引用改变后，不可变引用就失去了其作用）</li>
<li>多个不变的引用是可以的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = &amp;s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s4</span> = &amp;<span class="keyword">mut</span> s;    <span class="comment">//报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, s2, s3, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便会报错：<code>cannot borrow s as mutable because it is also borrowed as immutable</code></p>
<p><strong>悬空引用 Dangling References</strong></p>
<p>悬空指针（Dangling Pointer): 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了。</p>
<ul>
<li>在Rust里，编译器可保证引用永远都不是悬空引用</li>
<li>如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test07</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dangling reference&quot;</span>);</span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在 <code>dangle</code> 函数中声明了一个字符串，期望返回其的引用，但是函数结束后 s 便离开了他的作用域，即被销毁，因此返回的引用为空。这和 C 语言中返回局部变量的地址如出一辙，但是 Rust 在编译时就将避免这样的问题发生。</p>
<p>报错：<code>missing lifetime specifier</code></p>
<p><strong>引用的规则</strong></p>
<p>在任何给定的时刻，只能满足下列条件之一:一个可变的引用，或者任意数量不可变的引用，而且引用必须一直有效。</p>
<h2 id="六、切片"><a href="#六、切片" class="headerlink" title="六、切片"></a>六、切片</h2><p>Rust 的另一种不持有所有权的数据类型：切片（Slice）</p>
<p>下面编写这样一个函数进行示范：</p>
<ul>
<li>它接收字符串作为参数</li>
<li>返回它在这个字符串里找到的第一个单词</li>
<li>如果函数没有找到任何空格，则返回整个字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space_index</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The first blank&#x27;s position is in &#123;&#125;.&quot;</span>, space_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        byte 的 iter 方法会为数组 byte 创建一个迭代器，这个方法会依次返回集合中的每个元素</span></span><br><span class="line"><span class="comment">        enumerate 方法会将 iter 返回的结果进行包装，并把每个结果作为一个元组的一部分进行返回</span></span><br><span class="line"><span class="comment">        元组的第一个元素就是遍历的索引，第二个元素就是数组中的元素（是一个引用），这里实际用到的是模式匹配</span></span><br><span class="line"><span class="comment">        声明了两个变量对这个元组进行解构</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这个函数的设计有一个缺陷，这个函数是将字符串空格的索引位置返回，而一旦这个结果脱离了这个字符串的上下文，这个返回值便没有了意义。换句话说，这个索引位置的结果是独立于字符串而存在的，在函数返回以后，我们就再也无法保证其有效性。举个例子，若函数获取 <code>Hello World</code> 这个字符串的空格位置，获取到函数返回值为 <code>5</code> 后，将该字符串清空 <code>s.clear()</code>，但是此时函数返回值 <code>space_index</code> 的值仍然是 <code>5</code>，这跟现在的字符串便没有了任何关联，因此这个返回值便没有了意义了。这样的 API 需要关注两者之间的同步性，但是往往都会比较繁琐。</p>
<p>Rust 提供了切片类型用来解决这一问题。</p>
<p><strong>字符串切片</strong></p>
<p>字符串切片是指向字符串中一部分内容的引用</p>
<p>形式：[开始索引..结束索引]，前闭后开</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220513022342.png" alt="字符串切片"></p>
<p>切片是放在 stack 上，右边的数组是放在 heap 上的。</p>
<p><em>【更正】：s 切片的长度和容量应该为 11.</em></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里切片有三个语法糖，若切片的开始位置为 0，则可以省略写，若切片的末尾时字符串最后一个位置，即等于字符串长度，那么也可以省略不写，下面的例子和上面是等价的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">whole</span> = &amp;s[..];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, hello, world);   <span class="comment">//输出为 Hello, World</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, whole);              <span class="comment">//输出为 Hello World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><p>字符串切片的范围索引必须发生在有效的 <code>UTF-8</code> 字符边界内。</p>
</li>
<li><p>如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出</p>
</li>
</ul>
<p>下面用切片重写上面的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">space_index_slice</span> = <span class="title function_ invoke__">first_word_slice</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();                                      <span class="comment">//报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The first world is &#123;&#125;.&quot;</span>, space_index_slice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word_slice</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里函数返回 <code>&amp;str</code> 表示字符串切片，若找到空格，将返回该位置之前的字符串切片，否则返回整个字符串切片。</p>
<p>但是上述代码中 <code>s.clear()</code> 会报错，报错信息为:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">7</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">space_index_slice</span> = <span class="title function_ invoke__">first_word_slice</span>(&amp;s);</span><br><span class="line">   |                                              -- immutable borrow occurs here</span><br><span class="line"><span class="number">6</span>  | </span><br><span class="line"><span class="number">7</span>  |     s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line"><span class="number">13</span> |     <span class="built_in">println!</span>(<span class="string">&quot;The first blank&#x27;s position is in &#123;&#125;.&quot;</span>, space_index_slice);</span><br><span class="line">   |                                                      ----------------- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0502`.</span><br><span class="line">error: could not compile `slice` due to previous error</span><br></pre></td></tr></table></figure>
<p>即不能将变量 s 借用为可变，因为它已经被借用为不可变。在函数参数中用了不可变引用，但是下面 <code>s.clear()</code> 又要修改字符串的值，使其变成可变，这样便会报错。</p>
<p><strong>字符串字面值是切片</strong></p>
<ul>
<li>字符串字面值被直接存储在二进制程序中</li>
<li><code>let s = &quot;Hello, World!&quot;;</code></li>
<li>变量 s 的类型是 <code>&amp;str</code>，它是一个指向二进制程序特定位置的切片</li>
<li><code>&amp;str</code> 是不可变引用，所以字符串字面值也是不可变的</li>
</ul>
<p><strong>将字符串切片作为参数传递</strong></p>
<p>有经验的 Rust 开发者会采用 <code>&amp;str</code> 作为参数类型，因为这样就可以同时接收 <code>String</code> 和 <code>&amp;str</code> 类型的参数了</p>
<ul>
<li>使用字符串切片，直接调用该函数</li>
<li>使用 <code>String</code>，可以创建一个完整的 <code>String</code> 切片来调用该函数</li>
<li>定义函数时使用字符串切片来代替字符串引用会使我们的 API 更加通用，且不会损失任何功能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他类型的切片</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, slice[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个切片类型为 <code>&amp;[i32]</code>，它存储了一个指向起始元素的位置的指针，还存储了一个长度，该例中为 <code>2</code></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（三）：Package、Crate 和 Module</title>
    <url>/280b72d7.html</url>
    <content><![CDATA[<h1 id="Rust-入门教程（二）"><a href="#Rust-入门教程（二）" class="headerlink" title="Rust 入门教程（二）"></a>Rust 入门教程（二）</h1><p>[toc]</p>
<p><strong>Rust 的代码组织</strong></p>
<p>代码组织主要包括：</p>
<ul>
<li>哪些细节可以暴露，哪些细节是私有的一作用域内哪些名称有效</li>
<li>模块系统:<ul>
<li>Package（包）：Cargo 的特性，让你构建、测试、共享 crate</li>
<li>Crate（单元包）： 一个模块树，它可产生一个 library 或可执行文件</li>
<li>Module（模块）、use：让你控制代码的组织、作用域、私有路径</li>
<li>Path（路径）：为 struct、function 或 module 等项命名的方式</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="1-Package-和-Crate"><a href="#1-Package-和-Crate" class="headerlink" title="1. Package 和 Crate"></a>1. Package 和 Crate</h2><p>Crate的类型:</p>
<ul>
<li>binary</li>
<li>library</li>
</ul>
<p>Crate Root:</p>
<ul>
<li>是源代码文件</li>
<li>Rust编译器从这里开始，组成你的 Crate 的根Module</li>
</ul>
<p>一个 Package:</p>
<ul>
<li>包含 1 个 Cargo.toml，它描述了如何构建这些 Crates </li>
<li>只能包含 0-1 个 library crate</li>
<li>可以包含任意数量的 binary crate</li>
<li>但必须至少包含一个 crate (library 或 binary)</li>
</ul>
<p><strong>Cargo 的惯例</strong></p>
<p><code>src/main.rs</code>:</p>
<ul>
<li>binary crate 的 crate root</li>
<li>crate 名与 package 名相同</li>
</ul>
<p><code>src/lib.rs</code>:</p>
<ul>
<li>package 包含一个 library crate</li>
<li>library crate 的 crate root</li>
<li>crate 名与 package 名相同</li>
</ul>
<p>Cargo 把 crate root 文件交给 rustc 来构建 library 或 binary</p>
<p>如果 package 下有一个lib.rs，就说明 package 下面有一个 library crate，这个 lib.rs 就是这个 library crate 的入口文件，crate 名字也是叫 my-project.</p>
<p>一个 Package 可以同时包含 src/main.r s和 src/lib.rs</p>
<ul>
<li>一个 binary crate，一个 library crate</li>
<li>名称与 package 名相同</li>
</ul>
<p>一个 Package 可以有多个 binary crate:</p>
<ul>
<li>文件放在 src/bin</li>
<li>每个文件是单独的 binary crate</li>
</ul>
<p><strong>Crate 的作用</strong></p>
<p>将相关功能组合到一个作用域内，便于在项目间进行共享，防止冲突。例如 rand crate，访问它的功能需要通过它的名字:rand</p>
<p><strong>定义 module 来控制作用域和私有性</strong></p>
<p>Module:</p>
<ul>
<li>在一个crate内，将代码进行分组</li>
<li>增加可读性，易于复用</li>
<li>控制项目（item）的私有性。public、private</li>
</ul>
<p>建立 module:</p>
<ul>
<li>mod 关键字</li>
<li>可嵌套</li>
<li>可包含其它项（struct、enum、常量、trait、函数等）的定义</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220514204827.png" alt="crate树形结构"></p>
<p><code>src/main.rs</code> 和 <code>src/lib.rs</code> 叫做 <code>crate roots</code>:</p>
<ul>
<li>这两个文件（任意一个）的内容形成了名为 crate 的模块，位于整个模块树的根部</li>
<li>整个模块树在隐式的crate模块下</li>
</ul>
<h2 id="2-路径-Path"><a href="#2-路径-Path" class="headerlink" title="2. 路径(Path)"></a>2. 路径(Path)</h2><p>为了在 Rust 的模块中找到某个条目，需要使用路径。路径的两种形式:</p>
<ul>
<li>绝对路径:从 crate root开始，使用 crate 名或字面值 crate</li>
<li>相对路径:从当前模块开始，使用 self，super 或当前模块的标识符路径至少由一个标识符组成，标识符之间使用<code>::</code></li>
</ul>
<p><strong>私有边界（privacy boundary）</strong></p>
<ul>
<li>模块不仅可以组织代码，还可以定义私有边界</li>
<li>如果想把函数或结构体设为私有，可以将它放到某个模块中</li>
<li>Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的</li>
<li>父级模块无法访问子模块中的私有条目</li>
<li>子模块里可以使用所有祖先模块中的条目</li>
</ul>
<p><strong>Pub 关键字</strong></p>
<p>使用 <code>pub</code> 关键字将某些条目标记为公共的，同为根下的模块尽管都是私有，也可以访问</p>
<p><strong>super 关键字</strong></p>
<p>用来访问父级模块路径中的内容，类似文件系统中的 <code>..</code>，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">        crate::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pub struct</strong></p>
<p>pub 放在 struct 前:</p>
<ul>
<li>struct 是公共的</li>
<li>struct 的字段默认是私有的</li>
<li>struct 的字段需要<strong>单独设置</strong> pub 来变成公有</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;strawberry&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please.&quot;</span>, meal.toast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pub enum</strong></p>
<p>pub 放在 enum 前:</p>
<ul>
<li>enum 是公共的</li>
<li><strong>enum 的变体也都是公共的</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">        Soup,</span><br><span class="line">        Salad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-use-关键字"><a href="#3-use-关键字" class="headerlink" title="3. use 关键字"></a>3. use 关键字</h2><p>可以使用 <code>use</code> 将路径导入到作用域内，同样遵循私有性原则，即只有公共的才能被使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">some_function</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">some_function</span>();   <span class="comment">//报错，因为some_function为私有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>use</code> 指定相对路径：<code>use front_of_house::hosting;</code></p>
<p>可以直接将模块中的函数导入到作用域内，但是这样便无法区分该函数是在模块中定义还是在该文件内定义，因此通常的做法都是只导入到该函数的父模块，通过父模块调用函数。</p>
<p>对于函数和同名条目是这样，但是对于结构体和枚举，通常是指定完整路径，这是 <code>use</code> 的习惯用法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>as 关键字</strong></p>
<p><code>as</code> 关键字可以为引入的路径指定一个本地的别名，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::IOResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span>() <span class="punctuation">-&gt;</span> IOResult &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 pub use 重新导出名称</strong></p>
<p>使用 use 将路径（名称）导入到作用域内后，该名称在此作用域内是私有的</p>
<p>pub use:重导出</p>
<ul>
<li>将条目引入作用域</li>
<li>该条目可以被外部代码引入到它们的作用域</li>
</ul>
<p><code>pub use crate::front_of_house::hosting;</code></p>
<p><strong>使用外部包</strong></p>
<ol>
<li>Cargo.toml 添加依赖的包(package)<ul>
<li><a href="https://crates.io/">https://crates.io/</a></li>
</ul>
</li>
<li>use 将特定条目引入作用域</li>
</ol>
<p>标准库（std）也被当做外部包，但是不需要修改 Cargo.toml 来包含 std，需要使用 use 将 std 中的特定条目引入当前作用域</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br></pre></td></tr></table></figure>
<p><strong>使用嵌套路径清理大量 use 语句</strong></p>
<p>如果使用同一个包或模块下的多个条目，可以使用嵌套路径在同一行内将上述路径进行引入</p>
<p>格式如下：<code>路径相同的部分::&#123;路径不同的部分&#125;</code>，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用嵌套路径</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若是这样的引用</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写为</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>通配符*</strong></p>
<p>使用 <code>*</code> 可以把路径中所有的公共条目都引入到作用域</p>
<p><code>use std::collections::*;</code></p>
<p>应用场景:</p>
<ul>
<li>测试。将所有被测试代码引入到 tests 模块</li>
<li>有时被用于预导入（prelude）模块</li>
</ul>
<h2 id="4-将模块拆分为不同文件"><a href="#4-将模块拆分为不同文件" class="headerlink" title="4. 将模块拆分为不同文件"></a>4. 将模块拆分为不同文件</h2><p><strong>将模块内容移动到其它文件</strong></p>
<p>模块定义时，如果模块名后边是 <code>;</code>，而不是代码块，Rust 会从与模块同名的文件中加载内容，同时项目文件夹结构要与模块层级结构一致。随着模块的变大，该技术可以把模块中的内容移动到其他文件中。</p>
<p>例如：文件 <code>main.rs</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> back_of_house;</span><br></pre></td></tr></table></figure>
<p>文件 <code>back_of_house.rs</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure>
<p>这时必须在 <code>src</code> 下创建一个 <code>back_of_house</code> 的文件夹，里面创建一个 <code>hosting.rs</code> 文件，即为 <code>src/back_of_house/hosting.rs</code></p>
<p>文件 <code>hosting.rs</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">test</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（九）：Rust 宏编程</title>
    <url>/c3f8af28.html</url>
    <content><![CDATA[<blockquote>
<p>C/C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。</p>
</blockquote>
<p>【未完】</p>
<span id="more"></span>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>过程宏必须定义在一个独立的 crate 中。</p>
<p>【解释】：过程宏是在编译一个 crate 之前，对 crate 的代码进行加工的一段程序，这段程序也是需要编译后执行的。如果定义过程宏和使用过程宏的代码写在一个 crate 中，那么就会陷入死锁：</p>
<ul>
<li>要编译的代码首先需要运行过程宏来展开，否则代码就是不完整的，没法编译 crate</li>
<li>不能编译 crate，那么其中的过程宏代码就没法执行，就不能展开被过程宏装饰的代码</li>
</ul>
<p>要开发 rust 过程宏，需要在 <code>Cargo.toml</code> 文件中添加必备的三个依赖包：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">proc-macro2 = <span class="string">&quot;1.0.7&quot;</span></span><br><span class="line">quote = <span class="string">&quot;1&quot;</span></span><br><span class="line">syn = &#123; version = <span class="string">&quot;1.0.56&quot;</span>, features = &#123;<span class="string">&quot;full&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（二）：结构体和枚举</title>
    <url>/48404f67.html</url>
    <content><![CDATA[<h1 id="Rust-入门教程（二）：结构体和枚举"><a href="#Rust-入门教程（二）：结构体和枚举" class="headerlink" title="Rust 入门教程（二）：结构体和枚举"></a>Rust 入门教程（二）：结构体和枚举</h1><span id="more"></span>
<p>[toc]</p>
<h2 id="一、结构体的使用"><a href="#一、结构体的使用" class="headerlink" title="一、结构体的使用"></a>一、结构体的使用</h2><h3 id="1-定义和实例化-struct"><a href="#1-定义和实例化-struct" class="headerlink" title="1. 定义和实例化 struct"></a>1. 定义和实例化 struct</h3><p>例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">usize</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，每个字段后面用逗号隔开，最后一个字段后面可以没有逗号。</p>
<p>实例化例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cherry@gmail.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cherry&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">244</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>先创建 struct 实例，然后为每个字段指定值，无需按照声明的顺序指定。</p>
<p>但是注意不能少指定字段。</p>
<p>用点标记法取得结构体中的字段值，一旦 struct 的实例是可变的，那么实例中的所有字段都是可变的，不会同时既存在可变的字段又存在不可变的字段。</p>
<p><strong>结构体作为函数的返回值</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">struct_build</span>() <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cherry@gmail.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;cherry&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">244</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字段初始化简写</strong></p>
<p>当字段名与字段值对应变量相同的时候，就可以使用字段初始化简写的方式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">struct_build</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">244</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>struct 更新语法</strong></p>
<p>当想基于某个 struct 实例创建一个新的实例时（新的实例中某些字段可能和原先相同，某些不同），若不使用 struct 更新语法，则是这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;paul@nba.cn&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Chris Paul&quot;</span>),</span><br><span class="line">        active: user1.active,</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>而使用 struct 更新语法，则是这样写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user3</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;paul@nba.cn&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Chris Paul&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>用 <code>..user1</code> 表示该实例中未赋值的其他字段和实例 <code>user1</code> 中的值一致。</p>
<p><strong>Tuple Struct</strong></p>
<p>可以定义类似 Tuple 的 Struct，叫做 Tuple Struct。Tuple struct 整体有个名，但里面的元素没有名</p>
<p>适用：想给整个 tuple 起名，并让它不同于其它 tuple，而且又不需要给每个元素起名</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>black 和 origin 是不同的类型，是不同 tuple struct 的实例</p>
<p><strong>Unit-Like Struct(没有任何字段)</strong></p>
<p>可以定义没有任何字段的 struct，叫做 <code>Unit-Like struct</code>，因为与 <code>()</code> 和单元类型类似，适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</p>
<p><strong>struct 数据所有权</strong></p>
<p>再来看这个例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">usize</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的字段使用了 <code>String</code> 而不是 <code>&amp;str</code>，原因如下：</p>
<ul>
<li>该 struct 实例拥有其所有的数据</li>
<li>只要 struct 实例是有效的，那么里面的字段数据也是有效的 struct 里也可以存放引用，但这需要使用生命周期（以后讲）</li>
<li>若字段为 <code>&amp;str</code>，当其有效作用域小于该实例的作用域，该字段被清理时，实例未清理，访问该字段属于悬垂引用（类似野指针）</li>
<li>生命周期保证只要 struct 实例是有效的，那么里面的引用也是有效的</li>
<li>如果 struct 里面存储引用，而不使用生命周期，就会报错</li>
</ul>
<h3 id="2-struct-例子"><a href="#2-struct-例子" class="headerlink" title="2. struct 例子"></a>2. struct 例子</h3><p>一个简单的例子：计算长方形的面积</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width</span> = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">area</span> = <span class="title function_ invoke__">area_of_rectangle</span>(width, length);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The Area of Rectangle is &#123;&#125;.&quot;</span>, area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(width: <span class="type">usize</span>, length: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    width * length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子很简单，但是长方形的长和宽没有联系起来，width 和 length 是两个分离的没有逻辑联系的变量，我们考虑用元组将其联系起来：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = (<span class="number">25</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The Area of Rectangle is &#123;&#125;.&quot;</span>, <span class="title function_ invoke__">area_of_rectangle</span>(rect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(rect: (<span class="type">u32</span>, <span class="type">u32</span>)) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rect.<span class="number">0</span> * rect.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样仿佛可读性变差了，我们再用结构体实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">35</span>,</span><br><span class="line">        length: <span class="number">12</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The Area of Rectangle is &#123;&#125;.&quot;</span>, <span class="title function_ invoke__">area_of_rectangle</span>(&amp;rect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(rect: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rect.length * rect.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数使用结构体的借用，是为了不获得该实例的所有权，主函数在函数调用之后还可以继续使用该实例。</p>
<p>此时我们输出实例 <code>rect</code>，会报这样的错误：<code>Rectangle doesn&#39;t implement std::fmt::Display</code>，即该结构体未实现 <code>Display</code> 这个 trait，而 Rust 中很多类型都是实现了这个 trait，才能将其在终端打印出来。因为结构体这种比标量类型更加复杂，打印的类型的可能性很多，因此需要用户自定义实现 <code>Display</code>。</p>
<p>在报错的提示信息里，有个 note 提示我们可以使用 <code>&#123;:?&#125;</code> (或 <code>&#123;:#?&#125;</code>)来打印信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect);</span><br></pre></td></tr></table></figure>
<p>然而又出现了错误，这次的报错信息是：<code>Rectangle doesn&#39;t implement Debug</code>，显然 <code>Debug</code> 也是一种格式化方法，再看提示的 note：<code>add #[derive(Debug)] to Rectangle or manually impl Debug for Rectangle</code>，我们在结构体前添加 <code>#[derive(Debug)]</code>，使得该结构体派生与 <code>Debug</code> 这个 trait。</p>
<p>最终完整的程序如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">35</span>,</span><br><span class="line">        length: <span class="number">12</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The Area of Rectangle is &#123;&#125;.&quot;</span>, <span class="title function_ invoke__">area_of_rectangle</span>(&amp;rect));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(rect: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rect.length * rect.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/area_of_rectangle git:(master) ✗ cargo run</span><br><span class="line">   Compiling area_of_rectangle v0.<span class="number">1.0</span> (/home/cherry/Code/rust/area_of_rectangle)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.25</span>s</span><br><span class="line">     Running `target/debug/area_of_rectangle`</span><br><span class="line">The Area of Rectangle is <span class="number">420</span>.</span><br><span class="line">Rectangle &#123; width: <span class="number">35</span>, length: <span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>
<p>若在输出格式中间加入一个 <code>#</code>，结构体输出将更加清晰：<code>println!(&quot;&#123;:?&#125;&quot;, rect);</code>，输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: <span class="number">35</span>,</span><br><span class="line">    length: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-struct-方法"><a href="#3-struct-方法" class="headerlink" title="3. struct 方法"></a>3. struct 方法</h3><p>方法和函数类似: fn关键字、名称、参数、返回值</p>
<p>方法与函数不同之处:</p>
<ul>
<li>方法是在 struct(或 enum、trait 对象）的上下文中定义</li>
<li>第一个参数是 self，表示方法被调用的 struct 实例</li>
</ul>
<p>上一节我们定义了计算长方形面积的函数，但是该函数只能计算长方形的函数，无法计算其他形状的面积，因此我们希望将函数与长方形这一结构体关联起来，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">35</span>,</span><br><span class="line">        length: <span class="number">12</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The Area of Rectangle is &#123;&#125;.&quot;</span>, rect.<span class="title function_ invoke__">area_of_rectangle</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在impl块里定义方法，方法的第一个参数可以是 <code>&amp;self</code>，也可以<strong>获得其所有权</strong>或<strong>可变借用</strong>，和其他参数一样。这样写可以有更良好的代码组织。</p>
<p><strong>方法调用的运算符</strong></p>
<ul>
<li>C/C++ 中 <code>object-&gt;something()</code> 和 <code>(*object).something()</code> 一样，但是 Rust 没有 <code>→</code> 运算符</li>
<li>Rust 会自动引用或解引用一在调用方法时就会发生这种行为</li>
<li>在调用方法时，Rust 根据情况自动添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code>，以便 object 可以匹配方法的签名</li>
<li>下面这两种写法效果相同<ul>
<li><code>p1.distance(&amp;p2);</code></li>
<li><code>(&amp;p1).distance(&amp;p2);</code></li>
</ul>
</li>
</ul>
<p><strong>方法参数</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area_of_rectangle</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.length &gt; other.length &amp;&amp; <span class="keyword">self</span>.width &gt; other.width </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关联函数</strong></p>
<p>可以在 impl 块里定义不把 self 作为第一个参数的函数，它们叫关联函数（不叫方法）</p>
<p>例如：<code>String::from()</code></p>
<p>关联函数通常用于构造器，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>::</code> 符号</p>
<ul>
<li>关联函数</li>
<li>模块创建的命名空间</li>
</ul>
<h2 id="二、枚举与模式匹配"><a href="#二、枚举与模式匹配" class="headerlink" title="二、枚举与模式匹配"></a>二、枚举与模式匹配</h2><h3 id="1-枚举的定义"><a href="#1-枚举的定义" class="headerlink" title="1. 枚举的定义"></a>1. 枚举的定义</h3><p>枚举允许我们列举所有可能的类型来定义一个类型</p>
<p>例如 IP 地址，目前只有 IPv4 和 IPv6 两种类型，我们可以定义这样的枚举类型并使用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line">    <span class="title function_ invoke__">route</span>(four);</span><br><span class="line">    <span class="title function_ invoke__">route</span>(six);</span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的变体都位于标识符的命名空间下，使用两个冒号 <code>::</code> 进行分隔</p>
<p>枚举类型是一种自定义的类型，因此它可以作为结构体里字段的类型，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">        kind: IpAddrKind::V4,</span><br><span class="line">        address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;192.168.3.1&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将数据附加到枚举的变体中</strong></p>
<p>上述的枚举类型我们可以改为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点是：不需要使用 struct，<strong>每个变体可以拥有不同的类型以及相关联的数据量</strong>，例如</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddrKind::<span class="title function_ invoke__">V4</span>(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddrKind::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标准库中的 IpAddr</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">lpv4Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lpv6Addr</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">lpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(lpv4Addr),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(lpv6Addr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为枚举定义方法</strong></p>
<p>也使用 <code>impl</code> 这个关键字</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123;x: <span class="type">u32</span>, y: <span class="type">u32</span>&#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">q</span> = Message::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::Move&#123;x: <span class="number">10</span>, y: <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Option-枚举"><a href="#2-Option-枚举" class="headerlink" title="2. Option 枚举"></a>2. Option 枚举</h3><ul>
<li>定义于标准库中</li>
<li>在 Prelude（预导入模块）中</li>
<li>描述了某个值可能存在（某种类型）或不存在的情况</li>
</ul>
<p><strong>Rust 中没有 NULL</strong></p>
<p>其它语言中:</p>
<ul>
<li>Null是一个值，它表示“没有值”</li>
<li>一个变量可以处于两种状态：空值（null）、非空 </li>
<li>Null 引用：Billion Dollar Mistake</li>
</ul>
<p>Null 的问题在于:当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误，但是 Null 的概念还是有用的：<strong>因某种原因而变为无效或缺失的值</strong></p>
<p>Rust 中类似与 NULL 的概念的枚举：<code>Option&lt;T&gt;</code></p>
<p>标准库中的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它包含在预导入模块（Prelude）中，可以直接使用 <code>Option&lt;T&gt;</code>, <code>Some(T)</code>, <code>None</code>。例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;The String&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_num</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Some(3)</code> 编译器可以推断出来 <code>T</code> 类型为 <code>usize</code>，而 <code>None</code> 的话编译器无法推断出来，因此需要显式指定 <code>Option&lt;i32&gt;</code></p>
<p>这种设计比 NULL 好在哪？</p>
<p>因为 <code>Option&lt;T&gt;</code> 和 <code>T</code> 是不同的类型，不能将 <code>Option&lt;T&gt;</code> 当成 <code>T</code> 使用，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会报错，提示 <code>cannot add Option&lt;i8&gt; to i8</code>，表示两者不是同一个类型，若想使用 <code>Option&lt;T&gt;</code> 中的 <code>T</code>，则必须将其手动转换为 <code>T</code>，这种设计方式可以避免代码中 NULL 值泛滥的情况。</p>
<h3 id="3-match"><a href="#3-match" class="headerlink" title="3. match"></a>3. match</h3><p><strong>强大的控制流运算符 match</strong></p>
<p>允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码。模式可以是字面值、变量名、通配符…</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>绑定值的模式</strong></p>
<p>匹配的分支可以绑定到被匹配对象的部分值，因此可以从 enum 变体中提取值，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">USState</span> &#123;</span><br><span class="line">    California,</span><br><span class="line">    Texas,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(USState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,  </span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Coin::Quarter(state) 也可以这样展开写 */</span></span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(USState::Texas) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;&quot;</span>, USState::Texas);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(USState::California) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;&quot;</span>, USState::California);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Coin::<span class="title function_ invoke__">Quarter</span>(USState::California);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">value_in_cents</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匹配 Option<T></T></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：match 匹配必须穷举所有的可能，可以使用 <code>_</code> 通配符替代其他没有列出的值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">0u8</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-if-let"><a href="#4-if-let" class="headerlink" title="4. if let"></a>4. if let</h3><p><code>if let</code> 是一种比 <code>match</code> 简单的控制流，他处理只关心一种匹配而忽略其他匹配的情况，它有更少的代码，更少的缩进，更少的模板代码，但是放弃了穷举的可能，可以把 <code>if let</code> 看作是 <code>match</code> 的语法糖。</p>
<p><code>if let</code> 的格式如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">pattern</span> = value &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他也可以搭配 <code>else</code> 例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Three!&quot;</span>),</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">3</span> = v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Three&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">5</span> = v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Five!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Others!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（五）：错误处理</title>
    <url>/1bd17c37.html</url>
    <content><![CDATA[<h1 id="Rust入门教程（五）：错误处理"><a href="#Rust入门教程（五）：错误处理" class="headerlink" title="Rust入门教程（五）：错误处理"></a>Rust入门教程（五）：错误处理</h1><span id="more"></span>
<h2 id="一、panic"><a href="#一、panic" class="headerlink" title="一、panic!"></a>一、panic!</h2><h3 id="1-1-Rust-错误处理概述"><a href="#1-1-Rust-错误处理概述" class="headerlink" title="1.1 Rust 错误处理概述"></a>1.1 Rust 错误处理概述</h3><ul>
<li>Rust 的可靠性：错误处理<ul>
<li>大部分情况下：在编译时提示错误，并处理</li>
</ul>
</li>
<li>错误的分类<ul>
<li>可恢复<ul>
<li>例如文件未找到，可再次尝试</li>
</ul>
</li>
<li>不可恢复<ul>
<li>bug，例如访问的索引超出范围</li>
</ul>
</li>
</ul>
</li>
<li>Rust 没有类似异常的机制<ul>
<li>可恢复错误：<code>Result&lt;T, E&gt;</code></li>
<li>不可恢复：panic! 宏</li>
</ul>
</li>
</ul>
<h3 id="1-2-不可恢复的错误与-panic"><a href="#1-2-不可恢复的错误与-panic" class="headerlink" title="1.2 不可恢复的错误与 panic!"></a>1.2 不可恢复的错误与 panic!</h3><ul>
<li>当 panic! 宏执行<ul>
<li>你的程序会打印一个错误信息</li>
<li>展开（unwind）、清理调用栈（Stack）</li>
<li>退出程序</li>
</ul>
</li>
</ul>
<p><strong>为应对 panic，展开或中止（abort）调用栈</strong></p>
<ul>
<li>默认情况下，当 panic 发生<ul>
<li>程序展开调用栈（工作量大）<ul>
<li>Rust 沿着调用栈往回走</li>
<li>清理每个遇到的函数中的数据</li>
</ul>
</li>
<li>或立即中止调用栈<ul>
<li>不进行清理，直接停止程序</li>
<li>内存需要 OS 进行清理</li>
</ul>
</li>
</ul>
</li>
<li>想让二进制文件更小，把设置从“展开”改为“中止”<ul>
<li>在 Cargo.toml 中适当的 profile 部分设置:</li>
<li><code>panic = &#39;abort&#39;</code></li>
</ul>
</li>
</ul>
<p><strong>使用 panic! 产生的回溯信息</strong></p>
<ul>
<li>panic!可能出现在<ul>
<li>我们写的代码中</li>
<li>我们所依赖的代码中</li>
</ul>
</li>
<li>可通过调用 panic! 的函数的回溯信息来定位引起问题的代码</li>
<li>通过设置环境变量 <code>RUST_BACKTRACE</code> 可得到回溯信息<ul>
<li>Windows 下：<code>set RUST_BACKTRACE=1 &amp;&amp; cargo run</code></li>
<li>Unix 系下：<code>RUST_BACKTRACE=1 cargo run</code></li>
</ul>
</li>
<li>为了获取带有调试信息的回溯，必须启用调试符号（不带 <code>--release</code>）</li>
</ul>
<h2 id="二、Result-和可恢复的错误"><a href="#二、Result-和可恢复的错误" class="headerlink" title="二、Result 和可恢复的错误"></a>二、Result 和可恢复的错误</h2><h3 id="2-1-Result-枚举"><a href="#2-1-Result-枚举" class="headerlink" title="2.1 Result 枚举"></a>2.1 Result 枚举</h3><p>Result 枚举类型的定义：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T：操作成功情况下 Ok 变体里返回的数据的类型<br>E：操作失败情况下 Err 变体里返回的错误的类型</p>
<p>处理 Result 的一种方式：match 表达式。和 Option 枚举一样，Result 及其变体也是由 prelude 带入作用域，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们鼠标悬停在 file 变量上，可以看到它的类型是：<code>std::result::Result&lt;std::fs::File, std::io::Error&gt;</code>，说明 open 函数返回的是一个 Result 枚举，且其第一个参数就是该文件，第二个参数是 io 下的 Error 类型，包含了错误的具体信息。</p>
<p>最终输出结果如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/panic git:(master) ✗ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (/home/cherry/Code/rust/panic)</span><br><span class="line">warning: unused variable: `f`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">17</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |     <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">   |         ^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_f`</span><br><span class="line"></span><br><span class="line">warning: `panic` (bin <span class="string">&quot;panic&quot;</span>) generated <span class="number">2</span> warnings</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.46</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;Open</span> File Error: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">20</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p><strong>匹配不同的错误</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>()&#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Creating File Error: &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, other_error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Err 中也会有很多种类型的错误，我们尝试匹配不同的错误类型，例如 <code>NotFound</code>。</p>
<p>这里使用了很多 match，尽管很有用，但是比较原始。我们可以使用 <strong>闭包（closure）</strong> ，Result<T, e> 有很多方法，他们使用闭包作为参数，使用 match 进行实现，使用这些方法会使得代码更简洁</T,></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;foo&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Creating File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体内容到后面再讲。</p>
<h3 id="2-2-unwrap-与-expect"><a href="#2-2-unwrap-与-expect" class="headerlink" title="2.2 unwrap 与 expect"></a>2.2 unwrap 与 expect</h3><p><strong>unwrap</strong></p>
<p>unwrap 是 match 表达式的一个快捷方法，如果 Result 结果是 Ok 则返回 Ok 里面的值，如果 Result 结果是 Err 则调用 panic!宏。以刚刚这段代码举例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unwrap 的作用类似于上面这段代码，当成功打开文件时，unwrap 就会返回 Ok 里面的值，否则就会调用 Err 代码块的代码，上面那段代码用 unwrap 就可以这样写：<code>let f = File::open(&quot;foo.txt&quot;).unwrap();</code></p>
<p>但是发生恐慌的信息不可以自定义，这也是 unwrap 的一个缺点，而 Rust 提供了另一个方法：expect。</p>
<p><strong>expect</strong></p>
<p>和 unwrap 类似，但是可以指定错误信息：<code>let f = File::open(&quot;foo&quot;).expect(&quot;Open File Error!!!&quot;);</code>，这样得到的报错信息如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/panic git:(master) ✗ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (/home/cherry/Code/rust/panic)</span><br><span class="line">warning: unused variable: `f`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">26</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">26</span> |     <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Open File Error!!!&quot;</span>);</span><br><span class="line">   |         ^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_f`</span><br><span class="line"></span><br><span class="line">warning: `panic` (bin <span class="string">&quot;panic&quot;</span>) generated <span class="number">1</span> warnings</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.22</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;Open</span> File Error!!!: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">26</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<h3 id="2-3-传播错误"><a href="#2-3-传播错误" class="headerlink" title="2.3 传播错误"></a>2.3 传播错误</h3><p>当写的函数中包含可能会执行失败的调用的时候，除了可以在函数中处理这个错误，还可以将错误返回给函数的调用者，让他们来决定如何进一步处理这个错误，这就叫做 <strong>传播错误</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(error)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="title function_ invoke__">Err</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">read_text_from_file</span>();</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 Result<T, e> 设置成函数返回值，这样就将错误传递给了调用者，若文件 foo 存在的话，最终便可以输出文件中的内容。</T,></p>
<p>Rust 中还提供了 <code>?</code> 运算符，用其来简化传播错误的操作。</p>
<p>如果 Result 是 Ok：Ok 中的值就是表达式的结果，然后继续执行程序；<br>如果 Result 是 Err：Err 就是 <strong>整个函数</strong> 的返回值，就像使用了 return。例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file_easy</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段简化后的代码的含义就是，若 <code>?</code> 前 Result 类型的值是 Ok，那么 Ok 里的值就会作为表达式的返回值进行返回，若类型是 Err，那么 Err 就当做整个函数的返回值进行返回。而 <code>f.read_to_string(&amp;mut s)?;</code> 中，若 Result 类型是 Ok，实际上里面值为空，没有用到，因此当表达式返回 Ok 后，返回一个 Ok(s) 作为函数的返回值，若类型为 Err，则将其作为函数返回值进行返回。</p>
<p>上面这个例子还可以继续进行优化，使用链式调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file_easist</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是，要使用 ? 运算符，必须保证函数返回类型为 Result<T, e></T,></strong>，倘若我们尝试一下函数返回类型不是 Result，将会得到这样一条报错信息：<code>error[E0277]: the &#39;?&#39; operator can only be used in a function that returns &#39;Result&#39; or &#39;Option&#39; (or another type that implements &#39;FromResidual&#39;)</code></p>
<p>因此，? 运算符只能用于返回类型为 Result 或 Option 的函数</p>
<p><strong>? 运算符与 main 函数</strong></p>
<ul>
<li>main 函数返回类型是:()</li>
<li>main 函数的返回类型也可以是：Result<T，E></T，E></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Box&lt;dyn Error&gt;</code> 是 trait 对象，可以简单理解为“任何可能的错误类型”。</p>
<p>这样就可以在 main 函数中使用 <code>?</code> 运算符了。</p>
<p>（开始玄学 o_o）</p>
<p><strong>? 与 from 函数</strong></p>
<ul>
<li><code>Trait std:convert::From</code> 上的 from 函数<ul>
<li>用于错误之间的转换</li>
</ul>
</li>
<li>被 ? 所应用的错误，会隐式的被 from 函数处理</li>
<li>当 ? 调用 from 函数时<ul>
<li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li>
</ul>
</li>
<li>用于：针对不同错误原因，返回同一种错误类型<ul>
<li>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</li>
</ul>
</li>
</ul>
<h3 id="2-4-什么时候应该使用-panic"><a href="#2-4-什么时候应该使用-panic" class="headerlink" title="2.4 什么时候应该使用 panic!"></a>2.4 什么时候应该使用 panic!</h3><p><strong>总体原则</strong></p>
<p>在定义一个可能失败的函数时，优先考虑返回 Result，若你觉得这个错误一定无法恢复，那就可以代替调用者调用 panic!</p>
<p><strong>编写示例、原型代码、测试</strong></p>
<p>可以使用panic!</p>
<ul>
<li>演示某些概念: unwrap</li>
<li>原型代码: unwrap、expect</li>
<li>测试: unwrap、expect<ul>
<li>测试的失败是用 panic! 进行标记的</li>
</ul>
</li>
</ul>
<p><strong>有时你比编译器掌握更多的信息</strong></p>
<p>你可以确定 Result 就是 Ok，那么可以使用 unwrap，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;192.168.3.110&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以确定这个 IP 地址解析出来一定是有效的，因此可以直接使用 unwrap。</p>
<p><strong>错误处理的指导性建议</strong></p>
<ul>
<li>当代码最终可能处于损坏状态时，最好使用 panic!</li>
<li>损坏状态（Bad state）：某些假设、保证、约定或不可变性被打破<ul>
<li>例如非法的值、矛盾的值或空缺的值被传入代码</li>
<li>以及下列中的一条：<ul>
<li>这种损坏状态并不是预期能够偶尔发生的事情</li>
<li>在此之后，您的代码如果处于这种损坏状态就无法运行</li>
<li>在您使用的类型中没有一个好的方法来将这些信息（处于损坏状态）进行编码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>场景建议</strong></p>
<ul>
<li>调用你的代码，传入无意义的参数值：panic!</li>
<li>调用外部不可控代码，返回非法状态，你无法修复：panic!</li>
<li>如果失败是可预期的：Result</li>
<li>当你的代码对值进行操作，首先应该验证这些值：panic!</li>
</ul>
<p><strong>为验证创建自定义类型</strong></p>
<p>创建新的类型，把验证逻辑放在构造实例的函数里。</p>
<p>以第一节的猜数游戏为例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The num must between 1 and 100&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个功能就是判断输入的数是否符合 i32 类型，若符合的话表达式返回 num，然后再判断是否在 1~100 之间，如果不满足则继续循环。如果有多个函数中都需要类似这样的判断，则代码便会显得冗余，我们可以自定义一个验证逻辑：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;The guess value must between 1 and 100, got &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;value&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似 getter 方法</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">guess_game</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = Guess::<span class="title function_ invoke__">new</span>(guess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果能够成功创建 Guess 实例的话，那么就说明值通过了验证，而不需要将验证功能写在函数里了。</p>
<p>上述 value 方法是获得 Guess 结构体中的 value 字段值，因为结构体中的字段是私有的，外部无法直接对字段赋值。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（八）：编写和运行测试</title>
    <url>/290a7a7a.html</url>
    <content><![CDATA[<h1 id="Rust入门教程（八）：编写和运行测试"><a href="#Rust入门教程（八）：编写和运行测试" class="headerlink" title="Rust入门教程（八）：编写和运行测试"></a>Rust入门教程（八）：编写和运行测试</h1><blockquote>
<p>这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。</p>
<p>测试函数体通常执行下面三个操作，也称 <code>3a</code> 操作：</p>
<ol>
<li>准备数据或状态（arrange）；</li>
<li>运行被测试的代码（act）；</li>
<li>断言结果（assert）。</li>
</ol>
</blockquote>
<span id="more"></span>
<h2 id="一、测试的使用及演示"><a href="#一、测试的使用及演示" class="headerlink" title="一、测试的使用及演示"></a>一、测试的使用及演示</h2><ul>
<li>测试函数需要使用 <code>test</code> 属性（attribute）进行标注<ul>
<li>attribute 就是一段代码的元数据</li>
<li>在函数紧接着上面一行添加 <code>#[test]</code>，就将函数变成测试函数了</li>
</ul>
</li>
<li>运行测试<ul>
<li>使用 <code>cargo test</code> 命令运行所有测试<ul>
<li>Rust 会构建一个 Test Runner 可执行文件，会运行标注的 test 函数，并报告运行是否成功</li>
</ul>
</li>
<li>当使用 cargo 创建 library 项目时，会生成一个 test module，里面有默认的 test 函数<ul>
<li>可以添加任意数量的 test module 和 test 函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-1-测试演示"><a href="#1-1-测试演示" class="headerlink" title="1.1 测试演示"></a>1.1 测试演示</h3><p>我们输入命令 <code>cargo new test_demo --lib</code> 创建一个项目，在 <code>lib.rs</code> 文件中看到这样的函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>assert_eq!</code> 是一个断言的宏，判断两个数是否相等。</p>
<p>然后运行 <code>cargo test</code>，结果如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test               </span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">2.33</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests test_demo</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure>
<h3 id="1-2-测试失败"><a href="#1-2-测试失败" class="headerlink" title="1.2 测试失败"></a>1.2 测试失败</h3><ul>
<li>测试函数 panic 就表示测试失败</li>
<li>每个测试都运行在一个新线程中</li>
<li>当主线程看到测试线程挂掉后，那个测试就被标记为失败</li>
</ul>
<p>我们单独编写一个带有 panic 的测试函数，测试结果如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">another</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Test Failed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::another ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::another stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::another&#x27; panicked at <span class="symbol">&#x27;Test</span> Failed!&#x27;, src/lib.rs:<span class="number">11</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::another</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">1</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="二、断言"><a href="#二、断言" class="headerlink" title="二、断言"></a>二、断言</h2><h3 id="2-1-使用-assert-宏检查测试结果"><a href="#2-1-使用-assert-宏检查测试结果" class="headerlink" title="2.1 使用 assert! 宏检查测试结果"></a>2.1 使用 assert! 宏检查测试结果</h3><ul>
<li>assert! 来自于标准库，用来确定某个状态是否为 true<ul>
<li>如果为 true，表示测试通过</li>
<li>如果为 false，则调用 panic! 宏，测试失败</li>
</ul>
</li>
</ul>
<p>我们用之前写的一个小例子，判断矩形 r1 是否能容纳矩形 r2（为了简单起见，只判断正着放，而不考虑斜着放进去）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> other.x &gt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> other.x &lt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">self</span>.x &gt; x &amp;&amp; <span class="keyword">self</span>.y &gt; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rect &#123; x: <span class="number">12</span>, y: <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rect &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(r1.<span class="title function_ invoke__">can_hold</span>(&amp;r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然返回是 true，测试通过。</p>
<h3 id="2-2-使用-assert-eq-和-assert-ne-测试相等性"><a href="#2-2-使用-assert-eq-和-assert-ne-测试相等性" class="headerlink" title="2.2 使用 assert_eq! 和 assert_ne! 测试相等性"></a>2.2 使用 assert_eq! 和 assert_ne! 测试相等性</h3><ul>
<li>都来自标准库</li>
<li>判断两个参数是否相等或不等</li>
<li>实际上，它们使用的就是 <code>==</code> 和 <code>!=</code> 运算符</li>
<li>如果断言失败，该宏会自动打印出两个参数的值<ul>
<li>使用 debug 格式打印参数</li>
<li>要求参数实现 PartialEq 和 Debug Traits（所有基本类型和标准库里大部分类型基本都实现了）</li>
<li>如果使用 <code>assert!</code> 宏，则只会告知测试结果而不会打印出两个参数的值</li>
</ul>
</li>
</ul>
<p>我们再写一个简单的例子，将一个数加 2，判断两个值是否相等。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">it_add_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显然是正确的，若我们更改函数逻辑，把加 2 改成加 3，则运行测试结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.39</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">3</span> tests</span><br><span class="line">test tests::it_add_two ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line">test tests::larger_can_hold_smaller ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::it_add_two stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_add_two&#x27; panicked at <span class="symbol">&#x27;assertion</span> failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">4</span>`,</span><br><span class="line"> right: `<span class="number">5</span>`&#x27;, src/lib.rs:<span class="number">37</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::it_add_two</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">2</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure>
<p>编译器将会自动给出两个参数的值（左值和右值），若将宏改成 <code>assert_ne!</code> 测试结果又将变成正确。</p>
<h2 id="三、自定义错误消息"><a href="#三、自定义错误消息" class="headerlink" title="三、自定义错误消息"></a>三、自定义错误消息</h2>]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（六）：泛型和特性</title>
    <url>/fb8de022.html</url>
    <content><![CDATA[<h1 id="Rust入门教程（六）：泛型和特性"><a href="#Rust入门教程（六）：泛型和特性" class="headerlink" title="Rust入门教程（六）：泛型和特性"></a>Rust入门教程（六）：泛型和特性</h1><blockquote>
<p>泛型是一个编程语言不可或缺的机制。<br>C++ 语言中用”模板”来实现泛型，而 C 语言中没有泛型的机制，这也导致 C 语言难以构建类型复杂的工程。<br>泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。</p>
</blockquote>
<span id="more"></span>
<p>[toc]</p>
<h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h2><h3 id="1-1-泛型介绍"><a href="#1-1-泛型介绍" class="headerlink" title="1.1 泛型介绍"></a>1.1 泛型介绍</h3><ul>
<li>泛型可以提高代码复用能力，也就是处理重复代码的问题</li>
<li>泛型是具体类型或其它属性的抽象代替:<ul>
<li>你编写的代码不是最终的代码，而是一种模板，里面有一些“占位符”</li>
<li>编译器在编译时将<strong>占位符</strong>替换为具体的类型</li>
<li>例如：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt;T &#123;...&#125;</code></li>
</ul>
</li>
<li>类型参数<ul>
<li>很短，通常一个字母</li>
<li>CamelCase</li>
<li>T: type 的缩写</li>
</ul>
</li>
</ul>
<h3 id="1-2-在函数定义中使用泛型"><a href="#1-2-在函数定义中使用泛型" class="headerlink" title="1.2 在函数定义中使用泛型"></a>1.2 在函数定义中使用泛型</h3><p>泛型函数</p>
<ul>
<li>参数类型</li>
<li>返回类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">80</span>, <span class="number">2022</span>, <span class="number">36</span>, <span class="number">47</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">largest</span> = <span class="title function_ invoke__">largest</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest ele is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是求一个集合中最大的元素，我们定义的集合是一个 <code>i32</code> 类型，但是这时如果我们要传入 <code>f32</code> 或者字符型，还用同样的逻辑判断函数的话，是会报错的，这时我们就需要用到泛型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们声明了一个泛型 <code>T</code>，但是这样是会编译报错的，因为不是所有类型 T 都可以进行大小比较，只有实现了下面的 <code>std::cmp::PartialOrd</code> 的 trait 才能进行大小比较，所以要对 T 进行约束。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/pattern git:(master) ✗ cargo run</span><br><span class="line">   Compiling pattern v0.<span class="number">1.0</span> (/home/cherry/Code/rust/pattern)</span><br><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to <span class="keyword">type</span> `T`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">17</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> |         <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">   |            ---- ^ ------- T</span><br><span class="line">   |            |</span><br><span class="line">   |            T</span><br><span class="line">   |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T`</span><br><span class="line">   |</span><br><span class="line"><span class="number">7</span>  | <span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">   |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `pattern` due to previous error</span><br></pre></td></tr></table></figure>
<p>但是把 <code>std::cmp::PartialOrd</code> 这个 trait 加上又会报其他错误，这里在后面会进行介绍。</p>
<h3 id="1-3-结构体中的泛型"><a href="#1-3-结构体中的泛型" class="headerlink" title="1.3 结构体中的泛型"></a>1.3 结构体中的泛型</h3><p>可以使用多个泛型的类型参数，但是也不要有太多的类型，否则代码可读性将会下降。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point&#123;x: <span class="number">2022</span>, y: <span class="number">6.1</span>&#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-Enum定义中的泛型"><a href="#1-4-Enum定义中的泛型" class="headerlink" title="1.4 Enum定义中的泛型"></a>1.4 Enum定义中的泛型</h3><p>可以让枚举的变体持有泛型数据类型，例如：Option<T>, Result<T, e></T,></T></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-方法定义中使用泛型"><a href="#1-5-方法定义中使用泛型" class="headerlink" title="1.5 方法定义中使用泛型"></a>1.5 方法定义中使用泛型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point&#123;x: <span class="number">2022</span>, y: <span class="number">61</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, integer.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>把 T 放在 impl 关键字后，表示在类型 T 上实现方法<ul>
<li>例如：<code>impl&lt;T&gt; Point&lt;T&gt;</code></li>
</ul>
</li>
<li>只针对具体类型实现方法（其余类型没实现方法）<ul>
<li>例如: <code>impl Point&lt;f32&gt;</code></li>
</ul>
</li>
<li>struct 中的泛型参数可以和方法的泛型参数不同</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V,W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123;x: <span class="number">61</span>, y: <span class="number">85</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point&#123;x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&quot;Rust&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面实现的结构体方法实际上是将第一个 Point 中的 x 和第二个 Point 的 y 结合起来形成一个新的 Point。</p>
<h3 id="1-6-泛型代码的性能"><a href="#1-6-泛型代码的性能" class="headerlink" title="1.6 泛型代码的性能"></a>1.6 泛型代码的性能</h3><p>使用泛型的代码和使用具体类型的代码运行速度是一样的</p>
<ul>
<li>单态化（monomorphization）<ul>
<li>在编译时将泛型替换为具体类型的过程</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ingeter</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f32</span>),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2. trait"></a>2. trait</h2><ul>
<li>Trait 告诉 Rust 编译器<ul>
<li>某种类型具有哪些并且可以与其它类型共享的功能</li>
</ul>
</li>
<li>Trait：抽象的定义共享行为</li>
<li>Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型</li>
<li>Trait与其它语言的接口（interface）类似，但有些区别</li>
</ul>
<h3 id="2-1-定义一个-Trait"><a href="#2-1-定义一个-Trait" class="headerlink" title="2.1 定义一个 Trait"></a>2.1 定义一个 Trait</h3><p>Trait的定义：把方法签名放在一起，来定义实现某种目的所必需的一组行为。</p>
<ul>
<li>关键字：trait</li>
<li>只有方法签名，没有具体实现</li>
<li>trait 可以有多个方法：每个方法签名占一行，以 <code>;</code> 结尾</li>
<li>实现该 trait 的类型必须提供具体的方法实现</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-在类型上实现-trait"><a href="#2-2-在类型上实现-trait" class="headerlink" title="2.2 在类型上实现 trait"></a>2.2 在类型上实现 trait</h3><ul>
<li>在类型上实现 trait。与为类型实现方法类似</li>
<li>不同之处：<code>impl Xxxx for Tweet &#123;...&#125;</code></li>
<li>在 impl 的块里，需要对 Trait 里的方法签名进行具体的实现</li>
</ul>
<p>文件 <code>lib.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件 <code>main.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> trait_demo::Summary;</span><br><span class="line"><span class="keyword">use</span> trait_demo::Tweet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry_ICT&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;People in Shanghai are free today...&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Get 1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的功能很简单，不做具体解释了。</p>
<h3 id="2-3-实现-trait-的约束"><a href="#2-3-实现-trait-的约束" class="headerlink" title="2.3 实现 trait 的约束"></a>2.3 实现 trait 的约束</h3><ul>
<li>可以在某个类型上实现某个 trait 的前提条件是<ul>
<li>这个类型或这个 trait 是在本地 crate 里定义的</li>
</ul>
</li>
<li>无法为外部类型来实现外部的trait<ul>
<li>这个限制是程序属性的一部分（也就是一致性）</li>
<li>更具体地说是<strong>孤儿规则</strong>：之所以这样命名是因为父类型不存在</li>
<li>此规则确保其他人的代码不能破坏您的代码，反之亦然</li>
<li>如果没有这个规则，两个 crate 可以为同一类型实现同一个 trait，Rust 就不知道应该使用哪个实现了</li>
</ul>
</li>
</ul>
<p><strong>默认实现</strong></p>
<p>默认实现的方法可以调用 trait 中的其他方法，即使这些方法没有默认实现，但是注意，无法从方法的重写实现中调用默认实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125; ...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 trait 中可以有方法的默认实现，在默认实现的基础上，类型可以对该 trait 进行重载。同样，在 trait 中默认实现的方法可以实现 trait 中其他方法。</p>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>刚刚 trait 例子的完整代码如下：</p>
<p><code>lib.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125; ...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> trait_demo::Summary;</span><br><span class="line"><span class="keyword">use</span> trait_demo::Tweet;</span><br><span class="line"><span class="keyword">use</span> trait_demo::NewsArticle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry_ICT&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;People in Shanghai are free today...&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Get 1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news</span> = NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;WWDC will be held in June 7th&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;USA&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Tim Cook&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Apple will take us a lot of devices.&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You receive a news: &#123;&#125;&quot;</span>, news.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/trait_demo git:(master) ✗ cargo run</span><br><span class="line">   Compiling trait_demo v0.<span class="number">1.0</span> (/home/cherry/Code/rust/trait_demo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/trait_demo`</span><br><span class="line">Get <span class="number">1</span> new tweet: Cherry_ICT: People <span class="keyword">in</span> Shanghai are free today...</span><br><span class="line">You receive a news: WWDC will be held <span class="keyword">in</span> June <span class="number">7</span>th, by Tim <span class="title function_ invoke__">Cook</span> (USA)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-实现-Trait-作为参数"><a href="#2-4-实现-Trait-作为参数" class="headerlink" title="2.4 实现 Trait 作为参数"></a>2.4 实现 Trait 作为参数</h3><ul>
<li>impl Trait 语法：适用于简单情况</li>
<li>Trait bound 语法：可用于复杂情况<ul>
<li>impl trait 语法实际上是 trait bound 语法的语法糖</li>
</ul>
</li>
<li>使用 <code>+</code> 指定多个 trait bound</li>
<li>Trait bound 使用 where 子句<ul>
<li>在方法签名后指定 where 子句</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是采用 impl Trait 的语法，这里的 notify 方法要求传入的参数可以是 <code>NewsArticle</code> 类型或者是 <code>Tweet</code> 类型，也就是要求参数要实现 <code>Summary</code> 这个 trait，从而使用 summarize 这个方法。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是采用 Trait bound 的写法，下面这个例子讲展示出这种写法的优势：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有多个参数时，采用这种写法可以使得代码相对简洁一些。</p>
<p>使用 <code>+</code> 指定多个 trait bound：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而如果一个函数中参数过多，那么整个函数声明就会变得非常长，不太直观，可读性差，这里可以使用 where 子句来指定 trait 的约束：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify2</span>&lt;T: Summary + Display, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中函数签名太长，不够直观，采用 where 子句可以使得更加直观：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify3</span>&lt;T, U&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-实现-Trait-作为返回类型"><a href="#2-5-实现-Trait-作为返回类型" class="headerlink" title="2.5 实现 Trait 作为返回类型"></a>2.5 实现 Trait 作为返回类型</h3><ul>
<li>impl trait 语法<ul>
<li>注意：impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify4</span>(flag: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        NewsArticle &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;...&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话这个函数便没有了确定的返回类型，这样便会报错。</p>
<h3 id="2-6-使用-trait-bound-实现之前泛型-的例子"><a href="#2-6-使用-trait-bound-实现之前泛型-的例子" class="headerlink" title="2.6 使用 trait bound 实现之前泛型 的例子"></a>2.6 使用 trait bound 实现之前泛型 的例子</h3><p>我们再来看一下<a href="#12-在函数定义中使用泛型">之前的代码</a>。解决如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们说过，实际上比较大小的运算符是实现了 <code>std::cmp::PartialOrd</code> 这样一个 trait，因此我们需要指定实现这个 trait 的泛型才能进行大小比较。</p>
<p>但是这样改完后又会出现一个问题：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/Code/rust/pattern git:(master) ✗ cargo run </span><br><span class="line">   Compiling pattern v0.<span class="number">1.0</span> (/home/cherry/Code/rust/pattern)</span><br><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[T]`, a non-copy slice</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">19</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> | <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">   |                   ^^^^^^^</span><br><span class="line">   |                   |</span><br><span class="line">   |                   cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |                   <span class="keyword">move</span> occurs because `list[_]` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |                   help: consider borrowing here: `&amp;list[<span class="number">0</span>]`</span><br><span class="line"></span><br><span class="line">error[E0507]: cannot <span class="keyword">move</span> out of a shared reference</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">11</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> |     <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">   |         -----    ^^^^</span><br><span class="line">   |         ||</span><br><span class="line">   |         |data moved here</span><br><span class="line">   |         |<span class="keyword">move</span> occurs because `item` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |         help: consider removing the `&amp;`: `item`</span><br><span class="line"></span><br><span class="line"><span class="literal">Some</span> errors have detailed explanations: E0507, E0508.</span><br><span class="line">For more information about an error, <span class="keyword">try</span> `rustc --explain E0507`.</span><br><span class="line">error: could not compile `pattern` due to <span class="number">2</span> previous errors</span><br></pre></td></tr></table></figure>
<p>报错原因是：无法从 list 中移除 T，因为没有实现 Copy trait，建议采用借用</p>
<p>因为上面两个 vector 中的元素分别为整型和字符型，这两种类型有确定的大小并且都是存储在栈中，因此都实现了 Copy trait，于是在 T 的 trait 约束中再加上 Copy 即可：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果将 vec 中元素类型改为 String，那么又会报错，因为 String 是存储在堆中，没有实现 Copy trait，但是实现了 Clone trait</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">largest</span> = <span class="title function_ invoke__">get_max_ele</span>(&amp;str_list);</span><br></pre></td></tr></table></figure>
<p>我们将 T 加上 Clone 约束，去掉 Copy 约束：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样又会出现错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[T]`, a non-copy slice</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">   |                       ^^^^^^^</span><br><span class="line">   |                       |</span><br><span class="line">   |                       cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |                       <span class="keyword">move</span> occurs because `list[_]` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |                       help: consider borrowing here: `&amp;list[<span class="number">0</span>]`</span><br></pre></td></tr></table></figure>
<p>是因为这里 list[0] 是字符串切片，是一个借用，没有所有权，因此一个借用给一个变量赋值，这个借用对应的类型必须要实现 Copy trait。因此在 list 前面加上引用，并且将 item 也设为引用，最后返回 &amp;T。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若要最后还是返回 T，则可以使用 clone 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-使用-Trait-Bound-有条件的实现方法"><a href="#2-7-使用-Trait-Bound-有条件的实现方法" class="headerlink" title="2.7 使用 Trait Bound 有条件的实现方法"></a>2.7 使用 Trait Bound 有条件的实现方法</h3><p>在使用泛型类型参数的 impl 块上使用 Trait bound，我们可以有条件的为实现了特定 Trait 的类型来实现方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmd_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以为实现了其它 Trait 的任意类型有条件的实现某个 Trait</li>
<li>为满足 Trait Bound 的所有类型上实现 Trait 叫做覆盖实现 （blanket implementations）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: fmt::Display&gt; Tostring <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>含义为：为实现了 Display trait 的类型实现 ToString trait，而 ToString 中实现了 to_string 方法。</p>
<p>例如 <code>let s = 3.to_string();</code></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（十一）：闭包和迭代器</title>
    <url>/1b9cba25.html</url>
    <content><![CDATA[<blockquote>
<p>闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。<br>函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点</p>
</blockquote>
<span id="more"></span>
<h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a>1.1 什么是闭包</h3><ul>
<li>是匿名函数</li>
<li>保存为变量、作为参数</li>
<li>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li>
<li>可从其定义的作用域捕获值</li>
</ul>
<h3 id="1-2-例子：生成自定义运动计划的程序"><a href="#1-2-例子：生成自定义运动计划的程序" class="headerlink" title="1.2 例子：生成自定义运动计划的程序"></a>1.2 例子：生成自定义运动计划的程序</h3><ul>
<li>该算法的逻辑并不是重点，重点是算法中的计算过程需要几秒钟时间。</li>
<li>目标：不让用户发生不必要的等待<ul>
<li>仅在必要时调用该算法</li>
</ul>
</li>
</ul>
<p>例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用函数 <code>simulated_expensive_calculation</code> 模拟复杂的计算，我们不希望调用多次该函数，因为非常耗时，对用户不友好，因此首先想出的优化方案就是用一个变量接收该函数值，当 <code>generate_workout</code> 进入条件语句时，便只需要执行一次即可，如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity);</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, res);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这样又会产生一个新的问题：当进入 <code>else</code> 时，随机数值为 3 的时候，是无需执行复杂计算的，这时候用一个变量接收该复杂计算的函数值便会显得浪费。我们真正希望的是，函数定义单独在一个地方，等到函数真正被用到时再被执行，这就是闭包的功能。代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>expensive_closure</code> 只是定义了一个匿名函数，并没有执行。当然在条件语句中，该闭包还是执行了两次，对于这里的优化，后面会讲到。</p>
<h3 id="1-3-闭包的类型推断和标注"><a href="#1-3-闭包的类型推断和标注" class="headerlink" title="1.3 闭包的类型推断和标注"></a>1.3 闭包的类型推断和标注</h3><ul>
<li>闭包不要求标注参数和返回值的类型，和函数不同，无需对外暴露接口</li>
<li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li>
<li>可以手动添加类型标注</li>
<li>注意：闭包的定义最终只会为参数/返回值推断出唯一具体的类型</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(Hello));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>变量 <code>s</code> 传给该闭包一个字符串类型，编译器便推断出来闭包中参数 <code>x</code> 是字符串类型，便与其绑定，因此变量 <code>a</code> 再传入一个整型便会报错。</p>
<h3 id="1-4-使用泛型参数和-Fn-Trait-来存储闭包"><a href="#1-4-使用泛型参数和-Fn-Trait-来存储闭包" class="headerlink" title="1.4 使用泛型参数和 Fn Trait 来存储闭包"></a>1.4 使用泛型参数和 Fn Trait 来存储闭包</h3><h4 id="1-4-1-继续解决-1-2-中的例子"><a href="#1-4-1-继续解决-1-2-中的例子" class="headerlink" title="1.4.1 继续解决 1.2 中的例子"></a>1.4.1 继续解决 1.2 中的例子</h4><p>除了创建局部变量存储闭包的值，还有另一种解决方案：</p>
<p>创建一个 struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果。<br>这个模式通常叫做<strong>记忆化（memoization）</strong>或<strong>延迟计算（lazy evaluation）</strong></p>
<p><strong>如何让 struct 持有闭包</strong></p>
<ul>
<li>struct 的定义需要知道所有字段的类型<ul>
<li>需要指明闭包的类型</li>
</ul>
</li>
<li>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</li>
<li>所以需要使用：泛型和 Trait Bound（第10章）</li>
</ul>
<p><strong>Fn Trait</strong></p>
<ul>
<li>Fn traits 由标准库提供</li>
<li>所有的闭包都至少实现了以下 trait 之一：<ul>
<li>Fn</li>
<li>FnMut</li>
<li>FnOnce</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: F,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F&gt; Cacher&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: F) <span class="punctuation">-&gt;</span> Cacher&lt;F&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了一个结构体，该结构体泛型参数要实现 Fn trait，然后为该结构体实现 <code>new</code> 和 <code>value</code> 函数（方法），如果已经执行过该闭包，则返回值，若没有执行过则执行闭包，将值存进结构体变量中。<code>generate_workout</code> 函数实现如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_closure</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-使用缓存器（Cacher）实现的限制"><a href="#1-4-2-使用缓存器（Cacher）实现的限制" class="headerlink" title="1.4.2 使用缓存器（Cacher）实现的限制"></a>1.4.2 使用缓存器（Cacher）实现的限制</h4><ol>
<li>Cacher 实例假定针对不同的参数 arg，value 方法总会得到同样的值<ul>
<li>可以使用 HashMap 代替单个值：<ul>
<li>key: arg 参数</li>
<li>value：执行闭包的结果</li>
</ul>
</li>
</ul>
</li>
<li>只能接收一个 u32 类型的参数和 u32 类型的返回值<ul>
<li>引入两个或多个泛型参数</li>
</ul>
</li>
</ol>
<h3 id="1-5-使用闭包捕获环境"><a href="#1-5-使用闭包捕获环境" class="headerlink" title="1.5 使用闭包捕获环境"></a>1.5 使用闭包捕获环境</h3><h4 id="1-5-1-利用闭包捕获环境中的变量"><a href="#1-5-1-利用闭包捕获环境中的变量" class="headerlink" title="1.5.1 利用闭包捕获环境中的变量"></a>1.5.1 利用闭包捕获环境中的变量</h4><p>闭包可以捕获他们所在的环境</p>
<ul>
<li>闭包可以访问定义它的作用域内的变量，而普通函数则不能</li>
<li>会产生额外内存开销</li>
</ul>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure>
<p>上述代码中，闭包内的变量 <code>x</code> 并不是在闭包内定义的，但是却可以访问，因为闭包可以捕获和其在<strong>同一作用域内</strong>的其他变量，而函数却没有这样的作用。</p>
<p><strong>闭包从所在环境捕获值的方式</strong></p>
<p>与函数获得参数的三种方式一样：</p>
<ul>
<li>取得所有权：<code>FnOnce</code></li>
<li>可变借用：<code>FnMut</code></li>
<li>不可变借用： <code>Fn</code></li>
</ul>
<p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 frait：</p>
<ul>
<li>所有的闭包都实现了 FnOnce</li>
<li>没有移动捕获变量的实现了 FnMut</li>
<li>无需可变访问捕获变量的闭包实现了 Fn</li>
</ul>
<p>注：实现了 <code>Fn trait</code> 的闭包一定实现了 <code>Fn Mut</code>，实现了 <code>Fn Mut</code> 一定实现了 <code>Fn Once</code>。</p>
<h4 id="1-5-2-move-关键字"><a href="#1-5-2-move-关键字" class="headerlink" title="1.5.2 move 关键字"></a>1.5.2 move 关键字</h4><p>在参数列表前使用 move 关键字，可以强制闭包取得它所使用的环境值的所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p>
<p>例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here：&#123;:?&#125;&quot;</span>, x);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure>
<p>这里便不能使用 <code>x</code> 变量了。</p>
<p><strong>最佳实践</strong><br>当指定 Fn trait bound 之一时，首先用 Fn，基于闭包体里的情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你。<br>（面向编译器编程实锤 o_O）</p>
<h2 id="二、迭代器"><a href="#二、迭代器" class="headerlink" title="二、迭代器"></a>二、迭代器</h2><p><strong>什么是迭代器</strong></p>
<ul>
<li>迭代器模式：对一系列项执行某些任务</li>
<li>迭代器负责：<ul>
<li>遍历每个项</li>
<li>确定序列（遍历）何时完成</li>
</ul>
</li>
</ul>
<p><strong>Rust 的迭代器：</strong></p>
<ul>
<li>懒惰的：除非调用消费迭代器的方法，否则迭代器本身没有任何效果。</li>
</ul>
<p>先用一个最简单的迭代器的例子来进入本节的学习：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">9</span>, <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run   </span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Got: <span class="number">3</span></span><br><span class="line">Got: <span class="number">9</span></span><br><span class="line">Got: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-Iterator-trait-和-next-方法"><a href="#2-1-Iterator-trait-和-next-方法" class="headerlink" title="2.1 Iterator trait 和 next 方法"></a>2.1 Iterator trait 和 next 方法</h3><ul>
<li>所有迭代器都实现了 Iterator trait</li>
<li>Iterator trait 定义于标准库，定义大致如下</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ltem</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::tem&gt;;</span><br><span class="line">        <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>type Item 和 Self::Item 定义了与此该 trait 关联的类型<ul>
<li>实现 Iterator trait 需要你定义一个 Item 类型，它用于 next 方法的返回类型（迭代器的返回类型）</li>
</ul>
</li>
</ul>
<p><strong>Iterator trait 仅要求实现一个方法：next</strong></p>
<ul>
<li>next:<ul>
<li>每次返回迭代器中的一项</li>
<li>返回结果包裹在 Some 里</li>
<li>迭代结束，返回 None</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter_mut</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">9</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">100</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v1_iter_mut.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure>
<p>上述的例子要定义一个可变的迭代器，因为 <code>next</code> 方法会更改迭代器内部的用来标示顺序的某些值，而上面的 for 之所以不用定义迭代器为可变，是因为用 for 来进行循环，实际上是取得了该迭代器的所有权，在其内部已经将其变成可变的了。</p>
<p>需要注意的是，next 方法是一种消耗型行为，我们最后输出了迭代器 <code>v1_iter_mut</code> 的长度，结果为 0。</p>
<p><strong>几个迭代方法</strong></p>
<ul>
<li>iter 方法：在不可变引用上创建迭代器</li>
<li>into_iter 方法：创建的迭代器会获得所有权</li>
<li>iter_mut 方法：迭代可变的引用</li>
</ul>
<h3 id="2-2-消耗-产生迭代器"><a href="#2-2-消耗-产生迭代器" class="headerlink" title="2.2 消耗/产生迭代器"></a>2.2 消耗/产生迭代器</h3><h4 id="2-2-1-消耗迭代器的方法"><a href="#2-2-1-消耗迭代器的方法" class="headerlink" title="2.2.1 消耗迭代器的方法"></a>2.2.1 消耗迭代器的方法</h4><ul>
<li>在标准库中，Iterator trait 有一些带默认实现的方法</li>
<li>其中有一些方法会调用 next 方法<ul>
<li>实现 Iterator frait 时必须实现 nex† 方法的原因之一</li>
</ul>
</li>
<li>调用 next 的方法叫做“消耗型适配器”<ul>
<li>因为调用它们会把迭代器消耗尽</li>
</ul>
</li>
<li>例如：sum 方法（就会耗尽迭代器）<ul>
<li>取得迭代器的所有权</li>
<li>通过反复调用 next，遍历所有元素</li>
<li>每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>sum</code> 的时候要注意显示声明类型。</p>
<h4 id="2-2-2-产生其它迭代器的方法-map"><a href="#2-2-2-产生其它迭代器的方法-map" class="headerlink" title="2.2.2 产生其它迭代器的方法(map)"></a>2.2.2 产生其它迭代器的方法(map)</h4><ul>
<li>定义在 Iterator trait 上的另外一些方法叫做“迭代器适配器”<ul>
<li>把迭代器转换为不同种类的迭代器</li>
</ul>
</li>
<li>可以通过链式调用使用多个迭代器适配器来执行复杂的操作，这种调用可读性较高。</li>
<li>例如：map<ul>
<li>接收一个闭包，闭包作用于每个元素</li>
<li>产生一个新的迭代器</li>
</ul>
</li>
<li>collect 方法：消耗型适配器，把结果收集到一个集合类型中</li>
</ul>
<p>例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用闭包捕获环境-filter"><a href="#2-3-使用闭包捕获环境-filter" class="headerlink" title="2.3 使用闭包捕获环境(filter)"></a>2.3 使用闭包捕获环境(filter)</h3><ul>
<li>filter 方法：<ul>
<li>接收一个闭包</li>
<li>这个闭包在遍历迭代器的每个元素时，返回 bool 类型</li>
<li>如果闭包返回 true：当前元素将会包含在 filter 产生的迭代器中</li>
<li>如果闭包返回 false：当前元素将不会包含在 filter 产生的迭代器中</li>
</ul>
</li>
</ul>
<p>我们现在实现一个功能，取出一个迭代器中所有为偶数的元素，将取出的元素再放入一个新的迭代器，例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一点要注意：<code>iter</code> 方法里的元素都是引用类型，且不可变，因此若要进行 <code>x % 2 == 0</code> 操作的话，需要解引用 <code>*x</code>。上述代码中使用 <code>into_iter</code> 方法获得了迭代器中元素的所有权。</p>
<h3 id="2-4-创建自定义迭代器"><a href="#2-4-创建自定义迭代器" class="headerlink" title="2.4 创建自定义迭代器"></a>2.4 创建自定义迭代器</h3><p><strong>使用 Iterator frait 来创建自定义迭代器</strong></p>
<ul>
<li>实现 next 方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123;count: <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子很容易理解，就是通过 <code>next</code> 方法不断迭代，范围是 1-5，至于为 Counter 实现 Iterator 特征，将来会介绍。</p>
<p>下面要对迭代器的需求进行改进，有两个迭代器，第一个迭代器就是上面所说的，第二个迭代器的元素是 <code>[2, 3, 4, 5]</code>，现在要求将两个迭代器中的元素按顺序相乘，然后将结果存入一个新的迭代器，然后过滤出能被 3 整除的数，并求和。</p>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>介绍一下 <code>zip</code> 方法，这个单词本意是“拉链”，这里表示将两个迭代器“捏到一起”，形成一个新的迭代器，里面的每个元素就是一个元组 ，这个元组里有两个元素，这两个元素分别来自原来的两个迭代器。这里第一个迭代器就是通过 <code>Counter::new()</code> 得到的，第二个迭代器就是 <code>zip()</code> 方法内的参数 <code>Counter::new().skip(1)</code>，表示跳过第一个元素后剩下的元素组成的迭代器。</p>
<p>为了更好展示每一个方法的实现过程，我们运行</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v1);</span><br></pre></td></tr></table></figure>
<p>对于上例中的两个初始化后的迭代器，输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.20</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Zip &#123; a: Counter &#123; count: <span class="number">0</span> &#125;, b: Skip &#123; iter: Counter &#123; count: <span class="number">0</span> &#125;, n: <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>再来看官方文档中的实例就更清楚了：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a1</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span> = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = a1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(a2.<span class="title function_ invoke__">iter</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">1</span>, &amp;<span class="number">4</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">2</span>, &amp;<span class="number">5</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">3</span>, &amp;<span class="number">6</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-5-优化第十章的-I-O-项目"><a href="#2-5-优化第十章的-I-O-项目" class="headerlink" title="2.5 优化第十章的 I/O 项目"></a>2.5 优化第十章的 I/O 项目</h3><p>项目具体内容请参考 <a href="Rust入门教程（十）.md">Rust入门教程（十）</a></p>
<h4 id="2-5-1-利用迭代器优化-new-函数"><a href="#2-5-1-利用迭代器优化-new-函数" class="headerlink" title="2.5.1 利用迭代器优化 new 函数"></a>2.5.1 利用迭代器优化 new 函数</h4><p>我们来看一下 <code>minigrep</code> 项目中 <code>Config</code> 函数的 <code>new()</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>new()</code> 函数中，传入的参数是字符串切片，为了返回 <code>Config</code> 结构体，需要获得命令行参数这两个变量的所有权，之前的解决方法是将那两个参数进行克隆，但是这样会对性能带来一定的损耗。现在我们学习完了闭包和迭代器，便可以通过迭代器获取其实例，并且可以使用迭代器所带的一些方法进行长度检查和索引。通过迭代器的 <code>next</code> 方法，便将读取具体值的功能分离了出去。</p>
<p>原来的 <code>main</code> 函数中，通过 <code>env::args().collect()</code> 将参数列表转化成 vector，然后将这个 vector 传到 <code>new()</code> 函数中，其实 <code>env::args()</code> 返回的就是迭代器，我们直接把它当做 <code>new()</code> 的参数即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改过后的 <code>main</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过后的 <code>new()</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取要查询的字符串参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取文件名参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-利用迭代器优化-search-函数"><a href="#2-5-2-利用迭代器优化-search-函数" class="headerlink" title="2.5.2 利用迭代器优化 search 函数"></a>2.5.2 利用迭代器优化 search 函数</h4><p>原来的 <code>search()</code> 函数实现如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现思路是先将文本内容每一行取出来，然后手动遍历，判断当前行是否包含所要查询的字符串，将结果放入新的 vector 中，最后返回这个 vector。但是学完了迭代器适配器的知识点后，应该很容易想到 <code>filter</code> 这个方法。实现如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query)).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理 <code>search_case_insensitive</code> 修改如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_uppercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query.<span class="title function_ invoke__">to_uppercase</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们将原来的七行代码简化成了一行，这一行代码和之前的七行实现的功能是相同的，但是显然利用迭代器实现的这一行代码更加易读（熟悉了迭代器的使用之后，这种写法会非常简单），不仅从代码，减少了临时变量，同时消除了可变状态 <code>result</code>，这样可以使得将来通过并行来提升搜索效率，因为并行时不用再考虑并发访问 <code>result</code> 这个变量时会出现的安全问题了。</p>
<p>实际上，对于大多数 Rust 程序员会更喜欢使用迭代器这样的方式来实现，因为这样可以更加专注于实现逻辑本身，而不是总是浪费时间在大量的循环和维护临时变量这些细节工作上。至于两者的效率问题，并非像表面上那样，使用迭代器效率会降低，具体的我们下节再介绍。</p>
<h3 id="2-6-性能比较：循环-vs-迭代器"><a href="#2-6-性能比较：循环-vs-迭代器" class="headerlink" title="2.6 性能比较：循环 vs 迭代器"></a>2.6 性能比较：循环 vs 迭代器</h3><p><strong>零开销抽象 Zero-Cost Abstraction</strong></p>
<ul>
<li>使用抽象时不会引入额外的运行时开销</li>
</ul>
<p>对于迭代器，编译器会自行判断底层代码展开策略，对于某些特定次数的循环，编译器底层会手动将迭代器展开特定的次数，这样对于流水线 CPU 来说，会减少因跳转或延迟槽产生的停顿周期，使得流水线的吞吐量增大，从而使得效率提高。</p>
<p>因此在 Rust 中，尽量使用迭代器实现。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（十三）：智能指针</title>
    <url>/e9389bfa.html</url>
    <content><![CDATA[<blockquote>
<p>指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 <code>&amp;</code> 了，没有其他开销。<br>智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、智能指针介绍"><a href="#一、智能指针介绍" class="headerlink" title="一、智能指针介绍"></a>一、智能指针介绍</h2><p><strong>引用和智能指针的区别</strong></p>
<ul>
<li>智能指针往往基于结构体实现</li>
<li>引用只借用数据，而智能指针很多时候拥有其指向的数据</li>
</ul>
<p><strong>智能指针的例子</strong></p>
<ul>
<li><code>String</code> 和 <code>Vec&lt;T&gt;</code></li>
<li>都拥有一片内存区域，且允许用户对其操作</li>
<li>还拥有元数据（例如容量等）</li>
<li>提供额外的功能保障（String 保证其是合法的 UTF-8 数据）</li>
</ul>
<p><strong>智能指针的实现</strong></p>
<ul>
<li>智能指针通常使用 struct 实现，并且实现了 <code>Deref</code> 和 <code>Drop</code> 这两个 trait</li>
<li><code>Deref trait</code>：允许智能指针 struct 的实例像引用一样使用</li>
<li><code>Drop trait</code>：允许你自定义当智能指针实例走出作用域时的代码</li>
</ul>
<p><strong>本章内容</strong></p>
<ul>
<li>介绍标准库中常见的智能指针<ul>
<li><code>Box&lt;T&gt;</code>：在 heap内存上分配值</li>
<li><code>Rc&lt;T&gt;</code>：启用多重所有权的引用计数类型</li>
<li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCelk&lt;T&gt;</code> 访问：在运行时而不是编译时强制借用规则的类型</li>
</ul>
</li>
<li>此外</li>
<li>内部可变模式（interior mutability pattern）：不可变类型暴露出可修改其内部值的 API</li>
<li>引用循环（reference cycles）：它们如何泄露内存，以及如何防止其发生</li>
</ul>
<h2 id="二、使用-Box"><a href="#二、使用-Box" class="headerlink" title="二、使用 Box\"></a>二、使用 Box\<T></T></h2><h3 id="2-1-Box"><a href="#2-1-Box" class="headerlink" title="2.1 Box\"></a>2.1 Box\<T></T></h3><p><code>Box&lt;T&gt;</code> 是最简单的智能指针</p>
<ul>
<li>允许你在 heap 上存储数据（而不是 stack）</li>
<li>stack 上是指向 heap 数据的指针</li>
<li>没有性能开销</li>
<li>没有其它额外功能</li>
<li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code></li>
</ul>
<h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><ul>
<li>在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小</li>
<li>当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制</li>
<li>使用某个值时，你只关心它是否实现了特定的 trait，而不关心它的具体类型</li>
</ul>
<h4 id="2-2-1-Box-如何在-heap-上存储数据"><a href="#2-2-1-Box-如何在-heap-上存储数据" class="headerlink" title="2.2.1 Box\ 如何在 heap 上存储数据"></a>2.2.1 Box\<T> 如何在 heap 上存储数据</T></h4><p>来看一段简单的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不用 <code>Box</code>，那么就会在栈中创建一个变量 x，而使用了 <code>Box</code> 就会在 heap 上创建一个变量。在变量 x 走出作用域时，变量 x 在 stack 上的指针和在 heap 上的值都会被释放。</p>
<h4 id="2-2-2-使用-Box-赋能递归类型"><a href="#2-2-2-使用-Box-赋能递归类型" class="headerlink" title="2.2.2 使用 Box 赋能递归类型"></a>2.2.2 使用 Box 赋能递归类型</h4><p>比如有这样一个枚举</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Cons 变体，里面有一个他类型本身（List），这样就会一直递归下去。但是在编译时，Rust 需要知道一个类型所占的空间大小，而这样的递归类型无法确定其大小。在递归类型中使用 Box 就可以解决上述问题。这也是函数式语言中的 Cons List</p>
<p><strong>关于 Cons List</strong></p>
<p>Cons List 是来自 Lisp 语言的一种数据结构。Cons List里每个成员由两个元素组成：</p>
<ul>
<li>当前项的值</li>
<li>下一个元素</li>
</ul>
<p>Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素。<strong>实际上就是 Rust 中的一种链表</strong>，但他并不是 Rust 的常用集合。</p>
<p><strong>Rust 如何确定非递归类型所占用的大小的？</strong></p>
<p>实际上是取结构体或枚举下最大空间的变体的大小作为整个结构体或枚举的大小（非常类似于 C 语言中的联合体 Union）。</p>
<p>因此最终应将代码改成</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, </span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 Box 来获得确定大小的递归类型</strong></p>
<ul>
<li><code>Box&lt;T&gt;</code> 是一个指针，Rust 知道它需要多少空间，因为<ul>
<li>指针的大小不会基于它指向的数据的大小变化而变化</li>
</ul>
</li>
<li>Box<T>:<ul>
<li>只提供了“间接”存储和 heap 内存分配的功能</li>
<li>没有其它额外功能</li>
<li>没有性能开销</li>
<li>适用于需要“间接”存储的场景，例如 Cons List</li>
<li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code><ul>
<li><code>Deref trait</code>：可以将 Box 的值当做引用来处理</li>
<li><code>Drop trait</code>：定义了当 Box 值走出作用域时，清理掉栈上的指针和堆上的数据</li>
</ul>
</li>
</ul>
</T></li>
</ul>
<h2 id="三、Deref-trait"><a href="#三、Deref-trait" class="headerlink" title="三、Deref trait"></a>三、Deref trait</h2><p><code>Deref</code> 就是 <code>dereference</code> 解引用的意思。</p>
<ul>
<li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符 <code>*</code> 的行为</strong></li>
<li>通过实现 Deref，智能指针可像常规引用一样来处理</li>
</ul>
<h3 id="3-1-解引用运算符"><a href="#3-1-解引用运算符" class="headerlink" title="3.1 解引用运算符"></a>3.1 解引用运算符</h3><p>常规引用也是指针。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*y, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有什么好解释的，和 C 语言一样，<code>*y</code> 表示解引用变量 y。</p>
<h3 id="3-2-定义自己的智能指针"><a href="#3-2-定义自己的智能指针" class="headerlink" title="3.2 定义自己的智能指针"></a>3.2 定义自己的智能指针</h3><p><code>Box&lt;T&gt;</code> 被定义成拥有一个元素的 tuple struct。下面来定义自己的 <code>MyBox&lt;T&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看定义，<code>MyBox&lt;T&gt;</code> 实际上就是一个有名称的元组（tuple），这个元组里只有一个元素。</p>
<p>再看第二个断言，这里的 <code>*y</code> 会报错 <code>type &#39;MyBox&lt;&#123;integer&#125;&gt;&#39; cannot be dereferenced</code>，表示 <code>MyBox</code> 类型不能被解引用，这是因为 <code>MyBox</code> 没有实现 <code>Deref trait</code>。</p>
<p>标准库中的 <code>Deref trait</code> 要求我们实现一个 <code>deref</code> 方法</p>
<ul>
<li>该方法借用 self</li>
<li>返回一个指向内部数据的引用</li>
</ul>
<p>因此我们为 <code>MyBox</code> 实现 <code>Deref</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>type Target = T;</code> 类似于 C 语言中的 <code>typedef struct Person &#123;&#125; P</code>？</p>
<p>而 <code>*y</code> 实际上是 <code>*(y.deref())</code>，调用 <code>*</code> 之前，先执行 <code>deref</code> 取引用，然后通过 <code>*</code> 运算符解引用。</p>
<h3 id="3-3-隐式解引用转化"><a href="#3-3-隐式解引用转化" class="headerlink" title="3.3 隐式解引用转化"></a>3.3 隐式解引用转化</h3><ul>
<li>隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性。</li>
<li>假设 T 实现了 Deref trait：<ul>
<li>Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li>
</ul>
</li>
<li>当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配<ul>
<li>Deref Coercion 就会自动发生</li>
<li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li>
<li>在编译时完成，没有额外性能开销</li>
</ul>
</li>
</ul>
<p>在上面实现 <code>MyBox</code> 和 <code>Deref</code> 的前提下，增加以下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要分析 <code>hello</code> 函数中传入的参数类型，是一个字符串切片类型，而 <code>m</code> 是一个实现了 <code>Deref</code> 的结构体类型，但是为什么能传入 <code>&amp;m</code> 呢？</p>
<p>首先 <code>m</code> 的类型是 <code>MyBox&lt;String&gt;</code>，那么 <code>&amp;m</code> 的类型就是 <code>&amp;MyBox&lt;String&gt;</code>，由于 <code>MyBox</code> 实现了 <code>Deref</code> 方法，因此 Rust 可以调用 <code>deref()</code> 方法，来将 <code>MyBox&lt;String&gt;</code> 的引用转化成 <code>String</code> 的引用。然而在标准库中，<code>String</code> 也实现了 <code>Deref</code> 这个 trait，它返回的是一个字符串切片 <code>&amp;str</code>，因此 Rust 会继续调用 <code>deref()</code>，最终返回一个字符串切片的类型。</p>
<p>而如果 Rust 没有解引用转化功能，则参数应该这样传：<code>hello(&amp;(*m)[..]);</code>，而这却相当繁琐。只要类型实现了 <code>Deref</code> 这个 trait，Rust 就会自动分析类型，并不断尝试调用 <code>deref()</code> 方法来让其与函数或方法签名中的参数类型匹配，而这一切都在编译时执行，因此运行时不会产生额外的性能开销。</p>
<p><strong>解引用与可变性</strong></p>
<ul>
<li>可使用 <code>DerefMut trait</code> 重载可变引用的 <code>*</code> 运算符</li>
<li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code>（即类型 <code>T</code> 实现了 <code>Deref trait</code>，而 <code>deref</code> 方法返回的类型是 <code>U</code>，那么 <code>T</code> 的引用可以转化为 <code>U</code> 的引用）</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code>（反过来不成立，即不能将不可变引用转化为可变引用，违反借用规则）</li>
</ul>
</li>
</ul>
<h2 id="四、Drop-trait"><a href="#四、Drop-trait" class="headerlink" title="四、Drop trait"></a>四、Drop trait</h2><ul>
<li>实现 <code>Drop trait</code>，可以让我们自定义<strong>当值将要离开作用域的时候发生的动作</strong><ul>
<li>例如文件、网络资源的释放等</li>
<li>任何类型都可以实现 <code>Drop trait</code></li>
</ul>
</li>
<li><code>Drop trait</code> 只要求实现 <code>drop</code> 方法，其参数是对 <code>self</code> 的可变引用</li>
<li><code>Drop trait</code> 在预导入模块中，无需手动导入</li>
</ul>
<p>（个人理解：和 C++ 中的析构函数有点类似）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为如下，注意输出顺序（变量声明顺序为 s1，s2，Drop 顺序为 s2，s1）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br></pre></td></tr></table></figure>
<p>使用 <code>std::mem::drop</code> 来提前 drop 值</p>
<ul>
<li>很难直接禁用自动的 drop 功能，也没必要</li>
<li>Drop trait 的目的就是进行自动的释放处理逻辑</li>
<li>Rust 不允许手动调用 Drop trait 的 drop 方法</li>
<li>若要强行使用 <code>a.drop()</code> 这样来调用，会提示 <code>explicit destructor calls not allowed</code>，然后后面给的帮助是考虑使用 <code>drop(a)</code></li>
<li>但可以调用标准库中的 <code>std::mem::drop</code> 函数提前 <code>drop</code> 值</li>
</ul>
<p>我们手动 <code>drop</code> 一下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br></pre></td></tr></table></figure>
<p>尽管手动调用了 <code>drop</code> 函数，但是和 <code>drop</code> 方法并不会冲突，不会重复释放同一块内存，设计 Rust 语言的时候显然已经考虑到了这一点。</p>
<h2 id="五、Rc-：引用计数智能指针"><a href="#五、Rc-：引用计数智能指针" class="headerlink" title="五、Rc\：引用计数智能指针"></a>五、Rc\<T>：引用计数智能指针</T></h2><p>通常情况下，Rust 的所有权都是很清晰的，但是在某些场景中，单个值可能同时被多个所有者持有。例如一个图的数据结构，一个结点有多条边相连，那么这个结点就应该属于所有与其相连的边，只有当所有指向它的边都释放掉，该结点才会被清理，这就是多重所有权。</p>
<p>在 Rust 中，为了支持多重所有权，便有了 <code>Rc&lt;T&gt;</code>，即 <code>reference count（引用计数）</code>，这个类型会在实例的内部维护一个用于记录引用次数的计数器，从而判断该值是否仍然被使用，可以追踪所有对其的引用。若引用个数为 0，那么该值就会被清理掉，不会发生引用失效的问题。</p>
<h3 id="5-1-使用场景及实例"><a href="#5-1-使用场景及实例" class="headerlink" title="5.1 使用场景及实例"></a>5.1 使用场景及实例</h3><ul>
<li>需要在 heap 上分配数据，这写数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据</li>
<li>若在编译时能够确定哪个部分最后使用完这些数据，那么直接将这个部分程序成为这些数据的所有者即可，这样就只需要靠编译时期所有权规则，就可以保证程序的正确性</li>
<li><code>Rc&lt;T&gt;</code> 只能用于单线程场景，后面会介绍如何在多线程场景中使用引用计数</li>
<li><code>Rc&lt;T&gt;</code> 不在预导入模块中，需要手动导入 <code>use sstd::rc::Rc</code></li>
<li><code>Rc::clone(&amp;a)</code> 函数：增加引用计数</li>
<li><code>Rc::strong_count(&amp;a)</code>：获得引用计数</li>
<li>还有 <code>Rc::weak_count</code>函数</li>
</ul>
<p>例子如下：</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220709214558.png" alt="两个List共享所有权"></p>
<p>要实现两个 List 共享一个 List 的所有权。先看下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明变量 c 处，会报错，提示不能使用被移动的值 <code>use of moved value: &#39;a&#39;</code>。因为在声明 b 时，变量 a 的所有权已经移交给了 b。我们可以改变 <code>Cons</code> 的定义，让其持有 <code>List</code> 的引用而不是所有权，并为其指定声明周期参数，这个生命周期要求 <code>List</code> 中的所有元素的存活时间至少要和 <code>List</code> 本身一样。因此借用检查器会阻止我们编译这样的代码：<code>let a = Cons(1, &amp;Nil)</code>，因为这里 <code>Nil</code> 这个变体值会在 <code>a</code> 取得其引用前就被丢弃。</p>
<p>另一种办法就是将 <code>Box</code> 换成 <code>Rc</code>。如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 a 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 b 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;创建 c 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c 离开作用域后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出结果为<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">创建 a 后的的强引用计数为 <span class="number">1</span></span><br><span class="line">创建 b 后的的强引用计数为 <span class="number">2</span></span><br><span class="line">创建 c 后的的强引用计数为 <span class="number">3</span></span><br><span class="line">c 离开作用域后的的强引用计数为 <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>其实在 <code>Rc&lt;T&gt;</code> 这个类型上也有一个 <code>clone</code> 方法，和 <code>Rc::clone()</code> 的区别是，后者不会对数据进行深拷贝，只会增加引用计数，速度较快。而前者是类型上的 <code>clone</code> 方法，会进行深拷贝，拷贝对象本身，比较耗时。同时 <code>Rc&lt;T&gt;</code> 也实现了 <code>Drop</code> 这个 trait，因此当变量离开作用域时，引用计数会自动减少一。</p>
<p>在 <code>Rc&lt;T&gt;</code> 中，通过不可变引用，使你在程序不同部分之间共享只读数据，若共享的引用可变，将会违反 Rust 的借用规则，即多个指向同一区域的可变引用会导致数据竞争以及数据的不一致。但是在某些情况下，让其共享的数据可变也是非常重要的，这就需要使用 <code>RefCell&lt;T&gt;</code>。</p>
<h3 id="5-2-RefCell-和内部可变性"><a href="#5-2-RefCell-和内部可变性" class="headerlink" title="5.2 RefCell\ 和内部可变性"></a>5.2 RefCell\<T> 和内部可变性</T></h3><p>内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改，数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则，使其可变的借用一个不可变的值。</p>
<p>先来回忆一下 Rust 的借用规则：在任何给定的时刻，要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用，且引用总是有效的。</p>
<p>与 <code>Rc&lt;T&gt;</code> 不同，<code>RefCell&lt;T&gt;</code> 类型代表了其持有数据的唯一所有权。而 <code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 的区别是：前者只会在<strong>运行时</strong>检查借用规则，否则触发 panic；而后者在编译阶段就要强制代码遵守借用规则，否则出现错误，编译不通过。</p>
<p><strong>借用规则在不同阶段进行检查的比较</strong></p>
<ul>
<li>编译阶段<ul>
<li>尽早暴露问题</li>
<li>没有运行时的开销</li>
<li>对大多数场景是最佳选择</li>
<li>是 Rust 的默认行为</li>
</ul>
</li>
<li>运行时<ul>
<li>问题暴露延迟，甚至到生产环境</li>
<li>因为借用计数器而导致性能的损失</li>
<li>实现某些特定的内存安全场景（不可变环境中修改自身数据）</li>
</ul>
</li>
</ul>
<p>实际上 Rust 编译器是比较保守的，有些代码并不是在编译阶段就能分析明白，针对这些代码，Rust 编译器是无法完成分析的，因此编译器就会简单的拒绝所有不符合所有权规则的代码，哪怕这些代码并没有任何问题，这就是 Rust 编译器的保守性。因为一旦 Rust 将某一段有问题的程序通过了，那么 Rust 对安全性的保证将直接破产，尽管拒绝掉某些正确的代码会对开发者带来不便，但是至少不会在生产中带来灾难性的后果。针对 Rust 编译器无法分析的代码，如果开发者能够确保代码能够满足借用规则，这时候就要用到 <code>RefCell&lt;T&gt;</code> 了。</p>
<p>和 <code>Rc&lt;T&gt;</code> 一样 <code>RefCell&lt;T&gt;</code> 只能用于单线程的场景。</p>
<ul>
<li><code>Box&lt;T&gt;</code><ul>
<li>同一个数据只有一个所有者</li>
<li>可变和不可变借用，在编译时检查</li>
</ul>
</li>
<li><code>Rc&lt;T&gt;</code><ul>
<li>同一个数据可以有多个所有者</li>
<li>不可变借用，在编译时检查</li>
</ul>
</li>
<li><code>RefCell&lt;T&gt;</code><ul>
<li>同一个数据只有一个所有者</li>
<li>可变和不可变借用，在运行时检查</li>
<li>其中，即使 <code>RefCell&lt;T&gt;</code> 本身不可变，但是仍能修改其中存储的值</li>
</ul>
</li>
</ul>
<p>对于内部可变性，可以可变的借用一个不可变的值。在某些情况下，我们需要一个值，它对外部是不可变的，但能在方法内部修改自身的值，除了这个值本身的方法，其他的方法都不能修改这个值，<code>RefCell&lt;T&gt;</code> 正是获得这种内部可变性的一种方法。但是这种方法并没有完全绕开借用规则，只是通过内部可变性通过了编译检查，但是借用检查也只是从编译阶段延后到运行阶段，如果运行阶段仍然违反了借用规则，那么将会 panic，而不是编译错误。</p>
<p><strong>使用 <code>RefCell&lt;T&gt;</code> 在运行时记录借用信息</strong></p>
<ul>
<li><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针：<ul>
<li>每次调用 borrow：不可变借用计数加1</li>
<li>任何一个 <code>Ref&lt;T&gt;</code> 的值离开作用域被释放时：不可变借用计数减 1</li>
<li>每次调用 <code>borrow_mut</code>：可变借用计数加1</li>
<li>任何一个 <code>RefMut&lt;T&gt;</code> 的值离开作用域被释放时：可变借用计数减 1</li>
</ul>
</li>
<li>以此技术来维护借用检查规则：<ul>
<li>任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</li>
</ul>
</li>
</ul>
<p><strong>其它可实现内部可变性的类型</strong></p>
<ul>
<li><code>Cell&lt;T&gt;</code>：通过复制来访问数据</li>
<li><code>Mutex&lt;T&gt;</code>：用于实现跨线程情形下的内部可变性模式</li>
</ul>
<h2 id="六、循环引用导致内存泄露"><a href="#六、循环引用导致内存泄露" class="headerlink" title="六、循环引用导致内存泄露"></a>六、循环引用导致内存泄露</h2><h3 id="6-1-Rust-可能发生内存泄漏"><a href="#6-1-Rust-可能发生内存泄漏" class="headerlink" title="6.1 Rust 可能发生内存泄漏"></a>6.1 Rust 可能发生内存泄漏</h3><ul>
<li>Rust 的内存安全机制可以保证很难发生内存泄漏，但不是不可能</li>
<li>例如使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 就可能创造出循环引用，从而发生内存泄漏：<ul>
<li>每个项的引用数量不会变成 0，值也不会被处理掉</li>
</ul>
</li>
</ul>
<p>例子如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test02</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item is &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item is &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;a next item is &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建 <code>a</code>，<code>Cons</code> 第一个元素是 5，第二个元素是 <code>Nil</code>，然后输出 a 的强引用，输出 a 的 <code>Cons</code> 的第二个元素。同理创建 b，<code>Cons</code> 第一个元素是 10，第二个元素引用 a，然后输出此时 a 的强引用和 b 的强引用。</p>
<p>这个时候将 a 的 Cons 第二个元素改成 b 的引用，即这个 List 的 a 和 b 收尾相连了，形成了一个类似于循环链表的结构。这时我们观察输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.25</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">a initial rc count is <span class="number">1</span></span><br><span class="line">a next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation is <span class="number">2</span></span><br><span class="line">b initial rc count is <span class="number">1</span></span><br><span class="line">b next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">a rc count after changing a is <span class="number">2</span></span><br><span class="line">b rc count after changing a is <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>收尾相连后 a 和 b 的强引用计数都是 2（很显然）。但是这个时候如果要输出 a 的下一个元素，就会发生栈溢出。因为 a 和 b 形成了循环，a 的下一个元素是 b，但是 b 中又包含 a，a 中又包含 b… 如此往复，b 的大小其实是无穷大的，因此会导致<strong>栈溢出</strong>。取消上面的注释行，再次运行，会得到下面的结果：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">...RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; </span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; has overflowed its stack</span><br><span class="line">fatal runtime error: stack overflow</span><br><span class="line">[<span class="number">1</span>]    <span class="number">28287</span> abort      cargo run</span><br></pre></td></tr></table></figure>
<h3 id="6-2-防止内存泄漏的解决办法"><a href="#6-2-防止内存泄漏的解决办法" class="headerlink" title="6.2 防止内存泄漏的解决办法"></a>6.2 防止内存泄漏的解决办法</h3><ul>
<li>依靠开发者来保证，不能依靠 Rust</li>
<li>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权<ul>
<li>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</li>
<li>而只有所有权关系才影响值的清理</li>
</ul>
</li>
</ul>
<p><strong>防止循环引用把 <code>Rc&lt;T&gt;</code> 换成 <code>Weak&lt;T&gt;</code></strong></p>
<ul>
<li><code>Rc::clone</code> 为 <code>Rc&lt;T&gt;</code> 实例的 strong_count 加 1，<code>Rc&lt;T&gt;</code> 的实例只有在 strong_count 为 0 的时候才会被清理</li>
<li><code>Rc&lt;T&gt;</code> 实例通过调用 <code>Rc::downgrade</code> 方法可以创建值的 Weak Reference（弱引用）<ul>
<li>返回类型是 <code>Weak&lt;T&gt;</code>（智能指针）</li>
<li>调用 <code>Rc::downgrade</code> 会为 weak_count 加1</li>
</ul>
</li>
<li><code>Rc&lt;T&gt;</code> 使用 weak_count 来追踪存在多少 <code>Weak&lt;T&gt;</code></li>
<li>weak_count 不为 0 并不影响 <code>Rc&lt;T&gt;</code> 实例的清理</li>
</ul>
<p><strong>Strong vs Weak</strong></p>
<ul>
<li>Strong Reference（强引用）是关于如何分享 <code>Rc&lt;T&gt;</code> 实例的所有权</li>
<li>Weak Reference（弱引用）并不表达上述意思</li>
<li>使用 Weak Reference 并不会创建循环引用：<ul>
<li>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</li>
</ul>
</li>
<li>在使用 <code>Weak&lt;T&gt;</code> 前，需保证它指向的值仍然存在：<ul>
<li>在 <code>Weak&lt;T&gt;</code> 实例上调用 <code>upgrade</code> 方法，返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="6-3-实现树的数据结构的例子"><a href="#6-3-实现树的数据结构的例子" class="headerlink" title="6.3 实现树的数据结构的例子"></a>6.3 实现树的数据结构的例子</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个叶子结点值为 3，该叶子结点没有孩子结点，再创建一个分支结点，作为叶节点 3 的父节点。此时该叶子结点拥有两个强引用，即叶子结点本身和父节点拥有该叶子结点的所有权。我们可以通过分支结点访问到叶节点，因为他拥有叶节点的引用（这里也是所有权），而叶子结点无法访问到父节点，因为他没有拥有父节点的所有权或引用。</p>
<p>上面这种双向的引用形成了循环引用，这个时候就可以使用 <code>Weak&lt;T&gt;</code> 来避免产生循环引用。</p>
<p>我们修改上面的代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用 leaf 的 parent 字段的 <code>borrow</code> 方法获取其不可变引用，然后通过 <code>upgrade</code> 方法将 <code>Weak&lt;T&gt;</code> 转化成 <code>Rc&lt;T&gt;</code>，然后再调用 leaf 的 parent 字段的 <code>borrow_mut</code> 方法获取其可变引用，然后通过调用 <code>Rc::downgrade</code> 将 branch 里的 <code>Rc&lt;Node&gt;</code> 转化成 <code>Weak&lt;Node&gt;</code> 并存在 leaf.parent 里。</p>
<p>输出结果如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf parent is <span class="title function_ invoke__">Some</span>(Node &#123; value: <span class="number">5</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: <span class="number">3</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>我们通过分别打印 leaf 和 branch 的强弱引用来深入理解一下本小节内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.35</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br><span class="line">leaf strong = <span class="number">2</span>, weak = <span class="number">0</span></span><br><span class="line">branch strong = <span class="number">1</span>, weak = <span class="number">1</span></span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>刚创建 leaf 时，只有一个 leaf 的强引用，没有弱引用。然后在一个新的作用域内创建 branch，将 branch 和 leaf 关联起来，此时 branch 强引用只有一个（branch 自身），弱引用有一个（leaf）。leaf 强引用有两个，自身和 branch。然后 branch 走出了作用域，强引用计数减 1 变成 0，内存被释放，branch 便不存在了，此时通过 leaf 访问 branch 显然为 None，最后再输出 leaf 的强引用为 1，即 leaf 自身。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（十二）：cargo 和 crates.io</title>
    <url>/af9cf945.html</url>
    <content><![CDATA[<blockquote>
<p>本章内容如下：</p>
<ul>
<li>通过 release profle 来自定义构建</li>
<li>在 <a href="https://crates.io/">https://crates.io/</a> 上发布库</li>
<li>通过 workspaces 组织大工程</li>
<li>从 <a href="https://crates.io/">https://crates.io/</a> 来安装库</li>
<li>使用自定义命令扩展 cargo</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="一、通过-release-profle-来自定义构建"><a href="#一、通过-release-profle-来自定义构建" class="headerlink" title="一、通过 release profle 来自定义构建"></a>一、通过 release profle 来自定义构建</h2><p><strong>release profile（发布配置）</strong></p>
<ul>
<li>是预定义的</li>
<li>可自定义：可使用不同的配置，对代码编译拥有更多的控制</li>
<li>每个 profile 的配置都独立于其它的 profile</li>
<li>Cargo 主要的两个 profile<ul>
<li>dev profile：适用于开发，cargo build</li>
<li>release profile：适用于发布，cargo build —release</li>
</ul>
</li>
</ul>
<p><strong>自定义 profile</strong></p>
<ul>
<li>针对每个 profle，Cargo 都提供了默认的配置</li>
<li>如果想自定义 xxxx profile 的配置<ul>
<li>可以在 Cargo.toml 里添加 <code>[profile.xxxx]</code> 区域，在里面覆盖默认配置的子集</li>
</ul>
</li>
</ul>
<p>例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[profile. dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>opt-level</code> 表示编译优化等级，在开发模式下，一般希望有较快的编译速度，因此编译优化等级较低。而在发布模式下，需要多次运行程序，因此希望有较高等级的优化，从而用较长的编译时间换取较短的运行时间。</p>
<p>对于每个配置的默认值和完整选项，请参见：<a href="https://doc.rustlang.ora/cargo/">https://doc.rustlang.ora/cargo/</a></p>
<h2 id="二、发布-crate-到-crates-io"><a href="#二、发布-crate-到-crates-io" class="headerlink" title="二、发布 crate 到 crates.io"></a>二、发布 crate 到 crates.io</h2><h3 id="2-1-crates-io"><a href="#2-1-crates-io" class="headerlink" title="2.1 crates.io"></a>2.1 crates.io</h3><ul>
<li>可以通过发布包来共享你的代码</li>
<li>crate 的注册表在 <a href="https://crates.io/">https://crates.io/</a></li>
<li>它会分发己注册的包的源代码</li>
<li>主要托管开源的代码</li>
</ul>
<h3 id="2-2-文档注释"><a href="#2-2-文档注释" class="headerlink" title="2.2 文档注释"></a>2.2 文档注释</h3><h4 id="2-2-1-文档注释的使用"><a href="#2-2-1-文档注释的使用" class="headerlink" title="2.2.1 文档注释的使用"></a>2.2.1 文档注释的使用</h4><ul>
<li>文档注释：用于生成文档<ul>
<li>生成 HTML 文档</li>
<li>显式公共 API 的文档注释：如何使用 API</li>
<li>使用 <code>///</code></li>
<li>支持 Markdown</li>
<li>放置在被说明条目之前</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这个函数是将传入的 u32 类型的值加一，然后返回这个值的所有权</span></span><br><span class="line"><span class="comment">/// # 实例</span></span><br><span class="line"><span class="comment">/// let a = 3;</span></span><br><span class="line"><span class="comment">/// let b = add_one(a);</span></span><br><span class="line"><span class="comment">/// assert_eq!(4, b);</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(num: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-生成-HTML-文档的命令"><a href="#2-2-2-生成-HTML-文档的命令" class="headerlink" title="2.2.2 生成 HTML 文档的命令"></a>2.2.2 生成 HTML 文档的命令</h4><p><code>cargo doc</code></p>
<ul>
<li>它会运行 rustdoc 工具（Rust 安装包自带）</li>
<li>把生成的 HTML 文档放在 target/doc 目录下</li>
</ul>
<p><code>cargo doc --open</code></p>
<ul>
<li>构建当前 crate 的文档（也包含 crate 依赖项的文档）</li>
<li>在浏览器打开文档</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808150051.png" alt="Rust Doc"></p>
<h4 id="2-2-3-常用章节"><a href="#2-2-3-常用章节" class="headerlink" title="2.2.3 常用章节"></a>2.2.3 常用章节</h4><ul>
<li>＃ Examples</li>
<li>其它常用的章节<ul>
<li>Panics：函数可能发生 panic 的场景</li>
<li>Errors：如果函数返回 Result，描述可能的错误种类，以及可导致错误的条件</li>
<li>Safety：如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-文档注释作为测试"><a href="#2-2-4-文档注释作为测试" class="headerlink" title="2.2.4 文档注释作为测试"></a>2.2.4 文档注释作为测试</h4><ul>
<li>示例代码块的附加值：<ul>
<li>运行 cargo test：将把文档注释中的示例代码作为测试来运行 </li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo test</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.18</span>s</span><br><span class="line">     Running unittests src/lib.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-d31f5191c1eed090)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-<span class="number">8</span>c2dc60df354a71a)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests it</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test src/lib.rs - <span class="title function_ invoke__">add_one</span> (line <span class="number">3</span>) ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.16</span>s</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-为包含注释的项添加文档注释"><a href="#2-2-5-为包含注释的项添加文档注释" class="headerlink" title="2.2.5 为包含注释的项添加文档注释"></a>2.2.5 为包含注释的项添加文档注释</h4><ul>
<li>符号：<code>//!</code></li>
<li>这类注释通常用描述 crate 和模块：<ul>
<li>crate root（按惯例 src/lib.rs)</li>
<li>一个模块内，将 crate 或模块作为一个整体进行记录</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808151624.png" alt="Rust Doc"></p>
<h3 id="2-3-pub-use"><a href="#2-3-pub-use" class="headerlink" title="2.3 pub use"></a>2.3 pub use</h3><p><strong>使用 pub use 导出方便使用的公共 API</strong></p>
<ul>
<li>问题：crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便<ul>
<li>开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲</li>
</ul>
</li>
<li>例如<ul>
<li>麻烦：my_crate::some_module::another_module::UsefulType；</li>
<li>方便：my_crate::UsefulType</li>
</ul>
</li>
<li>解决办法<ul>
<li>不需要重新组织内部代码结构</li>
<li>使用 pub use：可以重新导出，创建一个与内部私有结构不同的对外公共结构</li>
</ul>
</li>
</ul>
<p><code>main.rs:</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> pubuse::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> pubuse::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = PrimaryColor::Blue;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = <span class="title function_ invoke__">mix</span>(c1, c2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The mixed color is &#123;:?&#125;&quot;</span>, c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lib.rs:</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 这是测试 pub use 使用的 crate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// 色彩三原色：红黄蓝</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 两种颜色混合后的颜色</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将红黄蓝中任意两种颜色混合</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808163422.png" alt="pub use Doc"></p>
<p>我们从生成的文档看出，就将很深层的函数提到了 crate 的外层，方便用户查看和调用。</p>
<h3 id="2-4-发布-crate"><a href="#2-4-发布-crate" class="headerlink" title="2.4 发布 crate"></a>2.4 发布 crate</h3><ul>
<li>创建并设置 crates.io 账号</li>
<li>发布 crate 前，需要在 crates.io 创建账号并获得 API token</li>
<li>运行命令：<code>cargo login</code> [你的API token]<ul>
<li>通知 cargo，你的 API token 存储在本地 <code>~/.cargo/credentials</code></li>
</ul>
</li>
<li>API token 可以在 <a href="https://crates.io/">https://crates.io/</a> 进行撤销</li>
</ul>
<p><strong>为新的 crate 添加元数据</strong></p>
<ul>
<li>在发布 crate 之前，需要在 Cargo.toml 的 Ipackage] 区域为 crate 添加一些元数据：<ul>
<li>crate 需要唯一的名称：name</li>
<li>description：一两句话即可，会出现在 crate 搜索的结果里</li>
<li>license：需提供许可证标识值（可到 <a href="http://spdk.org/licenses/">http://spdk.org/licenses/</a> 查找）</li>
<li>可指定多个 license：用 OR</li>
<li>version</li>
<li>author</li>
</ul>
</li>
<li>发布：<code>cargo publish</code> 命令</li>
</ul>
<p><strong>发布到 crates.io</strong></p>
<ul>
<li>crate一旦发布，就是永久性的：该版本无法覆盖，代码无法删除</li>
<li>目的：依赖于该版本的项目可继续正常工作</li>
</ul>
<p><strong>发布己存在 crate 的新版本</strong></p>
<ul>
<li>修改 crate 后，需要先修改 Cargo.toml 里面的 version 值，再进行重新发布</li>
<li>参照 htto://semver.orgl 来使用你的语义版本</li>
</ul>
<p><strong>使用 cargo yank 从 Crates.io 撤回版本</strong></p>
<ul>
<li>不可以删除 crate 之前的版本</li>
<li>但可以防止其它项目把它作为新的依赖：yank（撤回）一个 crate 版本<ul>
<li>防止新项目依赖于该版本</li>
<li>己经存在项目可继续将其作为依赖（并可下载）</li>
</ul>
</li>
<li>yank 意味着：<ul>
<li>所有己经产生 Cargo.lock 的项目都不会中断</li>
<li>任何将来生成的 Cargo.lock 文件都不会使用被 yank 的版本。</li>
</ul>
</li>
<li>命令：<ul>
<li>yank 一个版本（不会删除任何代码）：<code>cargo yank -vers 1.0.1</code></li>
</ul>
</li>
</ul>
<h3 id="2-5-cargo-工作空间"><a href="#2-5-cargo-工作空间" class="headerlink" title="2.5 cargo 工作空间"></a>2.5 cargo 工作空间</h3><h4 id="2-5-1-创建工作空间"><a href="#2-5-1-创建工作空间" class="headerlink" title="2.5.1 创建工作空间"></a>2.5.1 创建工作空间</h4><p>随着项目越来越大，代码也会越来越臃肿，这时就需要将 crate 拆分成多个包，cargo 便提供了<strong>工作空间</strong>这个功能。</p>
<ul>
<li>cargo 工作空间：帮助管理多个相互关联且需要协同开发的 crate</li>
<li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li>
</ul>
<p><strong>创建工作空间</strong></p>
<ul>
<li>有多种方式来组建工作空间例：1 个二进制 crate，2 个库 crate<ul>
<li>二进制 crate：main 函数，依赖于其它2个库 crate</li>
<li>其中1个库 crate 提供 addLone 函数</li>
<li>另外1个库 crate 提供 add_two 函数</li>
</ul>
</li>
</ul>
<p><strong>在工作空间中依赖外部 crate</strong></p>
<ul>
<li>工作空间只有一个 Cargo.lock 文件，在工作空间的顶层目录<ul>
<li>保证工作空间内所有 crate 使用的依赖的版本都相同</li>
<li>工作空间内所有 crate 相互兼容</li>
</ul>
</li>
</ul>
<p>参数 <code>-p</code> 可以指定某个 crate 构建、运行或测试。例如 <code>cargo test -p add-one</code>。<br>发布的时候需要手动进入每个 crate 逐个发布。</p>
<p>以上内容参考<a href="https://www.bilibili.com/video/BV1hp4y1k7SV?p=83&amp;spm_id_from=pageDriver&amp;vd_source=cd979f5b9cea5f03bd91461762cdd74c">视频</a>，未做具体记录。</p>
<h3 id="2-6-安装二进制-crate"><a href="#2-6-安装二进制-crate" class="headerlink" title="2.6 安装二进制 crate"></a>2.6 安装二进制 crate</h3><p><strong>从 CRATES.IO 安装二进制 crate</strong></p>
<ul>
<li>命令：cargo install</li>
<li>来源： <a href="https://crates.io">https://crates.io</a></li>
<li>限制：只能安装具有二进制目标 (binary target）的 crate</li>
<li>二进制目标 binary target：是一个可运行程序<ul>
<li>由拥有 src/main.rs 或其它被指定为二进制文件的 crate 生成</li>
</ul>
</li>
<li>通常：README 里有关于 crate 的描述：<ul>
<li>拥有 library target</li>
<li>拥有 binary target</li>
<li>两者兼备</li>
</ul>
</li>
</ul>
<p><strong>cargo install</strong></p>
<ul>
<li>cargo install 安装的二进制存放在根目录的 bin 文件夹</li>
<li>如果你用 rustup 安装的 Rust，没有任何自定义配置，那么二进制存放目录是 <code>$HOME/.cargo/bin</code><ul>
<li>要确保该目录在环境变量 ＄PATH 中</li>
</ul>
</li>
</ul>
<p><strong>使用自定义命令扩展 cargo</strong></p>
<ul>
<li>cargo 被设计成可以使用子命令来扩展</li>
<li>例：如果＄PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行：<ul>
<li>cargo something</li>
</ul>
</li>
<li>类似这样的自定义命令可以通过该命令列出：cargo —list</li>
<li>优点：可使用 cargo install 来安装扩展，像内置工具一样来运行</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（十六）：最后的项目</title>
    <url>/9e622d63.html</url>
    <content><![CDATA[<blockquote>
<p>前言</p>
</blockquote>
<span id="more"></span>
<h2 id="一、单线程-Web-服务器"><a href="#一、单线程-Web-服务器" class="headerlink" title="一、单线程 Web 服务器"></a>一、单线程 Web 服务器</h2><h3 id="1-1-构建单线程-Web-服务器"><a href="#1-1-构建单线程-Web-服务器" class="headerlink" title="1.1 构建单线程 Web 服务器"></a>1.1 构建单线程 Web 服务器</h3><ul>
<li>在 socket 上监听 TCP 连接</li>
<li>解析少量的 HTTP 请求</li>
<li>创建一个合适的HTTP响应</li>
<li>使用线程池改进服务器的吞吐量</li>
<li>注意：并不是最佳实践</li>
</ul>
<p>直接放代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;net::&#123;TcpListener, TcpStream&#125;, io::&#123;Read, Write&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Request: &#123;&#125;\n&quot;</span>, <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>, contents.<span class="title function_ invoke__">len</span>(), contents);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>TcpListener::bind()</code> 方法表示监听所绑定的 IP 及端口，返回一个 Result 枚举，<code>incoming</code> 方法能够将所监听到的流转化成一个个迭代器，然后一依次处理这些流。</p>
<p>在 <code>handle_connection()</code> 函数中，先构造了一个 <code>buffer</code> 用于存放每个流请求的具体内容（请求头），然后写了一个 <code>hello.html</code> 页面，构造一个响应头同时写回请求的流中。在 <code>response</code> 字段中，要注意添加 <code>Content-Length:&#123;&#125;</code>，这样执行该程序，在浏览器中访问 <code>127.0.0.1:9999</code>，便可以返回刚刚写的页面。</p>
<p>控制台输出如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment">Content-Length:170</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Hello!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Hi From Rust&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器显示的页面如下：</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929233943.png" alt="浏览器正常显示页面"></p>
<p>下面我们新建一个 404 页面，用于处理访问其他页面时显示的结果，我们主要修改 <code>handle_connection()</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_line</span> = <span class="string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;404.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;&#125;\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            status_line,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125;</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断请求头是不是以 <code>GET / HTTP/1.1\r\n</code> 开头，这表明我们请求的是根目录的资源，这里 <code>let get = b&quot;GET / HTTP/1.1\r\n&quot;;</code> 的 <code>b</code> 表示字节字符串，可以将字符串转化成字节，这样就可以用 <code>start_with()</code> 方法进行比较。</p>
<p>在浏览器中访问一个非根目录的资源，控制台输出如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.32</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET /undefined HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Sec-Fet</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 404 NOT FOUND</span></span><br><span class="line"><span class="comment">Content-Length:201</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Oops!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Sorry,I don&#x27;t know what you&#x27; re asking for. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器页面如下：</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929235635.png" alt="404页面"></p>
<p>重构一下 <code>handle_connection()</code> 函数，用元组来重构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(file_name).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;Content-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">        status_line,</span><br><span class="line">        contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        contents</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、多线程-Web-服务器"><a href="#二、多线程-Web-服务器" class="headerlink" title="二、多线程 Web 服务器"></a>二、多线程 Web 服务器</h2><h3 id="2-1-阻塞的场景"><a href="#2-1-阻塞的场景" class="headerlink" title="2.1 阻塞的场景"></a>2.1 阻塞的场景</h3><p>当前我们对于流的处理都是单线程，一旦有某个请求耗费的时间长了，那么其他请求就必须被阻塞等待。我们构造下面这样的场景：当访问 <code>sleep</code> 页面的时候，线程睡眠 5 秒钟再执行处理，运行程序后访问其他页面可以正常被处理，当访问 <code>sleep</code> 页面的时候会卡住 5 秒钟，这时访问其他页面就需要等待这 5 秒钟结束。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sleep</span> = <span class="string">b&quot;GET /sleep HTTP/1.1\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(sleep) &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中增加了对 <code>sleep</code> 页面的访问，运行效果与预期一致。</p>
<p>我们用线程池来解决这一问题。</p>
<h3 id="2-2-线程池"><a href="#2-2-线程池" class="headerlink" title="2.2 线程池"></a>2.2 线程池</h3><p>线程池是一组预先被分配的线程，他们用于等待并随时处理可能的任务。线程池可以实现并发处理请求，当前线程执行完之后，将其放回线程池。首先考虑到使用 <code>thread::spawn()</code> 为每个请求创建线程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(||&#123;</span><br><span class="line">    <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是这样显然会导致一个问题：当有黑客对服务器进行洪泛攻击时，服务器的资源将会很快被耗尽，因此我们还需要对线程数量进行限制。</p>
<p>在该项目中，采用编译器驱动开发的方式（笑），先将可能用到的结构体或方法等先写好，再逐步完善，修改 main 如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显 <code>ThreadPool</code> 和 <code>execute</code> 是未定义的。</p>
<p>新建 <code>lib.rs</code>，实现未定义的部分：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        ThreadPool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>execute</code> 方法，我们参考 <code>thread::spawn()</code>，后者实现了 <code>FnOnce() + Send + &#39;static</code>。</p>
<p>然后我们给结构体 <code>ThreadPool</code> 添加一个字段 <code>threads</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    threads: <span class="type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是怎么来的呢，我们看 <code>spawn</code> 的实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">spawn</span>(f).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to spawn thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它返回的是 <code>JoinHandle</code>，其中有一个范型 <code>T</code>，这个 <code>T</code> 就是传进去的闭包的返回值，但是我们实现的方法闭包没有返回值，因此返回单元类型 <code>()</code> 即可。</p>
<p>再次修改 <code>new()</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">threads</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        todo!()    </span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;threads&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看<code>spawn</code> 的实现，他会创建一个线程，立即执行接收到的代码。但是我们希望线程创建之后进入等待状态，当有代码传给他们的时候再执行线程。这里我们创建一个新的结构体，叫 <code>Worker</code>，用来管理和实现上述所说的行为。</p>
<p>实现 <code>Worker</code> 相关结构体和函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时将 <code>ThreadPool</code> 中的字段名改成 <code>workers</code>，更改 <code>ThreadPool</code> 的 <code>new()</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前为止，<code>lib.rs</code> 代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用通道"><a href="#2-3-使用通道" class="headerlink" title="2.3 使用通道"></a>2.3 使用通道</h3><p>下面我们需要考虑如何让 <code>Worker</code> 从线程池中接收任务并执行任务，这里就要使用到通道。</p>
<p>在 <code>ThreadPool</code> 中添加一个字段 <code>sender</code>，表示通道的发送端。线程池持有通道的发送端，而接收者应该是 <code>worker</code>。在通道中，可以有多个发送者，但是只能有一个接收者，我们希望所有线程共享同一个 <code>receiver</code>，从而能够在线程间分发任务。同时从通道队列中取出 <code>receiver</code> 也意味着这是可变的。我们可以用 “智能指针” 那一小节中的 <code>Arc</code> 和 <code>Mutex</code> 来实现线程间多所有权的可变引用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers, sender&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时修改 <code>Worker</code> 结构体的 <code>new</code> 的函数签名：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-实现-execute-方法"><a href="#2-4-实现-execute-方法" class="headerlink" title="2.4 实现 execute 方法"></a>2.4 实现 execute 方法</h3><p>新建一个 <code>job</code>，然后通过通道的发送端将 <code>job</code> 发送出去，接收端 <code>worker</code> 的 <code>new</code> 函数接收该 <code>job</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">    <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">        (*job)(); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Worker &#123;id, thread&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 <code>job</code> 是一个 <code>Box</code> 类型，那么实现 <code>FnOnce()</code> 的闭包要想调用就要先将其从 <code>Box</code> 取出来，但是 Rust 不允许这样做，因为不知道 <code>Box</code> 中的类型具体有多大。<code>FnOnce()</code> 中有一个 <code>call_once()</code> 方法，其中的参数便是 <code>self</code>，为了获得其所有权，但是现在不允许。我们可以将 <code>self</code> 改成 <code>Box&lt;Self&gt;</code>，这样方法就可以在类型的 <code>Box</code> 上来调用。</p>
<p>然后为实现了 <code>FnOnce()</code> 的类型实现 <code>FnBox</code>，<code>self</code> 的类型就是 <code>Box&lt;F&gt;</code>，而 <code>F</code> 就是实现了 <code>FnOnce()</code> 的类型，这样就可以获得 <code>Box</code> 里的所有权，再进行闭包调用，同时更改 <code>Job</code> 的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>最后在 <code>Worker</code> 的 <code>new</code> 函数中加入 loop，使得释放锁后还能继续使用该线程。</p>
<p>最终 <code>lib.rs</code> 文件如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, sync::&#123;mpsc, Arc, Mutex&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub struct Job &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers, sender&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">            job.<span class="title function_ invoke__">call_box</span>(); </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>TFTP简单文本传输协议的基本原理</title>
    <url>/2c942dc5.html</url>
    <content><![CDATA[<h2 id="TFTP简单文本传输协议的介绍"><a href="#TFTP简单文本传输协议的介绍" class="headerlink" title="TFTP简单文本传输协议的介绍"></a>TFTP简单文本传输协议的介绍</h2><p>随着互联网发展，文件传输效率越来越快，相应的传输协议也越来越复杂。早年有很多文件传输协议如今已经很少再用，所谓老兵不死，只是慢慢凋零。这些协议尽管现在使用不多，但它们的设计思想依然值得我们好好研究和掌握。</p>
<p>例如 FTP 以及它的 UDP 版本 TFTP，它们实现文件传输的协议设计思想依然非常值得研究，它对我们设计新协议依然很有启发性。本节开始，我们研究 TFTP 协议的原理以及相关代码实现。</p>
<p>TFTP 原名叫<code>Trivial File Transport Protocol</code>.对互联网早期存有记忆的同学对 FTP 协议一定非常了解，当时局域网乃至整个网络上很多大文件，例如电影的传输依靠的就是该协议。FTP 协议运行在 TCP 协议之上，它的内容很复杂，除了文件传输外，它还支持很多文件相关操作，例如远程实现文件建立，删除等。TFTP 是 FTP 协议的简化版，它运行在 UDP 协议上，同时简化了很多 FTP 操作，只支持文件的传输功能。<br><span id="more"></span><br>TFTP协议是基于服务器和客户端之间的传输协议。一开始客户端向服务器发出连接请求，服务器应答后两者连接建立。然后客户端向服务器发出文件传输请求，服务器将客户端需要的文件分割成多个小块，依次传递给客户端，客户端每收到一个小块后向服务器发出应答，收到应答后服务器再发送下一个小块。当所有文件块传输完毕后，两者连接断开。</p>
<p>TFTP 服务器程序通常在端口 69 监听客户端请求。值得注意的是，当服务器与客户端进行数据块传输时，服务器会使用一个随机端口而不是用于监听请求的 69 端口，这是为了服务器能同时相应多个客户端的连接。服务器与不同客户端使用不同端口进行数据通信，这样就保证不同客户端所需要的数据块不会发生混淆。</p>
<p>服务器与客户端在发送文件数据时，会按照一种名为”锁定步骤”的方式进行数据传输。也就是服务器向客户端发送一个数据块，再接收到客户端发回的应答数据包前什么都不做，直到收到客户端确定数据块已经收到的应答后，它才发送下一个数据块，这种方式使得数据传输效率不高，但确保数据传输流程足够简单，同时能保证传输出错时，数据重传很方便，同时客户端也不用考虑数据块不按次序抵达时，如何将数据块进行正确组装。</p>
<p>TFTP 协议的简单附带的代价是效率不高。由于它走的是 UDP 协议，因此一次发送数据块不能超过 512 字节，这也是服务器必须把文件切成小块反复传输的原因。还有一点值得注意的是 TFTP 协议没有任何安全措施，它不需要注册或登录，任何客户端都可以连接然后下载文件。</p>
<p>我们首先在网络上下载一个 TFTP 的服务器客户端：<a href="http://tftpd32.jounin.net/tftpd32_download.html">Tftpd64</a> 具体界面如下：</p>
<p><img src="/2c942dc5/tftpd64.png" alt="tftpd64"></p>
<p>然后在 Windows 中的设置的程序与功能中打开 TFTP Client:</p>
<p><img src="/2c942dc5/tftp_Windows.png" alt="tftp_Windows"></p>
<h2 id="TFTP抓包演示"><a href="#TFTP抓包演示" class="headerlink" title="TFTP抓包演示"></a>TFTP抓包演示</h2><p>我们在 TFTP 服务器客户端上选择我们的 IP 地址：192.168.1.101，然后这台电脑就可以作为我们的 TFTP 服务器了，然后我们在命令行中输入：<code>tftp 192.168.1.101 get test.txt</code>(test.txt 是我特地新建的用来测试的文件，该文件必须存放在 tftp 服务器客户端软件中 Current Directory 所显示的目录中)：</p>
<p><img src="/2c942dc5/tftp抓包1.png" alt="tftp抓包1"></p>
<p><img src="/2c942dc5/tftp抓包2.png" alt="tftp抓包2"></p>
<p>然后就可以在当前磁盘（G盘）中看到我们传送的文件了</p>
<p>需要注意的几个问题:</p>
<ol>
<li>文件传送成功与否，你朋友也可以在 Tftpd32 的 “Tftp Server” 和 “Current Action”这两项中看到。</li>
<li>如果想把文件传给你朋友，那么只要把命令换成 “Tftp -i朋友IP put pictures.rar” 即可。关于Tftp命令的更多参数，你可以在 CMD 下输入 Tftp 进行查看。不过此时你朋友不能进行上传和下载工作，因为他此时是 Tftp 的服务端，只有客户端才能进行这些操作。如果他想把西传给你，那就需要你做服务端了。</li>
<li>用 Tftp 传送文件时，服务端需有确定的公网 IP，如果你朋友在局域网中通过网关上网的话，那就无法传送了。当然，如果两个人在同一局域网中，内网的 IP 也可以传送文件,只是有些多此一举。</li>
<li>Windows 98 系统可以当服务端，但客户端一定要是 Windows 2000 或是 Windows XP 等有 Tftp 命令的系统。<br>以后如果你遇到因为防火墙等原因不能通过QQ传送文件时，不妨试试 Tftp.</li>
</ol>
<p><img src="/2c942dc5/tftp抓包3.png" alt="tftp抓包3"></p>
<p>我们再通过 Wireshark 抓包来观察 TFTP 协议(由于在 Windows上自己传给自己抓不到包，因此我在 Linux虚拟机上进行测试)，但是出现了 <code>Destination unreachable (Host administratively prohibited)</code>，查询资料得知，是 Linux 的防火墙没有设置，我们设置一下 iptables:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P OUTPUT ACCEPT       <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -P FORWARD ACCEPT      <span class="comment">#允许所有转发</span></span><br><span class="line">iptables -P INPUT ACCEPT        <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -F                     <span class="comment">#清除所有规则</span></span><br></pre></td></tr></table></figure>
<p><img src="/2c942dc5/tftp抓包4.png" alt="tftp抓包4"></p>
<p><img src="/2c942dc5/tftp抓包5.png" alt="tftp抓包5"></p>
<p><img src="/2c942dc5/tftp抓包6.png" alt="tftp抓包6"></p>
<p>【注】:我的电脑不知道为何只能抓到单向的数据包，无法抓到主机向虚拟机传送的数据包，查了很多资料之后未果，先接着学习吧。</p>
<p>抓包显示两种数据包，分别是 Acknowledgement 和 Data block，其中前者是客户端收到数据块后对服务器的应答，后者是服务器向客户端发送的数据块。数据包的具体格式我们会在后面进行详细分析。</p>
<h2 id="TFTP交互细节及数据包解读"><a href="#TFTP交互细节及数据包解读" class="headerlink" title="TFTP交互细节及数据包解读"></a>TFTP交互细节及数据包解读</h2><p>tftp 主要分为三步，首先是连接，然后是数据传输，最后是连接中断。所有这些步骤都通过发送相关数据包完成。最开始由客户端发送一个数据读取或写入请求，这个请求发出的同时连接自动建立，在这个过程中双方会协议要传输什么格式的文件。TFTP协议支持两个格式文件的传输，分别是 ASCII 文本，另一种是二进制数据，FTP 协议支持的文本格式比 TFTP 要复杂得多。</p>
<p>如果客户端请求的文件存在，服务器会直接将第一个数据块发送给客户端。如果是客户端想上传文件，服务器会发送一个 ACK 数据包表示确认。在这个过程中如果出现错误，其中一方就向另一方发送错误信息数据包，然后文件传输终止。由于使用 UDP 作为底层协议，因此一次数据发送最大不超过 <code>512</code> 字节。因此为了保证数据顺序正确性，每个数据包必须对应相应编号，编号根据数据块的顺序从1开始。</p>
<p>由于每次数据块最大是 512 字节，只要文件传输没有结束，那么一次数据块就是 512 字节，如果有数据包中数据少于 512 字节，那意味着这是文件最后一个数据包，最后一个数据块发送完后，连接自动中断。我们通过一个具体实例来掌握数据发送流程，假设客户端想从服务器读取一个 1200 字节的文件，以下是相关步骤：</p>
<ol>
<li>客户端发送一个数据包给服务器，其中包含了要读取的文件名。</li>
<li>服务器发回第一个 512 字节数据块，并对其标号为 1.</li>
<li>客户端返回服务器一个标号为 1 的确认数据包</li>
<li>服务器发送标号为 2 包含 512 字节的数据块</li>
<li>客户端收到 2 号数据块后发生确认数据包</li>
<li>服务器发送标号为 3 的包含 176 字节的数据块</li>
<li>客户端收到后回发标号为 3 的确认数据包</li>
<li>服务器收到确认数据包后，确认文件发送完毕</li>
</ol>
<p><img src="/2c942dc5/传输示例.png" alt="传输示例"></p>
<p>我们再看看客户端上传文件的流程：</p>
<ol>
<li>客户端发送一个写请求数据包，里面包含了要写的文件名称</li>
<li>服务器发送确认数据包，在数据包中它使用编号 0</li>
<li>客户端发送一个含有 512 字节，编号为1的数据包</li>
<li>服务器返回编号为 1 的确认数据包</li>
<li>客户端发送编号为 2，包含 512 字节的数据包</li>
<li>服务器返回编号为 2 的确认数据包</li>
<li>客户端发送编号为 3，包含 176 字节的数据包，等待服务器返回确认数据包。</li>
<li>服务器接受 3 号数据包后，返回确认数据包，由于该数据包数据少于 512 字节，服务器知道是最后一个数据包。</li>
<li>客户端收到 3 号确认数据包后，知道文件传输完毕，中断连接。</li>
</ol>
<p><img src="/2c942dc5/传输示例2.png" alt="传输示例2"></p>
<p>TFTP 协议后来又经过一次扩展，增加一些控制命令。如果客户端或服务器想使用扩展命令时，它必须向对方确认是否也能支持相应命令。它会发送一个数据包，里面包含扩展命令对应的数值列表，对方也会返回一个列表，把它支持的扩展命令对应的数值放在列表中，不支持的则不在列表里。TFTP 协议一个特点是，它不允许任何一方连续发送 2 个数据包，必须是<code>一来一回</code>。具体的扩展功能在协议实现时我们再详细研究。</p>
<h2 id="探究数据包具体格式"><a href="#探究数据包具体格式" class="headerlink" title="探究数据包具体格式"></a>探究数据包具体格式</h2><p>我们看看 TFTP 数据包的组装方式，为我们代码实现该协议奠定基础。TFTP 协议总共有5种不同数据包，分别对应读请求，写请求，数据块，接收回应(ACK)，以及错误。前两种数据包格式一样，只不过某些值域设置有差别，剩下的三种数据包格式各不相同。但无论哪一种数据包，他们都包含一个值域叫操作码，用来定义该数据包属于那种类型。</p>
<p>我们先看读请求和写请求数据包的格式，首先是2字节表示操作码，它用来表示当前数据包的类型，取值 1 表示该数据包是个读请求，2 表示该数据包是；接下来是可变长字段，它用来表示要读取或上传的文件名，它使用 ASCII 码并以 0 表示结尾；第三个字段叫 Mode，也是可变长字段，用来表示传输文件的数据类型，如果传输的是字符串文件，那么它填写字符串 “netascii”，如果传输的是二进制文件，那么它填写字符串 “octet”，这些字符串都以 0 结尾，其结构用下图表示：</p>
<p><img src="/2c942dc5/读写请求数据包.png" alt="读写请求数据包"></p>
<p>接着我们看看传输数据块的数据包，它的前 2 字节也是操作码，取值 3 用于表示数据包用于数据块传输，接下来是 2 字节，用于表示数据块编号，最后是可变长字段 Data，用于装载数据块，该数据包的格式如下：</p>
<p><img src="/2c942dc5/传输数据块数据包.png" alt="传输数据块数据包"></p>
<p>然后是应答数据包，它开始 2 字节也是操作码，取值 4，接下来2字节表示接收到的数据块编号，相应结构如下图：</p>
<p><img src="/2c942dc5/应答数据包.png" alt="应答数据包"></p>
<p>最后一个是错误数据报，它前 2 字节表示操作码，取值 5；接下来 2 字节表示错误码，0 表示未知错误，1 表示文件不存在，2 表示权限不足，3 表示磁盘已满，具体的错误码我们在实践时再具体分析；接下来是可变长字段，它用字符串的形式描述具体错误，该数据包的结构如下图：</p>
<p><img src="/2c942dc5/错误数据包.png" alt="错误数据包"></p>
<h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2>]]></content>
      <categories>
        <category>计算机网络</category>
        <category>TCP/IP协议</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TFTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（十）：项目实战</title>
    <url>/461e5b43.html</url>
    <content><![CDATA[<blockquote>
<p>本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。</p>
</blockquote>
<span id="more"></span>
<p>要实现的 grep 命令功能很简单，就是在指定文件中查找指定文字。grep 命令接收一个文件名和字符串作为输入参数，然后读取文件内容，搜索包含指定字符串的行，最终将这些匹配的行打印输出。</p>
<p>下面开始实战演示。</p>
<h2 id="一、接收命令行参数"><a href="#一、接收命令行参数" class="headerlink" title="一、接收命令行参数"></a>一、接收命令行参数</h2><p>我们预计使用如下命令来执行该程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run &lt;string&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>因此我们首先要读取命令行中的参数，我们导入函数 <code>use std::env::args()</code>，<code>args()</code> 函数返回一个迭代器，迭代器部分的内容将在后面才会介绍。然后使用 <code>collect</code> 方法，将迭代器中的值转化成一个集合，但是该函数不能处理命令行中非 <code>Unicode</code> 的字符（这种情况可以使用 <code>env::args _os()</code> 函数，这种情况下返回的迭代器值的类型是 <code>OsString</code>，在这里不做介绍）。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string filename</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.29</span>s</span><br><span class="line">     Running `target/debug/minigrep string filename`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;filename&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file filename</span><br></pre></td></tr></table></figure>
<p>根据程序执行结果我们能够得知：返回的第一个参数永远都是该程序的二进制文件（对应 <code>args[0]</code>），从第二个参数开始才是从命令行输入的各种参数（对应 <code>args[1]</code> …）。</p>
<h2 id="二、读取文件"><a href="#二、读取文件" class="headerlink" title="二、读取文件"></a>二、读取文件</h2><p>首先导入模块 <code>use std::fs</code>，用于处理和文件相关的事务，<code>read_to_string()</code> 用来读取文件中的内容，将其转化成字符串。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string poem    </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep string poem`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;poem&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file poem</span><br><span class="line">文件内容:</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For <span class="keyword">if</span> dreams die</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">That can never fly</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For when dreams go</span><br><span class="line">Life is a barren field</span><br><span class="line">Frozen only with snow</span><br><span class="line"></span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br><span class="line">And a heaven <span class="keyword">in</span> a wild flower,</span><br><span class="line">Hold infinity <span class="keyword">in</span> the palm of your hand,</span><br><span class="line">And eternity <span class="keyword">in</span> an hour.</span><br></pre></td></tr></table></figure>
<p>当然目前看来所有逻辑都放在了主函数中，并且很多错误情况都没有考虑。一般情况下一个函数只做一件事，如果代码逐渐变多，代码维护将变得越来越困难。代码越少重构越简单，因此下一节将对代码进行重构。</p>
<h2 id="三、重构：改进模块和错误处理"><a href="#三、重构：改进模块和错误处理" class="headerlink" title="三、重构：改进模块和错误处理"></a>三、重构：改进模块和错误处理</h2><h3 id="3-1-四个问题提炼"><a href="#3-1-四个问题提炼" class="headerlink" title="3.1 四个问题提炼"></a>3.1 四个问题提炼</h3><p>我们仔细观察一下目前的代码，主要有四个方面的问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>主函数负责的功能较多，既要负责命令行参数解析，又要负责读取文件。而程序编写的原则就是一个函数负责一个功能，因此要将主函数拆分；</li>
<li><code>search_string</code>、<code>filename</code> 和 <code>content</code> 变量，在程序越来越大之后，变量也会越来越多，将难以追踪每一个变量的实际意义。解决办法是将这些变量放入一个结构体中，从而使其用途更加清晰；</li>
<li>读取文件时，使用 <code>expect</code> 处理错误，但未对其读取错误的原因进行细分，因为文件打不开可能是文件不存在，文件权限不够，文件损坏等原因；</li>
<li>对于命令行参数的错误处理，若输入的参数没有两个，那么程序本身就会报错，并且能够预料到的错误一定是 <code>Out of bound</code> 这类的错误，但是对于使用者来说，可能并不清楚这个所谓的 <strong>越界错误</strong> 意味着什么，无法清晰解释错误的具体原因。因此最好要将所有错误处理集中到一起，将来开发者要考虑错误处理的时候，就只要处理这一处代码，这样也能保证为用户打印出有意义的错误信息，而不是只有程序员能看懂的 <code>Out of bound</code>。</li>
</ol>
<h3 id="3-2-二进制程序关注点分离的指导性原则"><a href="#3-2-二进制程序关注点分离的指导性原则" class="headerlink" title="3.2 二进制程序关注点分离的指导性原则"></a>3.2 二进制程序关注点分离的指导性原则</h3><ul>
<li>将程序拆分为 <code>main.rs</code> 和 <code>lib.rs</code>，将业务逻辑放入 <code>lib.rs</code></li>
<li>当命令行解析逻辑较少时，将它放在 <code>main.rs</code> 也行</li>
<li>当命令行解析逻辑变复杂时，需要将它从 <code>main.rs</code> 提取到 <code>lib.rs</code></li>
</ul>
<p>经过上述拆分，留在 <code>main</code> 的功能有：</p>
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>进行其它配置</li>
<li>调用 <code>lib.rs</code> 中的 <code>run</code> 函数</li>
<li>处理 <code>run</code> 函数可能出现的错误</li>
</ul>
<p>因此放在 <code>main.rs</code> 中的代码量应足够小，小到直接阅读代码就可以确保代码的正确性。将业务逻辑放入 <code>lib.rs</code> 中也方便进行功能测试。</p>
<p>针对上面说的四个方面的问题，我们逐一进行解决。</p>
<p><strong>1. 拆分出命令行参数提取功能</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">let</span> (search_string, filename) = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    (search_string, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，<code>parse_config</code> 函数目前返回一个元组，但是在主函数中，又将该元组拆分出来，赋值给两个变量，这样感觉有点“脱裤子放屁”的感觉，来回折腾。实际上这种情况就说明程序中这样设计数据结构是不正确的。因此较好的做法就是将返回的元组中的变量放入一个结构体。</p>
<p><strong>2. 创建结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们创建一个叫 <code>Config</code> 的结构体，将 <code>search_string</code> 和 <code>filename</code> 两个变量放入结构体。但是上面的代码会报错，这是因为在函数 <code>parse_config</code> 中，<code>args</code> 参数是切片类型，是没有所有权的（它的所有权被 <code>main</code> 函数拥有），而在最后要返回一个 <code>Config</code> 结构体对象，该结构体需要占用所有权，因此会报错。</p>
<p>这里用一个简单的方法来处理，就是创建 <code>args[1]</code> 和 <code>args[2]</code> 的两个副本，尽管这样会损失性能。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看 <code>parse_config</code> 函数，它返回的是一个结构体，实际上是要创建一个新的结构体，因此我们最好再实现该结构体的 <code>new</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是将刚刚的 <code>parse_config</code> 变成了结构体 <code>Config</code> 的函数。重构后的完整代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 错误处理</strong></p>
<p>我们不输入参数进行运行，不出预料的会产生下面的错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run       </span><br><span class="line">warning: field is never read: `search_string`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">19</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> |     search_string: <span class="type">String</span>,</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="meta">#[warn(dead_code)]</span>` on by default</span><br><span class="line"></span><br><span class="line">warning: `minigrep` (bin <span class="string">&quot;minigrep&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">1</span> but the index is <span class="number">1</span>&#x27;, src/main.rs:<span class="number">25</span>:<span class="number">29</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure>
<p>即 <strong>越界错误</strong>，这对于用户来说是无法理解的，我们当然可以在 <code>new</code> 函数中添加这样的判断语句，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样仍然会有编译器的其他信息，一般情况下，使用 <code>panic</code> 通常是程序本身的问题，但是像这类输入参数少的问题属于程序使用的问题，因此我们还需要进行改进，可以返回 <code>Result</code> 枚举，代码如下。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数个数不足，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数个数超过 2 个，则返回 <code>Err</code> 的变体，否则返回 <code>Ok</code>。主函数中，<code>unwrap_or_else</code> 函数的含义是，如果枚举返回的是 <code>Ok</code>，那么就取出 <code>Ok</code> 变体中的值返回，若枚举返回的是 <code>Err</code>，那么就调用一个闭包（匿名函数，闭包具体内容将来会介绍），然后使用 <code>process::exit(1)</code> 将程序返回，这样就不会有编译器的其他信息了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">参数解析错误：输入参数个数不足，请输入两个参数。</span><br></pre></td></tr></table></figure>
<p><strong>4. 功能模块化</strong></p>
<p>一个函数只处理一个功能，因此我们将业务逻辑（即读取文件内容）功能提取到一个新的函数中。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们进行 <code>run</code> 函数的错误处理。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>result&lt;(), Box&lt;dyn Error&gt;&gt;</code> 中第一个参数是空，第二个参数只要理解是一个实现了 <code>Error</code> 这个 <code>trait</code> 的类型，这样函数便可以在不同场景下返回不同的错误类型。</p>
<p>因为 <code>expect</code> 会引起恐慌，因此将其去掉，改成 <code>?</code>，<code>?</code> 运算符遇到错误不会恐慌，它会将错误值返回给函数的调用者，如果没有发生错误，那么我们最后返回一个 <code>Ok()</code>。</p>
<p>这时编译器会在 <code>run(config)</code> 出给予警告：<code>this &#39;Result&#39; may be an &#39;Err&#39; variant, which should be handled</code>，这说明函数返回值是一个 <code>Result</code> 类型，那么就说明可能会产生错误，因此需要对其进行处理。</p>
<p><code>unwrap</code> 有打开的意思，需要从 <code>Result</code> 中提取数据，但是 <code>run</code> 函数没有返回值，因此也就不需要 <code>unwrap</code>，可以像下面这样解决这一问题。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们将业务逻辑迁移到 <code>lib.rs</code> 中。</p>
<p><code>lib.rs:</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main.rs:</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要记得所有函数和结构体以及字段前都要加 <code>pub</code>，这样才能让其他 <code>crate</code> 才能进行调用。这样 <code>lib crate</code> 就有了一套公共的可用于测试的 API。</p>
<p>重构到这里就基本完成了，下面就要来编写测试了。</p>
<h2 id="四、使用-TDD（测试驱动开发）开发库功能"><a href="#四、使用-TDD（测试驱动开发）开发库功能" class="headerlink" title="四、使用 TDD（测试驱动开发）开发库功能"></a>四、使用 TDD（测试驱动开发）开发库功能</h2><p>测试驱动开发 TDD (Test-Driven Development)</p>
<ul>
<li>编写一个会失败的测试，运行该测试，确保它是按照预期的原因失败</li>
<li>编写或修改刚好足够的代码，让新测试通过</li>
<li>重构刚刚添加或修改的代码，确保测试会始终通过</li>
<li>返回步骤1，继续</li>
</ul>
<p>测试驱动开发能够对代码的设计起到指导和帮助的作用，先编写测试，然后再编写能够通过测试的代码，也能保证开发过程中能够保持测试较高的覆盖率。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">use</span> super::*;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>search</code> 函数中返回的引用的生命周期与 <code>content</code> 有关，而与 <code>query</code> 无关。<code>content.lines()</code> 函数返回一个的迭代器，取出文件中的每一行。这样测试代码就完成了，运行测试也是成功的。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo test        </span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.36</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">662</span>cb87b3d895995)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test test::one_result ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">33</span>abce92ed029d2f)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests minigrep</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>run</code> 函数并运行 <code>cargo run</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run is poem </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep is poem`</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">Life is a barren field</span><br></pre></td></tr></table></figure>
<h2 id="五、使用环境变量"><a href="#五、使用环境变量" class="headerlink" title="五、使用环境变量"></a>五、使用环境变量</h2><p>这一部分使用环境变量来实现配置选项（例如是否忽略大小写等）。</p>
<p>我们首先编写一个测试：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>], <span class="title function_ invoke__">search_case_insensitive</span>(query, contents));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写 <code>search_case_insensitive</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其思路就是将查询的字符串和文件中的都转化成小写。</p>
<p>然后我们在 <code>run</code> 函数中加入如下逻辑。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">    <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体的 <code>new</code> 函数也需要修改：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">        search_string,</span><br><span class="line">        filename,</span><br><span class="line">        case_sensitive</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env::var()</code> 函数返回的是 <code>Result</code> 枚举，若环境中有 <code>CASE_INSENSITIVE</code> 定义或者赋值，那么就会返回 <code>Ok</code> 中的值，我们这里只需要判断是否为 <code>Err</code> 即可。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ CASE_INSENSITIVE=<span class="number">1</span> cargo run to poem</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep to poem`</span><br><span class="line">Hold fast to dreams</span><br><span class="line">Hold fast to dreams</span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br></pre></td></tr></table></figure>
<h2 id="六、将错误消息写进标准错误而不是标准输出"><a href="#六、将错误消息写进标准错误而不是标准输出" class="headerlink" title="六、将错误消息写进标准错误而不是标准输出"></a>六、将错误消息写进标准错误而不是标准输出</h2><p>当前我们都将错误信息输出到终端上，而大多数终端提供两种输出，一个是标准输出（stdout，println!），另一个叫标准错误（stderr，eprintln!）。</p>
<p>我们将打印错误信息的 <code>println!</code> 改成 <code>eprintln!</code> 即可，然后运行 <code>cargo run &gt; output</code>，错误信息便不会输出到文件中，而是打印在终端了。</p>
<h2 id="七、完整代码"><a href="#七、完整代码" class="headerlink" title="七、完整代码"></a>七、完整代码</h2><p><strong>main.rs:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lib.rs:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、案例：代码统计"><a href="#七、案例：代码统计" class="headerlink" title="七、案例：代码统计"></a>七、案例：代码统计</h2><h3 id="7-1-基本功能介绍"><a href="#7-1-基本功能介绍" class="headerlink" title="7.1 基本功能介绍"></a>7.1 基本功能介绍</h3><p>代码统计以给定的输入参数作为统计对象（可以是文件或文件夹），根据文件后缀名统计代码所使用的语言（暂定只统计 C、C/C++ 头文件、C++、Java、Python、Rust、汇编语言、makefile 脚本），然后统计每一种代码文件的有效代码行数、注释行和空行。没有后缀名的文件默认不进行统计。</p>
<h3 id="7-2-可拓展功能"><a href="#7-2-可拓展功能" class="headerlink" title="7.2 可拓展功能"></a>7.2 可拓展功能</h3><ul>
<li>丰富统计的语言种类</li>
<li>命令行中利用参数指定要统计的语言，只统计指定的语言</li>
<li>加入多线程提高文件扫描速度</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust实现进度条功能</title>
    <url>/84b8101e.html</url>
    <content><![CDATA[<blockquote>
<p>本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h2><p>先上代码。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bar_show</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> BAR_FRONT: &amp;<span class="type">str</span> = <span class="string">&quot;-\\|/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">index</span> <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(</span><br><span class="line">            <span class="string">&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</span>,</span><br><span class="line">            BAR_FRONT.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">nth</span>(index % <span class="number">4</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(index / <span class="number">3</span>),</span><br><span class="line">            index</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为终端输出的进度条是带颜色的，在这里没法显示，只能通过截图看。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230112160436.png" alt="进度条显示"></p>
<h2 id="二、代码解释"><a href="#二、代码解释" class="headerlink" title="二、代码解释"></a>二、代码解释</h2><p>进度条前面的指示字符是 <code>&quot;-\\|/&quot;</code> 交替显示，呈现出动态效果，因为 <code>\</code> 需要转义，所以是两个反斜杠 <code>\\</code>。</p>
<p>然后就是进度条从 0-100 开始，每一次循环输出指示字符(模 4)，空白字符重复 (index / times) 次，根据进度条长度进行调整除数。然后刷新输出流，要不然输出会在缓存中，每隔一段时间才会输出到设备，不会实时显示进度条进度，最后再睡眠 30ms，让进度条缓慢加载。</p>
<p>最重要的是这一句：<code>&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</code>。</p>
<p>首先，<code>\r</code> 表示将光标置于本行行首，使用 <code>print!</code> 可以使得每次输出覆盖之前输出的行。然后 <code>\u</code> 表示输出后面的 <code>UniCode</code> 字符，<code>&#123;&#125;</code> 就不用说了，是 Rust 里用来控制格式化输出的。</p>
<blockquote>
<p>注：Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows 系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\n\r”；Mac 系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac 系统下的文件在 Windows里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。所以，如果你需要跨平台处理文本文件，可能会被回车换行搅得有点头大。<br>0x0D（ascii 码是 13） 指的是“回车”   \r 是把光标置于本行行首<br>0x0A（ascii 码是 10） 指的是“换行”   \n 是把光标置于下一行的同一列<br>0x0D + 0x0A         回车换行       \r\n 是把光标置于下一行行首 </p>
</blockquote>
<p><code>\u&#123;1b&#125;[42m</code> 这句的格式是 <code>\x1b[&lt;代码&gt;;&lt;代码&gt;</code>，其中 <code>\x1b[</code> 是十六进制 1b，写成八进制 <code>\033</code> 也行，然后一个左中括号，是特殊的终端控制符，格式固定。然后后面跟上一个数字和一个字母，这里 <code>42m</code> 就是将背景设置为绿色，字母 m 表示设置的属性类别，数字代表属性值。</p>
<p>下面是一些其他属性，可以设置文本的颜色，背景色，设置是否加粗，下划线等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\033[0m 关闭所有属性</span><br><span class="line">\033[1m 设置加粗</span><br><span class="line">\033[2m 设置模糊，有的终端可能不支持</span><br><span class="line">\033[3m 设置斜体，有的终端可能不支持</span><br><span class="line">\033[4m 下划线（单线）</span><br><span class="line">\033[5m 闪烁（慢）</span><br><span class="line">\033[5m 闪烁（快），有的终端可能不支持</span><br><span class="line">\033[7m 交换背景色与前景色</span><br><span class="line">\033[8m 隐藏所有</span><br><span class="line">\033[30m 至 \033[37m 设置前景色</span><br><span class="line">\033[40m 至 \033[47m 设置背景色</span><br><span class="line">\033[nA 光标上移n行 </span><br><span class="line">\033[nB 光标下移n行</span><br><span class="line">\033[nC 光标右移n行</span><br><span class="line">\033[nD 光标左移n行</span><br><span class="line">\033[y;xH 设置光标位置</span><br><span class="line">\033[2J 清屏</span><br><span class="line">\033[K 清除从光标到行尾的内容</span><br><span class="line">\033[s 保存光标位置 </span><br><span class="line">\033[u 恢复光标位置</span><br><span class="line">\033[?25l 隐藏光标</span><br><span class="line">\033[?25h 显示光标</span><br></pre></td></tr></table></figure>
<p>各个数字代表的颜色如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字背景颜色范围:40--49</span><br><span class="line">    40:黑</span><br><span class="line">    41:深红</span><br><span class="line">    42:绿</span><br><span class="line">    43:黄色</span><br><span class="line">    44:蓝色</span><br><span class="line">    45:紫色</span><br><span class="line">    46:深绿</span><br><span class="line">    47:白色</span><br><span class="line">字颜色: 30--39</span><br><span class="line">    30:黑</span><br><span class="line">    31:红</span><br><span class="line">    32:绿</span><br><span class="line">    33:黄</span><br><span class="line">    34:蓝色</span><br><span class="line">    35:紫色</span><br><span class="line">    36:深绿 </span><br><span class="line">    37:白色</span><br></pre></td></tr></table></figure>
<p>另外，同类的多种设置项可以组合在一起，中间用分号 <code>;</code> 隔开。</p>
<p>例如 <code>print!(&quot;\u&#123;1b&#125;[31;1;3;4m&#123;&#125;\u&#123;1b&#125;[0m&quot;, &quot;Rosa&quot;);</code>，其中 <code>\u&#123;1b&#125;[31;1;3;4m</code> 中，<code>31</code> 表示前景色（字的颜色）是红色，<code>1</code> 表示加粗，<code>3</code> 表示设置斜体，<code>4</code> 表示设置下划线。则上述代码输出的是一个红色加粗加下划线的斜体字符串 <code>Rosa</code>。最后的 <code>\u&#123;1b&#125;[0m</code> 表示将格式清除掉，否则下面输出的任何字符都将使用刚刚的样式。</p>
<p>同样，在 C 语言中也可以实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> color = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[20;1H\033[1;4;%dmHello, world.\033[0m&quot;</span>, color);</span><br></pre></td></tr></table></figure>
<p>这行命令首先 <code>\033[20;1H</code> 将光标移动到终端第 20 行第 1 列，之后的 <code>\033[1;4;32m</code> 将文本属性设置为高亮、带下划线且颜色为绿色，然后输出 <code>Hello,world</code>，最后 <code>\033[0m</code> 将终端属性恢复为默认值。</p>
<h2 id="三、一些参考实现"><a href="#三、一些参考实现" class="headerlink" title="三、一些参考实现"></a>三、一些参考实现</h2><h3 id="3-1-bash-中输出带样式的字符"><a href="#3-1-bash-中输出带样式的字符" class="headerlink" title="3.1 bash 中输出带样式的字符"></a>3.1 bash 中输出带样式的字符</h3><p>在 bash 中，通常我们可以使用 <code>echo</code> 命令加 <code>-e</code> 选项输出各种颜色的文本，<code>echo -e</code> 表示处理特殊字符，开启转义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\033[31mRed Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[32mGreen Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[33mYellow Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[34mBlue Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[35mMagenta Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[36mCyan Text\033[0m&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-C-语言中输出颜色表"><a href="#3-2-C-语言中输出颜色表" class="headerlink" title="3.2 C 语言中输出颜色表"></a>3.2 C 语言中输出颜色表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            n = <span class="number">10</span> * i + j;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">108</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[%dm %3d\033[m&quot;</span>, n, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、参考文档"><a href="#四、参考文档" class="headerlink" title="四、参考文档"></a>四、参考文档</h2><p>[浅析 <code>\x1B[1;3;31mxterm.js\x1B[0m</code> 是什么？如何在终端输出带颜色等格式的字符串<br>](<a href="https://www.cnblogs.com/goloving/p/15015053.html">https://www.cnblogs.com/goloving/p/15015053.html</a>)</p>
<p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI escape code</a></p>
<p><a href="https://www.cnblogs.com/opangle/p/4082692.html">控制台终端输出颜色</a></p>
<p>Rust 官方有进度条实现的 <a href="https://crates.io/crates/indicatif">indicatif crate</a>，用法比较全面，这里是 <a href="http://wilson-blog.cn/post/2021/02/20/rust.indicatif.html#indicatifmultiprogress">源码解析</a></p>
]]></content>
      <categories>
        <category>生产力工具</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust入门教程（四）：常用的集合</title>
    <url>/1bd17c37.html</url>
    <content><![CDATA[<h1 id="Rust-入门教程（四）：常用的集合"><a href="#Rust-入门教程（四）：常用的集合" class="headerlink" title="Rust 入门教程（四）：常用的集合"></a>Rust 入门教程（四）：常用的集合</h1><p>这一节介绍 Rust 中常用的几种集合类型：<code>Vector</code>，<code>String</code> 和 <code>HashMap</code>，这些集合类型都是存储在 Heap 中，不需要编译时确定大小，可以在运行时动态改变大小。</p>
<span id="more"></span>
<p>[toc]</p>
<h2 id="1-Vector"><a href="#1-Vector" class="headerlink" title="1. Vector"></a>1. Vector</h2><p>Vector 概念略，和 C++ STL 中的 Vector 差不多，下面来看使用：</p>
<p><strong>创建 Vector</strong></p>
<p>使用 <code>Vec::new()</code> 函数创建一个空 Vector，<code>let v: Vec&lt;i32&gt; = Vec::new();</code>（注意 V 是大写），也可以设定初始值进行创建，这时就要使用 <code>vec!</code> 宏，注意这里 v 是小写，<code>let v: vec![1, 2, 3];</code>。</p>
<p><strong>更新 Vector</strong></p>
<p>使用 <code>push</code> 方法向 vector 里添加元素</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Vec::new()</code> 创建 vector 时，需要显式指明类型，但是若下面用 push 函数添加 vector 元素时，编译器可以根据上下文推断出类型，于是便可以不用显式指定类型了。</p>
<p><strong>删除 Vector</strong></p>
<p>与任何其它 struct 一样，当 Vector 离开作用域后，它就被清理掉了，同时它所有的元素也被清理掉了</p>
<p><strong>读取 Vector 元素</strong></p>
<ul>
<li>索引</li>
<li>get 方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">45</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">third</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;.&quot;</span>, third);</span><br><span class="line">    <span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;.&quot;</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no element in the vec.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Vector 的 get 方法返回一个 Option 枚举类型，因此用 Some 和 None 做模式匹配。</p>
<p>但是如果用索引访问的下标越界的话，就会发生 panic，<strong>但是使用 get 的话，会返回 None.</strong></p>
<p><strong>所有权和借用规则</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">1</span>];</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在 <code>v.push();</code> 会报错，原因是 <code>first</code> 已经借用 v 为不可变引用，而 push 操作又将 v 变成可变的，因此会报错。</p>
<p>vector 之所以也有所有权和借用规则这样的机制，是因为 vector 是存储在堆中，并且数据是连续存放，如果在后面添加一个元素，而原来的内存中后面没有多余空间，则编译器将会在内存中重新寻找一块更大的内存来存放新的 vector，所以这是还是用原来 vector 的引用，就会发生错误。</p>
<p>实际上 C++ 中的 vector 也是这样的，但是 Rust 的语言机制从编译时就避免了，而不用等到运行时在发现错了，这也体现了 Rust 的高安全性和可靠性。下面是 C++ 中的 vector 元素首地址改变的例子，<a href="https://blog.csdn.net/wch0lalala/article/details/108337051">参考博客</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr&#x27;s size :&quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; capacity :&quot;</span> &lt;&lt; arr.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; head address :&quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">1</span> capacity :<span class="number">1</span> head address :<span class="number">0x10516fb0</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">2</span> capacity :<span class="number">2</span> head address :<span class="number">0x10516e30</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">3</span> capacity :<span class="number">4</span> head address :<span class="number">0x10516fb0</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">4</span> capacity :<span class="number">4</span> head address :<span class="number">0x10516fb0</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">5</span> capacity :<span class="number">8</span> head address :<span class="number">0x10516e30</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">6</span> capacity :<span class="number">8</span> head address :<span class="number">0x10516e30</span></span><br><span class="line">arr<span class="number">&#x27;</span>s size :<span class="number">7</span> capacity :<span class="number">8</span> head address :<span class="number">0x10516e30</span></span><br></pre></td></tr></table></figure>
<p>我们发现每次 vector 扩容时元素首地址都会改变。（注意在 vector 中，&amp;vec 和 &amp;vec[0] 是不一样的，这是因为 vector 结构存在栈中，而 vector 的数据存在堆中，&amp;vec 获得的只是栈中 vec 的结构的地址，始终不变，而 &amp;vec[0] 是堆中 vector 存储的真正的元素地址，每次动态扩容后都会改变）</p>
<p>好我们回到 Rust。</p>
<p><strong>遍历 vector</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想修改其中的值，看下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span>![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">5</span>;</span><br><span class="line">        <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>*i</code> 是解引用，我们以后会介绍。</p>
<p><strong>使用 enum 来存储多种数据类型</strong></p>
<p>vector 只能存储一种数据类型，但是我们有时候想存储不同类型的数据，我们可以用可附加数据的枚举来创建 vector。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Spreadsheetcell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Spreadsheetcell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">        Spreadsheetcell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Computer Science&quot;</span>)),</span><br><span class="line">        Spreadsheetcell::<span class="title function_ invoke__">Float</span>(<span class="number">6.18</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举的变体就可以在 vector 中存储不同类型的数据了。</p>
<h2 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h2><p>String 这个数据类型是所有编程语言中都非常重要的一个类型，Rust 开发者经常会被字符串困扰的原因是，Rust 倾向于暴露可能的错误，而且字符串数据结构复杂并且采用了 UTF-8 编码。</p>
<p><a href="#各种类型的编码">编码类型和编码方式</a></p>
<p>在 Rust 中，字符串是 Byte 的集合，并且有一些方法将 byte 解析为文本。</p>
<p><strong>字符串是什么</strong></p>
<p>从 Rust 语言的核心层面上将，只有一个字符串类型，叫字符串切片 <code>str</code>，它通常以引用的形式出现（即 <code>&amp;str</code>）。</p>
<p>字符串切片是对存储在其他地方，用 UTF-8 编码的字符串的引用。<strong>字符串字面值：存储在二进制文件中，也是字符串切片</strong></p>
<p><strong>String 类型，来自标准库，而不是核心语言</strong>，他可增长、可修改、可拥有，采用 UTF-8 编码，我们通常所说的字符串是指 <code>String</code> 和 <code>&amp;str</code> 两者，而不是单指某一种。当然这里主要将的是 <code>String</code>。</p>
<p><strong>其它类型的字符串</strong></p>
<p>Rust 的标准库还包含了很多其它的字符串类型，例如：OsString，OsStr、CString、CStr</p>
<ul>
<li>String vs Str 后缀：拥有或借用的变体</li>
<li>可存储不同编码的文本或在内存中以不同的形式展现</li>
<li>Library crate 针对存储字符串可提供更多的选项</li>
</ul>
<h3 id="2-1-字符串的创建"><a href="#2-1-字符串的创建" class="headerlink" title="2.1 字符串的创建"></a>2.1 字符串的创建</h3><ul>
<li>很多 <code>Vec&lt;T&gt;</code> 都可用于 <code>String</code></li>
<li>利用 <code>String::new()</code> 创建字符串</li>
<li>使用初始值来创建 String：<ul>
<li><code>to_string()</code> <strong>方法</strong>，可用于实现了 Display trait 的类型，包括字符串字面值</li>
<li><code>String::from()</code> <strong>函数</strong>，从字面值创建 String 类型</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s3</span> = <span class="string">&quot;Hello, Rust&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s4</span> = <span class="string">&quot;Hello, Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过字符串字面值创建的 <code>s3</code> 是切片类型，其他都是 String 类型</p>
<p>【注】：我理解的函数就是没有 self 参数的，通过 <code>::</code> 来调用，而方法则是带有 <code>&amp;self</code> 为其第一个参数，是通过实例来调用的，使用的是点调用的方式</p>
<h3 id="2-2-字符串更新"><a href="#2-2-字符串更新" class="headerlink" title="2.2 字符串更新"></a>2.2 字符串更新</h3><ul>
<li>使用 <code>push_str()</code> <strong>方法</strong>，把一个字符串切片附加到 String，这个方法不会获得参数的所有权</li>
<li>使用 <code>push()</code> <strong>方法</strong>，将一个单独的字符附加到 String 后</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;, Rust&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(&amp;s1);</span><br><span class="line">    s1.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还是可以打印出 s1 的值，说明没有获得 s1 的所有权。</p>
<ul>
<li><code>+</code> 用来连接字符串，注意加号前是<strong>字符串类型</strong>，后面是<strong>字符串类型的引用</strong><ul>
<li>使用了类似这个签名的方法 <code>fn add(self, s: &amp;str) -&gt; String &#123; ... &#125;</code></li>
<li>标准库中 <code>add</code> 方法使用了泛型</li>
<li>解引用强制转换（deref coercion）</li>
<li>只能把 <code>&amp;str</code> 添加到 <code>String</code></li>
</ul>
</li>
<li><code>format!</code> 用于连接多个字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;, Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，我们发现 <code>s1</code> 不能再使用了，而 <code>s2</code> 可以再被使用，因为底层方法中使用了类似这个签名的方法 <code>fn add(self, s: &amp;str) -&gt; String &#123; ... &#125;</code>，是将字符串自身和另一个字符串的切片进行相加组合。但是 <code>s2</code> 是字符串类型，而函数参数中是字符串切片类型，不匹配，为什么代码 <code>let s3 = s1 + &amp;s2;</code> 能够编译通过？</p>
<p>这是因为标准库中 <code>add</code> 方法使用了泛型，Rust 采用了一种叫 <strong>解引用强制转换（deref coercion）</strong> 的技术，强制将字符串类型转化成字符串切片类型，因此 <code>s2</code> 的所有权就会被保留，而 <code>add</code> 函数就会取得第一个参数的所有权，当函数调用完毕时，<code>s1</code> 的所有权就会消失。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let s3 = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;, s3);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中将三个字符串之间用 <code>-</code> 连接，如果代码太多显得很繁琐，采用 <code>format!</code> 宏不仅可以使得代码简单易读，更重要的是不会取得所有变量的所有权。这个宏和 <code>println!</code> 很像，只不过 <code>format!</code> 宏是将结果返回，这里可以用一个变量去接收。</p>
<h3 id="2-3-字符串的索引"><a href="#2-3-字符串的索引" class="headerlink" title="2.3 字符串的索引"></a>2.3 字符串的索引</h3><p>不可以按照索引的语法对 String 某部分进行访问，因为 String 类型没有实现 <code>Index&lt;Integer&gt;</code> trait，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = s[<span class="number">0</span>];  <span class="comment">//这样是错误的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以无法通过索引进行访问是因为，字符串是用 UTF-8 进行编码，每一个字符都对应一个 Unicode 编码。在英文中，一个字符是 <code>1B</code>，而对于某些语言，一个字符可能对应 <code>2B</code>，而中文一个字符对应 <code>3B</code>，因此用索引进行访问的话，无法知道应该取一个字节还是两个字节。</p>
<p>当然 Rust 不允许通过索引进行访问的另一个原因是，索引操作理应只消耗 <code>O(1)</code> 的时间，但是为了保证不会越界，需要使用 <code>O(n)</code> 的时间进行遍历字符串长度。</p>
<p><strong>String 内部表示</strong></p>
<p>String 实际上是对 <code>Vec&lt;u8&gt;</code> 进行的包装，可以用 <code>len()</code> 方法获得字符串长度</p>
<p>字节（Bytes），标量值（Scalar Values），字形簇（Grapheme Clusters）</p>
<p>Rust有三种看待字符串的方式：</p>
<ul>
<li>字节</li>
<li>标量值</li>
<li>字形簇（最接近所谓的“字母”）</li>
</ul>
<h3 id="2-4-切割-String"><a href="#2-4-切割-String" class="headerlink" title="2.4 切割 String"></a>2.4 切割 String</h3><p>可以使用 <code>[]</code> 和 <code>一个范围</code> 来创建一个字符串的切片</p>
<ul>
<li>要谨慎使用</li>
<li>如果切割时越过边界就会 panic</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好吗&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们说了在 Rust 中一个中文字符占 <code>3B</code>，因此我们获取字符串 hello 的前 3 个字节，输出结果为 <code>你</code>，但是要注意的是，所获取的字节必须能够构成所定义的字符，比如只获取前两字节最后运行就会报错（但是编译不会报错）。</p>
<h3 id="2-5-遍历-String"><a href="#2-5-遍历-String" class="headerlink" title="2.5 遍历 String"></a>2.5 遍历 String</h3><ul>
<li>对于标量值：chars() 方法</li>
<li>对于字节：bytes() 方法</li>
<li>对于字形簇，过于复杂，标准库未提供</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好吗&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> hello.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> hello.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">你 好 吗 </span><br><span class="line"><span class="number">228</span> <span class="number">189</span> <span class="number">160</span> <span class="number">229</span> <span class="number">165</span> <span class="number">189</span> <span class="number">229</span> <span class="number">144</span> <span class="number">151</span></span><br></pre></td></tr></table></figure>
<p><strong>String不简单</strong></p>
<ul>
<li>Rust 选择将正确处理 String 数据作为所有 Rust 程序的默认行为——程序员必须在处理 UTF-8 数据之前投入更多的精力</li>
<li>可防止在开发后期处理涉及非 ASCII 字符的错误</li>
</ul>
<h3 id="各种类型的编码"><a href="#各种类型的编码" class="headerlink" title="各种类型的编码"></a>各种类型的编码</h3><ul>
<li>1967 年 ASCII，包含英文字母，阿拉伯数字，西文字符和控制字符</li>
<li>1980 年 GB2312，包含简体中文，拉丁字母和日文假名</li>
<li>1984 年 BIG5，增加了繁体字</li>
<li>1993 年 GB130001，包含了中日韩三国文字</li>
<li>1995 年 GBK，不支持韩文</li>
<li>2000 年 GB18030，兼容更多的字符</li>
</ul>
<p>在 1994 年诞生的 Unicode 实现了编码的全球化。</p>
<p>那么这时候如何表示字符呢，英文所需要表示的二进制位和汉字所要表示的二进制位肯定是不同的，也就是说一个英文字符可能要占 1B，而汉字要占 2B，编码时都是将二进制连接在一起，那么怎么知道当前的一个字节所要表示的是英文还是中文呢？因此直接将每个字符用编号表示无法正确区分每个字符的边界。</p>
<p>一种解决方法是 <strong>定长编码</strong>，即每个字符都用统一长度表示，位数不够前面补 0。但是这样又出现了一个问题，一个英文字母要占两个字节，要忍受前面全是 0 的情况，只会占用更多的内存。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220519005429.png" alt="定长编码"></p>
<p>解决方法也很简单，可以采用 <strong>变长编码</strong>，那么如何区分字符边界呢？其实和计组中的 <strong>拓展操作码</strong>，<strong>IP 地址</strong>，<strong>哈夫曼编码</strong> 都很类似，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220519005820.png" alt="变长编码"></p>
<p>这就是 <strong>UTF-8 编码</strong></p>
<h2 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h2><p>和各种语言中的 HashMap 一样，也是通过键值对来存储数据，通过键（Key）来寻找数据，而不是索引</p>
<h3 id="3-1-创建-HashMap"><a href="#3-1-创建-HashMap" class="headerlink" title="3.1 创建 HashMap"></a>3.1 创建 HashMap</h3><ul>
<li>创建空 HashMap：new() 函数</li>
<li>添加数据：insert() 方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hash</span>: HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    hash.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry&quot;</span>), <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若声明的时候没有指定类型，则必须要插入数据才不会报错，若声明时已经指定类型了，那么不用插入数据也不会报错。</p>
<ul>
<li>HashMap 用的较少，不在 Prelude中</li>
<li>标准库对其支持较少，没有内置的宏来创建</li>
<li>HashMap 数据存储在 heap 上</li>
<li>同构的。一个 HashMap 中<ul>
<li>所有的 K 必须是同一种类型</li>
<li>所有的 V 必须是同一种类型</li>
</ul>
</li>
</ul>
<p><strong>另一种创建 HashMap 的方式：collect 方法</strong></p>
<p>在元素类型为 Tuple 的 Vector 上使用 collect 方法，可以组建一个 HashMap</p>
<ul>
<li>要求 Tuple 有两个值：一个作为 K，一个作为 V</li>
<li>collect 方法可以把数据整合成很多种集合类型，包括 HashMap</li>
<li>返回值需要显式指明类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Lakers&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rank</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nba</span>: HashMap&lt;_, _&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(rank.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>collect</code> 时，要显式声明返回类型，因为它可以生成各种类型。</p>
<p><strong>HashMap 和所有权</strong></p>
<p>对于实现了 Copy trait 的类型（例如i32），值会被复制到 HashMap 中。对于拥有所有权的值（例如String)，值会被移动，所有权会转移给 HashMap。</p>
<p>如果将值的引用插入到 HashMap，值本身不会移动一在 HashMap 有效的期间，<strong>被引用的值必须保持有效</strong>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Champion&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(key, value);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, key, value);      <span class="comment">//这里会报错，因为key和value所有权已经没有了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通常应该是这样插入数据</span></span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(&amp;key, &amp;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在堆 HashMap 赋值之后，key 和 value 的所有权就被转移给了 HashMap，通常都是传入字符串的引用。</p>
<h3 id="3-2-访问-HashMap"><a href="#3-2-访问-HashMap" class="headerlink" title="3.2 访问 HashMap"></a>3.2 访问 HashMap</h3><p>get方法</p>
<ul>
<li>参数：K</li>
<li>返回：<code>Option&lt;&amp;V&gt;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nba</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    nba.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Suns&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">    nba.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Lakers&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">team</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rank</span> = nba.<span class="title function_ invoke__">get</span>(&amp;team);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> rank &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;team not exist&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 的 get 方法返回的是一个 Option 枚举，并且 get 方法的参数是 String 的引用。</p>
<h3 id="3-3-遍历-HashMap"><a href="#3-3-遍历-HashMap" class="headerlink" title="3.3 遍历 HashMap"></a>3.3 遍历 HashMap</h3><p>使用 for 循环：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nba</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    nba.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Suns&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">1</span>);</span><br><span class="line">    nba.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Lakers&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (k, v) <span class="keyword">in</span> &amp;nba &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(k, v) 这里是用元组做模式匹配。</p>
<h3 id="3-4-更新-HashMap"><a href="#3-4-更新-HashMap" class="headerlink" title="3.4 更新 HashMap"></a>3.4 更新 HashMap</h3><ul>
<li>HashMap 大小可变</li>
<li>每个 K 同时只能对应一个 V</li>
<li>更新 HashMap 中的数据</li>
<li>K 已经存在，对应一个 V<ul>
<li>替换现有的 V</li>
<li>保留现有的 V，忽略新的 V</li>
<li>合并现有的 V 和新的 V</li>
</ul>
</li>
<li>K 不存在<ul>
<li>添加一对新的 K, V</li>
</ul>
</li>
</ul>
<p><strong>替换现有的 V</strong></p>
<p>如果向 HashMap 插入一对 (K, V)，然后再插入同样的 K，但是不同的 V，那么原来的 V 会被替换掉</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>), <span class="number">115</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>), <span class="number">132</span>);   <span class="comment">//覆盖</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只在 K 不对应任何值的情况下，才插入 V</strong></p>
<p>entry方法</p>
<ul>
<li>检查指定的 K 是否对应一个 V</li>
<li>参数为 K</li>
<li>返回 enum Entry：代表值是否存在</li>
</ul>
<p>Entry 的 or_insert()方法</p>
<ul>
<li>返回<ul>
<li>如果 K 存在，返回到对应的 V 的一个可变引用</li>
<li>如果 K 不存在，将方法参数作为 K 的新值插进去，返回到这个值的可变引用</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Suns&quot;</span>), <span class="number">115</span>);</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Lakers&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">or_insert</span>(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>scores.entry()</code> 返回 Entry，如果没有值的话，会返回类似于 <code>Entry(VacantEntry(&quot;Lakers&quot;))</code> 的枚举。</p>
<p><strong>基于现有值来更新</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;What a wonderful world a a a&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终返回结果为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;wonderful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;world&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&quot;What&quot;</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Hash-函数"><a href="#3-5-Hash-函数" class="headerlink" title="3.5 Hash 函数"></a>3.5 Hash 函数</h3><p>默认情况下，HashMap 使用加密功能强大的 Hash 函数，可以抵抗拒绝服务（DoS）攻击。</p>
<ul>
<li>不是可用的最快的 Hash 算法</li>
<li>但具有更好安全性。</li>
<li>可以指定不同的 hasher 来切换到另一个函数</li>
<li>hasher 是实现 BuildHasher trait 的类型</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>l2p cache 优化方案</title>
    <url>/32e63730.html</url>
    <content><![CDATA[<h2 id="l2p-cache-优化方案"><a href="#l2p-cache-优化方案" class="headerlink" title="l2p cache 优化方案"></a>l2p cache 优化方案</h2><p>根据已有的 cache 方案，在 SLC 模式下，由于映射表大小不到 400MB，因此将整个映射表存储在 DRAM 中。</p>
<p>先对这种情况的地址映射进行分析。</p>
<span id="more"></span>
<h3 id="1-映射表和全局映射目录"><a href="#1-映射表和全局映射目录" class="headerlink" title="1. 映射表和全局映射目录"></a>1. 映射表和全局映射目录</h3><p>在原先的方案中有两种映射表，一种是存放每一个 page 表项的映射表，每个表项大小为 4B，这个表项用一维数组来存储，数组的下标记录对应表项的逻辑地址。另一种表存放第一种映射表所在 page 的映射，称为 GTD（Global Table Directory，全局表目录），非常类似于二级页表。GTD 表每个表项也是 4B，也用一维数组来表示。数组下标指明逻辑页号的范围，数组元素存放对应的 page 位置。</p>
<p>根据 page 所设定的大小和项目所采用的硬件参数，一个 page 为 16KB，一个表项为 4B，则一个 page 可以存放 16KB/4KB=4K 个表项，GTD 的第一个表项指向存放逻辑地址从 0 到 4K-1 的表项所存储的页的物理地址，GTD 第二个表项则指向存放逻辑地址从 4K 到 8K-1 的表项所存储的页的物理地址。。。以此类推，最后大约需要 7 个 page 即可存储所有 GTD。</p>
<h3 id="2-物理地址的分配"><a href="#2-物理地址的分配" class="headerlink" title="2. 物理地址的分配"></a>2. 物理地址的分配</h3><p>先对每个逻辑页分配可用的物理页，（首先确保该逻辑地址是有效的，不能重复分配逻辑地址）若该逻辑页被写过，则覆盖对应的物理页。</p>
<p>同时以块为单位，对每个 page 进行管理，用 <code>free</code>, <code>valid</code>, <code>invalid</code> 标记 page 的三种状态</p>
<h3 id="3-cache-优化方案"><a href="#3-cache-优化方案" class="headerlink" title="3. cache 优化方案"></a>3. cache 优化方案</h3><p>优化思路为：只将一部分最近使用的映射表以及全部 GTD 放进 DRAM，完整的映射表存放在 flash 中。采用 TPFTL 方案，DRAM 中使用两级 LRU 进行管理。基本思路如下：</p>
<p>缓存中的每个表项根据翻译页进行聚类，即同属于一个翻译页的表项聚合在一个 TP 结点下，TP 结点用一个 LRU 列表进行管理，而每一个 TP 结点下的所有表项也用 LRU 列表进行管理，这样便形成了两级 LRU。</p>
<p>用来管理 TP 结点的 LRU 列表称为页级 LRU，管理每个 TP 结点下表项的 LRU 列表被称为条目级 LRU。每个 TP 结点的热度由该结点下所有表项的平均热度所计算得出，根据这个热度值来决定该 TP 结点在页级 LRU 列表中的位置。</p>
<p>进行 LRU 替换时，先找出页级 LRU 中热度最低的 TP 结点，再从该结点中找出热度最低的表项进行替换，尽管其他 TP 结点中可能有比被替换的热度更低的表项。</p>
<p>另外缓存中还有一个计数器来维护 TP 结点的数量。</p>
<h4 id="DFTL-优化方案"><a href="#DFTL-优化方案" class="headerlink" title="DFTL 优化方案"></a>DFTL 优化方案</h4><p>实现步骤：</p>
<ol>
<li>首先获得要访问的逻辑页号，检查 cache 中是否已经存在该页</li>
<li>若存在，直接访问对应的物理页号，将该表项标记为最近使用过，转到 10</li>
<li>若不存在，则进行 4</li>
<li>若 CMT（cached mapping table，即 DRAM 存储的部分映射表）中表项没满，转到 6</li>
<li>若 CMT 表项已满，则在 CMT 中使用 LRU 替换算法，找到要替换的表项，转到 7</li>
<li>根据逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，将其放入 DRAM 的 CMT 中，标记该表项为最近使用过，转到 10</li>
<li>检查该页是否被修改过</li>
<li>若修改过则将其写回 flash 同时修改 GTD 表，转到 6</li>
<li>若没有修改过，删除该表项，转到 6</li>
<li>完成一次逻辑页到物理页的转换，重复 1</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220609221501.png" alt="DFTL流程图"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220609181254.png" alt="优化后访问flash的示意图"></p>
<h4 id="TPFTL-优化方案"><a href="#TPFTL-优化方案" class="headerlink" title="TPFTL 优化方案"></a>TPFTL 优化方案</h4><ol>
<li>首先获得要访问的逻辑页号，根据页号检查对应的 TP 结点是否被缓存</li>
<li>若已缓存，检查该结点下的表项，若存在该页，转到 4，若不存在该页，转到 5</li>
<li>若没有缓存，则缓存不命中，转到 5</li>
<li>访问对应的物理页号，将该表项标记为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11</li>
<li>若 LRU 列表没满，转到 7</li>
<li>若 LRU 列表已满，则先在页级 LRU 列表中选出热度最低的 TP 结点，然后再在 TP 结点下找到热度最低的表项，转到 8</li>
<li>根据请求的逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，若 DRAM 中没有缓存该 TP 结点，则创建新 TP 结点，若有 TP 结点而没有表项，则创建新表项，标记该表项为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11</li>
<li>检查该页是否被修改过</li>
<li>若修改过则将其写回 flash 同时修改 GTD 表，转到 7</li>
<li>若没有修改过，删除该表项，转到 7</li>
<li>完成一次逻辑页到物理页的转换，重复 1</li>
</ol>
<p><strong>流程图如下所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220615143024.png" alt="TPFTL流程图"></p>
<h4 id="两级-LRU-算法实现思路"><a href="#两级-LRU-算法实现思路" class="headerlink" title="两级 LRU 算法实现思路"></a>两级 LRU 算法实现思路</h4><p><strong>1. 时间戳</strong></p>
<p>通过设置一个全局时间戳，在每次替换新表项时，将表项中的流行度字段设置为当前时间戳，每个 TP 结点的平均热度由其下的所有表项的热度的平均值决定。</p>
<p>但是这样会导致两个严重的问题：</p>
<ol>
<li>全局时间戳是一个有范围的整型，系统到一定阶段一定会溢出，这时时间戳就会归零。归零之后表项记录热度所表示的时间戳较小，但是却是最近使用过的；</li>
<li>当时间戳较大时（快要到整型所表示的范围时），需要计算 TP 结点的平均热度，这时需要将结点下所有表项的热度相加再取平均，在相加求和的过程中，采用一般的直接相加的方法将会导致溢出。</li>
</ol>
<p><strong>2. 访问次数</strong></p>
<p>将每个表项的时间戳字段改成访问次数，即根据访问次数来进行替换，先替换访问次数少的，当访问次数相同时，再根据先后次序进行替换。</p>
<p>这样仍然会产生两个问题：</p>
<ol>
<li>只能体现 “最久” 未使用，而不能体现出 “最近”，若一个刚刚被访问的新的表项，访问次数显然为 1，但是它却是刚来的，显然不能被替换；</li>
<li>对于两级 LRU，需要计算 TP 结点的平均热度，通过平均访问次数也无法体现出 “最近”，即若一个 TP 结点下频繁发生替换（即命中率不高），那么平均访问次数偏低，但是该 TP 结点却是最近访问的。</li>
</ol>
<p><strong>3. 命中或替换一个表项时将该表项计数器清零</strong></p>
<p>另一种实现思路是命中或替换一个表项时，将该表项的计数器清零，其余的表项加一，TP 结点下所有表项的计数器平均值越低说明该 TP 结点热度越高。</p>
<p>尽管这样不会出现计数器溢出，但是会导致一个问题：</p>
<p>若命中 TP1 结点下的某一表项，将该表项清零后只将该 TP1 结点的其他表项计数器加一，这样仍然会导致算法不能体现出 “最近”（即频繁访问的 TP 结点由于很多计数器被加了一从而导致该 TP 结点计数器平均值较高）。</p>
<p>提出两种解决方案：</p>
<ol>
<li>在将命中或替换的表项计数器归零时，遍历所有 TP 结点和 TP 结点下的所有表项，将内存中所有表项的计数器全部加一，但是这样可能会导致极大的时间开销（具体的时间开销占比还不清楚，不知道系统是否能容忍这样的时间开销）；</li>
<li>在 TP 结点上再增加一个字段，用来记录在下一次命中自己之前，其他 TP 结点中命中或替换的次数，等待下次自己被命中时，再将 TP 结点下所有表项的计数器加上该字段值。</li>
</ol>
<p><strong>最终解决方案</strong></p>
<p>综合考虑后，最终的解决方案在访问次数的基础上进行改进。表项级 LRU 列表以访问的先后顺序进行排序，最新访问的表项插入链表的头部，同时维护一个访问次数字段，TP 结点平均热度就是访问次数的平均值。尽管这样可能会使得最近访问的表项的 TP 结点成为热度最低的结点，但这已经是相对完善且资源消耗较少的方案。每个表项的热度被页面级热度所掩盖，这导致利用时间局部性的效率较低。由于缓存空间利用率的提高，缓存命中率略有提高。</p>
<h3 id="4-结构体定义"><a href="#4-结构体定义" class="headerlink" title="4. 结构体定义"></a>4. 结构体定义</h3><p>在原来 l2p 模块基础上新增以下结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页级 LRU 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tp_node_list</span> &#123;</span></span><br><span class="line">    list_node tp_list_node;             <span class="comment">// tp 链表头结点</span></span><br><span class="line">    u32 entry_per_tp_node[MAX_TP_NODE]; <span class="comment">// 存储每个 tp 结点下有多少表项的表，0 表示当前 tp 结点不存在</span></span><br><span class="line">    u32 tp_node_num;                    <span class="comment">// 有效 TP 结点数量</span></span><br><span class="line">    tp_node *lru_tp_node;               <span class="comment">// 热度最低（最近最久未使用）的 TP 结点</span></span><br><span class="line">    u32 total_entry_num;                <span class="comment">// 总表项个数，代表缓存中映射表总容量</span></span><br><span class="line">&#125; tp_node_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">tp_entry_node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* TP 结点数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u16 tvpn;                       <span class="comment">// 虚拟翻译页号</span></span><br><span class="line">        u16 entry_num;                  <span class="comment">// 结点下表项数量</span></span><br><span class="line">        u32 ava_popular;                <span class="comment">// 结点平均热度</span></span><br><span class="line">        list_head entry_list;           <span class="comment">// 表项链表头结点</span></span><br><span class="line">        list_node tp_node;              <span class="comment">// tp 链表结点</span></span><br><span class="line">    &#125; tp_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个 TP 结点下的表项结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        list_node entry_node;           <span class="comment">// 表项链表结点</span></span><br><span class="line">        psa_entry entry;                <span class="comment">// psa 结构体，存储 l2p 映射表项</span></span><br><span class="line">        u32 popular;                    <span class="comment">// 表项热度</span></span><br><span class="line">        u32 reserve;                    <span class="comment">// 填充空间，为了结构体和 tp_node 占用空间一样</span></span><br><span class="line">    &#125; entry_node;</span><br><span class="line">&#125; tp_entry_node;</span><br></pre></td></tr></table></figure>
<p><strong>下面是结构体之间的关系图。</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220621183034.png" alt="结点关系图"></p>
<h3 id="5-函数定义"><a href="#5-函数定义" class="headerlink" title="5. 函数定义"></a>5. 函数定义</h3><p>在原有 l2p 模块中函数基础上，新增以下函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得最近最久未使用的映射表项。</span></span><br><span class="line"><span class="comment"> * 在表项链表头结点的前一个结点，（即整个链表的最后一个结点）就是最近最久未使用的表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">entry_node *<span class="title">l2p_get_least_recent_used_entry</span><span class="params">(tp_node *entry_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 DRAM 中有表项变化时，更新所有 TP 结点的流行度，更改 tp_node_list 结点信息。</span></span><br><span class="line"><span class="comment"> * 当进行替换时，表项会进行变化，同样带来 TP 结点的热度变化，调用函数获得热度最低的 TP 结点，更新字段。</span></span><br><span class="line"><span class="comment"> * 该 TP 结点的热度由 tp_node 结构体中 ava_popular 字段指定，该字段由 TP 结点下所有表项的热度之和除以表项数量得出（取整即可）。</span></span><br><span class="line"><span class="comment"> * 循环以 tp_node_list 为头结点的链表，选出热度最低的 TP 结点。（算法待定，暂时用循环解决）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_update_tp_node_list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前的逻辑子页号所属的 TP 结点是否被缓存 */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_is_TP_node_cached</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查 tp_node_list 结点下的 total_entry_num 字段，判断当前所给内存是否已满 */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_is_DRAM_empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据物理地址从闪存中读取相应表项放到内存中 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_read_entry_from_flash</span><span class="params">(psa_entry *psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将被修改的表项写回闪存。</span></span><br><span class="line"><span class="comment"> * 有一个小问题：表项在内存中需要有热度字段，在闪存中则无需该字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_write_the_modified_entry_back_to_flash</span><span class="params">(l2p_table_entry *l2p_entry)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原来模块中的函数定义如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置当前 l2p 表项无效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_invalid_l2p_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前 l2p 表项有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_valid_l2p_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前标状态是否有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_if_l2p_entry_valid</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断两个 psa 表项所表示的 psa 是否相等 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_if_psa_equal</span><span class="params">(psa_entry *a, psa_entry *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* psa + 1 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_inc_psa</span><span class="params">(psa_entry *psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 block 结构体的 page 状态字段中得到子页的状态 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> BIT <span class="title">l2p_get_subpage_status</span><span class="params">(<span class="type">bitmap_t</span> T, psa_entry psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置子页的状态 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_set_subpage_status</span><span class="params">(<span class="type">bitmap_t</span> T, psa_entry *psa, BIT bit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 block table，为其分配内存 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_block_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给 l2p_table 指针分配地址，初始化 l2p_table */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_l2p_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 global_table 指针，分配地址，初始化 global_table*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_global_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号（lsn）查找相应的 l2p 表项 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> boolean <span class="title">l2p_search_l2p_entry</span><span class="params">(l2p_table_index lsn, l2p_table_entry *l2p_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改逻辑子页号 lsn 对应的 l2p 表项，并设置该表项为有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_update_l2p_table</span><span class="params">(l2p_table_index lsn, l2p_table_entry l2p_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ？ */</span></span><br><span class="line"><span class="function"><span class="type">static</span> psa_entry <span class="title">l2p_get_new_psa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> psa_entry <span class="title">l2p_get_and_update_global_psa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 L2P 模块，为 global_psa 分配内存*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_init_l2p_module</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号 lsn 获得一个 l2p entry，此函数是提供给别的模块的 API*/</span></span><br><span class="line"><span class="function">l2p_table_entry <span class="title">l2p_get_l2p_entry</span><span class="params">(l2p_table_index lsn, u32 opcode, u32 is_searched)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号 lsn 获得对应表项的翻译页所在的全局翻译目录（GTD） 的表项 */</span></span><br><span class="line"><span class="function">global_table_entry <span class="title">l2p_get_global_table_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-全局变量"><a href="#6-全局变量" class="headerlink" title="6. 全局变量"></a>6. 全局变量</h3><p>在原有 l2p 模块中全局变量的基础上，新增以下全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tp_node_list *tp_list;        <span class="comment">// 管理所有 tp 结点的链表头结点</span></span><br></pre></td></tr></table></figure>
<p>原有的全局变量如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">psa_entry global_psa;         <span class="comment">// 记录下一个待分配地址</span></span><br><span class="line"></span><br><span class="line">block_entry *block_table;     <span class="comment">// 用来记录每个 block，指向一个一维数组的指针</span></span><br><span class="line"></span><br><span class="line">global_table_entry *g_table;  <span class="comment">// 用来记录 global_table，指向一个一维数组的首地址</span></span><br><span class="line"></span><br><span class="line">l2p_table_entry *l2p_table;   <span class="comment">// 用来记录 l2p_table，指向一个一维数组的首地址</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li>[x] psa 地址更新的优先级为什么是 <code>subpage-&gt;plane-&gt;ch-&gt;ce-&gt;lun-&gt;block-&gt;page</code>?</li>
<li>[x] 代码中有两处疑问：<ul>
<li>[x] <code>l2p.h</code> Line: 42（lun: 1？）</li>
<li>[x] <code>l2p.h</code> Line: 48（slc_ppa？）</li>
</ul>
</li>
<li>[x] 为什么要记录下一个即将分配的 subpage 物理地址，记录当前的是否能够起到同样的逻辑？</li>
<li>[x] <code>u8 free[PAGE_PER_BLOCK / 8 + 1][PAGE_SIZE / SUB_PAGE_SZ];</code> 除以 8 是什么意思？（<code>l2p.h</code> Line: 75）</li>
</ul>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul>
<li>psa：physical subpage address，物理子页地址</li>
<li>GTD：global table directory，全局表目录</li>
<li>CMT：cached mapping table，缓存的映射表，存放在 DRAM 中</li>
<li>TP：translation page</li>
</ul>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul>
<li>[ ] 是否要进行指令缓存，有竞争情况，是否加锁</li>
<li>[x] DFTL 要改成 TPFTL</li>
<li>[ ] 更新页级 LRU 和条目级 LRU 列表算法</li>
<li>[x] 192MB DRAM</li>
<li>[x] 给定 TP 结点数量？TP 结点和 entry 结点总和为 8M 个</li>
<li><p>[ ] 读写 flash 步骤：先 FCL_get_free_SQ_entry(u32 ch)，返回得到 SQ index，ch 是约定的 flash 中 l2p 表地址的 channel，然后 FCL_set_SQ_entry，最后 FCL_send_SQ_entry</p>
</li>
<li><p>[x] 申请一个空的 SQ_entry 之后，如何将参数写入 SQ_entry？</p>
</li>
<li>[x] <code>void FCL_set_SQ_entry(u32 hcmd_entry_index, u32 SQ_entry_index, u32 buffer_index, u32 opcode, phy_page_addr *ppa, u32 cmd_sp)</code> 里的参数含义，怎么使用？（hcmd_entry_index、cmd_sp 为 0 即可，buffer_index 是内存中你要读写的地址，phy_page_addr 是你要写入的 flash 的地址，全部自己指定）</li>
<li>[x] 若读取 flash 中的数据，send SQ_entry 之后，通过哪些接口取得该数据？</li>
<li>[x] block_entry *block_table;    用来记录 block 中 page 的状态，指向一个 4 维数组的首地址，访问数组元素的形式可为 <code>block_table[ch][ce][lun][plane]</code>（应该是 <code>block_table[ch][ce][lun][plane][block]</code>？）</li>
<li>[x] 重新定义了结构体，TP 结点和 entry 结点数量总和为 8M，每个 tp 结点或 entry 结点结构体大小为 20B，总大小约为 160MB，可映射约 8MB * 4KB = 32GB 的闪存空间。加上结点的状态位 8MB，一共占用空间约为 168MB</li>
<li>[x] <code>block_table</code> 记录的是闪存块中每个页的状态，该数据从何处读取</li>
<li>[x] <code>g_table</code> 和 <code>l2p</code> 表在闪存中有固定的位置，该位置由谁指定？</li>
<li>[x] LRU 实现策略</li>
</ul>
]]></content>
      <categories>
        <category>OpenSSD</category>
        <category>文档</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown箭头汇总</title>
    <url>/be1bf65e.html</url>
    <content><![CDATA[<h1 id="Markdown箭头的输入方法汇总"><a href="#Markdown箭头的输入方法汇总" class="headerlink" title="Markdown箭头的输入方法汇总"></a>Markdown箭头的输入方法汇总</h1><h2 id="普通箭头"><a href="#普通箭头" class="headerlink" title="普通箭头"></a>普通箭头</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">箭头形状</th>
<th>MarkDown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td>$\uparrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Uparrow$</td>
<td>$\Uparrow$</td>
</tr>
<tr>
<td style="text-align:center">$\downarrow$</td>
<td>$\downarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Downarrow$</td>
<td>$\Downarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\leftarrow$</td>
<td>$\leftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Leftarrow$</td>
<td>$\Leftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\rightarrow$</td>
<td>$\rightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Rightarrow$</td>
<td>$\Rightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\updownarrow$</td>
<td>$\updownarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Updownarrow$</td>
<td>$\Updownarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrow$</td>
<td>$\leftrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Leftrightarrow$</td>
<td>$\Leftrightarrow$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<span id="more"></span>
<h2 id="长箭头"><a href="#长箭头" class="headerlink" title="长箭头"></a>长箭头</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">箭头形状</th>
<th>MarkDown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\longleftarrow$</td>
<td>$\longleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Longleftarrow$</td>
<td>$\Longleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\longrightarrow$</td>
<td>$\longrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Longrightarrow$</td>
<td>$\Longrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\longleftrightarrow$</td>
<td>$\longleftrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\Longleftrightarrow$</td>
<td>$\Longleftrightarrow$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="其他箭头"><a href="#其他箭头" class="headerlink" title="其他箭头"></a>其他箭头</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">箭头形状</th>
<th>MarkDown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\twoheadrightarrow$</td>
<td>$\twoheadrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\rightarrowtail$</td>
<td>$\rightarrowtail$</td>
</tr>
<tr>
<td style="text-align:center">$\looparrowright$</td>
<td>$\looparrowright$</td>
</tr>
<tr>
<td style="text-align:center">$\curvearrowright$</td>
<td>$\curvearrowright$</td>
</tr>
<tr>
<td style="text-align:center">$\circlearrowright$</td>
<td>$\circlearrowright$</td>
</tr>
<tr>
<td style="text-align:center">$\Rsh$</td>
<td>$\Rsh$</td>
</tr>
<tr>
<td style="text-align:center">$\multimap$</td>
<td>$\multimap$</td>
</tr>
<tr>
<td style="text-align:center">$\leftrightsquigarrow$</td>
<td>$\leftrightsquigarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\rightsquigarrow$</td>
<td>$\rightsquigarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\leadsto$</td>
<td>$\leadsto$</td>
</tr>
<tr>
<td style="text-align:center">$\nearrow$</td>
<td>$\nearrow$</td>
</tr>
<tr>
<td style="text-align:center">$\searrow$</td>
<td>$\searrow$</td>
</tr>
<tr>
<td style="text-align:center">$\swarrow$</td>
<td>$\swarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nwarrow$</td>
<td>$\nwarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nleftarrow$</td>
<td>$\nleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nLeftarrow$</td>
<td>$\nLeftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nrightarrow$</td>
<td>$\nrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nRightarrow$</td>
<td>$\nRightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nleftrightarrow$</td>
<td>$\nleftrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\nLeftrightarrow$</td>
<td>$\nLeftrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\dashrightarrow$</td>
<td>$\dashrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\dashleftarrow$</td>
<td>$\dashleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\leftleftarrows$</td>
<td>$\leftleftarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrows$</td>
<td>$\leftrightarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\Lleftarrow$</td>
<td>$\Lleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\twoheadleftarrow$</td>
<td>$\twoheadleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\leftarrowtail$</td>
<td>$\leftarrowtail$</td>
</tr>
<tr>
<td style="text-align:center">$\looparrowleft$</td>
<td>$\looparrowleft$</td>
</tr>
<tr>
<td style="text-align:center">$\curvearrowleft$</td>
<td>$\curvearrowleft$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">箭头形状</th>
<th>MarkDown</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\circlearrowleft$</td>
<td>$\circlearrowleft$</td>
</tr>
<tr>
<td style="text-align:center">$\Lsh$</td>
<td>$\Lsh$</td>
</tr>
<tr>
<td style="text-align:center">$\mapsto$</td>
<td>$\mapsto$</td>
</tr>
<tr>
<td style="text-align:center">$\hookleftarrow$</td>
<td>$\hookleftarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\hookrightarrow$</td>
<td>$\hookrightarrow$</td>
</tr>
<tr>
<td style="text-align:center">$\upharpoonright$</td>
<td>$\upharpoonright$</td>
</tr>
<tr>
<td style="text-align:center">$\upharpoonleft$</td>
<td>$\upharpoonleft$</td>
</tr>
<tr>
<td style="text-align:center">$\downharpoonright$</td>
<td>$\downharpoonright$</td>
</tr>
<tr>
<td style="text-align:center">$\downharpoonleft$</td>
<td>$\downharpoonleft$</td>
</tr>
<tr>
<td style="text-align:center">$\leftharpoonup$</td>
<td>$\leftharpoonup$</td>
</tr>
<tr>
<td style="text-align:center">$\rightharpoonup$</td>
<td>$\rightharpoonup$</td>
</tr>
<tr>
<td style="text-align:center">$\rightharpoondown$</td>
<td>$\rightharpoondown$</td>
</tr>
<tr>
<td style="text-align:center">$\leftharpoondown$</td>
<td>$\leftharpoondown$</td>
</tr>
<tr>
<td style="text-align:center">$\upuparrows$</td>
<td>$\upuparrows$</td>
</tr>
<tr>
<td style="text-align:center">$\downdownarrows$</td>
<td>$\downdownarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\rightrightarrows$</td>
<td>$\rightrightarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\rightleftarrows$</td>
<td>$\rightleftarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\leftleftarrows$</td>
<td>$\leftleftarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\leftrightarrows$</td>
<td>$\leftrightarrows$</td>
</tr>
<tr>
<td style="text-align:center">$\rightleftharpoons$</td>
<td>$\rightleftharpoons$</td>
</tr>
<tr>
<td style="text-align:center">$\leftrightharpoons$</td>
<td>$\leftrightharpoons$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown简明语法</title>
    <url>/e1ac91e3.html</url>
    <content><![CDATA[<h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><hr>
<h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <em> 和 *</em> 表示斜体和粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。<br><span id="more"></span></p>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 —- 表示二级标题。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">### 这是一个三级标题</span><br></pre></td></tr></table></figure>
<p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>
<h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>
<p>示例：</p>
<p>这是去往 <a href="http://ghosertblog.github.com">本人博客</a> 的链接。</p>
<h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>
<p>示例：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p>
<p>示例：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p>
<p>示例：</p>
<blockquote>
<p>野火烧不尽，春风吹又生。</p>
</blockquote>
<h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>
<p>示例：</p>
<p>让我们聊聊 <code>html</code>。</p>
<h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p>
<p>示例：</p>
<pre><code>这是一个代码块，此行左侧有四个不可见的空格。
</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>
<p>示例：</p>
<p><img src="https://www.zybuluo.com/static/img/my_head.jpg" alt="我的头像"></p>
<h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h3 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>
<p>标签： 数学 英语 Markdown</p>
<p>或者</p>
<p>Tags： 数学 英语 Markdown</p>
<h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p>
<p><del>这是一段错误的文本。</del></p>
<h3 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h3><p>使用 <sup><a href="#fn_keyword" id="reffn_keyword">keyword</a></sup> 表示注脚。</p>
<p>这是一个注脚<sup><a href="#fn_footnote" id="reffn_footnote">footnote</a></sup>的样例。</p>
<p>这是第二个注脚<sup><a href="#fn_footnote2" id="reffn_footnote2">footnote2</a></sup>的样例。</p>
<h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<script type="math/tex; mode=display">表示整行公式：

$$\sum_{i=1}^n a_i=0</script><script type="math/tex; mode=display">f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2</script><script type="math/tex; mode=display">\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}</script><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p>
<h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>
<p>非代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<p>Python 示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title function_">fib</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>
<h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure>
<h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure>
<h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>
<h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
</div>
<h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p>
<p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>
<pre><code>    代码块（左侧有八个不可见的空格）
</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>

<h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>
<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;
</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p>
<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>
<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;
</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p>
<p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/">font-awesome</a> 官方网站。</p>
<h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code>- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票
</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li>[ ] <strong>Cmd Markdown 开发</strong><ul>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[x] 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments">语法参考</a></li>
<li>[x] 改进 LaTex 功能<ul>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li>[ ] <strong>七月旅行准备</strong><ul>
<li>[ ] 准备邮轮上需要携带的物品</li>
<li>[ ] 浏览日本免税店的物品</li>
<li>[x] 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<blockquote id="fn_footnote">
<sup>footnote</sup>. 这是一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote" title="Jump back to footnote [footnote] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_footnote2">
<sup>footnote2</sup>. 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote2" title="Jump back to footnote [footnote2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论 第1节 导论——五个入门结论</title>
    <url>/2558636.html</url>
    <content><![CDATA[<h1 id="耶鲁博弈论-第1节-导论——五个入门结论"><a href="#耶鲁博弈论-第1节-导论——五个入门结论" class="headerlink" title="耶鲁博弈论 第1节 导论——五个入门结论"></a>耶鲁博弈论 第1节 导论——五个入门结论</h1><blockquote>
<p>本系列笔记来自耶鲁博弈论，课程视频来自b站<a href="https://www.bilibili.com/video/BV1Kt411h7Ep">耶鲁大学：博弈论</a>，笔记不定期更新。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、开胃菜——成绩博弈"><a href="#一、开胃菜——成绩博弈" class="headerlink" title="一、开胃菜——成绩博弈"></a>一、开胃菜——成绩博弈</h2><blockquote>
<p>开场游戏：你和你的同桌在完全不知情的情况下，填写自己的成绩 $α$ 和 $β$，然后老师将所有同学随机分成两两一组，你的成绩将按照以下情况给出：<br>(1)若你填写 $α$ 你的对手填写 $β$，你将得到 $A$ 等级，你的对手将得到 $C$ 等级<br>(2)若你填写 $α$ 你的对手填写 $α$，你将得到 $B-$ 等级，你的对手将得到 $B-$ 等级<br>(3)若你填写 $β$ 你的对手填写 $β$，你将得到 $B+$ 等级，你的对手将得到 $B+$ 等级<br>(4)若你填写 $β$ 你的对手填写 $α$，你将得到 $C$ 等级，你的对手将得到 $A$ 等级</p>
</blockquote>
<p>课堂上老师询问了几个选 $α$ 的同学的理由，第一个人觉得对方也会填 $α$，所以我要填 $α$；第二个人的理由是，填 $α$ 的结果总要优于填 $β$.<br>而选择 $β$ 的同学觉得选择 $β$ 成绩波动较小，（会从B+波动到C）（实际上选择 $α$ 波动和 $β$ 一样，从A到B-）；另一个觉得一开始大家可以合作，都填 $β$ 获得最大利益。<br><!-- more --><br>目前我们涉及到博弈的<code>行为</code>、<code>策略</code>、<code>参与人</code>，但是忽略了一个博弈的必备要素：<code>动机(objectives)</code>.</p>
<p>下面我们用效用矩阵表示收益（Possible Payoffs）：</p>
<table>
<tr>
    <td> 可能情况</td>
    <td colspan="2"> Pair <br>

</td></tr>
<tr>
    <td rowspan="2"> Me <br>
    </td><td> α,α</td>
    <td> α,β</td>
</tr>
<tr>
    <td> β,α <br>
    </td><td> β,β <br>
</td></tr>
</table>

<table>
<tr>
    <td> 效用 </td>
    <td colspan="2"> Pair <br>

</td></tr>
<tr>
    <td rowspan="2"> Me <br>
    </td><td> 0, 0</td>
    <td> 3,-1</td>
</tr>
<tr>
    <td> -1,3 <br>
    </td><td> 1, 1 <br>
</td></tr>
</table>

<p>前提是所有人只在乎自己的成绩，并且努力想取得更高的成绩。这里显然能够看出，不管对手选择什么，选择 $α$ 的效益始终大于 $β$ $（0 &gt; -1, 3 &gt; 1）$</p>
<p>我们称这种始终不会取得劣势的选择称作<code>严格优势策略</code></p>
<p>因此得到第一个结论：<strong>1.不要选择严格劣势策略</strong>，原因很简单，the payoffs are lower.<br>但似乎这样的结论有些过于简单而不值得讨论。</p>
<p>但是如若别人也是这样想，选择了 $β$，那么你们都将获得 1 的效用，而 1 是 大于 0 的，因此选择 $β$ 是更好的选择，这似乎与第一个结论有些矛盾。</p>
<p>实际上这种说法有两个问题，其一，我的想法实际上是无法影响到你的想法，也就是我的选择无法左右你的选择，其二，建立在第一个假设上，若我的想法能够左右你的想法，那么为了争取最大的效用，我应该选择 $α$ 而不是 $β$</p>
<p>由此得到第二个结论：<strong>2.理性的选择（严格优势策略）往往使得结果变得糟糕</strong><br><code>协商难以达成的原因不是缺少沟通，而是没有强制力</code></p>
<p>（囚徒困境，三个和尚没水吃，企业价格战）</p>
<p>换种情况，若效用矩阵变成下面这样：</p>
<table>
<tr>
    <td> 效用 </td>
    <td colspan="2"> Pair <br>

</td></tr>
<tr>
    <td rowspan="2"> Me <br>
    </td><td> 0, 0</td>
    <td> -1,-1</td>
</tr>
<tr>
    <td> -3, 3 <br>
    </td><td> 1, 1 <br>
</td></tr>
</table>

<p>若我选择 $α$，而对手选择了 $β$，但是我感到愧疚，良心受到谴责，减去我的负罪感的负效用后只得到了 -1（把他称作负罪感）。相反我选择 $β$，而对手选择了 $α$，觉得不服气只得到了 C，因此下次要好好学习，表现出了雄心壮志，并且这个成绩是因为对手选了 $α$ 所致，在道义上的谴责又减去了一些效用，最终变成了 -3.</p>
<p>选 $α$ 的人觉得这样可以最小化损失，而选 $β$ 的人觉得这样有机会获得最大效用 1.</p>
<p>当对方选择 $α$ 时，我应该选择 $α$ 才能获得最大效用，相反，当对方选择 $β$ 时，我也应该选择 $β$ 才能得到最大效用。因此，这种情况下没有严格优势策略，而这也仅仅是改变了博弈的收益，并没有改变博弈的结构和结果，但是我们的目的被改变了。第一种情况我们显然应该选择 $α$，而第二种情况我们却不知道该选什么，这种博弈叫 <strong>协和谬误</strong></p>
<p>由此得出第三个结论：<strong>3.汝欲得之，必先知之</strong><br><code>永远选择优势策略，损失小，如果对手有优势策略应以此作为选择策略的指导</code></p>
<p>第三种情况，我们更改<code>对手</code>每种情况的效用，如下：</p>
<table>
<tr>
    <td> 效用 </td>
    <td colspan="2"> Pair <br>

</td></tr>
<tr>
    <td rowspan="2"> Me <br>
    </td><td> 0, 0</td>
    <td> 3,-3</td>
</tr>
<tr>
    <td> -1, -1 <br>
    </td><td> 1, 1 <br>
</td></tr>
</table>

<p>显然，$α$ 是严格优势策略，选择 $α$ 更好。</p>
<p>第四种情况，仅仅修改我自己不同情况下的效用，如下：</p>
<table>
<tr>
    <td> 效用 </td>
    <td colspan="2"> Pair <br>

</td></tr>
<tr>
    <td rowspan="2"> Me <br>
    </td><td> 0, 0</td>
    <td> -1,-1</td>
</tr>
<tr>
    <td> -3, 3 <br>
    </td><td> 1, 1 <br>
</td></tr>
</table>

<p>这种情况下，对我自己而言，没有了所谓的严格优势策略，但是对于对手而言，$α$ 是严格优势策略，他必定会选择 $α$，因此我只能选择 $α$ 来获得最大效用。</p>
<p>因此得到第四个结论：<strong>4.站在对方的立场上去分析对方会怎么做</strong></p>
<p>综上可以得到第五个结论： <strong>5.人都是自私的</strong></p>
<h2 id="填数游戏"><a href="#填数游戏" class="headerlink" title="填数游戏"></a>填数游戏</h2><blockquote>
<p>每个人写下 $1-100$ 中随机一个数，最终离平均数的 $\frac{2}{3}$ 最接近的人获得奖励</p>
</blockquote>
<p>解析请看下节…</p>
<p>【老师每节课开奖是为了不让学生逃课吗？（笑）】</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论 第2节 学会换位思考</title>
    <url>/ccda0dbe.html</url>
    <content><![CDATA[<h1 id="耶鲁博弈论-第2节-学会换位思考"><a href="#耶鲁博弈论-第2节-学会换位思考" class="headerlink" title="耶鲁博弈论 第2节 学会换位思考"></a>耶鲁博弈论 第2节 学会换位思考</h1><span id="more"></span>
<h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><p>形成博弈的要素</p>
<ul>
<li>参与人（players），用 $i$, $j$ 表示</li>
<li>参与人的策略（strategies），用 $s<em>{i}$，$s</em>{j}$ 表示；<br>所有可能的策略集合 $S_{i}$，区别于参与人的策略小写 $s$；<br>某一次博弈 $s$，用不带下标的 $s$ 表示，称为策略组合（a strategy profile），也称为策略向量</li>
<li>博弈的收益（payoffs），用大写的 $U$ 表示，$U<em>{i}$ 取决于参与博弈的 $N$ 个人的博弈策略，记做 $(s</em>{1},…,s<em>{i},…,s</em>{i})$，简写为 $U_{i}(s)$，由策略组合决定（即所有参与博弈的人）<!-- more -->
我们用 $s_{-i}$ 表示除了 $i$ 之外的其他参与者的决策，因为考虑在和对手在不同选择下的收益是很有必要的，填数游戏中以标准形式描述博弈：</li>
</ul>
<script type="math/tex; mode=display">
U_{i}(s)=
\begin{cases}
    5美元 - 误差 \\
    0
\end{cases}</script><p>再用一个例子熟悉使用符号语言来描述博弈：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>左</th>
<th>中</th>
<th>右</th>
</tr>
</thead>
<tbody>
<tr>
<td>上</td>
<td>5, -1</td>
<td>11, 3</td>
<td>0, 0</td>
</tr>
<tr>
<td>下</td>
<td>6, 4</td>
<td>0, 2</td>
<td>2, 0</td>
</tr>
</tbody>
</table>
</div>
<p>这里参与人是 $A$ 和 $B$<br>策略集合是 $S<em>{1}={上，下}$，$S</em>{2}={左，中，右}$<br>收益：例如 $U<em>{1}(上，中)=11$，$U</em>{2}(下，右)=0$<br>显然对于参与者 $B$，右是严格劣势策略。因此我们给出 <strong>严格优势策略的定义：</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
参与人 i 的策略 s_{i}^{'} 严格劣于参与人 i 的另一个策略 s_{i}，在其他参与者\\ 选择 s_{-i} 时，选择 s_{i} 的收益 U_{i}(s_{i}) 严格优于此情况下 s_{i}^{'} 的收益 U_{i}(s_{i}^{'})
\end{aligned}</script><p>再来一个例子：</p>
<blockquote>
<p>汉尼拔将军将要攻打一个国家，他有两个营的兵力，他可以选择从崎岖道路（翻过阿尔卑斯山）进军（但是行军途中要损失一个营的兵力），也可以选择从平坦的道路（平原）进军（途中没有损失）。防守者只能在崎岖道路和平坦道路其中之一设防，当进攻者遇到防守者时，进攻者将损失一个营的兵力。若你是防守者，你该选择何处设防？</p>
</blockquote>
<p>双方收益如下：（行是防守者，列是进攻者）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>easy</th>
<th>hard</th>
</tr>
</thead>
<tbody>
<tr>
<td>easy</td>
<td>1, 1</td>
<td>1, 1</td>
</tr>
<tr>
<td>hard</td>
<td>0, 2</td>
<td>2, 0</td>
</tr>
</tbody>
</table>
</div>
<p>在这个例子中，防守者似乎没有严格优势策略，但是对于汉尼拔将军（进攻方）来说，选择平坦道路进攻似乎优于从崎岖道路进攻，这只是一个优势策略，并非严格优势，只是一个弱优势。我们引出 <strong>弱优势</strong> 的定义：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{array}{c}
参与人 i 的策略 s_{i}^{'} 弱于参与人 i 的另一个策略 s_{i}，在其他参与者\\
选择 s_{-i} 时，选择 s_{i} 的收益 U_{i}(s_{i}) 大于等于此情况下 s_{i}^{'} 的收益 U_{i}(s_{i}^{'})，即\\
U_{i}(s_{i},s_{-i}) \geq U_{i}(s_{i}^{'},s_{-i})\ for\ all\ s_{-i} \\
U_{i}(s_{i},s_{-i}) > U_{i}(s_{i}^{'},s_{-i})\ for\ some\ s_{-i}
\end{array}
\end{aligned}</script><!-- hspace{2cm} -->
<h2 id="回到填数游戏"><a href="#回到填数游戏" class="headerlink" title="回到填数游戏"></a>回到填数游戏</h2><p>好，那么我们现在回到第一节课的填数游戏，在 $1-100$ 之间任选一个数，最接近平均数的 $\frac{2}{3}$ 的人获胜。</p>
<p>老师询问了填 $33-35$ 之间的数的同学，他们回答：大家在 $1-100$ 之间随机选择一个数，最后平均值会在 $50$ 左右，而 $50$ 的三分之二就是 $33$ 左右。</p>
<p>这个说法看似正确，但是却忽略了一个重要前提：<strong>教室里的人并不会随机选择一个数</strong>，他们都想赢得这5美元。若人人都这样想，最终平均值会趋近于 $33$，而 $33$ 的三分之二是 $22$。然而，这还是太大了。</p>
<p>再次重申这个游戏的重点：每个人都有自己的策略，每个人都想赢。</p>
<p>那么我们来分析一下这个游戏，哪些选择是（弱）劣势策略？</p>
<p>设想最坏的情况，每个人都选了 $100$ 那么这样最终的结果也只是 $66\frac{2}{3}$ 最接近的是 $67$，那么选择大于 $67$ 的数相对于 $67$ 来说就是弱劣势策略。这样对于<strong>理智</strong>的人来说，游戏简化成了在 $1-67$ 之间选择一个数，因为他们知道没人会选择 $67$ 以上的数。<br>同样，相似的策略也会被排除，这样，$45$ 以上的数也不会有人选。但是 $45-67$ 之间的数在原博弈中并不是弱劣势策略，可是我们排除掉 $67-100$ 的时候，$45-67$ 便成为了弱劣势策略。同理，$30-45$ 也被排除，$20-30$，$14-20$……直至 $1$.</p>
<p>尽管 $1$ 就是这个游戏的最优策略，但是这一切都是建立在参与人都是理性的情况下，并且理性的参与者知道其他人也都是理性的。我们用术语<strong>共同知识</strong>来描述类似：我知道，我知道你知道，我知道你知道我知道…这样的循环。但是实际上，每个区间的数都有人选择，这就要考虑分布的问题了。最终老师公布结果，平均数在 $13$ 左右，最终选择 $9$ 的人获得了胜利，巧的是，这也是所有人选择的中位数。</p>
<p>按照之前的最优策略，为什么 $1$ 不是最终结果呢？尽管有相当一部分人选择了 $1$，</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>实现C语言编译器：一、简单数学表达式的词法分析</title>
    <url>/19cdc324.html</url>
    <content><![CDATA[<h1 id="一、简单数学表达式的词法分析"><a href="#一、简单数学表达式的词法分析" class="headerlink" title="一、简单数学表达式的词法分析"></a>一、简单数学表达式的词法分析</h1><span id="more"></span>]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编译器</tag>
        <tag>编译原理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>实现C语言编译器：三、输入及词法分析</title>
    <url>/2a32925d.html</url>
    <content><![CDATA[<h1 id="三、输入及词法分析"><a href="#三、输入及词法分析" class="headerlink" title="三、输入及词法分析"></a>三、输入及词法分析</h1><h2 id="输入系统"><a href="#输入系统" class="headerlink" title="输入系统"></a>输入系统</h2><p><img src="https://github.com/CherryYang05/PicGo-image/blob/master/images/20220118211008.png" alt="20220118211008"></p>
<p>输入系统的作用是将源文件从磁盘或内存中读入，根据模块化设计原理，如果输入系统是一个独立模块，通过固定接口与词法解析器交互的话，那么它的修改和维护将会非常灵活。<br>输入系统的效率，决定着整个编译系统的效率。我们用 C 语言的时候，经常会用到他提供的输入函数例如 scanf 等 C 语言的输入系统设计得不是很合理。当 C 语言的库函数将数据读入程序的过程中，有三次拷贝, 一是从磁盘上将数据拷贝到操作系统中，二是将数据从操作系统拷贝到一个 FILE 结构中，三是将数据从 FILE 结构拷贝到程序的内存中。这些拷贝都需要耗费时间和空间。另外，词法解析器在解析时需要预先读入一些字符(look ahead，在前面的简易编译器中使用过这种技巧), 以便对输入的字符串打上合适的标签(想象前面的 typedef 语句， 一旦读到typedef 那就需要将 typedef 后面的字符读进来才好解析), 预先读入的字符，使用完后，可能需要重新放回到缓冲区中，这一取一放，如果不加以良好的设计，那很可能会产生 I/O 性能上的影响。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编译器</tag>
        <tag>编译原理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>实现C语言编译器：二、简单数学表达式的语法分析</title>
    <url>/f73c25d7.html</url>
    <content><![CDATA[<h1 id="二、简单数学表达式的语法分析"><a href="#二、简单数学表达式的语法分析" class="headerlink" title="二、简单数学表达式的语法分析"></a>二、简单数学表达式的语法分析</h1><p>当前所实现的简易编译器是将一条或一组数学表达式编译成类似汇编语言的代码，因此就要给算术表达式设立一组语法规则，判断是否是合法的算数表达式，那么程序才能对输入的表达式进行分析，我们将一组带有分号的算数表达式称为 <code>statements</code>，例如 <code>1+2*3+4; 41*2;1+2+3+4;</code>，这三个表达式的集合称为 <code>statements</code>，同时将一组表达式中的某一条带有分号的表达式称为 <code>expression</code>，也就是说 <code>statements</code> 是由多个 <code>expression</code> 组成的。</p>
<p>statements 的语法规则可以写成：</p>
<p>$statements\rightarrow expression;|expression;statements$<br><span id="more"></span><br>观察上述表达式，我们发现箭头左边的被解析的对象在右边也出现了，这样便构成了一种循环，在编译原理中称为左循环(LR，Left recursive)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">statements</span>(buffer) &#123;</span><br><span class="line">    <span class="built_in">expression</span>(buffer);</span><br><span class="line">    <span class="built_in">statements</span>(buffer); <span class="comment">//此处导致循环调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的语法规则：</p>
<script type="math/tex; mode=display">
expression \rightarrow expression + term | term \\
term \rightarrow term * factor | factor\\
factor \rightarrow NUMBER | (expression)</script><p>现在我们先记住这些，根据代码先整体理解，在后面的内容中再详细介绍。</p>
<p>回到语法规则上，箭头右边有两种替换规则，那么我们应该选取哪一种进行替换呢？在编译原理中，有一种方法叫做 <code>lookahead</code>，举个例子，对于语法：<br>$statements\rightarrow expression;|expression;statements$<br>我们按照顺序读取到第一个分号，若下一个字符有意义，那么就选取后者进行解析；如果下一个字符是 <code>EOI</code>，那么说明该表达式已经读完，那么选取前者进行解析。</p>
<p>那么如何解决语法规则中的循环调用呢？我们更改语法规则如下：<br>$1. \quad statements \rightarrow 空|expression;statements$<br>$2. \quad expression \rightarrow term \,\, expression’$<br>$3. \quad expression \rightarrow +term \,\, expression’ | 空$<br>$4. \quad term \rightarrow factor \,\, term’$<br>$5. \quad term’ \rightarrow *factor \,\, term’ | 空$<br>$6. \quad factor \rightarrow number | (expression)$</p>
<p>语法解析树如下：</p>
<p><img src="/f73c25d7/语法解析树.png" alt="语法解析树"></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>编译器</tag>
        <tag>编译原理</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学（一）：古典密码之维吉尼亚密码介绍</title>
    <url>/73f9281.html</url>
    <content><![CDATA[<h2 id="维吉尼亚（Vigenere-Cipher）密码原理介绍"><a href="#维吉尼亚（Vigenere-Cipher）密码原理介绍" class="headerlink" title="维吉尼亚（Vigenère Cipher）密码原理介绍"></a>维吉尼亚（Vigenère Cipher）密码原理介绍</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><blockquote>
<p>&emsp;&emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。<br>&emsp;&emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。<br>&emsp;&emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。<br>来源：<a href="https://baike.baidu.com/item/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/4905472?fr=aladdin">百度百科</a><br><img src="https://img-blog.csdnimg.cn/20200216154546299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><span id="more"></span></p>
<h3 id="二、古典密码"><a href="#二、古典密码" class="headerlink" title="二、古典密码"></a>二、古典密码</h3><h4 id="1-移位密码"><a href="#1-移位密码" class="headerlink" title="1. 移位密码"></a>1. 移位密码</h4><p>我们首先引入符号表示：<br>$P$：明文空间，所有可能的明文组成的有限集<br>$C$：密文空间，所有可能的密文组成的有限集<br>$K$：密钥空间，所有可能的密钥 $k$ 组成的有限集<br>$Enc$：加密算法<br>&emsp;&emsp;$Enc_k(m)=c$ 加密算法$Enc$以密钥$k$、明文$m$为输入，输出密文$c$<br>$Dec$：加密算法<br>&emsp;&emsp;$Dec_k(c)=m$ 解密算法$Dec$以密钥$k$、密文$c$为输入，输出明文$m$<br>算法正确性：对每个明文 $m\in P$ 以及秘钥 $k\in K$ 都有 $Dec_k(Enc_k(m))=m$</p>
</blockquote>
<p>其中最典型的移位密码就是凯撒密码，凯撒密码是通过移位替换的方法，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p>
<script type="math/tex; mode=display">
令P=C=K=Z_{26}=\{ 0,1,2,3,...,25 \} \\
随机选择 K \in Z_{26} 作为密钥 \\
Enc_k(m)=m+k \pmod {26} \\
Dec_k(c)=c-k\pmod{26}</script><p>其中 $Z_{26}$ 是26个英文字母组成的集合空间。<br>例如，当偏移量$k$是3的时候，所有的字母A将被替换成D，B变成E … Z变成C，以此类推。</p>
<h4 id="2-维吉尼亚密码"><a href="#2-维吉尼亚密码" class="headerlink" title="2.维吉尼亚密码"></a>2.维吉尼亚密码</h4><p>维吉尼亚密码便是移位密码的推广</p>
<script type="math/tex; mode=display">
P=C=K=Z_{26}^n\\
随机选择密钥k=(k_1,k_2,..,k_n) \in Z_{26}^n \\
Enc_k(m_1,m_2,...,m_n)=(m_1+k_1,m_2+k_2,...,m_n+k_n) \\
Dec_k(c_1,c_2,...,c_n)=(c_1-k_1,c_2-k_2,...,c_n-k_n)</script><p>实际上就是每个明文加上对应的密钥字。<br>举例如下：若密钥为 $CIPHER$，即 $k=(2,8,15,7,4,17)$<br><img src="https://img-blog.csdnimg.cn/20200216154923425.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>明文是以下字符串：</p>
<p>$THISCRYPTOSYSTEMISNOTSECURE$</p>
<p>我们根据字母表将字符串翻译成数字：</p>
<p>$(19,7,8,18,2,17,24,15,19,14,18,24,18,19,4,12,8,18,13,14,19,18,4,2,20,17,4)$</p>
<p>然后将其按照密钥个数进行分组，分别与集合 $K$ 相加，得到密钥：</p>
<p>$(21,15,23,25,6,8,0,23,8,21,22,15,20,1,19,19,12,9,15,22,8,25,8,19,22,25,19)$</p>
<p>因此密文为：</p>
<p>$VPXZGIAXIVWPUBTTMJPWIZITWZT$</p>
<h4 id="3-二维表形式"><a href="#3-二维表形式" class="headerlink" title="3. 二维表形式"></a>3. 二维表形式</h4><p>我们观察到，若密钥为1的话，A将会变成B，若密钥为2的话，A将会变成C，实际上就是字母表整体往左边移动了一个字母和两个字母的距离，我们把移动的26种情况整理下来，变成了一张二维表。<br>其中棕色的行表示明文，橙色的列表示密钥。<br>若密钥为3，实际上对应的字母为C，那么就到C的那一行，可以观察到，A对应的是C，以此类推。因此若想找明文A对应密钥为C的密文，只要找他们的交点即可。以上述例子为例，$THIS$ 的密钥为$(2,8,5,17)$，对应的字母为 $CIPH$，找到 $T$ 和 $C$的交点 $V$，$H$ 和 $I$ 的交点 $P$，$I$ 和 $P$ 的焦点 $X$，$S$ 和 $H$ 的交点 $Z$.因此其密文为 $VPXZ.$<br><img src="https://img-blog.csdnimg.cn/20200216150222284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="维吉尼亚密码二维表"><br>普通的移位密码是通过相同的移位来加密，若明文中有两个相同的字母，例如 $HAPPY$ 的$P$，加密过后仍然会有两个相同的字母，若样本多了之后，就可以根据一些单词的特征进行判断推理进行解密，因此普通的移位加密并不是一种好的加密方法。维吉尼亚密码就可以很好的解决这样的问题。</p>
<p>下一章将介绍维吉尼亚密码的解密。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>古典密码</tag>
        <tag>维吉尼亚密码</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学（二）：古典密码之维吉尼亚密码的破解</title>
    <url>/a1c2e50d.html</url>
    <content><![CDATA[<h2 id="维吉尼亚密码的破解"><a href="#维吉尼亚密码的破解" class="headerlink" title="维吉尼亚密码的破解"></a>维吉尼亚密码的破解</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>&emsp;&emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 <strong>e</strong> 是出现频率最高的，占<strong>12.7%</strong>；其次是<strong>t</strong>，<strong>9.1%</strong>；然后是<strong>a</strong>，<strong>o</strong>，<strong>i</strong>，<strong>n</strong>等，最少的是<strong>z</strong>，只占<strong>0.1%</strong>。<br><span id="more"></span><br><img src="https://img-blog.csdnimg.cn/20200216150747368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="字母出现概率"></p>
<p><a id="具体概率表">具体概率表</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200216161337882.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_26,color_FFFFFF,t_70" width="450" height="500" alt="概率表" style="margin-left:50px"></p>
<p>除了英语，其他语言也有相关统计（<a href="https://www.cnblogs.com/inverseEntropy/p/10151176.html">图片来源</a>）<br><img src="https://img-blog.csdnimg.cn/20200216150833315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="多种语言的字母出现频率"></p>
<h3 id="二、一般破解的方法"><a href="#二、一般破解的方法" class="headerlink" title="二、一般破解的方法"></a>二、一般破解的方法</h3><h4 id="1-穷举密钥搜索"><a href="#1-穷举密钥搜索" class="headerlink" title="1. 穷举密钥搜索"></a>1. 穷举密钥搜索</h4><p>&emsp;&emsp;只适用于与小的密钥空间，而像维吉尼亚密码的 $Z^n_{26}$ 是 26 的 n 次方的空间，当 n 很大时，计算量是相当大的。</p>
<h4 id="2-频率统计"><a href="#2-频率统计" class="headerlink" title="2. 频率统计"></a>2. 频率统计</h4><h5 id="单表代换"><a href="#单表代换" class="headerlink" title="单表代换"></a>单表代换</h5><p><strong>移位密码：</strong> 相同的明文字母总是对应相同的密文字母，因此，尽管字母的外形改变了，他出现的概率还是不变的，只要根据足够多的样例来进行统计，最终密文字母的出现概率总是近似于明文字母的出现概率，并且与之一一对应。</p>
<h5 id="多表代换"><a href="#多表代换" class="headerlink" title="多表代换"></a>多表代换</h5><p><strong>维吉尼亚密码：</strong> 相同的明文字母可能对应不同的密文字母，这里讲的维吉尼亚密码的破解也是根据字母出现的频率的蛛丝马迹进行破解。</p>
<h3 id="三、维吉尼亚密码的破解"><a href="#三、维吉尼亚密码的破解" class="headerlink" title="三、维吉尼亚密码的破解"></a>三、维吉尼亚密码的破解</h3><h4 id="1-确定密钥长度"><a href="#1-确定密钥长度" class="headerlink" title="1. 确定密钥长度"></a>1. 确定密钥长度</h4><h5 id="方法一：Kasiski测试法"><a href="#方法一：Kasiski测试法" class="headerlink" title="方法一：Kasiski测试法"></a>方法一：Kasiski测试法</h5><p><strong>原理：密文中出现两个相同字母组，它们所对应的明文字母相同的可能性很大，这样的两个密文字母组之间的距离可能为密钥长度的整数倍。</strong><br><img src="https://img-blog.csdnimg.cn/2020021617084725.jpg" alt="在这里插入图片描述"><br>&emsp;&emsp;尽管在维吉尼亚密码中相同的明文可能对应不同的密文，但是若连续出现相同的密文，那么用同样的密钥加密的概率会大大增加。这里密文 $ZB$ 都是用 $HI$ 加密，计算两者之间的距离为 $5$，因此可推断出来密钥长度为 $5.$</p>
<h5 id="方法二：重合指数法"><a href="#方法二：重合指数法" class="headerlink" title="方法二：重合指数法"></a>方法二：重合指数法</h5><p><strong>原理：自然语言（以英语为例）的重合指数约为 0.065，而且单标代换不会改变该值。</strong><br><strong>重合指数定义：</strong></p>
<p>设 <script type="math/tex">x=x_1x_2...x_n</script> 是含有 $n$ 个字母的串，则在 $x$ 中随机选择两个元素且这两个元素相同的概率为：</p>
<p>定义：$f_i$ 为 26 个字母中第 $i$ 个字母在 $x$ 中出现的次数</p>
<p>[例如：$x=AAZZZ,n=5,f<em>0=2,f</em>{25}=3$，第一次取出 A 的概率为 $\frac {f_0} {n}$，第二次再取出 A 的概率为 $\frac {f_0} {n} * \frac {f_0-1} {n-1}$]</p>
<p>当我们把 26 个字母的概率全部相加，得到的总的概率就是<strong>重合指数</strong>：</p>
<script type="math/tex; mode=display">
I_c(x)={\frac {\displaystyle\sum_{i=0}^{25}f_i(f_i-1)} {n(n-1)} }</script><p>当计算的数量很大时，我们将 $n(n-1)$ 近似为 $n^2$，将 $f_i(f_i-1)$ 近似为 $f_i^2$</p>
<p>因此</p>
<script type="math/tex; mode=display">
I_c(x) \approx \displaystyle\sum_{i=0}^{25} {p_i^2} \approx0.065</script><p>这里的 $p_i$ 表示第 $i$ 个字母在英语语言中出现的概率，就是在<a href="#具体概率表">引言</a>中列出的数值。<br>这个数值非常重要。</p>
<p><strong>注意：在单表代换中，不会改变该值，也就是用相同密钥字加密应服从相同的重合指数。</strong></p>
<h5 id="猜测密钥长度"><a href="#猜测密钥长度" class="headerlink" title="猜测密钥长度"></a>猜测密钥长度</h5><p>&emsp;&emsp;假设密钥长度为 $d$，提取相同密钥字加密的密文，测试其重合指数。<br>&emsp;&emsp;如果猜测正确，则重合指数接近 $0.065$，否则字符串表现得更加随机一般在 $0.038(1/26) \thicksim 0.065$ 之间。<br><img src="https://img-blog.csdnimg.cn/20200216184236771.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="猜测密钥长度"><br>&emsp;&emsp;在这里，我们先猜测密钥长度为 5，然后将密文按照 5 进行分组，分别提取出用密钥 $k_1,k_2,k_3,k_4,k_5$ 加密的密文，组成集合 $C_1,C_2,C_3,C_4,C_5$，这样就把多表代换转化成了单表代换。<br>这里 $C_1={Z,P,L,W,Z},C_2={P,A,Z,Z,N},C_3={D,Z,B,B,M},C_4={X,H,H,K},C_5={V,S,I,M}$</p>
<p>以一个例子为例：<br><img src="https://img-blog.csdnimg.cn/20200216214722472.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;$CHR$ 这三个字符出现频率较高，因此我们将其位置记录下来，测算他们之间的距离，并取最大公因数 5，猜测 5 便是密钥长度。这很有可能是相同的明文被相同的密文加密了。其实很容易猜到，这很可能是英语当中的定冠词 <strong>the</strong>.</p>
<p>我们在用重合指数法进行测试，分别测试 $d=1,2,3,4,5$ （过程略）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$d$</th>
<th>重合指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td>$[0.045]$</td>
</tr>
<tr>
<td>$2$</td>
<td>$[0.046,0.041]$</td>
</tr>
<tr>
<td>$3$</td>
<td>$[0.043,0050,0.047]$</td>
</tr>
<tr>
<td>$4$</td>
<td>$[0.042,0.039,0.046,0.040]$</td>
</tr>
<tr>
<td>$5$</td>
<td>$[0.063,0.068,0.069,0.061,0.072]$</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;观察发现，只有当 $d=5$ 的时候，重合指数接近 $0.065$，因此刚刚的猜测 $d=5$ 是正确的，这时通过穷举密钥的复杂度为 $26^5$，但是仍然比较大。</p>
<h4 id="2-确定密钥字相对位移"><a href="#2-确定密钥字相对位移" class="headerlink" title="2. 确定密钥字相对位移"></a>2. 确定密钥字相对位移</h4><p>密钥字的相对位移实际上就是确定密钥之间的相互关系。<br>这里引入一个定义：</p>
<p><strong>重合互指数:</strong><br>&emsp;&emsp;设 $x=x<em>1,x_2,…,x_n,y=y_1,y_2,…,y</em>{n’}$，分别为长度为 $n$ 和 $n’$ 的串，其重合互指数为从 $x$ 和 $y$ 中分别随机选出一个元素且两个元素相同的概率。</p>
<p>计算方法和刚刚的计算方法类似：</p>
<script type="math/tex; mode=display">
MI_c(x,y)=\frac{\displaystyle\sum_{i=0}^{25}f_if'_i}{nn'}</script><p>具体不再阐述。</p>
<p>&emsp;&emsp;考虑不同密钥字加密后密文串的重合互指数，设密钥字为 $k=k<em>1k_2…k_d$，$C_i$ 中的一个字母与 $C_j$ 中的一个字母都是 $A$ 的概率为 $p</em>{0-k<em>i}p</em>{0-k_j}$.</p>
<p>其中 $p_{0-k_i}$ 为密文 $A$ 所对应明文字母的出现概率。同理可以计算 $B,C,D,…,Z$，因此：</p>
<script type="math/tex; mode=display">
MI_c(C_i,C_j) \approx \displaystyle\sum_{l=0}^{25}p_{l-k_i}p_{l-k_j}=
\displaystyle\sum_{l=0}^{25}p_lp_{l+k_i-k_j}=\displaystyle\sum_{l=0}^{25}p_{l-k_i+k_j}p_l</script><p>这里的下标是需要对 26 取模的，可以观察到：$Mi_c$ 取决于相对位移 $k_i-k_j$.</p>
<p>移位表如下：<br><img src="https://img-blog.csdnimg.cn/20200216224709354.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="500"><br>观察这里当相对距离为0时，重合互指数为 $0.065$，在之前提到的自然语言的重合互指数也是 $0.065$，这并不是巧合。当相对位移位 0 时，其实就是 $C_1,C_2$ 的集合是用同一种密文加密得到，这也就是单表代换这样，并不会改变重合指数。</p>
<p>这里其实并不需要列举从 0 到 25 的所有值。</p>
<h5 id="猜测不同密钥字的相对位移s（猜测范围0-25）"><a href="#猜测不同密钥字的相对位移s（猜测范围0-25）" class="headerlink" title="猜测不同密钥字的相对位移s（猜测范围0~25）"></a>猜测不同密钥字的相对位移s（猜测范围0~25）</h5><script type="math/tex; mode=display">
MI_c(C_i,C_j)=\frac{\displaystyle\sum_{t=0}^{25}f_{i,t}f_{j,t-s} } {n_in_j}</script><p>&emsp;&emsp;这里 $n<em>i$ 是指集合 $C_i$ 中字符个数，这里 $n_j$ 是指集合 $C_j$ 中字符个数，$f</em>{i,t}$ 表示在集合 $C<em>i$ 中，$t$ 这个密文字符出现的次数，$f</em>{j,t-s}$ 表示在集合 $C_j$ 中，$t-s$ 这个密文字符出现的次数。</p>
<p>&emsp;&emsp;如果猜对 $s$，那么 $MI_c$ 应该接近 $0.065$，这意味着找到了<strong>不同密钥字加密的相同的明文字母</strong>，这也就找到了密钥字之间的相对位移，也就转化成了单表代换。<br>这里用 $m$ 表示明文字母，$c,c’$ 分别表示 $C_i,C_j$ 中 $m$ 对应的密文字母，那么：</p>
<script type="math/tex; mode=display">
m=c-k_i \pmod{26} \\ m=c'-k_j \pmod{26}</script><p>&emsp;&emsp;实际上，在维吉尼亚密码中，并没有很好的隐藏密钥和密文之间的相互关系，密钥之间的相互差距会体现在密文之间的相互关系。</p>
<p>&emsp;&emsp;我们计算上面例子中的集合 $C_1,C_2,C_3,C_4,C_5$ 两两之间的重合互指数：</p>
<p><img src="https://img-blog.csdnimg.cn/20200216231804835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"></p>
<p>&emsp;&emsp;这里的 $i,j$ 表示当取到不同集合的时候，后面的值表示当猜测的相对位移 $s$ 取不同值的时候重合互指数的结果。</p>
<p>&emsp;&emsp;我们观察结果，当 $i=1,j=2,s=9$ 时，重合互指数达到了 $0.068$，因此可以得到 $k_1-k_2=9$.<br>&emsp;&emsp;但是当 $i=1,j=3;i=1,j=4$ 时，没有合适的相对位移，那么我们先暂时跳过，观察其他结果，发现当 $i=1,j=5,s=16$ 时，重合互指数达到 $0.070$，$i=2,j=3,s=13$ 的时候，重合互指数达到了 $0.067$.<br><img src="https://img-blog.csdnimg.cn/2020021623254417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjUwOTg4,size_16,color_FFFFFF,t_70" width="550"><br>我们列举完剩下的结果，得到：</p>
<script type="math/tex; mode=display">
k_1-k_2=9 \\ k_1-k_5=16 \\ k_2-k_3=13 \\ k_2-k_5=7 \\ k_3-k_5=20 \\ k_4-k_5=11</script><h4 id="3-穷举搜索密钥字"><a href="#3-穷举搜索密钥字" class="headerlink" title="3. 穷举搜索密钥字"></a>3. 穷举搜索密钥字</h4><p>&emsp;&emsp;根据上述的结果，在确定密钥字之间关系式的基础上，只要穷举 $26$ 中可能性就可以了。因为当猜测 $k_1$ 的时候， $k_2$ 也就确定下来了，以此类推，剩下的几个密钥也就确定下来了，只要从 $A-Z$ 进行穷举即可。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>&emsp;&emsp;一个好的密码加密方案（或者说是算法），应该要很好的隐藏密钥和密文之间的联系，通过更复杂的算法或者在更大的密钥空间中，可以有效避免穷举搜索破解。如何设计加密算法以及如何选择合适的密钥空间，将在今后继续学习。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>古典密码</tag>
        <tag>维吉尼亚密码</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出SSD（二）：SSD核心技术：FTL</title>
    <url>/bd809a3f.html</url>
    <content><![CDATA[<h1 id="深入浅出-SSD（二）：SSD-核心技术：FTL"><a href="#深入浅出-SSD（二）：SSD-核心技术：FTL" class="headerlink" title="深入浅出 SSD（二）：SSD 核心技术：FTL"></a>深入浅出 SSD（二）：SSD 核心技术：FTL</h1><blockquote>
<p>本文介绍 SSD 的核心技术 FTL（闪存转换层）</p>
</blockquote>
<span id="more"></span>
<h2 id="一、FTL-综述"><a href="#一、FTL-综述" class="headerlink" title="一、FTL 综述"></a>一、FTL 综述</h2><p>FTL（Flash Translation Layer，闪存转换层），是 SSD 固件的核心组成，完成主机（Host）逻辑地址空间到闪存（Flash）物理地址空间的翻译（Translation），或映射（Mapping）。SSD 使用的存储介质一般是 NAND Flash</p>
<p>闪存块的有以下重要特性：</p>
<ol>
<li>闪存块需要先擦除才能写入，不能覆盖写，当写入新数据时，不能在老地方更改，因为闪存不允许在一个闪存页上重复写入，一次擦除只能写一次。因此 Firmware 固件需要维护一张逻辑地址到物理地址的映射表。当闪存空间不够时，FTL 就需要做垃圾回收，将若干个闪存块中的有效数据搬出，写到某个新的闪存块上，然后把之前的闪存块删除，得到新的闪存块。</li>
<li>闪存块都是有一定寿命的，可以用 PE（Program/EraseCount）数衡量，通过 Wear Leveling 让数据均摊到每个闪存块上，保证 SSD 的最大数据写入量。</li>
<li>每个闪存块读的数量是有限的，读的太多会造成读干扰（Read Disturb）问题，FTL 需要处理读干扰问题，当某个闪存块读次数快到一定阈值的时候，FTL 需要将其从闪存块中移走，避免数据出错。</li>
<li>闪存的数据保持问题（Data Retention）问题。（电荷流失）</li>
<li>闪存的坏块。</li>
<li>对 MLC 和 TLC 来说，存在 Lower page corruption 问题。</li>
<li>MLC 或 TLC 的读写速度都不如 SLC，但它们都可以配成 SLC 模式来使用。</li>
</ol>
<p>FTL 分为 Host Based（基于主机）和 Device Based （基于设备），目前主流 SSD 都是基于设备。</p>
<h2 id="二、映射管理"><a href="#二、映射管理" class="headerlink" title="二、映射管理"></a>二、映射管理</h2><h3 id="1-映射种类"><a href="#1-映射种类" class="headerlink" title="1. 映射种类"></a>1. 映射种类</h3><ul>
<li>基于块的映射<ul>
<li>对小尺寸数据写入不友好，对大尺寸数据写入友好</li>
<li>U 盘一般采用块映射</li>
</ul>
</li>
<li>基于页的映射<ul>
<li>需要更大的映射表</li>
<li>随机写性能更好</li>
<li>SSD 一般采用页映射</li>
</ul>
</li>
<li>混合映射（Hybrid Mapping）</li>
</ul>
<h3 id="2-映射基本原理"><a href="#2-映射基本原理" class="headerlink" title="2. 映射基本原理"></a>2. 映射基本原理</h3><p>用户通过 LBA（Login Block Address，逻辑块地址）访问 SSD，用户访问 SSD 的基本单元叫逻辑页，SSD 主控按照闪存页为基本单位读写 SSD，闪存页也叫物理页。</p>
<p>映射表</p>
<h3 id="3-HMB"><a href="#3-HMB" class="headerlink" title="3. HMB"></a>3. HMB</h3><p>映射表可以放在 DRAM、SRAM 和闪存中，也可以放到主机的内存中</p>
<p>HMB（Host Memory Buffer，主机高速缓冲存储器），主机在内存中专门划出一部分空间给 SSD 用，SSD 可以把它当成自己的 DRAM 使用。在性能上，它应该介于带 DRAM 和不带 DRAM 之间。带 DRAM 的 SSD，性能好，但是能耗高，成本高；不带 DRAM 的 SSD 与其相反，需要访问两次闪存才能得到数据。</p>
<h3 id="4-映射表刷新"><a href="#4-映射表刷新" class="headerlink" title="4. 映射表刷新"></a>4. 映射表刷新</h3><p>映射表在 SSD 掉电前需要将其写入到闪存中。下次上电初始化时，需要把它从闪存中部分或全部加载到 SSD 的缓存（DRAM或者SRAM）中。为防止异常掉电导致这些新的映射关系丢失，SSD 的固件不仅仅只在正常掉电前把这些映射关系刷新到闪存中去，而是在 SSD 运行过程中按照一定策略把映射表写进闪存，这样可以防止异常掉电带来的映射关系的丢失。</p>
<p>触发映射表的写入时机：</p>
<ul>
<li>新产生的映射关系累积到一定的阈值</li>
<li>用户写入的数据量达到一定的阈值</li>
<li>闪存写完闪存块的数量达到一定的阈值</li>
<li>其他</li>
</ul>
<p>写入策略一般有:</p>
<ul>
<li>全部更新</li>
<li>增量更新</li>
</ul>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1-垃圾回收原理"><a href="#1-垃圾回收原理" class="headerlink" title="1. 垃圾回收原理"></a>1. 垃圾回收原理</h3><h3 id="2-写放大"><a href="#2-写放大" class="headerlink" title="2. 写放大"></a>2. 写放大</h3><p>由于 GC 的存在，就有一个问题，用户要写入一定的数据，SSD 为了腾出空间写这些数据，需要额外的做一些数据的搬移，也就是额外的写，最后往往导致 SSD 往闪存中写人的数据量比实际用户写入 SSD 的数据量多。因此，SSD 中有个重要参数，就是 <strong>写放大(WA, Write Amplification):</strong></p>
<script type="math/tex; mode=display">写放大=\cfrac{写入闪存的数据量}{用户写的数据量}</script><p>空盘的写放大一般为 1，写放大越大，意味着额外写入闪存的数据越多，一方面磨损闪存，减少 SSD 寿命，另一方面，写人这些额外数据会占用底层闪存带宽，影响 SSD 性能。因此，SSD 设计的一个目标是让 WA 尽量小。减小写放大，可以使用前面提到的压缩办法（主控决定），顺序写也可以减小写放大（垃圾集中，但顺序写可遇不可求，取决于用户 Workload），还有就是增大OP（这个可控）。</p>
<p>OP 定义：$OP比例=(闪存空间-用户空间)/用户空间$，增大 OP 能够减小写放大。</p>
<p>总结一下: WA 越小越好，因为越小意味着对闪存的损耗越小，可以延长闪存使用寿命，从而支持更多的用户数据写入量；OP 越大越好，OP 越大，意味着写放大越小，也意味着 SSD 写性能越好。</p>
<p>影响写放大的因素：</p>
<ul>
<li>OP</li>
<li>用户写入数据的 Pattern（顺序写入还是随机写入）</li>
<li>GC 策略</li>
<li>磨损均衡</li>
<li>读干扰和数据保存处理</li>
<li>主控：是否对数据有压缩</li>
<li>Trim</li>
</ul>
<h3 id="3-垃圾回收实现"><a href="#3-垃圾回收实现" class="headerlink" title="3. 垃圾回收实现"></a>3. 垃圾回收实现</h3><p>垃圾回收可以简单分为三步：</p>
<ul>
<li>挑选源闪存块</li>
<li>从源闪存块中找到有效数据</li>
<li>把有效数据写入到目标闪存块</li>
</ul>
<p><strong>1. 挑选源闪存块</strong></p>
<ul>
<li>挑选有效数据最小的块</li>
<li>固件需要记录和维护每个闪存块的有效数据量</li>
<li>这种 BPA 算法叫做 Greedy 算法，是大多数 SSD 使用的算法</li>
<li>有的 BPA 还需要考虑到擦写次数 </li>
</ul>
<p><strong>2. 从源闪存块中找到有效数据</strong></p>
<p>最好的策略当然是只读出块中的有效数据</p>
<ul>
<li>固件在更新和维护闪存块中的有效数据量时，同时维护一张映射表，标识物理页的有效性</li>
<li>当然这种策略也有一个问题，当 SSD 很大时，一个闪存块有上千个闪存页，一个闪存页有上千个逻辑页，因此每个闪存块需要的映射表就会非常大，对于没有 DRAM 的 SSD，没有那么多的 SRAM 空间存储映射表，只能加载部分映射表，因此还要实现映射表的换入换出，实现起来较为困难</li>
</ul>
<p>也可以选择把所有数据都读出来，这样就要判断哪些数据是有效的</p>
<ul>
<li>SSD 在将用户数据写入闪存时，会额外打包一些数据，叫<strong>元数据（Meta data）</strong>，它记录该用户数据的一些信息，例如该数据对应的逻辑地址、数据长度、时间戳等</li>
<li>然后 GC 的时候，FW 读出该数据，得到该数据的逻辑块地址，然后查找映射表，获得物理地址，如果该地址和该数据在闪存中的地址一致，说明数据是有效的，否则无效</li>
<li>该方法显而易见太过繁琐</li>
</ul>
<p>还有一个折中的办法，除了维护一张 <code>L2P(Logical to Physical)</code> 的表，还维护一张 <code>P2L(Physical to Logical)</code> 的表</p>
<p>该表记录了每个闪存块写入的 LBA，该 P2L 数据写在该闪存块的某个位置（或单独存储）。当回收该闪存块时，首先把该 P2L 表加载上来，然后根据上面的 LBA，依次查找映射表，决定该数据是否有效，有效的数据会被读出来，然后重新写人。采用该方法，不需要把该闪存块上的所有数据一股脑地读出来，但还是需要查找映射表以决定数据是否有效。因此，该方法在性能上介于前面两种方法之间，在资源和固件开销上也是处于中间的。</p>
<p>实际上就是将闪存单元中的逻辑地址信息提取出来放到一张表中，节省的是读取闪存块的时间。</p>
<p><strong>3. 把有效数据写入到目标闪存块</strong></p>
<p>当有效数据读出来时，最后一步就是重写，即把读出来的有效数据写入闪存。</p>
<h3 id="4-垃圾回收时机"><a href="#4-垃圾回收时机" class="headerlink" title="4. 垃圾回收时机"></a>4. 垃圾回收时机</h3><ul>
<li>可用闪存块小于一定阈值，就要进行 <code>Foreground GC（前台垃圾回收）</code>，这是被动的方式</li>
<li>与之相对应的 <code>Background GC（后台垃圾回收）</code>，是在 SSD Idle（空闲）的时候主动进行 GC</li>
</ul>
<h2 id="四、Trim"><a href="#四、Trim" class="headerlink" title="四、Trim"></a>四、Trim</h2><p>对一个文件 File A 来说，用户看到的是文件，操作系统把文件划分为若干个逻辑块，然后写入 SSD 的闪存空间。当用户删除掉文件 File A 时，其实它只是切断用户与操作系统的联系，即用户访问不到这些地址空间；而在 SSD 内部，逻辑页与物理页的映射关系还在，文件数据在闪存当中也是有效的。</p>
<p><code>Trim</code> 是一个新增的 ATA 命令（Data Set Management），专为 SSD 设计。当用户删除一个数据时，操作系统会发 Trim 命令给 SSD，告诉 SSD 该文件对应的数据已经无效。</p>
<p>SCSI 里面的同等命令叫 <code>UNMAP</code>，<code>NVMe</code> 里面叫 <code>Deallocate</code>，它们指的都是同一个功能。</p>
<p>SSD 收到 Trim 命令时，固件要按顺序做以下几件事：</p>
<ol>
<li>清除 L2P table 到空地址</li>
<li>清除 Valid Page Bit map（VPBM） 上对应的 bit</li>
<li>更新 Valid Page Count（VPC）</li>
<li>重复以上 3 步直到完成每一个 LBA </li>
<li>根据新的 VPC 重新计算 GC 的优先级</li>
<li>回收最少 VPC 的 block</li>
<li>擦除全是垃圾的 block</li>
</ol>
<p>步骤 5~7 是 Trim 命令处理后，GC 的处理，它们不是 Trim 命令要处理的事情，Trim 命令是不会触发 GC 的。</p>
<h2 id="五、磨损平衡"><a href="#五、磨损平衡" class="headerlink" title="五、磨损平衡"></a>五、磨损平衡</h2><p>磨损平衡，就是让 SSD 中的每个闪存块的磨损（擦除）都保持均衡。</p>
<p>在这之前，我们先抛出几个概念: 冷数据（Cold Data）和热数据（Hot Data），年老的（Old）块和年轻的（Young）块。</p>
<p>所谓冷数据，就是用户不经常更新的数据，比如用户写入 SSD 的操作系统数据、只读文件数据、小电影等；相反，热数据就是用户更新频繁的数据。数据的频繁更新，会在 SSD 内部产生很多垃圾数据（新的数据写入导致老数据失效）。</p>
<p>所谓年老的块，就是擦写次数比较多的闪存块；擦写次数比较少的闪存块，年纪相对小，我们叫它年轻的块。SSD 很容易区分年老的块和年轻的块，看它们的 EC（Erase Count，擦除次数）就可以了，大的就是老的，小的就是年轻的。</p>
<p>动态磨损平衡（Dynamic WL）：将热数据写到年轻的块上</p>
<p>静态磨损平衡（Static WL）：将冷数据写到年老的块上</p>
<p>动态磨损均衡和静态磨损均衡可能导致冷数据和热数据放到同一个闪存块上，冷数据、用户刚写入的数据和 GC 数据可能混在一起。这样在 GC 的时候冷数据可能就会被经常移动，增大了写放大。</p>
<p>解决的策略：做静态磨损均衡的时候，用专门的闪存块来存放冷数据，不与用户或者 GC 写入同一个闪存块</p>
<h2 id="六、掉电恢复"><a href="#六、掉电恢复" class="headerlink" title="六、掉电恢复"></a>六、掉电恢复</h2><p>掉电分为两种：正常掉电和异常掉电。</p>
<p><strong>正常掉电</strong></p>
<p>掉电前，主机通过命令通知 SSD，收到命令之后，会做以下几件事：</p>
<ul>
<li>把 buffer 中缓存的用户数据刷入闪存</li>
<li>把映射表刷入闪存</li>
<li>把闪存的块信息写入闪存（比如当前写的是哪个闪存块，以及写到该闪存块的哪个位置，哪些闪存块已经写过,哪些闪存块又是无效的等）</li>
<li>把 SSD 其他信息写入闪存</li>
</ul>
<p>正常掉电不会导致数据的丢失，重新上电之后 SSD 只需将上述信息重新加载即可。</p>
<p><strong>异常掉电</strong></p>
<p>SSD 中不只有闪存，还有用来存储映射表等用户数据的缓存，这用的是 RAM（DRAM 或 SRAM）。</p>
<p>一个办法是将 SSD 加上电容，当检测到异常掉电时，电容放电，将 RAM 中的数据刷到闪存中，这样的 SSD 需要有异常掉电处理模块。</p>
<p>还有一种前卫的想法，就是用一种掉电不会丢失数据的材料来代替 RAM，例如 3D XPoint.</p>
<p>SSD 的异常掉电恢复主要是映射表的恢复，SSD 在把用户数据写到闪存的时候，会额外打包一些数据，我们叫它元数据（Meta Data），它记录着该笔用户数据的相关信息，比如该笔数据对应的逻辑地址、数据写入时间（时间戳）等，如下图：</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220515204014.png" alt="元数据和用户数据存储示例"></p>
<p>以图 4-44 为例，如果我们读取物理地址 Pa x，就能读取到元数据 x 和用户数据 x，而元数据是有逻辑地址 La x 的，因此，我们就能获得映射: La x→Pa x。映射表的恢复原理其实很简单，只要全盘扫描整个闪存空间，就能获得所有的映射关系，最终完成整个映射表的重构。</p>
<p>若同时存在新老数据，那么便会根据时间戳来获得最新的数据，从而构建映射。但是如果 SSD 容量很大的话，这样的全盘检查耗时会很久，其中一种办法就是 SSD 定期把 SSD RAM 中的数据（包括映射表和用户缓存的数据）和 SSD 相关的状态信息（诸如闪存块擦写次数、闪存块读次数、闪存块其他信息等）写到闪存中去，这个操作被称为 <strong>Checkpoint（检查点），或 “快照”</strong>，这样掉电后只需要扫描局部的物理空间，节省了大量时间。</p>
<h2 id="七、坏块管理"><a href="#七、坏块管理" class="headerlink" title="七、坏块管理"></a>七、坏块管理</h2><p><strong>来源：</strong> 一般来自于出厂自带的坏块和使用中产生的。</p>
<p><strong>坏块鉴别</strong> </p>
<ul>
<li>它会在出厂坏块的第一个闪存页和最后一个闪存页的数据区第一个字节和 Spare 区第一个字节写上一个非 OxFF 的值</li>
<li>一部分厂商会将坏块的信息表存储在闪存中</li>
</ul>
<p><strong>坏块管理</strong></p>
<ul>
<li>略过（Skip）<ul>
<li>用户写闪存的时候，一遇到坏块就越过，写下一个 Block</li>
</ul>
</li>
<li>替换（Replace）<ul>
<li>当某个 Die 上发现坏块时，会被 Die 上某个好块替换，用户写数据时，不是跳过这个坏块，而是写到替换的好块上</li>
<li>整个 Die 空间分为用户空间和预留空间</li>
<li>采用替换策略的话，SSD 内部需要维护一张重映射表（Remap Table），即坏块到替换块的映射</li>
</ul>
</li>
</ul>
<p>两种策略的优劣：</p>
<p>略过策略的性能不稳定，并行度可能在 1~4 个 Die 之间（假设有 4 个 Die），但是替换策略有木桶效应，如果某个 Die 质量较差，整个 SSD 可用的闪存块受限于那个坏的 Die。</p>
<h2 id="八、SLC-Cache"><a href="#八、SLC-Cache" class="headerlink" title="八、SLC Cache"></a>八、SLC Cache</h2><p>SLC 相比 MLC 和 TLC，有更好的性能和寿命，有些 SSD 用其来做 Cache，让 SSD 有更好的突发性能（Brust Performance）。</p>
<p>这里所说的 SLC Cache，不是说单独拿 SLC 闪存来做 Cache，而是把 MLC 或者 TLC 里面的一些闪存块配置成 SLC 模式来访问，而这个特性一般的 MLC 或者 TLC 都是支持的。SLC 模式下的闪存块，相比 MLC 或者 TLC 模式下的闪存块，更快更耐写，可以用来做 Cache。</p>
<p>SLC Cache写入策略有:</p>
<ul>
<li>强制 SLC 写入<ul>
<li>用户写入数据时，必须先写人到 SLC 闪存块，然后通过 GC 搬到 MLC 或者 TLC 闪存块、</li>
<li>能够保护 Lower Page 的数据</li>
</ul>
</li>
<li>非强制 SLC 写入<ul>
<li>用户写人数据时，如果有 SLC 闪存块，则写入到 SLC 闪存块，否则直接写到 MLC 或者 TLC 闪存块</li>
<li>具有更好的后期写入性能</li>
</ul>
</li>
</ul>
<p>SLC Cache 办法：</p>
<ul>
<li>静态 SLC Cache：拿出一些 Block 专门做 SLC Cache</li>
<li>动态 SLC Cache：所有的 MLC 和 TLC 都可以用来做 SLC Cache</li>
<li>两者混合</li>
</ul>
<h2 id="九、RD-amp-DR"><a href="#九、RD-amp-DR" class="headerlink" title="九、RD &amp; DR"></a>九、RD &amp; DR</h2><p><code>RD</code> 指的是 <code>Read Disturb</code>，<code>DR</code> 指的是 <code>Data Retention</code>。两者都能导致数据丢失，但原理和固件处理方式都不一样，下面分别介绍。</p>
<h3 id="1-RD"><a href="#1-RD" class="headerlink" title="1. RD"></a>1. RD</h3><p>闪存块在读取时需要在其他字线（Wordline）上施加电压，时间一长，电子进入浮栅极过多，从而导致比特翻转（1-&gt;0），当出错比特数超过 ECC 纠错能力时，数据便会丢失，这就是 RD。</p>
<p>我们要保证每个闪存块读取的次数低于某个阈值，在比特翻转前就将其刷新，这样可以避免 RD。因此 FTL 应该要记录每个闪存块读取次数的表。当然为了避免“过刷新”的问题，可以在读次数超过阈值后，先检测比特翻转数，若不需要刷新，则可以设置一个更大的阈值。最理想的阈值是根据 SSD 的 PE 数动态设置。</p>
<p>对于刷新动作，也分为阻塞（Block）和非阻塞（Non-Block），一般采用非阻塞。</p>
<h3 id="2-DR"><a href="#2-DR" class="headerlink" title="2. DR"></a>2. DR</h3><p>SSD 使用时间长了之后，会有电子逃逸，当逃逸的电子到一定数量的时候，就会使存储单元的比特发生翻转（0-&gt;1，注意 RD 是 1-&gt;0），解决办法仍然是扫描闪存空间，若检测到比特翻转超出一定阈值，进行刷新。</p>
<h2 id="十、Host-Based-FTL"><a href="#十、Host-Based-FTL" class="headerlink" title="十、Host Based FTL"></a>十、Host Based FTL</h2><p>按照 FTL 放在哪里进行划分，分为 Host Based FTL 和 Device Based FTL</p>
<p>总体来说，Device Based 存在以下缺点:</p>
<ul>
<li>FTL 架构通用，不能针对具体应用做定制化。控制器芯片功能复杂，设计难度大，研发成本高</li>
<li>闪存更新很快，一般每年闪存厂商都会推出新一代产品，有新的使用特性，需要控制器芯片做出修改，但是芯片改版成本很高</li>
<li>企业级应用需要高性能、大容量，通用控制器芯片支持的最大性能和容量有限制企业级市场需求多种多样，有些需求需要控制器提供特殊功能支持，这些是通用 SSD 主控芯片无法提供的。</li>
</ul>
<p>百度的欧阳剑团队在国际著名的计算机体系结构学术会议 ASPLOS’14 上发表了一篇文章，介绍他们研发的软件定义闪存 SDF（Software Defined Flash）。相比市场上销售的 SSD，SDF 主要的特点有:</p>
<ol>
<li><p>没有垃圾回收。SDF 的使用者使用闪存块大小的整数倍为单位来写数据（比如8 MB），所以每个闪存块里面不会有垃圾，或者整体都是垃圾，写之前整体擦除就可以。这样的好处有:</p>
<ul>
<li>SSD 内部不用做垃圾回收，读写带宽得到提高</li>
<li>不需要预留空间，释放出 20% 的额外空间</li>
<li>没有内部搬移数据产生的写操作，闪存没有了写放大，寿命延长</li>
</ul>
</li>
<li><p>没有闪存级 RAID。SSD 内部其实是闪存阵列，所以为了数据安全性，很多企业级 SSD 会用闪存组成 RAID 组，用一块或几块闪存保存RAID 数据。但是互联网公司的数据一般都有3个备份，所以不担心 SSD 内部数据丢失，因此，RAID是没有必要的</p>
</li>
<li><p>FPGA 作为控制芯片，功能很少:ECC、坏块管理、地址转换、动态磨损均衡。Virtex-5 FPGA 实现了 PCIe 接口和 DMA，Spartan FPGA 则是闪存控制芯片</p>
</li>
<li></li>
<li><p>SSD 内部每个通道都向用户开放，由用户选择写哪个通道</p>
</li>
<li><p>软件接口层非常简单，相比传统的 Linux 存储堆栈，省略了文件系统、块设备、IO 调度、SATA 协议等，用户可以直接使用 IOCTRL（设备驱动程序中对 IO 设备的通道进行管理的函数）来发同步的写命令到 PCIe 驱动</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OpenSSD</category>
        <category>SSD</category>
      </categories>
      <tags>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出SSD（一）</title>
    <url>/11b7e709.html</url>
    <content><![CDATA[<blockquote>
<p>本文是《深入浅出SSD 固态存储核心技术、原理与实战》的学习笔记</p>
</blockquote>
<span id="more"></span>
<h2 id="一、SSD-介绍"><a href="#一、SSD-介绍" class="headerlink" title="一、SSD 介绍"></a>一、SSD 介绍</h2><p>SSD(Solid State Drive) 固态硬盘，主要以半导体闪存为介质的存储设备，属于 ROM 的一种。</p>
<p>SSD 硬件包括几大组成部分:主控、闪存、缓存芯片DRAM（可选，有些SSD上可能只有 SRAM，并没有配置 DRAM）、PCB（电源芯片、电阻、电容等）、接口（SATA、SAS、PCle等），其主体就是一块 PCB。</p>
<p>软件角度，SSD 内部运行固件（Firmware, FW）负责调度数据从接口端到介质端的读写，还包括嵌入核心的闪存介质寿命和可靠性管理调度算法，以及其他 SSD 的算法。</p>
<p>SSD 控制器，闪存和固件是 SSD 三大技术核心。</p>
<p>SSD 的容量，性能，可靠性，寿命，尺寸，功耗，噪声，重量，抗震，温度都优于机械硬盘，目前价格也逐渐接近机械硬盘。</p>
<h2 id="二、SSD-基本工作原理"><a href="#二、SSD-基本工作原理" class="headerlink" title="二、SSD 基本工作原理"></a>二、SSD 基本工作原理</h2><p>SSD 的输入是命令(Command)，输出是数据(Data)和命令状态(Command Status)。SSD 前端(Front End)接收用户命令请求，经过内部计算和处理逻辑，输出用户所需要的数据或状态。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220512163939.png" alt="SSD系统调用"></p>
<p>SSD 的三大功能模块：</p>
<ul>
<li>前端接口和相关的协议模块;</li>
<li>中间的 FTL 层（Flash Translation Layer，闪存转换层）模块;</li>
<li>后端和闪存通信模块</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220512164826.png" alt="接口协议"></p>
<p>FTL 算法决定了性能、可靠性、功耗等 SSD 的核心参数。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220512165605.png" alt="SSD的垃圾回收（GC）"></p>
<h2 id="三、SSD-系统架构"><a href="#三、SSD-系统架构" class="headerlink" title="三、SSD 系统架构"></a>三、SSD 系统架构</h2><p>SSD 作为数据存储设备，其实是一种典型的(System on Chip)单机系统，有主控CPU、RAM、操作加速器、总线、数据编码译码等模块(见图2-1)，操作对象为协议、数据命令、介质，操作目的是写入和读取用户数据。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220512170135.png" alt="SSD主控模块硬件图"></p>
<p>SSD 系统架构分为前端（Host Interface Controller，主机接口控制器）和后端（Flash Controller，闪存控制器），前端和主机接口打交道，包含 SATA、PCIe、SAS 接口等，后端和闪存打交道，完成数据编解码和 ECC。</p>
<h3 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h3><p>SATA 的全称是 Serial Advanced Technology Attachment（串行高级技术附件），是一种串行硬件驱动器接口。</p>
<p>SAS（Serial Attached SCSI）即串行连接 SCSI，是新一代的 SCSI 技术。</p>
<p>PCIe（Peripheral Component Interconnect Express）是一种高速串行计算机扩展总线标准，原来被称为 3GIO</p>
<h3 id="2-主控-CPU"><a href="#2-主控-CPU" class="headerlink" title="2. 主控 CPU"></a>2. 主控 CPU</h3><h3 id="3-后端"><a href="#3-后端" class="headerlink" title="3. 后端"></a>3. 后端</h3><p>后端两大模块分别为 ECC 和闪存控制器。</p>
<p>ECC 模块是数据编解码单元，由于闪存存储天生的误码率，要在数据写入是加上 ECC 检验保护，同样读取的时候要通过 ECC 进行解码。</p>
<p>SSD 中的 ECC 算法主要有 BCH 和 LDPC，后者逐渐成为主流。</p>
<h2 id="四、闪存物理结构"><a href="#四、闪存物理结构" class="headerlink" title="四、闪存物理结构"></a>四、闪存物理结构</h2><p>现在固态硬盘采用 NAND 闪存作为存储介质。闪存在写之前必须先擦除，不能覆盖写，因此 SSD 需要有垃圾回收，一个块读写次数超过一定限度就会损坏，因此要有磨损均衡。</p>
<p>闪存是一种非易失性存储器，基本存储单元是一种类 NMOS 的双层浮栅 MOS 管，电子被上下绝缘层包围，因此掉电不会消失。</p>
<p>施敏发明浮栅晶体管的来源是奶酪蛋糕~~</p>
<h3 id="SLC、MLC、TCL"><a href="#SLC、MLC、TCL" class="headerlink" title="SLC、MLC、TCL"></a>SLC、MLC、TCL</h3><p>一个存储单元存储 1bit 的数据的闪存，叫做 SLC（Single Level Cell），存储 2bit 数据的闪存叫 MLC（Multiple Level Cell），存储 3bit 数据的闪存为 TLC（Triple Level Cell）。</p>
<p>存储单元存储的值是按照存储单元里的电子相对个数来判断的，电子相对个数通过电压的区间范围来判断。</p>
<p>但同时，一个存储单元电子划分得越多，那么在写入的时候，控制进入浮栅极的电子个数就要越精细，所以写耗费的时间就越长;同样的，读的时候，需要尝试用不同的参考电压去读取，一定程度上加长了读取时间。所以我们会看到在性能上，TLC 不如 MLC，MLC 不如 SLC。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220513194602.png" alt="SLC、MLC和TCL参数比较"></p>
<p>一个闪存内部的存储组织结构如下图所示:<br>一个闪存芯片有若干个 DIE（或者叫LUN），每个 DIE 有若干个 Plane，每个 Plane 有若干个 Block，每个 Block 有若干个 Page,每个 Page 对应着一个 Wordline，Wordline 由成千上万个存储单元构成。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220513194929.png" alt="闪存内部组织架构"></p>
<p>DIE/LUN 是接收和执行闪存命令的最基本单元，在一个 LUN 中，不能对某个 Page 写的同时，又对其他 Page 进行读访问。</p>
<p>一个 LUN 又分为若干个 Plane，市面上常见的是 1 个或者 2 个 Plane，现在也有 4 个 Plane 的闪存了。每个 Plane 都有自己独立的 Cache Register 和 Page Register，其大小等于一个 Page 的大小。</p>
<p>固态硬盘主控在写某个 Page 的时候，先把数据从主控传输到该 Page 所对应 Plane 的 Cache Register 中，然后把整个 Cache Register 写到闪存阵列，读的时候相反，先把这个 Page 中的数据从闪存介质读取到 Cache Register 中，然后<strong>按需</strong>传给主控。</p>
<p>同时有 Cache Register 和 Page Register 的目的是优化闪存的访问速度（类似于二级缓存）。</p>
<p>我们通常所说的闪存读写时间，并不包含数据从闪存到主控之间的数据传输时间，也不包括数据在 Cache Register 和 Page Register 之间的传输时间。闪存写人时间是指一个 Page 的数据从 Page Register 当中写人闪存介质的时间，闪存读取时间是指一个 Page 的数据从闪存介质读取到 Page Register 的时间。</p>
<p>闪存一般都支持 Multi-Plane（或者Dual-Plane）操作，就是将同一个 LUN 中多个 Plane 中 Cache Register 写入数据后同时写入闪存介质，这样可以节省 Page 写入时间。</p>
<p>闪存的擦除是以 block 为单位的，因为在物理结构上，一个 block 中的存储单元共用一个衬底（Substrate）。</p>
<h3 id="读、写、擦原理"><a href="#读、写、擦原理" class="headerlink" title="读、写、擦原理"></a>读、写、擦原理</h3><p>量子隧道效应</p>
<h3 id="三维闪存"><a href="#三维闪存" class="headerlink" title="三维闪存"></a>三维闪存</h3><h3 id="3D-XPoint"><a href="#3D-XPoint" class="headerlink" title="3D XPoint"></a>3D XPoint</h3><p>相变存储器：PRAM，PCM</p>
<p>PCM 通过一种微小的电阻作用使得玻璃融化，相变为晶体，现在 PCM 读取时间已经可以到皮秒级别。</p>
<p>PCM 特点：</p>
<ul>
<li>掉电数据不丢失</li>
<li>可以按照字节访问</li>
<li>软件简单</li>
<li>写之前不需要擦除操作</li>
<li>功耗低，和闪存差不多</li>
<li>读写速度快</li>
<li>寿命远长于闪存</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220513213919.png" alt="几种存储器特性对比"></p>
]]></content>
      <categories>
        <category>OpenSSD</category>
        <category>SSD</category>
      </categories>
      <tags>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题总结</title>
    <url>/200b33f8.html</url>
    <content><![CDATA[<h1 id="刷笔试题错误和易混点总结"><a href="#刷笔试题错误和易混点总结" class="headerlink" title="刷笔试题错误和易混点总结"></a>刷笔试题错误和易混点总结</h1><h3 id="1-下面哪些机制可以用于进程间通信？"><a href="#1-下面哪些机制可以用于进程间通信？" class="headerlink" title="1. 下面哪些机制可以用于进程间通信？"></a>1. 下面哪些机制可以用于进程间通信？</h3><ul>
<li>[x] Socket</li>
<li>[x] Named pipe</li>
<li>[ ] Named event</li>
<li>[ ] Critical Section</li>
<li>[x] Shared memory</li>
<li>[ ] Virtual memory</li>
</ul>
<blockquote>
<p>Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)<br>Linux线程间通信：互斥量（mutex），信号量，条件变量<br>Windows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)<br>Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）</p>
</blockquote>
<span id="more"></span>
<blockquote>
<ul>
<li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
</blockquote>
<h3 id="2-Linux系统中的wc-Word-Count-命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出"><a href="#2-Linux系统中的wc-Word-Count-命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出" class="headerlink" title="2. Linux系统中的wc (Word Count) 命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出"></a>2. Linux系统中的wc (Word Count) 命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出</h3><p>1．命令格式：</p>
<p>wc [选项]文件…</p>
<p>2．命令功能：</p>
<p>统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的<em>*</em>计数。</p>
<p>3．命令参数：</p>
<p>-c 统计字节数。</p>
<p>-l 统计行数。</p>
<p>-m 统计字符数。这个标志不能与 -c 标志一起使用。</p>
<p>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</p>
<p>-L 打印最长行的长度。</p>
<p>-help 显示帮助信息</p>
<p>—version 显示版本信息</p>
<p>4．使用实例：</p>
<p>实例1：查看文件的字节数、字数、行数</p>
<p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wc test.txt</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost test] # cat test.txt </span><br><span class="line">hnlinux</span><br><span class="line">peida.cnblogs.com</span><br><span class="line">ubuntu</span><br><span class="line">ubuntu linux</span><br><span class="line">redhat</span><br><span class="line">Redhat</span><br><span class="line">linuxmint</span><br><span class="line">[root @localhost test] # wc test.txt</span><br><span class="line">7 8 70 test.txt</span><br><span class="line">[root @localhost test] # wc -l test.txt </span><br><span class="line">7 test.txt</span><br><span class="line">[root @localhost test] # wc -c test.txt </span><br><span class="line">70 test.txt</span><br><span class="line">[root @localhost test] # wc -w test.txt </span><br><span class="line">8 test.txt</span><br><span class="line">[root @localhost test] # wc -m test.txt </span><br><span class="line">70 test.txt</span><br><span class="line">[root @localhost test] # wc -L test.txt </span><br><span class="line">17 test.txt</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7 8 70 test.txt</span><br><span class="line">行数 单词数 字节数 文件名</span><br></pre></td></tr></table></figure>
<h3 id="3-Cookie可以用于验证用户，并且可以在无状态的HTTP上建立一个用户会话层"><a href="#3-Cookie可以用于验证用户，并且可以在无状态的HTTP上建立一个用户会话层" class="headerlink" title="3. Cookie可以用于验证用户，并且可以在无状态的HTTP上建立一个用户会话层"></a>3. Cookie可以用于验证用户，并且可以在无状态的HTTP上建立一个用户会话层</h3><p>正确</p>
<p>当浏览器访问服务器时，服务器会创建一个session对象（该对象有一个唯一的id号，称之为sessionId）服务器在默认的情况下，会将sessionId以cookie的方式，发送给浏览器，浏览器会将sessionId保存到内存中。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可以找到之间创建的session对象</p>
<h3 id="4-定义字符串-String-str-“用户1-用户2-用户3-用户4”，现在想要对字符串根据字符“-”进行分割解析，下面哪种分割方式是正确的？"><a href="#4-定义字符串-String-str-“用户1-用户2-用户3-用户4”，现在想要对字符串根据字符“-”进行分割解析，下面哪种分割方式是正确的？" class="headerlink" title="4. 定义字符串 String str = “用户1|用户2|用户3|用户4”，现在想要对字符串根据字符“|”进行分割解析，下面哪种分割方式是正确的？"></a>4. 定义字符串 String str = “用户1|用户2|用户3|用户4”，现在想要对字符串根据字符“|”进行分割解析，下面哪种分割方式是正确的？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.split(&amp;ldquo;\\|&amp;rdquo;)</span><br></pre></td></tr></table></figure>
<p><code>|</code>属于正则表达式中的字符，转义字符前面加<code>\\</code></p>
<h3 id="5-ATM-既可以用于广域网，又可以用于局域网，这是因为它的工作原理与-Ethernet-基本上是相同的"><a href="#5-ATM-既可以用于广域网，又可以用于局域网，这是因为它的工作原理与-Ethernet-基本上是相同的" class="headerlink" title="5. ATM 既可以用于广域网，又可以用于局域网，这是因为它的工作原理与 Ethernet 基本上是相同的"></a>5. ATM 既可以用于广域网，又可以用于局域网，这是因为它的工作原理与 Ethernet 基本上是相同的</h3><p>错误</p>
<p>ATM可以用于广域网，也可以用于广域网，一般用于广域网比较多。<br>ATM的原理是采用面向连接的传输方式，将数据分割成固定长度的信元，通过虚连接进行交换。<br>ATM的原理和以太网的原理是不一样的。</p>
<p>ATM是一种为了多种业务设计的通用的面向连接的传输模式。它适用于局域网和广域网，它具有高速数据传输率和支持许多种类型如声音、数据、传真、实时视频、CD质量音频和图像的通信。<br>ATM采用面向连接的传输方式，将数据分割成固定长度的信元，通过虚连接进行交换。ATM集交换、复用、传输为一体，在复用上采用的是异步时分复用方式，通过信息的首部或标头来区分不同信道。</p>
<h3 id="6-如果一个接口Glass有个方法setColor-，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是"><a href="#6-如果一个接口Glass有个方法setColor-，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是" class="headerlink" title="6. 如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是"></a>6. 如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是</h3><ul>
<li>[ ] protected void setColor() {…}</li>
<li>[ ] void setColor() {…}</li>
<li>[x] public void setColor() {…}</li>
<li>[ ] 以上语句都可以用在类BlueGlass中</li>
</ul>
<p>JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。<br>接口中属性为public static final，方法为public abstract.</p>
<h3 id="7-以下哪些命令可以查看当前系统的启动时间"><a href="#7-以下哪些命令可以查看当前系统的启动时间" class="headerlink" title="7. 以下哪些命令可以查看当前系统的启动时间"></a>7. 以下哪些命令可以查看当前系统的启动时间</h3><ul>
<li>[x] w</li>
<li>[x] top</li>
<li>[ ] ps</li>
<li>[x] uptime</li>
</ul>
<p><code>w</code>: 查看当前登录到系统中的用户，并查看该用户正在运行的进程<br><code>top</code>: 查看Linux中的资源信息，第一行开始部分显示了系统当前时间，并显示已经运行了多长时间，两者相减就是系统启动时间<br><code>uptime</code>: 查看系统启动时间<br><code>who -b</code>: 查看登录到系统中的用户什么时候登录的</p>
<h3 id="8-关于Nginx的安全加固，以下说法正确的是"><a href="#8-关于Nginx的安全加固，以下说法正确的是" class="headerlink" title="8. 关于Nginx的安全加固，以下说法正确的是"></a>8. 关于Nginx的安全加固，以下说法正确的是</h3><ul>
<li>[ ] nginx的master进程不能以root权限启动</li>
<li>[x] nginx的Worker进程不能以root权限启动</li>
<li>[x] 图片等静态资源目录不能给脚本执行权限</li>
<li>[x] 禁止访问.git、.svn和.sql目录，可以防止因运维操作不当造成的代码或数据泄漏</li>
</ul>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>组会纪要</title>
    <url>/cf54ade6.html</url>
    <content><![CDATA[<h1 id="组会纪要"><a href="#组会纪要" class="headerlink" title="组会纪要"></a>组会纪要</h1><blockquote>
<p>对每周五开会和平时讨论内容的总结整理</p>
</blockquote>
<span id="more"></span>
<h2 id="8-5-组会"><a href="#8-5-组会" class="headerlink" title="8.5 组会"></a>8.5 组会</h2><h3 id="上周任务"><a href="#上周任务" class="headerlink" title="上周任务"></a>上周任务</h3><ol>
<li>测试 tpftl 模块</li>
</ol>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ol>
<li>因 mac 架构问题，导致无法使用模拟器</li>
<li>内存中表项写回 flash 时机：设置阈值即可</li>
<li>连接 VPN</li>
</ol>
<h3 id="下周任务"><a href="#下周任务" class="headerlink" title="下周任务"></a>下周任务</h3><ol>
<li>连所里服务器继续测试</li>
</ol>
<hr>
<h2 id="7-29-组会"><a href="#7-29-组会" class="headerlink" title="7.29 组会"></a>7.29 组会</h2><h3 id="上周任务-1"><a href="#上周任务-1" class="headerlink" title="上周任务"></a>上周任务</h3><ol>
<li>编写代码<ol>
<li>主要完成了与 flash 的读写相关逻辑</li>
<li>优化了读写相关逻辑</li>
</ol>
</li>
</ol>
<h3 id="问题总结-1"><a href="#问题总结-1" class="headerlink" title="问题总结"></a>问题总结</h3><ol>
<li><code>l2p_table_entry l2p_get_l2p_entry(l2p_table_index lsn, u32 opcode, u32 is_searched)</code><br>写操作时要在 flash 中分配一个空闲页，然后建立逻辑地址到物理地址的映射。<br>通过该 API 进行写操作时，写的数据在哪？</li>
</ol>
<h3 id="下周任务-1"><a href="#下周任务-1" class="headerlink" title="下周任务"></a>下周任务</h3><ol>
<li>继续编写代码</li>
</ol>
<h2 id="7-22-组会"><a href="#7-22-组会" class="headerlink" title="7.22 组会"></a>7.22 组会</h2><h3 id="上周任务-2"><a href="#上周任务-2" class="headerlink" title="上周任务"></a>上周任务</h3><ol>
<li>看 12 篇论文并总结</li>
</ol>
<h3 id="下周任务-2"><a href="#下周任务-2" class="headerlink" title="下周任务"></a>下周任务</h3><ol>
<li>继续编写代码</li>
</ol>
<hr>
<h2 id="7-15-组会"><a href="#7-15-组会" class="headerlink" title="7.15 组会"></a>7.15 组会</h2><h3 id="上周任务-3"><a href="#上周任务-3" class="headerlink" title="上周任务"></a>上周任务</h3><ol>
<li>继续编写代码</li>
</ol>
<h3 id="问题总结-2"><a href="#问题总结-2" class="headerlink" title="问题总结"></a>问题总结</h3><h3 id="下周任务-3"><a href="#下周任务-3" class="headerlink" title="下周任务"></a>下周任务</h3><hr>
<h2 id="7-7-组会"><a href="#7-7-组会" class="headerlink" title="7.7 组会"></a>7.7 组会</h2><p>请假</p>
<hr>
<h2 id="7-1-组会"><a href="#7-1-组会" class="headerlink" title="7.1 组会"></a>7.1 组会</h2><h3 id="上周任务-4"><a href="#上周任务-4" class="headerlink" title="上周任务"></a>上周任务</h3><ol>
<li>编写 tp_l2p 模块代码</li>
<li>学习模拟器的使用</li>
<li>修改文档</li>
</ol>
<h3 id="问题总结-3"><a href="#问题总结-3" class="headerlink" title="问题总结"></a>问题总结</h3><ol>
<li>修改了部分结构体，新增了部分函数</li>
<li>TP 结点数量设置为 1M 个，总结点数量最大也为 1M 个</li>
<li>如何读取和写入 flash（API）</li>
<li>LRU 的计数器问题<ul>
<li>LRU 可用访问次数来实现</li>
</ul>
</li>
</ol>
<h3 id="下周任务-4"><a href="#下周任务-4" class="headerlink" title="下周任务"></a>下周任务</h3><ol>
<li>继续编写模块代码</li>
</ol>
<hr>
<h2 id="6-23-组会"><a href="#6-23-组会" class="headerlink" title="6.23 组会"></a>6.23 组会</h2><h3 id="上周完成"><a href="#上周完成" class="headerlink" title="上周完成"></a>上周完成</h3><ol>
<li>完成 TPFTL 设计文档</li>
<li>文档用 Latex 完成并推送到 doc 仓库</li>
</ol>
<hr>
<h2 id="6-17-组会"><a href="#6-17-组会" class="headerlink" title="6.17 组会"></a>6.17 组会</h2><ol>
<li>完善 l2p 优化，使用 TPFTL 方案</li>
<li>增加函数接口设计，结构体设计和全局变量</li>
</ol>
<p>（是否要重新开分支）</p>
<h3 id="问题总结-4"><a href="#问题总结-4" class="headerlink" title="问题总结"></a>问题总结</h3><ul>
<li>用数组会浪费空间，改成链表。</li>
<li>list.h 链表结构体的使用</li>
</ul>
<hr>
<h2 id="6-10-组会"><a href="#6-10-组会" class="headerlink" title="6.10 组会"></a>6.10 组会</h2><ol>
<li>搜集 HPCA 2015-2022 年相关论文并上传到仓库</li>
<li>阅读 Eurosys2015 那篇论文，TPFTL</li>
<li>阅读 Handbook，了解代码整体框架</li>
<li>提出 cache 优化方案</li>
</ol>
<h3 id="下周工作"><a href="#下周工作" class="headerlink" title="下周工作"></a>下周工作</h3><p>将 DFTL 方案改成 TPFTL，加上函数接口设计，结构体设计，和全局变量</p>
<hr>
<h2 id="6-2-组会"><a href="#6-2-组会" class="headerlink" title="6.2 组会"></a>6.2 组会</h2><ol>
<li>和大家讨论 C 语言代码规范</li>
<li>搜集 HPCA MSST 2012-2014 年相关论文并上传到仓库</li>
<li>开始阅读 l2p 相关代码</li>
</ol>
<h3 id="下周工作-1"><a href="#下周工作-1" class="headerlink" title="下周工作"></a>下周工作</h3><ol>
<li>继续阅读 l2p 代码</li>
<li>阅读 Eurosys2015 那篇论文</li>
<li>完成 cache 设计方案</li>
</ol>
<hr>
<h2 id="5-30-代码规范"><a href="#5-30-代码规范" class="headerlink" title="5.30 代码规范"></a>5.30 代码规范</h2><hr>
<h2 id="5-27-组会"><a href="#5-27-组会" class="headerlink" title="5.27 组会"></a>5.27 组会</h2><ol>
<li><p>阅读相关论文，学习了解 DFTL 的结构和原理</p>
<ul>
<li>将闪存块分为<strong>数据块</strong>和<strong>翻译块</strong>，前者存放真正的数据，后者存放存放映射表，并且是在闪存的固定位置</li>
<li>根据工作运行情况将映射表动态调入 SRAM</li>
<li>先查找 SRAM 中的 CMT（Cached Mapping Table），若未找到，再根据 GTD（Global Translation Directory，类似于二级页表）将闪存中的表替换到 SRAM 中，类似于分页机制中的 TLB</li>
<li>Cache 采用写回法，当表项替换出去的时候将其最新值写入闪存中</li>
</ul>
</li>
<li><p>学习了解 SLC Cache 相关内容</p>
</li>
</ol>
<h3 id="下周工作-2"><a href="#下周工作-2" class="headerlink" title="下周工作"></a>下周工作</h3><ol>
<li>C 语言代码规范文档讨论</li>
<li>阅读 standard v3 仓库代码的 l2p 模块</li>
</ol>
<hr>
<h2 id="5-20-组会"><a href="#5-20-组会" class="headerlink" title="5.20 组会"></a>5.20 组会</h2><p><strong>进度</strong></p>
<ol>
<li><p>学习《深入浅出SSD》1.4, 2.1, 3.1 和第四章的相关内容，对 SSD 有个大致的了解，以及对 SSD 的核心 FTL 有个基本了解（<a href="/source/_posts/深入浅出SSD（一）.md">深入浅出SSD（一）</a> <a href="/source/_posts/深入浅出SSD（二）：SSD核心技术：FTL.md">深入浅出SSD（二）</a>）</p>
</li>
<li><p>阅读相关论文，了解 FTL 中虚拟地址映射、垃圾回收、磨损均衡等核心技术</p>
</li>
<li><p>自己学了一点其他的知识</p>
</li>
</ol>
<p><strong>遇到的问题</strong>：刚开始阅读论文，速度较慢</p>
<p><strong>建议</strong>：论文阅读关注背景、评测部分，理解论文里的思想</p>
<p><strong>未来工作</strong>：L2P 优化，DFTL</p>
]]></content>
      <categories>
        <category>OpenSSD</category>
        <category>组会</category>
      </categories>
      <tags>
        <tag>组会</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化的实现（包括makefile脚本的使用）</title>
    <url>/ec9e8461.html</url>
    <content><![CDATA[<h1 id="makefile脚本的实现"><a href="#makefile脚本的实现" class="headerlink" title="makefile脚本的实现"></a>makefile脚本的实现</h1><p>在此之前，我们编译内核都是通过手动输入一条一条命令实现的，但是随着我们的模块越来越多，每次编译内核再手动链接成一个二进制文件，最后再手动反汇编是很麻烦的。作为一名合格的计算机专业的大学生，这种手动模式是很不专业的，一是手输代码很容易出错，倘若我们更新了某个模块，却忘了重新编译链接的话，那么最后的内核就会出现一些难以排除的诡异 bug；二是，作为计算机专业的大学生，将工作自动化是理所应当的，这也是和其他专业的毕业生的一个区别。因此，要想真正的提升自己的技术水平，就必须懂得将业务逻辑进行自动化实现。</p>
<p>那么从现在开始，我们将把以前手动处理的编译链接反编译等一系列工作，全面自动化。</p>
<p>我们之前在 Windows 上也有一个简单的 bat 脚本，如下所示：</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">::cls</span><br><span class="line">f:</span><br><span class="line">cd F:\Code\Java\Java4LinuxOS</span><br><span class="line">nasm boot.asm -o boot</span><br><span class="line">::copy boot \src</span><br><span class="line">nasm kernel.asm -o kernel</span><br><span class="line">::copy kernel \src</span><br><span class="line">cd src</span><br><span class="line">javac OS.java</span><br><span class="line">java OS</span><br><span class="line">del OS.class</span><br><span class="line">del Floppy.class</span><br><span class="line">del Floppy$MAGNETIC_HEAD.class</span><br><span class="line">::del boot</span><br><span class="line">::del kernel</span><br><span class="line">move system.img ../</span><br><span class="line">cd F:\Code\Java\Java4LinuxOS</span><br><span class="line">e:</span><br><span class="line">cd E:\Virtual\SimpleOS</span><br><span class="line">del system.img</span><br><span class="line">echo 原映像文件已删除</span><br><span class="line">copy F:\Code\Java\Java4LinuxOS\system.img E:\Virtual\SimpleOS</span><br><span class="line">echo 新映像已移动至虚拟机根目录下</span><br><span class="line">f:</span><br><span class="line">move F:\Code\Java\Java4LinuxOS\system.img F:\bochs\Bochs-2.6.11</span><br><span class="line">echo 新映像已移动至bochs根目录下</span><br></pre></td></tr></table></figure>
<p>该脚本的作用是用 nasm 编译内核，运行 Java 类生成镜像文件，再将镜像文件传到虚拟机和 bochs 根目录下，这样一来，也能节省不少时间，而且不用启动 Java 编辑器了，也不用再一次次的点击复制粘贴了。<br>但是这样的话还是需要在 Linux 中手动输入很多冗长的编译指令，下面的 makefile 脚本文件能够实现这些编译，链接，反汇编，以及传输等操作。<br>首先，是内核 C 语言模块部分的编译，反汇编，以及从虚拟机传输到实体机。现在我们 C 内核有以下模块：write_vga_desktop.c,mem_util.c, mem_util.h, win_sheet.c, win_sheet.h。makefile内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ckernel.asm : ckernel.o</span><br><span class="line">    ./objconv -fnasm ckernel.o -o ckernel.asm</span><br><span class="line">ckernel.o : write_vga_desktop_win.o win_sheet.o mem_util.o</span><br><span class="line">    ld -m elf_i386 -r write_vga_desktop_win.o mem_util.o win_sheet.o -o ckernel.o</span><br><span class="line">write_vga_desktop_win.o : write_vga_desktop_win.c win_sheet.c win_sheet.h mem_util.c mem_util.h</span><br><span class="line">    gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c write_vga_desktop_win.c -o write_vga_desktop_win.o</span><br><span class="line">win_sheet.o : win_sheet.c win_sheet.h</span><br><span class="line">    gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c win_sheet.c -o win_sheet.o</span><br><span class="line">mem_util.o : mem_util.c mem_util.h</span><br><span class="line">    gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c mem_util.c -o mem_util.o</span><br><span class="line">all : ckernel.asm</span><br><span class="line">    @cd src/ &amp;&amp; javac -encoding gbk OS.java</span><br><span class="line">    @cd src/ &amp;&amp; mv OS.class ../ &amp;&amp; mv Floppy.class ../ &amp;&amp; mv Floppy\$$MAGNETIC_HEAD.class ../ &amp;&amp; mv ProcessASMFile.class ../</span><br><span class="line">    @rm *.class</span><br><span class="line">    java OS ckernel.asm</span><br><span class="line">    @cp system.img /home/cherry/Virtual</span><br><span class="line">    @echo <span class="string">&quot;镜像已移动到虚拟机根目下&quot;</span></span><br><span class="line">    @mv system.img /home/cherry/Bochs</span><br><span class="line">    @echo <span class="string">&quot;镜像已移动到Bochs根目下&quot;</span></span><br><span class="line">    @rm ckernel.o write_vga_desktop_win.o win_sheet.o mem_util.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm ckernel.o write_vga_desktop_win.o win_sheet.o mem_util.o</span><br></pre></td></tr></table></figure>
<p>其中，我将OS.java和ProcessASMFile.java结合起来，并且增加了通过Java来执行命令行的功能，使用<code>Runtime.getRuntime().exec()</code>函数实现。</p>
<p>makefile脚本中转义字符为<code>\$</code>，在要转义字符的前面加上这个符号表示转义单个字符。</p>
<p>我们将不想显示的命令前面加<code>@</code>来隐藏，然后再将我们需要操作的文件夹在虚拟机上共享。</p>
<p>最终运行效果如下：</p>
<p><img src="/ec9e8461/001.png" alt="001"></p>
<p><img src="/ec9e8461/002.png" alt="002"></p>
<p>感觉makefile脚本中all指令执行有点繁琐，总是将字节码移来移去，最好的方式是在src源代码目录下运行Java，处理asm文件，运行nasm命令，然后在根目录下生成boot, kernel二进制文件并生成system.img镜像</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>脚本</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>自旋锁</title>
    <url>/6d00129c.html</url>
    <content><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><blockquote>
<p>该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 <a href="https://github.com/CherryYang05/MultiProcessor">GitHub 仓库</a> 中查看。</p>
</blockquote>
<span id="more"></span>
<h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><p>关于自旋锁的内容，需要有以下几个方面的基础知识：基本数据结构（链表，队列）、操作系统中进程调度、锁及死锁、计算机体系结构中 cache 一致性、计算机组成原理中 cache 结构、Java 基本语法及 concurrent 包的基本用法。</p>
<h2 id="二、背景介绍"><a href="#二、背景介绍" class="headerlink" title="二、背景介绍"></a>二、背景介绍</h2><p>在如今多线程环境下对于共享临界资源的访问，需要加锁实现互斥。拿到锁的线程获得 CPU 执行临界区代码，而未拿到锁的线程通常来说有两种处理方式，一种是该线程进入循环等待，直到它等待的那个 CPU 空闲，然后获得 CPU 开始执行；另一种便是将自己阻塞，等待操作系统重新调度。</p>
<p>前一种锁叫 <code>自旋锁</code>，后一种锁叫 <code>互斥锁</code>。</p>
<!-- 实现两个线程间互斥有 `Peterson` 算法、`Bakery` 算法等，在这里暂时不做讨论，这里主要介绍自旋锁 -->
<p>先举一个很容易理解的例子。有两个进程，分别为 <code>P1</code> 和 <code>P2</code>，这两个线程做的工作都是将变量 a 加 1，就像这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果执行这两个线程各 100 次，我们预期的结果是 <code>a = 200</code>，但是实际上结果并不是我们想象的这样，它有可能是 200，但是更多的情况是一个小于 200 的数。</p>
<p>在计算机底层上，对一个数执行加一操作，编译器会将其编译成下面三条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, mem</span><br><span class="line">add ax, <span class="number">1</span></span><br><span class="line">mov mem, ax</span><br></pre></td></tr></table></figure>
<p>当多线程执行时，代码执行顺序将不可控，因此会出现一个线程还未将值写进内存的时候，其他线程就读取内存中的值，造成数据相关问题。</p>
<h2 id="三、TAS-锁与-TTAS-锁"><a href="#三、TAS-锁与-TTAS-锁" class="headerlink" title="三、TAS 锁与 TTAS 锁"></a>三、TAS 锁与 TTAS 锁</h2><h3 id="3-1-TAS-锁"><a href="#3-1-TAS-锁" class="headerlink" title="3.1 TAS 锁"></a>3.1 TAS 锁</h3><p><code>TAS(testAndSet)</code> 是一个原子操作，它的功能是将 <code>true</code> 原子地写入变量，然后获取变量之前的值，即用 <code>true</code> 来交换变量的值。</p>
<p>为什么这个操作是原子的呢？因为在 x86 汇编中有个指令叫 <code>xchg</code>，它的功能便是交换两个数。</p>
<p>在 Java 中，有个与其功能一致的函数叫 <code>getAndSet()</code>，下面是 <code>TASLock</code> 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (state.getAndSet(<span class="literal">true</span>)) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>AtomicBoolean</code> 是原子布尔类型，能够实现原子的赋值，来自 <code>java.util.concurrent.atomic.AtomicBoolean</code>。</p>
<p>这个锁通过代码很容易理解：当线程 A 获取锁时，将 <code>state</code> 置为 <code>true</code>，若线程 A 还未释放锁时，其他线程 B 若也要申请锁，便会在 <code>while (state.getAndSet(true)) &#123;&#125;</code> 空转，直到 <code>state</code> 为 <code>false</code>，然后线程 B 便可以申请到锁了。</p>
<p>我们先来看一下另一种形式的 <code>TAS</code> 锁，然后将两者进行比较。</p>
<h3 id="3-2-TTAS-锁"><a href="#3-2-TTAS-锁" class="headerlink" title="3.2 TTAS 锁"></a>3.2 TTAS 锁</h3><p>直接看具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TTAS</code> 锁并没有每次都直接调用 <code>getAndSet(boolean)</code> 方法，而是先判断 <code>state</code> 变量是否为 <code>true</code>，若为 <code>true</code> 便无需用 <code>true</code> 和原先的值进行交换。而若 <code>state</code> 变量是 <code>false</code>，则再对 <code>state</code> 执行 <code>getAndSet</code>。</p>
<p>因为这里有两次 test，因此该锁叫 <code>TTAS(testTestAndSet)</code> 锁。</p>
<p>当然从加锁的正确性来说，这两种锁是等价的，都可以保证无死锁的互斥，对于简单的情况，这两种并无明显差别。但是在多处理器上运行大量线程，这两种锁将会展现出指数级别的效率差距。</p>
<p>下面是 n 个线程分别执行一段临界区代码所需的时间图，在没有任何争用干扰的情况下，最下面的平直曲线应该是理想情况（实际上并不可能）。可以看出这三条曲线差距非常明显。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20221030211520.png" alt="n个线程执行时间图" style="zoom: 40%;"></p>
<p>上图的情况可以用多处理器的系统结构进行解释。</p>
<h3 id="3-3-比较两种锁的性能差距"><a href="#3-3-比较两种锁的性能差距" class="headerlink" title="3.3 比较两种锁的性能差距"></a>3.3 比较两种锁的性能差距</h3><p>首先我们要确定的是，现代处理器几乎都包含高速缓存（cache），cache 与内存的一致性问题是现代处理器研究的重要问题；CPU 访问内存的时间时间比访问 cache 的时间多 2～3 个数量级。</p>
<p>多处理器中的 cache 一致性问题这里不展开讲述，大致内容如下。</p>
<p>每个处理器都有一个自己的 cache，考虑以下情况：处理器 A 访问数据 <code>x</code>（假设 <code>x = a</code>），将 x 放入 <code>cache_A</code> 中，处理器 B 也想访问 <code>x</code>，而 <code>cache_B</code> 中没有对 x 的缓存，这个时候处理器 B 便会在 <code>cache_A</code> 中查找 <code>x</code>，找到之后将其放入自己的缓存中（此时 <code>x = a</code>）。这时处理器 A 修改了 <code>x</code> 的值（假设修改为 b），并更新自己的 cache，若此时处理器 B 再次访问 <code>x</code>，它首先会从自己的 cache 中找，而目前 <code>cache_B</code> 中存放了 <code>x = a</code>，但是目前最新的值是 <code>x = b</code>，产生了错误，这就是 cache 一致性问题。</p>
<p>解决 cache 一致性问题的一个解决办法便是在一个处理器更新自己的 cache 后，该处理器在总线上广播这个地址，其他处理器监听总线，如果其他处理器在自己的 cache 中发现了同样的地址，则将对应的 cache 置为无效。</p>
<p>然后我们再来分析 <code>TAS</code> 锁。</p>
<p>在 <code>TAS</code> 锁中，每个线程每次执行都将调用 <code>getAndSet</code> 方法，而这个方法需要写入变量，因此在修改变量前需要在总线上进行广播，通知其他处理器将该 cache 行置为无效。而这便会带来两种问题：一是广播占用了总线流量，当的确需要从内存中读取值时便会造成总线上的延迟；二是每次修改变量是会造成其他处理器的 cache 缺失，即其他自旋的线程每次都会遇到 cache 不命中的情况，便需要通过总线获取新的值。同时，当持有锁的线程尝试释放锁时，因为总线拥挤而不得不被迫延迟，这样的多米诺骨牌效应只会导致效率越来越低。</p>
<p>总结来说，<code>TAS</code> 锁存在着大量的总线占用，每个线程每一次自旋都会产生大量的总线流量，从而使得其他线程也必须延迟，最终造成了系统的效率急剧降低。</p>
<p>而 <code>TTAS</code> 锁中，当线程 A 持有锁时，线程 B 第一次读锁时会发生 cache 缺失，但是只要线程 A 持有锁，线程 B 便只要不断读取值，这样每次 cache 都将命中，不产生总线流量，也不会影响其他线程对总线的使用。</p>
<p>当然当持有锁的线程释放锁时，会导致所有正在自旋的线程的 cache 失效，从而导致大量总线流量，但是短暂过后所有线程将归于平静，又将回到本地自旋的状态。</p>
<h2 id="四、指数后退锁"><a href="#四、指数后退锁" class="headerlink" title="四、指数后退锁"></a>四、指数后退锁</h2><p>我们现在考虑如何改进 <code>TTAS</code> 锁的算法，这里先引出一个术语：争用，争用的意思是多个线程试图同时获得一个锁。在上面的 <code>TTAS</code> 锁中，在两个 while 循环之间可能会产生高争用现象，此时线程获得锁的几率非常小，并且还会带来极高的总线流量。我们可以考虑将某些线程推迟一段时间再去尝试获得锁，这样同时申请锁的线程将减少，实际证明这样的效果行之有效。</p>
<p>那么应该将线程退后多长时间呢？了解过计算机网络中 CSMA/CD（载波监听多路访问/碰撞检测）中的二进制指数退避应该很容易想到，这里的指数后退与其相似。线程随机在 <code>(0, limit)</code> 中后退一段时间，若还未获得锁，那么将 <code>limit</code> 加倍，再次重新在 <code>(0, limit)</code> 获取一个随机值进行后退，直到 <code>limit</code> 到达一个设定的最大值 <code>maxDelay</code>。下面是代码实现。</p>
<p><code>Backoff.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backoff</span> &#123;</span><br><span class="line">    <span class="type">int</span> minDelay, maxDelay;     <span class="comment">// 限定最大和最小时延，避免无意义的过小的后退以及无限制后退</span></span><br><span class="line">    <span class="type">int</span> limit;                  <span class="comment">// 当前的时延限制</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Backoff</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        minDelay = min;</span><br><span class="line">        maxDelay = max;</span><br><span class="line">        limit = min;</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 0 和 limit 之间随机选取一个值进行退避，然后倍乘 limit，但是不能超过 maxDelay</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backoff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> random.nextInt(limit);</span><br><span class="line">        limit = Math.max(maxDelay, limit * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BackoffLock.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackoffLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">minDelay</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxDelay</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Backoff</span> <span class="variable">backoff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Backoff</span>(minDelay, maxDelay);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                backoff.backoff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>BackoffLock</code> 的性能，与 <code>minDelay</code> 和 <code>maxDelay</code> 的值的选取密切相关，要根据实际任务及自身处理器及架构的情况合理设置阈值。</p>
<h2 id="五、队列锁"><a href="#五、队列锁" class="headerlink" title="五、队列锁"></a>五、队列锁</h2><h3 id="5-0-队列锁的介绍"><a href="#5-0-队列锁的介绍" class="headerlink" title="5.0 队列锁的介绍"></a>5.0 队列锁的介绍</h3><p>队列锁是一种易于扩展的自旋锁，尽管稍微复杂一点 <del>(亿点)</del>，但是具有更好的移植性。</p>
<p>在指数后退锁中，存在两个问题。</p>
<ul>
<li>一是所有线程获得锁都依赖于同一个变量 <code>state</code>，因此每个线程都在同一个共享存储单元上自旋，每一次成功的锁访问都会带来 cache 一致性流量（尽管相比之下比 TASLock 低）；</li>
<li>二是临界区利用率低，因为很多线程被“后退”了，因此延迟带来的开销是无法忽略的。</li>
</ul>
<p>可以将这些线程组织成一个链表（队列）来解决这些问题，在队列中，每个线程只要检测前一个线程是否已经完成来判断自己能否成功获取锁，这样每个线程就在不同存储单元上自旋了，也不会有延迟带来的开销。</p>
<p>下面介绍三种队列锁，基于数组的队列锁，CLH 队列锁和 MCS 队列锁。</p>
<h3 id="5-1-基于数组的队列锁"><a href="#5-1-基于数组的队列锁" class="headerlink" title="5.1 基于数组的队列锁"></a>5.1 基于数组的队列锁</h3><p>基于数组的队列锁 ALock，其有一个 tail 字段，初始值为 0，它被所有的线程共享，用来表示数组的下标。每个线程原子地增加 tail 字段的值，每个线程还有一个局部变量用来保存这个当前的 tail 值，称为 slot（槽）。如果 flag[j] 为 true，那么表示下标为 j 的线程有权获得锁。</p>
<p>初始状态时，flag 数组只有下标为 0 的那个值为 true，其他均为 false。其他线程调用 lock() 方法尝试获得锁时，会不断地在 <code>flag[slot]</code> 上旋转，直到 <code>flag[slot] == true</code>。在释放锁时，线程将对应于它自己的槽点 flag 设为 false，然后将下一个槽的 slot 设为 true。上述所有操作都要对 n 取模，n 的大小至少为最大的并发线程数。</p>
<p>下面用具体例子来说明基于数组的队列锁。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/239b8e7f91620c96909e40c1792ae9e6.png" alt="基于数组的自旋锁"></p>
<p>上图的 a) 中，当前获得锁的线程是 A，<code>flag[2] == true</code>，线程 B 和 C 也尝试获得锁，线程 B 和 C 在 flag[3] 和 flag[4] 上自旋等待。当线程 A 释放锁后，flag[2] 设置为 false，flag[3] 设置为 true，线程 B 获得锁。</p>
<p><code>ALock.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ALock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mySLotIndex 是线程的局部变量，线程局部变量无需保存在共享存储器中，无需同步，不产生一致性流量</span></span><br><span class="line">    ThreadLocal&lt;Integer&gt; mySlotIndex = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    AtomicInteger tail;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span>[] flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ALock</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        size = capacity;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[capacity];</span><br><span class="line">        <span class="comment">// 为了避免假共享现象，可以将数组开大，让每一个项独占一个 cache 行</span></span><br><span class="line">        <span class="comment">// flag = new boolean[capacity * 4];</span></span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> tail.getAndIncrement() % size;</span><br><span class="line">        mySlotIndex.set(slot);</span><br><span class="line">        <span class="keyword">while</span> (!flag[slot]) &#123;&#125;;     <span class="comment">// 当前域为 false 则表明锁被占用，陷入空转等待</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> mySlotIndex.get();</span><br><span class="line">        flag[slot] = <span class="literal">false</span>;</span><br><span class="line">        flag[(slot + <span class="number">1</span>) % size] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基于数组的队列锁中，mySlotIndex 是线程的局部变量，局部变量不需要与其他线程共享，不需要同步，也就不会产生一致性流量，因为它只能被一个线程访问。尽管 flag 数组是被多个线程共享的，但是在任意特定的时刻，线程对应的 flag 存储单元会被存放在对应的 cache 中，线程是在本地 cache 中旋转，大大降低了无效流量，从而使得对数组的存储单元的争用大大降低。</p>
<p>但是值得注意的是，争用仍然可能发生，因为存在一种“假共享”现象，当相邻的数组元素在同一个 cache 行时，就会发生这样的现象。继续看上面的图 a)，假设一个 cache 行能够存放 4 个数组元素，那么 flag[0] ~ flag[3] 都将存放在同一个 cache 行中。当某一个线程对 cache 行执行写操作时，会导致当前 cache 行无效，从而导致其他在该 cache 旋转的线程产生无效流量。</p>
<p>一种解决办法就是上图中的 b)，于是我们将数组进行填，充让一个 cache 行只存放一个数组元素，具体实现上只需要将 <code>(i + 1) % 8</code> 改成 <code>4 * (i + 1) % 32</code> 即可。</p>
<h3 id="5-2-CLH-队列锁"><a href="#5-2-CLH-队列锁" class="headerlink" title="5.2 CLH 队列锁"></a>5.2 CLH 队列锁</h3><h3 id="5-3-MCS-队列锁"><a href="#5-3-MCS-队列锁" class="headerlink" title="5.3 MCS 队列锁"></a>5.3 MCS 队列锁</h3>]]></content>
      <categories>
        <category>计算机原理知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发多核</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构课程笔记（一）</title>
    <url>/bc5a2705.html</url>
    <content><![CDATA[<blockquote>
<p>本系列笔记来自于国防科技大学的计算机体系结构课程<br>作者：Cherry<br>时间：2022.1</p>
</blockquote>
<span id="more"></span>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote>
<p>国防科大计算机体系结构课程第一至三章笔记</p>
</blockquote>
<h2 id="1-1-计算机体系结构的概念与发展"><a href="#1-1-计算机体系结构的概念与发展" class="headerlink" title="1.1 计算机体系结构的概念与发展"></a>1.1 计算机体系结构的概念与发展</h2><p><strong>冯诺依曼结构：</strong><br>运算器（核心）、存储器、输入/输出设备、控制器</p>
<p><strong>程序执行的过程</strong></p>
<ul>
<li>分解程序指令，形成控制四个部分工作的控制流</li>
<li>对数据进行加工（运算），形成数据流</li>
<li>周而复始地产生指令流 / 数据流</li>
<li>并最终得到结果</li>
</ul>
<p><strong>一个机器周期里面安排的操作序列</strong></p>
<ol>
<li>计算机从存储器中取出一条指令</li>
<li>对这条指令进行译码</li>
</ol>
<ul>
<li>分解并确定这条指令所指示的操作</li>
<li>确定操作对象（操作数）所在的位置</li>
<li>某个寄存器单元、存储器单元或者输入设备</li>
</ul>
<ol>
<li>取操作数并送到运算器</li>
<li>运算器按照译码确定的操作进行运算</li>
<li>运算结束后，将结果送到指定的位置</li>
</ol>
<ul>
<li>计算机准备执行下一条指令</li>
</ul>
<p>阿姆道尔（C. M. Amdahl）首次明确</p>
<ul>
<li>计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性</li>
<li>1964 年 4 月， Architecture of the IBM System/360 ，发表在 IBM Journal of Research and Development 上</li>
<li>计算机体系结构概念的经典定义</li>
</ul>
<p><strong>程序员所看到的计算机的属性</strong></p>
<ul>
<li>对于通用寄存器型机器，这些属性主要是指<br>（1）数据表示：硬件能直接辨认和处理的数据类型<br>（2）寻址规则：最小寻址单元、寻址方式及其表示<br>（3）寄存器定义：寄存器的定义、数量和使用方式<br>（4）指令系统：机器指令的操作类型和格式、指令间的排序和控制机构等<br>（5）中断系统：中断的类型和中断响应硬件的功能等<br>（6）机器工作状态的定义和切换：如管态和目态等<br>（7）存储系统：程序员可用的最大存储容量<br>（8）信息保护：信息保护方式和硬件的支持<br>（9）I/O 结构：I/O 寻址方式、数据传送的方式等</li>
</ul>
<p><strong>计算机组成关注的问题：</strong></p>
<p>指令集结构的逻辑实现</p>
<ul>
<li>数据通路宽度</li>
<li>各种操作对功能部件的共享程度</li>
<li>专用功能部件的设置</li>
<li>功能部件的并行性</li>
<li>缓冲和排队技术</li>
<li>预测技术</li>
<li>可靠性技术</li>
<li>控制机构的组成，等等</li>
</ul>
<p>计算机的实现</p>
<ul>
<li>处理器、主存的物理结构</li>
<li>器件的集成度和速度</li>
<li>信号传输</li>
<li>器件、模块、插件、底板的划分与连接</li>
<li>涉及的专用器件</li>
<li>电源、冷却</li>
<li>微组装技术</li>
<li>整机装配技术，等等</li>
</ul>
<p><strong>不同年代计算机体系结构研究内容的变化：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>年代</th>
<th>研究内容</th>
<th>典型计算机</th>
</tr>
</thead>
<tbody>
<tr>
<td>1940s</td>
<td>程序控制计算机、存储程序计算机</td>
<td>ENIAC、EDVAC</td>
</tr>
<tr>
<td>1950s</td>
<td>指令系统</td>
<td>IBM 360 系列机</td>
</tr>
<tr>
<td>1960s</td>
<td>阵列机和并行处理</td>
<td>ILLIAC IV</td>
</tr>
<tr>
<td>1970s</td>
<td>流水线、向量处理、微处理器</td>
<td>Cray-1、Intel 4004</td>
</tr>
<tr>
<td>1980s</td>
<td>RISC、cache、流水线</td>
<td>MIPS R1000、Power</td>
</tr>
<tr>
<td>1990s</td>
<td>SMP、CMP、指令级并行</td>
<td>MIPS R100000、PowerPC 604</td>
</tr>
<tr>
<td>2000 年以来</td>
<td>SMT、功耗、Multi-core，Stream</td>
<td>Intel i7、Power 6、ARM、GPU</td>
</tr>
</tbody>
</table>
</div>
<p>同一个功能用硬件和软件实现是等效的，但是效率不同。</p>
<p><strong>计算机系统中的多语言层次结构：</strong></p>
<p>第一级：微程序机器级</p>
<ul>
<li>微程序机器级的机器语言是微指令集</li>
<li>程序员用微指令编写的微程序一般是直接由硬件解释实现的</li>
</ul>
<p>第二级：传统机器级</p>
<ul>
<li>传统机器级的语言是该机的指令集</li>
<li>机器指令程序可以由微程序进行解释(仿真)，可有多个解释程序通过仿真，实现多种指令集</li>
<li>可以没有微程序机器级</li>
</ul>
<p>第三级：操作系统虚拟机</p>
<ul>
<li>直接管理传统机器中的软硬件资源</li>
<li>是传统机器的引伸</li>
<li>提供了传统机器所没有的某些基本操作和数据结构<ul>
<li>文件系统</li>
<li>虚拟存储系统</li>
<li>多道程序系统</li>
<li>多线程管理等</li>
</ul>
</li>
</ul>
<p>第四级：汇编语言虚拟机</p>
<ul>
<li>用汇编语言编写的程序，首先翻译或解释成第 3 级和第 2 级语言，然后再由相应的机器执行</li>
<li>完成汇编语言翻译的程序就叫做汇编程序，又叫汇编器</li>
</ul>
<p>第五级：高级语言虚拟机</p>
<ul>
<li>机器语言就是各种高级语言</li>
<li>用这些语言所编写的程序一般是由称为编译程序翻译到第４级或第 3 级上</li>
<li>也有用解释的方法实现转化</li>
</ul>
<p>第六级：应用语言虚拟机</p>
<ul>
<li>为使计算机满足某种用途而专门设计的（人工智能、教育、行政管理、计算机设计）</li>
<li>应用语言编写的程序一般是由应用程序包翻译到第 5 级上</li>
</ul>
<p><strong>翻译和解释：</strong></p>
<p>翻译（Translation）：<br>先把 N+1 级程序全部变换成 N 级程序后，再去执行新产生的 N 级程序，在执行过程中 N+1 级程序不再被访问</p>
<p>解释（Interpretation）：<br>每当一条 N+1 级指令被译码后，就直接去执行一串等效的 N 级指令，然后再去取下一条 N+1 级的指令，依此重复进行</p>
<p>一般来说，解释执行比翻译花的时间多，但存储空间较少。</p>
<h3 id="1-1-4-系列机和兼容"><a href="#1-1-4-系列机和兼容" class="headerlink" title="1.1.4 系列机和兼容"></a>1.1.4 系列机和兼容</h3><ul>
<li>系列机（family machine）是具有相同体系结构，但组成和实现不同的一系列不同型号的计算机系统<ul>
<li>IBM 公司在推出 IBM S360 时首次提出的系列机的概念，被认为是计算机发展史上一个重要里程碑</li>
<li>各计算机厂家仍按系列机研发产品</li>
</ul>
</li>
<li>现代计算机不但系统系列化，其构成部件和软件也系列化<ul>
<li>如微处理器（ CPU ）、硬盘、操作系统、高级语言等</li>
</ul>
</li>
</ul>
<p><strong>兼容性</strong></p>
<ul>
<li>向上 (下) 兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器</li>
<li>向前(后)兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前 (后) 投入市场的机器</li>
</ul>
<p><strong>兼容对体系结构的影响</strong></p>
<p>计算机系统及软件设计者的“障碍”：</p>
<ul>
<li>系统软件的开发难度大</li>
<li>需要保护巨大的应用软件宝库</li>
</ul>
<p>向后兼容是才是软件兼容的根本特征，也是系列机的根本特征</p>
<ul>
<li>为了保证软件的兼容，要求指令集不改变，这无疑又妨碍计算机体系结构的发展</li>
<li>向后兼容虽然削弱了系列机对体系结构发展的约束，但仍然是体系结发展的沉重包袱</li>
<li>20 世纪 80 年代具有 RISC 体系结构的微处理器在新结构、新技术应用等方面领先传统的 CISC 微处理器的主要原因之一</li>
</ul>
<h2 id="1-2-计算机体系结构的发展"><a href="#1-2-计算机体系结构的发展" class="headerlink" title="1.2 计算机体系结构的发展"></a>1.2 计算机体系结构的发展</h2><p><img src="/bc5a2705/计算机体系结构的发展历史.png" alt="计算机体系结构的发展历史"></p>
<p><strong>并行技术的发展：</strong><br>概念：</p>
<ol>
<li>指令集并行</li>
<li>线程级并行</li>
<li>任务级/过程级并行</li>
</ol>
<p>提高并行性的技术途径：</p>
<ol>
<li>时间重叠</li>
<li>资源重复</li>
<li>资源共享（提高资源的使用效率，如打印机）</li>
</ol>
<p>并行计算的应用需求</p>
<p><strong>计算机的成本构成：</strong></p>
<ol>
<li>处理器板：37%</li>
<li>I/O 设备：37%</li>
<li>附件：6%</li>
<li>软件：20%</li>
</ol>
<p>目前，设计者需要取得性能与成本之间的平衡</p>
<p><strong>摩尔定律</strong><br>1965 年，时任仙童公司研发实验室主任的摩尔（Gordon Mooer）在《Electronics》上撰文，认为集成电路密度大约每两年翻一番，大约成指数级增长。<br>40 年来，摩尔定律不但印证了集成电路技术的发展，也印证了计算机技术的发展。</p>
<h2 id="1-3-计算机系统设计和分析"><a href="#1-3-计算机系统设计和分析" class="headerlink" title="1.3 计算机系统设计和分析"></a>1.3 计算机系统设计和分析</h2><p>装机部件的成本的 50% 左右在显示部件上，即显示器和显卡。<br>成本——时间因素：学习曲线</p>
<ul>
<li>产品价格随着时间下降的趋势</li>
</ul>
<h3 id="1-3-2-基准测试程序"><a href="#1-3-2-基准测试程序" class="headerlink" title="1.3.2 基准测试程序"></a>1.3.2 基准测试程序</h3><p>五类测试程序</p>
<ul>
<li>真实程序</li>
<li>修正的（或者脚本化）应用程序</li>
<li>核心程序</li>
<li>小测试程序</li>
<li>合成测试程序(将多个程序的核心部分提取出来)</li>
</ul>
<p>测试程序包：选择一组各个方面有代表性的测试程序组成<br>如：<code>www.SPEC.org</code></p>
<ul>
<li>基于 NUIX ，诞生于 20 世纪 80 年代</li>
<li>由真实程序和核心程序构成</li>
<li>采用 C 和 Fortran 两种语言，后增加 C++</li>
<li>包括整数部分 SPECint 和浮点部分 SPECfp</li>
<li>主要版本包括 SPEC89 、 SPEC92 、 SPEC95 、 SPEC2000 和 SPEC2006 等<ul>
<li>SECP2006 功能进一步细化<ul>
<li>台式计测试： SPEC CPU2000</li>
<li>图像测试： SPECviewperf, SPECapc</li>
<li>NFS 性能测试： SPECSFS</li>
<li>Web 服务测试： SPECWeb</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-3-量化设计的基本原则"><a href="#1-3-3-量化设计的基本原则" class="headerlink" title="1.3.3 量化设计的基本原则"></a>1.3.3 量化设计的基本原则</h3><ol>
<li>大概率事件优先原则</li>
</ol>
<ul>
<li>追求全局的最优结果</li>
</ul>
<ol>
<li>Amdahl 定律</li>
</ol>
<ul>
<li>系统性能加速比，受限于该部件在系统中所占的重要性</li>
<li>可以定量计算</li>
</ul>
<ol>
<li>程序的局部性原理</li>
</ol>
<ul>
<li>程序执行时所访问存储器在时-空上是相对地簇聚</li>
<li>这种簇聚包括指令和数据两部分</li>
</ul>
<p><strong>大概率事件优先原则</strong></p>
<ul>
<li>对于大概率事件（常见的事件）赋予优先的处理权和资源使用权，以获得全局的最优结果</li>
<li>要能确定什么是大概率事件，同时要说明针对该事件进行的改进将如何提高机器的性能</li>
<li>“好钢用在刀刃上”，事半功倍</li>
</ul>
<p><strong>Amdahl 定律</strong></p>
<ul>
<li><script type="math/tex; mode=display">系统加速比=\dfrac{系统性能_{改进后}}{系统性能_{改进前}}=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}</script></li>
<li>核心概念：时间</li>
<li>系统加速比依赖于两个因素<ul>
<li>“可改进比例”：可改进部分在原系统计算时间中所占的比例 ，它总是小于等于 1 的</li>
<li>“部件加速比”：可改进部分改进以后的性能提高，一般情况下它是大于 1 的</li>
</ul>
</li>
<li>Amdahl的系统执行时间：<script type="math/tex; mode=display">=(1-可改进比例)×总执行时间_{改进前}+\dfrac{可改进比例}{部件加速比}×总执行时间_{改进前}</script><script type="math/tex; mode=display">=总执行时间_{改进前}×(1-可改进比例+\dfrac{可改进比例}{部件加速比})</script></li>
<li>则Amdahl的系统加速比<script type="math/tex; mode=display">=\dfrac{总执行时间_{改进前}}{总执行时间_{改进后}}</script><script type="math/tex; mode=display">=\dfrac{1}{(1-可改进比例)+\dfrac{可改进比例}{部件加速比}}</script></li>
<li>Amdahl定律的观点<ul>
<li>性能增加的递减规则<ul>
<li>仅仅对计算机中的一部分做性能改进，则改进的越多，系统获得的效果越小</li>
</ul>
</li>
<li>Amdahl 定律的一个重要推论<ul>
<li>针对整个任务的一部分进行优化，则最大加速比不大于<script type="math/tex">\frac{1}{1-可改进比例}</script></li>
<li>通俗的说，系统的性能是由他不可加速的部分的性能决定</li>
<li>Amdahl 定律衡量一个“好”的计算机系统<ul>
<li>具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>程序局部性</strong></p>
<ul>
<li>程序访问地址的分布不是随机的，而是相对地簇聚<ul>
<li>包括时间局部性和程序的空间局部性</li>
</ul>
</li>
<li>程序的时间局部性<ul>
<li>程序即将用到的信息很可能就是目前正在使用的信息</li>
</ul>
</li>
<li>程序的空间局部性<ul>
<li>程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近</li>
</ul>
</li>
<li>其他局部性<ul>
<li>生产 - 消费局部性</li>
</ul>
</li>
</ul>
<h3 id="1-3-5-CPU-性能"><a href="#1-3-5-CPU-性能" class="headerlink" title="1.3.5 CPU 性能"></a>1.3.5 CPU 性能</h3><ul>
<li>程序执行过程中所处理的指令数，记为 IC</li>
<li>每条指令执行所需要的时钟周期数 CPI(Cycles Per Instruction)</li>
<li>每条指令执行所需要的平均时钟周期数 CPI = CLK / IC</li>
</ul>
<h4 id="CPU-性能公式"><a href="#CPU-性能公式" class="headerlink" title="CPU 性能公式"></a>CPU 性能公式</h4><p>例子见 PPT</p>
<h1 id="第二章-指令系统"><a href="#第二章-指令系统" class="headerlink" title="第二章 指令系统"></a>第二章 指令系统</h1><p><strong>大纲</strong></p>
<ul>
<li>指令集结构概述</li>
<li>指令集结构的分类        </li>
<li>寻址方式</li>
<li>指令系统的设计和优化</li>
<li>指令系统的发展和改进    </li>
<li>操作数的类型和大小</li>
<li>MIPS指令系统结构    </li>
<li>指令集结构概述</li>
<li>指令集结构的分类</li>
</ul>
<hr>
<h2 id="2-1-指令集结构和设计技术"><a href="#2-1-指令集结构和设计技术" class="headerlink" title="2.1 指令集结构和设计技术"></a>2.1 指令集结构和设计技术</h2><h3 id="1-指令集结构概述"><a href="#1-指令集结构概述" class="headerlink" title="1. 指令集结构概述"></a>1. 指令集结构概述</h3><h3 id="2-指令集结构的分类"><a href="#2-指令集结构的分类" class="headerlink" title="2. 指令集结构的分类"></a>2. 指令集结构的分类</h3><ul>
<li><p>一般来说，可以从如下五个因素考虑对计算机指令集结构进行分类，即：</p>
<ul>
<li>在CPU中操作数的存储方法；</li>
<li>指令中显式表示的操作数个数；</li>
<li>操作数的寻址方式；</li>
<li>指令集所提供的操作类型；</li>
<li>操作数的类型和大小。</li>
</ul>
</li>
<li><p>CPU中用来存储操作数的存储单元主要有：</p>
<ul>
<li>堆栈；</li>
<li>累加器；</li>
<li>一组寄存器。</li>
</ul>
</li>
</ul>
<p> 指令中的操作数可以被明确地显式给出，也可以按照某种约定隐式地给出。</p>
<p><strong>通用寄存器型指令集结构的分类</strong></p>
<ul>
<li><p>通用寄存器型指令集结构的主要优点:</p>
<ul>
<li>在表达式求值方面，比其它类型指令集结构都具有更大的灵活性；</li>
<li>寄存器可以用来存放变量；<ul>
<li>减少存储器的通信量，加快程序的执行速度（因为寄存器比存储器快）</li>
<li>可以用更少的地址位来寻址寄存器，从而可以有效改进程序的目标代码大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>两种主要的指令特性能够将通用寄存器型指令集结构（GPR）进一步细分。</p>
<ul>
<li>ALU指令到底有两个或是三个操作数？</li>
<li>在ALU指令中，有多少个操作数可以用存储器来寻址，也即有多少个存储器操作数？</li>
</ul>
</li>
<li>可以将当前大多数通用寄存器型指令集结构进一步细分为三种类型：<ul>
<li>寄存器－寄存器型(R－R：register-register)</li>
<li>寄存器－存储器型(R－M：register-memory)</li>
<li>存储器－存储器型(M－M：memory-memory)</li>
</ul>
</li>
</ul>
<p>三种通用寄存器型指令集结构的优缺点</p>
<ul>
<li>寄存器－寄存器型（0,3）<ul>
<li>优点：<ul>
<li>指令字长固定，指令结构简洁，是一种简单的代码生成模型，各种指令的执行时钟周期数相近。</li>
</ul>
</li>
<li>缺点：<ul>
<li>与指令中含存储器操作数的指令系统结构相比，指令条数多，目标代码不够紧凑，因而程序占用的空间比较大。</li>
</ul>
</li>
</ul>
</li>
<li>寄存器－存储器型（1,2）<ul>
<li>优点：<ul>
<li>可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能<em>限制指令所能够表示的寄存器个数</em>。指令的执行时钟周期因操作数的来源（寄存器或存储器）的不同而差别比较大。</li>
</ul>
</li>
</ul>
</li>
<li>存储器－存储器型（3,3）<ul>
<li>优点：<ul>
<li>目标代码最紧凑，不需要设置存储器来保存变量。</li>
</ul>
</li>
<li>缺点：<ul>
<li>指令字长变换很大，特别是3个操作数指令。而且每条指令完成的工作也差别很大。对存储器的频率访问会使存储器成为瓶颈。这种类型的指令系统现在已经不用了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-指令集结构和MIPS指令集"><a href="#2-2-指令集结构和MIPS指令集" class="headerlink" title="2.2 指令集结构和MIPS指令集"></a>2.2 指令集结构和MIPS指令集</h2><h3 id="3-寻址技术"><a href="#3-寻址技术" class="headerlink" title="3. 寻址技术"></a>3. 寻址技术</h3><ul>
<li>在通用寄存器型指令集结构中，一般是利用寻址方式指明指令中的操作数是一个常数、一个寄存器操作数，抑或是一个存储器操作数。</li>
<li>寻址实际上是从形式地址到实际地址的转换。形式地址由指令描述，实际地址也称为有效地址。</li>
<li>有效地址指明的是存储器单元的地址或寄存器地址。</li>
<li>必须加速有效地址生成。</li>
</ul>
<p>常用的一些操作数寻址方式：</p>
<ul>
<li>寄存器寻址</li>
<li>立即值寻址</li>
<li>偏移寻址</li>
<li>寄存器间接寻址</li>
<li>索引寻址</li>
<li>直接寻址或绝对寻址</li>
<li>存储器间接寻址</li>
<li>自增寻址（串操作，先寻址再加）</li>
<li>自减寻址（先减再寻址）</li>
<li>缩放寻址<ul>
<li>指令实例： Add R1, 100(R2)[R3]</li>
<li>含义：Regs[R1]←Regs[R1]+Mem[100+Regs[R2]+Regs[R3]*d]</li>
</ul>
</li>
</ul>
<h3 id="4-指令系统的设计和优化"><a href="#4-指令系统的设计和优化" class="headerlink" title="4. 指令系统的设计和优化"></a>4. 指令系统的设计和优化</h3><p>一种指令集结构中的指令到底要支持哪些类型的操作呢？这就是所谓的指令集结构功能设计问题。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术和逻辑运算</td>
<td>整数的算术和逻辑操作：加、减、与、或等</td>
</tr>
<tr>
<td>数据传输</td>
<td>Load/Store</td>
</tr>
<tr>
<td>控制</td>
<td>分支、跳转、过程调用和返回、自陷等</td>
</tr>
<tr>
<td>系统</td>
<td>操作系统调用、虚拟存储器管理等</td>
</tr>
<tr>
<td>浮点</td>
<td>浮点操作：加、乘等</td>
</tr>
<tr>
<td>十进制</td>
<td>十进制加、十进制乘、十进制到字符的转换</td>
</tr>
<tr>
<td>字符串</td>
<td>字符串移动、字符串比较、字符串搜索等</td>
</tr>
<tr>
<td>图形</td>
<td>像素操作、压缩/解压操作等</td>
</tr>
</tbody>
</table>
</div>
<p>控制指令</p>
<ul>
<li>跳转” （Jump）：当控制指令为无条件改变控制流时，我们称之为“跳转” 。</li>
<li>“分支” （Branch）：而当控制指令是有条件改变控制流时，我们称之为“分支” 。</li>
<li>控制流程的改变情况：<ul>
<li>条件分支（conditional branch）；</li>
<li>跳转（jump）；</li>
<li>过程调用（call）；</li>
<li>过程返回（return）。</li>
</ul>
</li>
<li>控制指令主要使用在条件分支上</li>
</ul>
<p>条件分支指令的表示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分支条件表示</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件码（CC）在程序的控制下，由ALU操作设置特殊的位</td>
<td>可以自由设置分支条件</td>
<td>必须从一条指令将分支条件信息传送到分支指令，所以CC是额外状态，条件码限制了指令执行顺序</td>
</tr>
<tr>
<td>条件寄存器：根据比较结果测试条件寄存器</td>
<td>简单</td>
<td>占用了一个寄存器</td>
</tr>
<tr>
<td>比较分支：比较操作是分支指令的一部分，比较受限制</td>
<td>一条指令完成了两条指令的功能</td>
<td>分支指令的操作增多(串行)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>过程调用和返回的状态保存</strong></p>
<ul>
<li>调用者保存” （caller saving）方法：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器，以备调用结束返回后，能够再次访问调用者。</li>
<li>“被调用者保存” （callee saving）方法：如果采用被调用者保存策略，那么被调用的过程必须保存它要用的寄存器，保证不会破坏过程调用者的程序执行环境，并在过程调用结束返回时，恢复这些寄存器的内容。</li>
</ul>
<h3 id="5-指令系统的发展和改进"><a href="#5-指令系统的发展和改进" class="headerlink" title="5. 指令系统的发展和改进"></a>5. 指令系统的发展和改进</h3><ul>
<li>一个方向是强化指令功能，实现软件功能向硬件功能转移，基于这种指令集结构而设计实现的计算机系统称为复杂指令集计算机（CISC）。</li>
<li>八十年代发展起来的精简指令集计算机（RISC），其目的是尽可能地降低指令集结构的复杂性，以达到简化实现，提高性能的目的。</li>
</ul>
<p><strong>CISC指令集功能设计</strong></p>
<ul>
<li>面向目标程序增强指令功能<ul>
<li>提高运算型指令功能；</li>
<li>提高传送指令功能；</li>
<li>增加程序控制指令功能。</li>
</ul>
</li>
<li>面向高级语言和编译程序改进指令系统<ul>
<li>增加对高级语言和编译系统支持的指令功能；</li>
<li>高级语言计算机指令系统。</li>
</ul>
</li>
<li>面向操作系统的优化实现改进指令系统<ul>
<li>主要表现在对中断处理、进程管理、存储管理和保护、系统工作状态的建立与切换等的支持。</li>
<li>可以设置支持系统工作状态和访问方式转移的指令、支持进程转移的指令、支持进程同步和互斥的指令等措施，达到优化实现操作系统的目的。</li>
</ul>
</li>
</ul>
<p><strong>RISC指令集功能设计</strong></p>
<ul>
<li>CISC结构存在着如下缺点：<ul>
<li>在CISC结构的指令系统中，各种指令的使用频率相差悬殊。据统计，<code>有20％的指令使用频率最大，占运行时间的80％</code>。也就是说，<code>有80％的指令在20％的运行时间内才会用到</code>。</li>
<li>CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误。</li>
</ul>
</li>
<li>CISC结构指令系统的复杂性给VLSI设计增加了很大负担，不利于单片集成。</li>
<li>CISC结构的指令系统中，许多复杂指令需要很复杂的操作，因而运行速度慢。</li>
<li>在CISC结构的指令系统中，由于各条指令的功能不均衡性，不利于采用先进的计算机体系结构技术（如流水技术）来提高系统的性能。</li>
</ul>
<p><strong>注：x86 从奔腾4开始，内部已经实现 RISC 化</strong></p>
<p><img src="/bc5a2705/RISC指令集功能设计.png" alt="RISC指令执行频率"></p>
<p><strong>RISC指令集功能设计原则</strong></p>
<ul>
<li>选取使用频率最高的指令，并补充一些最有用的指令；</li>
<li>每条指令的功能应尽可能简单，并在一个机器周期内完成；</li>
<li>所有指令长度均相同；</li>
<li>只有load和store操作指令才访问存储器，其它指令操作均在寄存器之间进行；</li>
<li>以简单有效的方式支持高级语言。</li>
</ul>
<h3 id="6-操作数的类型和大小"><a href="#6-操作数的类型和大小" class="headerlink" title="6. 操作数的类型和大小"></a>6. 操作数的类型和大小</h3><ul>
<li>操作数类型和操作数表示也是软硬件主要界面之一。</li>
<li>操作数类型是面向应用、面向软件系统所处理的各种数据结构。</li>
<li>操作数表示是硬件结构能够识别、指令系统可以直接调用的那些结构。</li>
<li>操作数表示所表征的那些操作数类型，是应用软件和系统软件所处理的操作数类型的子集。</li>
<li>确定操作数表示实际上也是软硬件取舍折衷的问题<ul>
<li>计算机即使只具有最简单的操作数表示，如只有整数（定点）表示法，也可以通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率。</li>
<li>如果各种复杂的操作数类型均包含在操作数表示之中，无疑会大大提高系统的效率，但是所花费的硬件代价也很高。</li>
</ul>
</li>
</ul>
<h3 id="7-MIPS指令系统结构"><a href="#7-MIPS指令系统结构" class="headerlink" title="7. MIPS指令系统结构"></a>7. MIPS指令系统结构</h3><ul>
<li>Load/Store型指令集结构；</li>
<li>MIPS是一种多元指令集结构；</li>
<li>具有一个简单的Load/Store指令集；</li>
<li>注重指令流水效率；</li>
<li>简化指令的译码；</li>
<li>高效支持编译器。</li>
</ul>
<p><strong>MIPS指令集结构：寄存器</strong></p>
<ul>
<li>32个32位通用寄存器（GRPs）<ul>
<li>寄存器R0的内容恒为0</li>
</ul>
</li>
<li>32个32位浮点寄存器（FPRs）<ul>
<li>单精度浮点数表示和双精度浮点表示</li>
</ul>
</li>
</ul>
<p><strong>MIPS指令集结构：数据类型</strong></p>
<ul>
<li>整型数据：<ul>
<li>8位、 16位、 32位。</li>
</ul>
</li>
<li>浮点数据：<ul>
<li>32位单精度浮点；</li>
<li>64位双精度浮点；</li>
<li>IEEE 754标准。</li>
</ul>
</li>
</ul>
<p><strong>MIPS指令集结构：寻址方式</strong></p>
<ul>
<li>寄存器寻址；如ADD R1,R2,R3</li>
<li>立即值寻址；如ADD R1,R2,#42</li>
<li>偏移寻址； 如ADD R1,R2,40(R3)</li>
<li>寄存器间接寻址。存储器地址宽度为32位。如ADD R1,R2,0(R3)</li>
</ul>
<p><strong>MIPS指令集结构：指令格式</strong></p>
<ul>
<li>I类型指令</li>
<li>R类型指令</li>
<li>J类型指令</li>
</ul>
<p><strong>MPIS指令集结构：操作类型</strong></p>
<ul>
<li>Load和Store操作；</li>
<li>ALU操作；</li>
<li>分支和跳转操作；</li>
<li>浮点操作；</li>
<li>符号<code>&lt;-</code> 表示数据传送操作，其后附带一个下标n，也即 <code>&lt;-n</code> 表示传送一个n位数据。</li>
<li>符号 <code>##</code> 用来表示两个域的串联操作，它可以出现在数据传送操作的任何一边。</li>
<li>域的下标用来表明从该域中选择某一位。域中位的标记是从最高位开始标记，并且起始标记为0。下标可以是一个单独的数字，也可以是一个范围；</li>
<li>上标表示复制一个域，如$0^{24}$可以得到一个24位全为0的一个域。</li>
<li>变量Mem用来表示存储器中的一个数组，存储器按照字节寻址，它可以传送任何数目的字节。</li>
</ul>
<p><img src="/bc5a2705/MIPS指令集结构.png" alt="MIPS指令集"></p>
<ul>
<li>Load和Store操作：可以对MIPS的所有通用寄存器和浮点寄存器进行Load（载入）和Store（储存）操作， 但是对通用寄存器R0的Load操作没有任何效果。</li>
</ul>
<p><img src="/bc5a2705/MIPS指令举例.png" alt="MIPS指令举例"></p>
<ul>
<li>ALU操作：在MIPS中，所有的ALU指令都是寄存器－寄存器型指令，其运算包含了简单的算术和逻辑运算，如加、减、AND、OR、XOR和移位。</li>
<li>“设置相等”、“设置不等”“设置小于”:寄存器比较指令</li>
<li>描述目标地址的方法：<ul>
<li>其中两种类型的跳转指令用带符号位的26位偏移量加上程序计数器的值来确定跳转的目标地址；</li>
<li>另外两种类型的跳转指令则指定一个寄存器，由寄存器中的内容决定跳转的目标地址。</li>
</ul>
</li>
<li>两种跳转类型：<ul>
<li>一种是简单跳转；</li>
<li>另一种是跳转并链接（用于过程调用），它将下一条顺序指令地址（返回地址）保存在寄存器R31中。</li>
</ul>
</li>
</ul>
<p><img src="/bc5a2705/MIPS跳转指令.png" alt="MIPS跳转指令"></p>
<ul>
<li>浮点操作：浮点指令的操作数来源于浮点寄存器，同时它还指明了相应的操作是单精度<br>浮点操作还是双精度浮点操作。<ul>
<li>后缀D代表双精度浮点操作；</li>
<li>而后缀F代表单精度浮点操作（如： ADDD、ADDF、 SUBD、 SUBF、 MULTD、 MULTF、DIVD、 DIVF）。</li>
</ul>
</li>
<li>MIPS的浮点操作有：加、减、乘、除。</li>
</ul>
<p><strong>MIPS的效能分析</strong></p>
<ul>
<li>问题的提出：<ul>
<li>MIPS指令集结构的指令格式、寻址方式和操作都非常简单。也许有人会担心，这些特性会使得目标代码中指令条数增多，导致程序运行时间加长，从而使这种指令集结构的机器性能并不会太高。</li>
</ul>
</li>
</ul>
<h1 id="第三章-流水线技术"><a href="#第三章-流水线技术" class="headerlink" title="第三章 流水线技术"></a>第三章 流水线技术</h1><h2 id="3-1-流水线基本概念"><a href="#3-1-流水线基本概念" class="headerlink" title="3.1 流水线基本概念"></a>3.1 流水线基本概念</h2><p><strong>流水技术</strong><br>将一重复的时序过程分解为若干子过程，每个子过程都可以有效地在其专用功能段上与其它子过程同时执行，这种技术成为流水技术。</p>
<p><strong>时空图</strong><br>从时间和空间两个方面描述流水线的工作过程，横坐标表示时间，纵坐标表示各流水段。</p>
<p><strong>流水线的特点</strong></p>
<ul>
<li>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线的“深度”。</li>
<li>每个子过程由专用的功能段实现</li>
<li>各功能段的时间应基本相等，通常为1个时钟周期（1拍）</li>
<li>流水线需要经过一定的通过时间才能稳定。</li>
<li>流水技术适合于大量重复的时序过程。（流水也是一种并行，但和“并发”不一样，是处于“不同阶段”任务的并行）</li>
</ul>
<h3 id="3-1-2-流水线的分类"><a href="#3-1-2-流水线的分类" class="headerlink" title="3.1.2 流水线的分类"></a>3.1.2 流水线的分类</h3><p><strong>1. 单功能流水线和多功能流水线</strong></p>
<ul>
<li>按流水线所完成的功能分类</li>
<li>单功能流水线，是指只能完成一种固定功能的流水线。<ul>
<li>例如：功能单元流水线</li>
</ul>
</li>
<li>多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能。<ul>
<li>例如：TI ASC的多功能流水线</li>
</ul>
</li>
</ul>
<p><strong>2. 静态流水线和动态流水线</strong></p>
<ul>
<li>按同一时间内流水段的连接方式划分</li>
<li>静态流水线，是指在同一时间内，流水线的各段只能按同一种功能的连接方式工作<ul>
<li>例如：TI ASC的流水线</li>
<li>适合于处理一串相同的运算操作</li>
</ul>
</li>
<li>动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算<ul>
<li>会使流水线的控制变得很复杂</li>
<li>多功能流水线才有这样的划分。</li>
</ul>
</li>
</ul>
<p><strong>3. 部件级、处理机级及处理机间流水线</strong></p>
<ul>
<li>按流水的级别划分</li>
<li>部件级流水线，又叫 <em>运算操作流水线</em>，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水。</li>
<li>处理机级流水线，又叫 <em>指令流水线</em>，是把解释指令的过程按照流水方式处理。</li>
<li>处理机间流水线，又叫 <em>宏流水线</em>，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。 </li>
</ul>
<p><strong>4. 标量流水处理机和向量流水处理机</strong></p>
<ul>
<li>按照数据表示来进行分类</li>
<li>标量流水处理机，是指处理机不具有向量数据表示，仅对标量数据进行流水处理。<ul>
<li>例如IBM360/91，Amdahl 470V/6等 </li>
</ul>
</li>
<li>向量流水处理机，是指处理机具有向量数据表示，并通过向量指令对向量的各元素进行处理。<ul>
<li>例如TI ASC、STAR-100、CYBER-205、CRAY-1、YH-1等</li>
</ul>
</li>
</ul>
<p><strong>5. 线性流水线和非线性流水线</strong></p>
<ul>
<li>按照是否有反馈回路来进行分类</li>
<li>线性流水线是指流水线的各段串行连接，没有反馈回路。</li>
<li>非线性流水线是指流水线中除有串行连接的通路外，还有 <em>反馈回路</em>。<ul>
<li>存在流水线调度问题。</li>
<li>确定什么时候向流水线引进新的输入，从而使新输入的数据和先前操作的反馈数据在流水线中不产生冲突，此即所谓 <em>流水线调度</em> 问题。 </li>
<li>一般不采用该方式</li>
</ul>
</li>
</ul>
<h2 id="3-2-MIPS基本流水线"><a href="#3-2-MIPS基本流水线" class="headerlink" title="3.2 MIPS基本流水线"></a>3.2 MIPS基本流水线</h2><h3 id="3-2-1-MIPS的一种简单实现"><a href="#3-2-1-MIPS的一种简单实现" class="headerlink" title="3.2.1 MIPS的一种简单实现"></a>3.2.1 MIPS的一种简单实现</h3><p>下图给出了实现MIPS指令的一种简单数据通路<br><img src="/bc5a2705/MIPS简单数据通路.png" alt="MIPS简单数据通路"></p>
<ul>
<li>这是非流水方式</li>
<li>指令执行划分为5个阶段<ul>
<li>取指（IF）<ul>
<li>根据PC值从存储器中取出指令，并将指令送入指令寄存器IR；PC值增加4，指向顺序的下一条指令，并将下一条指令的地址放入临时寄存器NPC中。</li>
<li>IR←Mem[PC]，NPC←PC+4<br><img src="/bc5a2705/取指令周期.png" alt="取指周期"></li>
</ul>
</li>
<li>译码，读寄存器（ID）<ul>
<li>进行指令译码，读IR寄存器（指令寄存器），按照相应寄存器号读寄存器文件，并将读出结果放入两个临时寄存器A和B中。同时对IR寄存器中内容的低16位进行符号扩展，然后将符号扩展之后的32位立即值保存在临时寄存器Imm中。</li>
<li>A←Regs[IR6..10]<pre><code>  B←Regs[IR11..15]
  Imm←((IR16)16##IR16..31)
</code></pre><img src="/bc5a2705/指令译码，读寄存器周期.png" alt="译码"></li>
</ul>
</li>
<li>执行，有效地址计算（EX）<ul>
<li>存储器访问：            ALUoutput←A+Imm<ul>
<li>寄存器-寄存器ALU：    ALUoutput←A op B</li>
<li>寄存器-立即值ALU:      ALUoutput←A op Imm</li>
<li>分支操作：              ALUoutput←NPC+Imm<pre><code>                      Cond←(A op 0)
</code></pre></li>
<li>问题：为什么执行和有效地址计算可以合并？<br><img src="/bc5a2705/执行，有效地址计算周期.png" alt="执行周期"></li>
</ul>
</li>
</ul>
</li>
<li>访存（MEM）<ul>
<li>访存操作：<ul>
<li>Load：    LMD←LMDMEM[ALUoutput]</li>
<li>Store：    Mem[ALUoutput]←B</li>
</ul>
</li>
<li>分支操作：    if (Cond) PC←ALUoutput else PC←NPC</li>
</ul>
</li>
<li>写回（WB）<ul>
<li>寄存器-寄存器型ALU指令： Reg[IR16..20]←ALUoutput</li>
<li>寄存器-立即值型ALU指令： Reg[IR11..15]←ALUoutput</li>
<li>Load指令：Reg[IR11..15]←LMD<br><img src="/bc5a2705/写回周期.png" alt="写回周期">    </li>
</ul>
</li>
<li>性能分析<ul>
<li>在该数据通路上，分支指令需要4个时钟周期，其它指令需要5个时钟周期。假设分支指令占总指令数的12%，问CPI=?</li>
<li>CPI=4×12%+5×(1-12%)=4.88</li>
<li>结论：就性能和硬件开销而言，上述实现不是一种优化实现！</li>
</ul>
</li>
<li>改进方法<ul>
<li>在Mem周期完成ALU指令</li>
<li>假设ALU指令数占指令总数的44%，则在时钟周期时间不变的同时，CPI可以降低至4.4</li>
<li>如要进一步降低CPI，可能会增加时钟周期时间</li>
<li>采用单周期实现，可以将CPI降低为1，但时钟周期时间却会增加为原来的5倍。一般不采用这种方法，为什么？（因为实际上并没有提高效率）</li>
<li>流水技术</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-基本MIPS流水线"><a href="#3-2-2-基本MIPS流水线" class="headerlink" title="3.2.2 基本MIPS流水线"></a>3.2.2 基本MIPS流水线</h3><p><strong>1. 一种简单的MIPS流水线</strong></p>
<ul>
<li>将3.2.1中的数据通路流水化，使得数据通路中的每一个周期就成为流水线的一段</li>
<li>每个时钟周期启动一条指令——得到了一条简单的MIPS流水线。</li>
<li>简单MIPS流水线的流水过程：<ul>
<li>时-空图</li>
<li>按时间错开的数据通路<br><img src="/bc5a2705/简单的MIPS流水线.png" alt="简单的MIPS流水线"><br>注意：纵坐标不是流水段，而是指令</li>
</ul>
</li>
</ul>
<p><strong>2. 实现流水技术应解决的一些问题</strong> </p>
<ul>
<li>应保证流水线各段不会在同一时钟周期内使用相同的寄存器通路资源。<ul>
<li>例如，不能要求一个ALU既做有效地址计算，又做减法操作</li>
<li>IF与Mem两个阶段都要访问存储器，怎样避免访存冲突？<ul>
<li>使用 <em>哈佛结构</em>，将指令存储器和数据存储器分离</li>
</ul>
</li>
<li>ID和WB两个阶段都要访问寄存器，是否存在冲突？怎样避免？<ul>
<li>将寄存器隔离，各自使用各自的资源（？）</li>
</ul>
</li>
</ul>
</li>
<li>PC计算问题<ul>
<li>为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获得下一条指令的地址，并将其保存在PC中。<ul>
<li>但是，分支指令会改变PC的值，而且只有在Mem段结束时，这个新值才会被写入PC，出现矛盾。</li>
<li>解决方法：<ul>
<li>改变数据通路，在IF段完成PC计算。但分支指令如何处理？</li>
<li>处理分支指令可以在流水线中加入暂停周期，或设置延迟槽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>合理划分流水段，每段内的操作都必须在一个时钟周期内完成。</li>
<li>流水线寄存器设计<ul>
<li>为防止寄存器中的值在为流水线中某条指令所用时被流水线中其它的指令所重写，可在流水线各段之间设置流水线寄存器文件，也称锁存器。<br><img src="/bc5a2705/各流水段之间的锁存器.png" alt="流水段之间的锁存器"><br>（分站后站间寄存器算哪站的？都可以，但不要不一致）</li>
<li>流水线寄存器文件的命名<br><img src="/bc5a2705/流水线寄存器的命名.png" alt="流水线寄存器的命名"></li>
<li>段A与B之间的流水线寄存器文件称为A/B</li>
<li>流水线寄存器的作用<br><img src="/bc5a2705/流水线寄存器的作用.png" alt="流水线寄存器的作用"><br>当指令在流水线中流动时，其数据和控制信息也在同步地向前流动</li>
<li>流水线寄存器文件的构成<br><img src="/bc5a2705/流水线寄存器的构成.png" alt="流水线寄存器的构成"></li>
</ul>
</li>
</ul>
<p><strong>3. MIPS流水线的操作</strong></p>
<ul>
<li>在任一时刻，流水中的指令仅在流水线中的某一段内执行操作。</li>
<li>因此，只要知道每一流水段在各指令下进行何种操作，就知道了整个流水线的操作。<br><img src="/bc5a2705/MIPS流水线每个流水段的操作.png" alt="MIPS流水线每个流水段的操作"><br><img src="/bc5a2705/MIPS流水线每个流水段的操作（续）.png" alt="MIPS流水线每个流水段的操作（续）"></li>
</ul>
<p><strong>4. MIPS流水线中多路选择器的控制</strong></p>
<ul>
<li>主要是确定如何控制那四个多路选择器：</li>
<li>ALU输入端的两个MUX由ID/EX.IR所指出的指令类型控制</li>
<li>IF段的MUX由EX/MEM.Cond域的值控制</li>
<li>WB段的MUX由当前指令类型(Load/ALU)控制<br><img src="/bc5a2705/DLX流水线中对多路选择器MUX的控制.png" alt="MUX的控制"></li>
</ul>
<h3 id="3-2-3-流水线性能分析"><a href="#3-2-3-流水线性能分析" class="headerlink" title="3.2.3 流水线性能分析"></a>3.2.3 流水线性能分析</h3><p><strong>三项性能指标：吞吐率、加速比和效率</strong></p>
<p><strong>1. 吞吐率</strong></p>
<ul>
<li>是衡量流水线速度的重要指标</li>
<li>吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量。</li>
<li>最大吞吐率TPmax是指流水线在达到 <em>稳定状态</em>后所得到的吞吐率。</li>
<li>设流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率，记作TP。</li>
</ul>
<p><strong>(1) 最大吞吐率</strong></p>
<ul>
<li>假设流水线各段时间相等，均为 $\Delta t<em>{0}$，则：$TP</em>{max} = \frac{1}{\Delta t_{0}}$</li>
<li>假设流水线各段时间不等，第 i 段时间为$\Delta t<em>{i}$，则：$TP</em>{max} = \frac{1}{max{\Delta t_{0}}}$<ul>
<li>最大吞吐率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈（不均匀的流水线才能反映出流水线瓶颈问题）</li>
<li>消除瓶颈的方法<ul>
<li>细分瓶颈段</li>
<li>重复设置瓶颈段</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>(2) 实际吞吐率</strong></p>
<ul>
<li>若各段时间相等（假设均为$\Delta t<em>{0}$），则完成时间<br>$T</em>{流水} = m\Delta t<em>{0}+(n-1)\Delta t</em>{0}$<ul>
<li>实际吞吐率 $TP=\cfrac{1}{T<em>{流水}}=\cfrac{n}{m\Delta t</em>{0}+(n-1)\Delta t<em>{0}}=\cfrac{1}{(1+\frac{m-1}{n})\Delta t</em>{0}} = \cfrac{TP_{max}}{1+\frac{m-1}{n}}$</li>
</ul>
</li>
<li>若各段时间不等（假设第i段为$\Delta t<em>{i}$），则完成时间为：<br><img src="/bc5a2705/流水线时空图（各段时间不等）.png" alt="流水线时空图（各段时间不等）"><br>$T=\sum\limits</em>{i=1}^{m}\Delta t<em>{i}+(n-1)\Delta t</em>{j}$<br>这里$\Delta t<em>{j}=max{\Delta t</em>{i}}$<br>实际吞吐率 $TP=\cfrac{n}{\sum\limits<em>{i=1}^{m}\Delta t</em>{i}+(n-1)\Delta t_{j}}$</li>
<li>不均匀流水线吞吐率的影响因素：深度、任务数、瓶颈段时间。</li>
</ul>
<p><strong>2. 加速比</strong></p>
<ul>
<li>加速比是指流水线速度与等功能的非流水线速度之比，加速比一定大于1。</li>
<li>根据定义可知，加速比 $S = T<em>{非流水}/T</em>{流水}$</li>
<li>若流水线为m段，每段时间均为 $\Delta t<em>{0}$，则 $T</em>{非流水}=nm\Delta t<em>{0}$<br>$T</em>{流水}=m\Delta t<em>{0}+(n-1)\Delta t</em>{0}$<br>加速比 $S=\cfrac{mn}{m+n-1}=\cfrac{m}{1+\frac{m-1}{n}}$</li>
</ul>
<p><strong>3. 效率</strong></p>
<ul>
<li>效率指流水线的设备利用率。</li>
<li>由于流水线有 <em>通过时间和排空时间</em>，所以流水线的各段并非一直满负荷工作，$E&lt;1$</li>
<li>若各段时间相等，则各段效率也相等，即 $e1 = e2 = e3 =…= n\Delta t<em>{0}/T</em>{流水}$</li>
<li>整个流水线效率 $E=\cfrac{n}{m+n-1}=\cfrac{1}{1+\frac{m-1}{n}}$<br>当 $n\ll m$ 时，$E\approx 1$</li>
<li>从时-空图上看，效率就是n个任务所占的时空区与m个段总的时空区之比</li>
<li>根据这个定义，可以计算流水线各段时间不等时的流水线效率 $E=\cfrac{n个任务占用的时空区}{m个段总的时空区}$</li>
<li>时空图上的对应关系：忙的时间和总时间的比。算出来的是所有设备的平均效率。</li>
</ul>
<p><strong>4. 吞吐率、加速比和效率的关系</strong></p>
<ul>
<li>根据加速比 $S=\dfrac{mn}{m+n-1}=\dfrac{m}{1+\frac{m-1}{n}}$<br>和效率 $E=\dfrac{n}{m+n-1}=\dfrac{1}{1+\frac{m-1}{n}}$<br>可得，效率实际上是加速比 S 和最大加速比 m 的比值，即 $E=\dfrac{S}{m}$</li>
<li>$E=n\Delta t<em>{0}/T</em>{流水}=(n/T<em>{流水})\Delta t</em>{0}=TP\Delta t<em>{0}$<br>当 $\Delta t</em>{0}$ 不变时，流水线的效率与吞吐率呈正比。为提高效率而采取的措施，也有助于提高吞吐率</li>
</ul>
<p><strong>例题 3.1</strong> 在静态流水线上计算 $\sum\limits<em>{i=1}^{4}A</em>{i}B_{i}$，问吞吐率、加速比、效率各是多少？</p>
<p><img src="/bc5a2705/例3.1%20静态流水线.png" alt="静态流水线"><br><img src="/bc5a2705/例3.1%20计算过程.png" alt="计算过程"><br><img src="/bc5a2705/例3.1%20时空图.png" alt="时空图"><br><img src="/bc5a2705/例3.1%20性能计算.png" alt="性能计算"></p>
<p><strong>上述方案性能不高，效率仅为 0.21</strong></p>
<ul>
<li>静态多功能流水线在对某种功能进行处理时，总有某些段处于空闲状态</li>
<li>功能切换增加了前一种功能的排空时间和后一种功能的通过时间</li>
<li>需要把输出回传到输入（相关）</li>
<li>能否通过动态流水线改进其性能？<ul>
<li>设置多功能流水线，在加法未进行完时，便进行乘法流水（可以缩短进入时间和排空时间）<br><img src="/bc5a2705/例3.1改进：多功能流水线.png" alt="多功能流水线"></li>
<li>当需要的乘法结果出来后立即执行加法流水，也可缩短一定的进入时间和排空时间<br><img src="/bc5a2705/例3.1改进：加法流水提前.png" alt="加法提前"></li>
</ul>
</li>
</ul>
<p>实际上这样设置流水线是有问题的，只有当前两个乘法完全执行完，才能执行加法，即在t=5 时才能执行第一个加法，在 t=7 时才能执行第二个加法，最后总时间为 19$\Delta t_{0}$。</p>
<p><img src="/bc5a2705/例3.1改进：加法流水提前（正确）.png" alt="加法提前"></p>
<p><strong>例 3.3</strong> 在 MIPS 的非流水实现和基本流水线中，5个功能单元的执行时间：10/8/10/10/7ns。流水线额外开销为 1ns，求相对于非流水指令实现而言，基本 MIPS 流水线的加速比是多少？</p>
<p>注：流水线额外开销包括：流水寄存器的延迟（建立时间和传输延迟）以及时钟扭曲</p>
<p><strong>6. 有关流水线性能的若干问题</strong></p>
<ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但能够提高吞吐率</li>
<li>增加流水线的深度可以提高流水线性能</li>
<li>流水线深度受限于流水线的延迟和额外开销</li>
<li>需要用高速锁存器作为流水线寄存器——Earle 锁存器</li>
<li>指令之间存在的<strong>相关</strong>，限制了流水线的性能</li>
</ul>
<p><strong>Earle锁存器</strong></p>
<ul>
<li>1965 年由 J.G.Earle 发明</li>
<li>优点<ul>
<li>对时钟扭曲不敏感（相对而言），一般是两级门延迟，避免了数据通过锁存器时可能产生的时钟扭曲</li>
<li>在锁存器中可以执行两级逻辑运算，而不会增加锁存器的延迟时间，可以隐藏锁存器产生的额外开销</li>
<li>锁存器是流水线技术存在的基本保证</li>
</ul>
</li>
</ul>
<h2 id="3-3-流水线中的相关"><a href="#3-3-流水线中的相关" class="headerlink" title="3.3 流水线中的相关"></a>3.3 流水线中的相关</h2><p><strong>1. 什么是相关？</strong></p>
<ul>
<li>流水线中的相关是指相邻或相近的两条指令因存在某种关联，后一条指令不能在原先指定的时钟周期开始执行。</li>
<li>消除相关的基本方法——暂停（stall）<ul>
<li>暂停流水线中某条指令及其后面所有指令的执行，该指令之前的所有指令继续执行。</li>
</ul>
</li>
</ul>
<p><strong>2. 三种不同类型的相关</strong></p>
<ul>
<li><strong>结构相关</strong>：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突时将产生“结构相关”。</li>
<li><strong>数据相关</strong>：因一条指令需要用到前面指令的结果，而无法与产生结果的指令重叠执行时，就发生了数据相关。</li>
<li><strong>控制相关</strong>：当流水线遇到分支指令和其它会改变 PC 值的指令时就发生控制相关。</li>
</ul>
<h3 id="3-3-1-流水线的结构相关"><a href="#3-3-1-流水线的结构相关" class="headerlink" title="3.3.1 流水线的结构相关"></a>3.3.1 流水线的结构相关</h3><p><img src="/bc5a2705/结构相关——访存冲突.png" alt="结构相关"></p>
<ul>
<li>导致结构相关的常见原因：<ul>
<li>功能部件不是全流水</li>
<li>重复设置的资源数量不足</li>
</ul>
</li>
<li>实例：当数据和指令存在同一存储器中时，访存指令会引起存储器访问冲突。</li>
<li>解决方法：<ul>
<li>I. 插入暂停周期</li>
</ul>
</li>
</ul>
<p><img src="/bc5a2705/结构相关——插入暂停周期.png" alt="插入暂停周期"></p>
<ul>
<li>II. 将指令存储器和数据存储器分离</li>
<li>避免结构相关的方法：<ul>
<li>所有功能单元完全流水化</li>
<li>设置足够多的硬件资源<ul>
<li>但是，硬件代价很大！</li>
</ul>
</li>
<li>有些设计方案允许结构相关存在<ul>
<li>降低成本</li>
<li>减少功能单元的延迟</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>例 3.4</strong> 当前许多机器都没有将浮点功能单元完全流水， 比如在MIPS实现中，浮点乘需要5个时钟周期，但对该指令不流水。请分析由此引起的结构相关对 mdljdp2 基准程序在MIPS上运行的性能有何影响？为简单起见，假设浮点乘法服从均匀分布。</p>
<p>解：mdljdp2中浮点乘法出现的频率约为14%。<br>最坏情况：每个浮点乘都无法与其它操作重叠执行，都需要5个周期，此时CPI为1.56<br>最好情况：可以完全重叠执行，仅需要1个周期，此时没有性能损失</p>
<h3 id="3-3-2-流水线的数据相关"><a href="#3-3-2-流水线的数据相关" class="headerlink" title="3.3.2 流水线的数据相关"></a>3.3.2 流水线的数据相关</h3><h4 id="1-数据相关简介"><a href="#1-数据相关简介" class="headerlink" title="1. 数据相关简介"></a>1. 数据相关简介</h4><ul>
<li>实例： </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD	R1, R2, R3</span><br><span class="line">SUB	R4, R1, R5</span><br><span class="line">AND	R6, R1, R7</span><br><span class="line">OR	R8, R1, R9</span><br><span class="line">XOR	R10, R1, R11</span><br></pre></td></tr></table></figure>
<ul>
<li>产生原因：当指令在流水线中重叠执行时，流水线有可能改变指令读/写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据相关。</li>
<li>消除方法：向流水线中插入暂停周期（stall）</li>
</ul>
<h4 id="2-通过定向技术（Forwarding）减少数据相关带来的暂停"><a href="#2-通过定向技术（Forwarding）减少数据相关带来的暂停" class="headerlink" title="2. 通过定向技术（Forwarding）减少数据相关带来的暂停"></a>2. 通过定向技术（Forwarding）减少数据相关带来的暂停</h4><ul>
<li>定向（Forwarding），也称为旁路技术（bypassing），转发技术</li>
<li>主要思路：将计算结果从其产生的地方直接送到真正需要它的地方，就可以避免暂停。<ul>
<li>寄存器文件 EX/MEM 中的 ALU 运算结果总是回送到 ALU 的输入寄存器</li>
<li>从定向通路得到输入数据的 ALU 操作不必从源寄存器中读取操作数</li>
<li>进一步推广：一个结果不仅可以从某一功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。</li>
<li>在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。</li>
<li>两条指令访问同一存储单元，也可能引起数据相关，例如访问数据 Cache 失效时。</li>
<li>本章只讨论寄存器数据相关！</li>
</ul>
</li>
</ul>
<h4 id="3-数据相关的分类"><a href="#3-数据相关的分类" class="headerlink" title="3. 数据相关的分类"></a>3. 数据相关的分类</h4><ul>
<li>两条指令 i 和 j，都会访问同一寄存器R，假设i 先进入流水线，则它们对R有四种不同的访问顺序：</li>
</ul>
<p><strong>(1) 写后读(RAW) —— i 写 j 读</strong></p>
<ul>
<li>如果 j 在 i 完成写之前从 R 中读出数据，将得到错误的结果！</li>
<li>最常见的数据相关，严重制约了 CPU 的性能，是程序最重要的特征之一！</li>
</ul>
<p><strong>(2) 写后写(WAW) —— i 写 j 写</strong></p>
<ul>
<li>如果 j 在 i 之前完成写操作，R 中将保存错误的结果！</li>
<li>MIPS 流水线不会出现这种相关！</li>
<li>当流水线中有多个段可以写回，而且当流水线暂停某条指令的执行时，其后的指令可以继续前进时，可能引起这种类型的相关。</li>
</ul>
<p><img src="/bc5a2705/数据相关——写后写相关.png" alt="写后写相关"></p>
<p><strong>(3) 读后写(WAR) —— i 读 j 写</strong></p>
<ul>
<li>如果 j 先将数据写入 R，i 将读出错误的结果！</li>
<li>MIPS流水线不会出现这种类型的相关！</li>
<li>当有些指令在流水段后半部分读源操作数，另一些指令在流水线前半部分写结果，可能引起这种类型的相关。</li>
</ul>
<p><strong>(4) 读后读(RAR) —— i 读 j 读</strong></p>
<ul>
<li>不引起数据相关！</li>
</ul>
<h4 id="4-需要暂停的数据相关"><a href="#4-需要暂停的数据相关" class="headerlink" title="4. 需要暂停的数据相关"></a>4. 需要暂停的数据相关</h4><ul>
<li>并非所有数据相关都可以通过定向技术解决。</li>
<li>例：  LW    R1，0（R2）<pre><code> SUB    R4，R1，R5
 AND    R6，R1，R7
 OR    R8，R1，R9
</code></pre></li>
<li>增加流水线“流水线互锁”部件，当互锁硬件发现这种相关后，就暂停流水线，直到相关消除。</li>
<li>这种情况下，暂停的时钟周期数称为<strong>载入延迟</strong>。<br><img src="/bc5a2705/定向技术不能解决的数据相关.png" alt="定向技术不能解决的数据相关"></li>
</ul>
<h4 id="5-对数据相关的编译调度方法"><a href="#5-对数据相关的编译调度方法" class="headerlink" title="5. 对数据相关的编译调度方法"></a>5. 对数据相关的编译调度方法</h4><ul>
<li>流水线中常常会遇到多种类型的暂停</li>
<li>例如，计算表达式 $A=B+C$ 时会出现暂停</li>
<li>编译器可以通过重新排列代码的顺序来消除这种暂停，这种技术就是<strong>流水线调度</strong>或<strong>指令调度</strong></li>
<li>软件上的方法有时会使事情变得轻而易举，但这取决于编译器的智能。</li>
</ul>
<p><strong>例 3.6</strong>请为下列表达式生成没有暂停的MIPS指令序列 $a = b – c$，$d = e – f$，假设载入延迟为1个时钟周期。<br>分析：为了避免数据相关，需要调整指令的顺序，并合理利用 Forwarding 技术。</p>
<h4 id="6-对-MIPS-流水线控制的实现"><a href="#6-对-MIPS-流水线控制的实现" class="headerlink" title="6. 对 MIPS 流水线控制的实现"></a>6. 对 MIPS 流水线控制的实现</h4><ul>
<li>指令发射：指令从流水线的<strong>译码段</strong>进入<strong>执行段</strong>的过程称为指令发射。</li>
<li><p>检测数据相关</p>
<ul>
<li>ID 段可以检测所有数据相关</li>
<li>在使用一个操作数的时钟周期的开始(EX 和 MEM 段的开始)检测相关，并确定必需的定向</li>
<li>流水线相关硬件可以检测到的各种相关情况<br><img src="/bc5a2705/流水线相关检测硬件可以检测到的各种相关情况.png" alt="硬件可以检测到的各种相关"></li>
</ul>
</li>
<li><p>例：Load 互锁的检测与实现</p>
<ul>
<li>在 ID 段检测是否需要启动 Load 互锁，必须进行三种比较</li>
<li>一旦检测到相关，控制部件必须在流水线中插入暂停周期，并使 IF 和 ID 段中的指令停止前进<ul>
<li>将 ID/EX 中控制部分清 0</li>
<li>保持 IF/ID 的内容不变</li>
</ul>
</li>
</ul>
</li>
<li>定向逻辑的实现<ul>
<li>所有的定向都是从 ALU/DM 的输出到 ALU、DM 或 0 检测单元的输入</li>
<li>形成了一个旁路网络<ul>
<li>需要比较哪些信息？</li>
<li>ALU输入端应采用多少个输入的 MUX？</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/bc5a2705/定向路径.png" alt="定向路径"></p>
<h3 id="3-3-3-流水线的控制相关"><a href="#3-3-3-流水线的控制相关" class="headerlink" title="3.3.3 流水线的控制相关"></a>3.3.3 流水线的控制相关</h3><h4 id="1-分支指令的实现"><a href="#1-分支指令的实现" class="headerlink" title="1. 分支指令的实现"></a>1. 分支指令的实现</h4><ul>
<li>一旦分支转移成功，正确的地址要在 Mem 段的末尾才会被写入 PC</li>
<li>一旦 ID 段检测到分支指令，就暂停执行其后的指令，直到分支指令达到 Mem 段，确定新的 PC 为止</li>
<li>分支转移成功将导致 MIPS 流水线暂停 3 个周期</li>
<li>这是引起更大暂停的另一类相关</li>
<li>没有控制流指令的指令集机器是很不好用的</li>
<li>在事务处理应用中，分支跳转等指令占有相当大的比重。<br><img src="/bc5a2705/分支转移成功将导致暂停3个时钟周期.png" alt="分支成功将暂停3个时钟周期"></li>
</ul>
<h4 id="2-减少分支开销的途径"><a href="#2-减少分支开销的途径" class="headerlink" title="2. 减少分支开销的途径"></a>2. 减少分支开销的途径</h4><ul>
<li>两个基本途径：同时采用，缺一不可！<ul>
<li>在流水线中尽早判断分支转移是否成功</li>
<li>转移成功时，尽早计算出转移目标地址</li>
</ul>
</li>
<li>经改进，MIPS流水线可以将分支开销减少1拍<ul>
<li>将 $=0?$ 测试提前到 ID 段</li>
<li>在 ID 段增加一个加法器，计算分支目标地址</li>
<li>表 3.6 列出了改进后流水线的分支操作</li>
<li>第一种改进，注意分支结果在 EX 段有效。<br><img src="/bc5a2705/修改DLX以减少分支开销.png" alt="修改DLX以减少分支开销"><br><img src="/bc5a2705/分支指令操作.png" alt="分支指令操作"></li>
</ul>
</li>
<li>再改进，MIPS 流水线可以将分支开销再减少 1 拍<ul>
<li>将分支判断结果和目标地址提前到 ID/EX 站前</li>
<li>第二步改进，这次分支结果在 ID 段有效！！！<br><img src="/bc5a2705/修改DLX以减少分支开销（再改进）.png" alt="修改DLX以减少分支开销"></li>
</ul>
</li>
</ul>
<h4 id="3-程序中分支指令的行为特点"><a href="#3-程序中分支指令的行为特点" class="headerlink" title="3. 程序中分支指令的行为特点"></a>3. 程序中分支指令的行为特点</h4><p><strong>(1) 各种能改变PC值的指令的执行频度</strong></p>
<ul>
<li>条件分支：<ul>
<li>整数程序：14-15%</li>
<li>浮点程序：3-12%</li>
<li>其中，向前分支与向后分支的比：3:1</li>
</ul>
</li>
<li>无条件分支：≤4%（绝大多数）</li>
</ul>
<p><strong>(2) 条件分支转移成功的概率</strong></p>
<ul>
<li>向前转移成功：60%；向后转移成功：85%<br><img src="/bc5a2705/条件分支转移成功的概率.png" alt="条件分支转移成功的概率"></li>
</ul>
<h4 id="4-减少流水线分支损失的方法"><a href="#4-减少流水线分支损失的方法" class="headerlink" title="4. 减少流水线分支损失的方法"></a>4. 减少流水线分支损失的方法</h4><p><strong>(1) 冻结或排空流水线</strong></p>
<ul>
<li>思路：在流水线中暂停或删除分支后的指令，直到得到转移目标地址</li>
<li>优点：简单</li>
</ul>
<p><strong>(2) 预测分支转移失败</strong></p>
<ul>
<li>思路：流水线继续照常流动，如果分支转移成功，将分支指令后的指令转换为空操作，并从分支目标处开始取指令执行；否则照常执行</li>
<li>实际发生的成功分支多，就应该在硬件上预测成功，反之则预测失</li>
<li>所谓预测，就是在硬件执行时把分支当作全部成功或全部失败</li>
<li>MIPS流水线的处理过程<br><img src="/bc5a2705/DLX流水线对分支的处理过程.png" alt="DLX流水线对分支的处理过程"></li>
</ul>
<p><strong>(3) 预测分支转移成功</strong></p>
<ul>
<li>思路：始终假设分支成功，直接从分支目标处取指令执行</li>
<li>对 MIPS 流水线没有任何好处！</li>
</ul>
<p><strong>(4) 延迟分支（delayed branch）</strong></p>
<ul>
<li>思路：分支开销为 n 的分支指令后紧跟有 n 个延迟槽，<strong>流水线遇到分支指令时，按正常方式处理</strong>，顺带执行延迟槽中的指令，从而减少分支开销。</li>
<li>延迟槽指令不影响后续指令执行，编译器动态调度</li>
<li>延迟分支及指令的执行顺序<br><img src="/bc5a2705/延迟分支以及指令的执行顺序.png" alt="延迟分支以及指令的执行顺序"></li>
<li><p>具有一个分支延迟槽的MIPS流水线的执行过程<br><img src="/bc5a2705/具有一个分支延迟槽的MIPS流水线的执行过程.png" alt="具有一个分支延迟槽的MIPS流水线的执行过程"></p>
</li>
<li><p>什么样的指令能否放入分支延迟槽？</p>
<ul>
<li>三种调度方法：从前调度；从目标处调度；从失败处调度<br><img src="/bc5a2705/分支延迟指令的三种调度方法.png" alt="分支延迟指令的三种调度方法"></li>
<li>三种方法的要求与效果，存在限制因素<ul>
<li>编译器预测分支是否成功的能力</li>
<li>放入延迟槽中的指令<br><img src="/bc5a2705/三种调度方法的要求及效果.png" alt="三种调度方法的要求及效果"></li>
</ul>
</li>
<li>取消分支<ul>
<li>思路：分支指令中包含预测方向，若预测正确，正常执行延迟槽中的指令，否则将其转换为空操作<br><img src="/bc5a2705/取消分支.png" alt="取消分支"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-各种分支处理方法的性能"><a href="#5-各种分支处理方法的性能" class="headerlink" title="5. 各种分支处理方法的性能"></a>5. 各种分支处理方法的性能</h4><ul>
<li>假设理想CPI=1，则加速比<br>$S=D/(1+C)=D/(1+f×p_{分支})$<ul>
<li>这里，D 为流水线的深度，p 分支为分支开销，C 为分支引起的流水线暂停时钟周期数(每条指令的平均值)，f 为分支的出现频度。</li>
</ul>
</li>
<li>表 3.7 列出了流水线中各种处理方法的开销<br><img src="/bc5a2705/各种减少分支损失方法的效果.png" alt="各种减少分支损失方法的效果"></li>
</ul>
<h4 id="补充-流水线数据相关与冒险（冲突）"><a href="#补充-流水线数据相关与冒险（冲突）" class="headerlink" title="[补充] 流水线数据相关与冒险（冲突）"></a>[补充] 流水线数据相关与冒险（冲突）</h4><p>在组成原理中，流水线相关包含数据相关，结构相关，控制相关，这里的<strong>相关</strong>在体系结构中应该称作为<strong>冲突</strong>（或冒险），实际上相关和冲突在含义上有一些不同</p>
<p>在体系结构中有 3 种不同类型的相关：<strong>数据相关</strong>（也叫真数据相关）、<strong>名相关</strong>和<strong>控制相关</strong></p>
<h5 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h5><p>若：</p>
<ul>
<li>指令 i 生成的结果可能会被指令 j 用到</li>
<li>指令 j 数据相关于指令 k，指令 k 相关于指令 i</li>
</ul>
<p>那么指令 j 数据相关于指令 i</p>
<p>要说明的是，数据相关<strong>可能</strong>会导致数据冒险</p>
<h5 id="名相关（名称相关）"><a href="#名相关（名称相关）" class="headerlink" title="名相关（名称相关）"></a>名相关（名称相关）</h5><p>当两条指令使用相同的寄存器或存储器位置（称为名称），但与该名称相关的指令之间没有数据流动时，就会发生名相关</p>
<ul>
<li>当指令 j 对指令 i 读取的寄存器或存储器位置执行写操作时，会发生<strong>反相关</strong></li>
<li>当指令 i 和指令 j 对同一个寄存器或存储器位置执行写操作时，会发生<strong>输出相关</strong></li>
</ul>
<p>由于没有在指令之间传递值，所以反相关和输出相关都是名称相关，与真数据相关相对。因为名称相关不是真正的相关，因此如果改变这些指令中使用的名称，使这些指令不再冲突，这些指令便可以同时执行，或者重新排序。</p>
<h5 id="数据冒险（数据冲突）"><a href="#数据冒险（数据冲突）" class="headerlink" title="数据冒险（数据冲突）"></a>数据冒险（数据冲突）</h5><ul>
<li>写后读（RAW），与<strong>真数据相关</strong>对应</li>
<li>写后写（WAW），与<strong>输出相关</strong>对应</li>
<li>读后写（WAR），源于<strong>反相关</strong>，或<strong>名称相关</strong></li>
<li>读后读（RAR），不是冒险</li>
</ul>
<h2 id="3-4-实例分析：MIPS-R4000"><a href="#3-4-实例分析：MIPS-R4000" class="headerlink" title="3.4 实例分析：MIPS R4000"></a>3.4 实例分析：MIPS R4000</h2><h3 id="3-4-1-MIPS-R4000的整型流水线"><a href="#3-4-1-MIPS-R4000的整型流水线" class="headerlink" title="3.4.1 MIPS R4000的整型流水线"></a>3.4.1 MIPS R4000的整型流水线</h3><p><strong>1. 指令集：64位MIPS-3指令集</strong></p>
<p><strong>2. MIPS R4000流水线结构</strong></p>
<ul>
<li>超流水结构（superpipeling）</li>
<li>访存操作流水化</li>
</ul>
<p><strong>3. 流水线各段的功能</strong><br><img src="/bc5a2705/R4000流水线各段功能.png" alt="R4000流水线各段功能"></p>
<p><strong>4. 指令序列在流水线中的重叠执行过程</strong></p>
<ul>
<li>定向+插入暂停周期</li>
<li>定向不一定是相邻指令</li>
<li>结构不同，定向和暂停机制所对应的硬件结构也不同<br><img src="/bc5a2705/指令序列在R4000流水线中的重叠执行过程.png" alt="指令序列在R4000流水线中的重叠执行过程"></li>
</ul>
<p><strong>5. 载入延迟为两个时钟周期</strong></p>
<ul>
<li>实际上在 DS 阶段数据已经计算出来，后一个阶段 TC 是将数据写入存储器（WB 阶段写入寄存器），而进行旁路时，无需将其写入存储器便可以得到数据，因此载入延迟为两个时钟周期<br><img src="/bc5a2705/载入延迟为两个时钟周期.png" alt="载入延迟为两个时钟周期"></li>
</ul>
<p><strong>6. 指令序列在流水线中的执行时空图</strong><br><img src="/bc5a2705/R4000流水线的执行时空图.png" alt="R4000流水线的执行时空图"></p>
<p><strong>7. R4000流水线的定向路径远多于MIPS流水线</strong></p>
<pre><code>- ALU输入端的定向源有4个：EX/DF，DF/DS，DS/TC，TC/WB
</code></pre><p><img src="/bc5a2705/R4000流水线ALU输入的四个定向源.png" alt="R4000流水线ALU输入的四个定向源"></p>
<p><strong>8. 分支处理</strong></p>
<ul>
<li>在 EX 段完成分支条件的计算，基本分支延迟为3个时钟周期<br><img src="/bc5a2705/R4000流水线基本分支延迟.png" alt="R4000流水线基本分支延迟"></li>
<li>分支处理策略<ul>
<li>单周期延迟分支</li>
<li>从失败处调度<br><img src="/bc5a2705/R4000流水线处理分支指令的时空图.png" alt="R4000流水线处理分支指令的时空图"></li>
</ul>
</li>
</ul>
<h3 id="3-4-2-MIPS-R4000的浮点流水线"><a href="#3-4-2-MIPS-R4000的浮点流水线" class="headerlink" title="3.4.2 MIPS R4000的浮点流水线"></a>3.4.2 MIPS R4000的浮点流水线</h3><ul>
<li>包括浮点除法器、浮点乘法器和浮点加法器各1个</li>
<li>分为8段（表3.9）<br><img src="/bc5a2705/R4000浮点流水线中8个流水段.png" alt="R4000浮点流水线中8个流水段"></li>
<li>多功能非线性流水线</li>
<li>双精度浮点操作指令延迟、初始化间隔和流水段的使用情况（表3.10）<br><img src="/bc5a2705/双精度浮点操作指令延迟、初始化间隔和流水段的使用情况.png" alt="双精度浮点操作指令延迟、初始化间隔和流水段的使用情况"></li>
</ul>
<h3 id="3-4-3-MIPS-R4000流水线性能分析"><a href="#3-4-3-MIPS-R4000流水线性能分析" class="headerlink" title="3.4.3 MIPS R4000流水线性能分析"></a>3.4.3 MIPS R4000流水线性能分析</h3><p><strong>1. 引起流水线暂停的四个主要原因</strong></p>
<ul>
<li>载入暂停</li>
<li>分支暂停</li>
<li>浮点结果暂停</li>
<li>浮点结构性暂停</li>
</ul>
<p><strong>2. 暂停对MIPS R4000流水线CPI的影响</strong><br><img src="/bc5a2705/暂停对R4000流水线CPI的影响.png" alt="暂停对R4000流水线CPI的影响"></p>
<h2 id="3-5-向量处理机"><a href="#3-5-向量处理机" class="headerlink" title="3.5 向量处理机"></a>3.5 向量处理机</h2><p><strong>1. 什么是向量机？</strong></p>
<ul>
<li>具有向量数据表示和相应向量指令的流水线处理机称为向量流水线处理机，也称向量处理机。</li>
<li>与之对应的是标量处理机，不支持向量数据表示，没有提供向量指令。</li>
</ul>
<p><strong>2. 实例：一个简单的FORTRAN循环程序</strong></p>
<script type="math/tex; mode=display">
  DO \quad 10 \quad i=1, N \\
    10 \quad d[i] = a[i]*(b[i]+c[i])</script><h3 id="3-5-1-向量处理方式和向量处理机"><a href="#3-5-1-向量处理方式和向量处理机" class="headerlink" title="3.5.1 向量处理方式和向量处理机"></a>3.5.1 向量处理方式和向量处理机</h3><ul>
<li>水平（横向）处理方式</li>
<li>垂直（纵向）处理方式</li>
<li>分组（纵横）处理方式<ul>
<li>将长度为N的向量分为m组，每组有n个元素，组内按纵向方式处理，依次处理各组。</li>
<li>需要m次迭代；每次迭代执行两条向量指令，有1次数据相关，需要2次功能切换</li>
<li>需要寄存器-寄存器型操作的运算流水线</li>
<li>这种技术称为<strong>向量循环</strong>或<strong>分段开采</strong></li>
</ul>
</li>
</ul>
<p><strong>例3.8</strong> 设 A 和 B 是长度为N的向量，考虑在一个向量长度为 64 的向量处理机上实现如下的循环操作：<br>DO 10 I=1, N<br>10 A(I) = 5.0 * B(I) + 1.0</p>
<p>(1) 当N≤64时<br><img src="/bc5a2705/N小于等于64.png" alt="N&lt;=64"><br>(2) 当N&gt;64时，需要进行分段开采<br><img src="/bc5a2705/N大于64.png" alt="N&gt;64"></p>
<p><strong>4. 向量处理机的速度评价方法</strong></p>
<ul>
<li>由于一条指令最多得到一个结果，标量处理机通常用每秒执行多少条指令(MIPS)来衡量机器的运算速度</li>
<li>向量处理机用每秒取得多少浮点运算结果来衡量机器速度，以 MFLOPS 作为测量单位</li>
<li>采用 MFLOPS 可以忽视 Load、Store、分支、测试等类型指令的影响</li>
<li>一般认为，在标量计算机中执行一次浮点运算，平均需 3 条指令。因此，如果要把这两种速度指标放在一起比较，就应该把 MFLOPS 乘以一个系数，以得到相应的 MIPS</li>
<li>比较法：选择一台速度指标得到公认的机器作为标准机，给定一些典型的基准程序，分别在标准机和被测机上求解。 </li>
</ul>
<h3 id="3-5-2-向量处理机实例分析"><a href="#3-5-2-向量处理机实例分析" class="headerlink" title="3.5.2 向量处理机实例分析"></a>3.5.2 向量处理机实例分析</h3><p><strong>实例：Cray-I</strong></p>
<h4 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1. 性能指标"></a>1. 性能指标</h4><p>1GFLOPS、主频80M、向量长度64</p>
<h4 id="2-基本结构"><a href="#2-基本结构" class="headerlink" title="2. 基本结构"></a>2. 基本结构</h4><ul>
<li>向量运算部件</li>
<li>向量寄存器组（V0-V7）</li>
<li>向量长度寄存器</li>
<li>向量屏蔽寄存器<br><img src="/bc5a2705/CRAY-1的基本结构.png" alt="CRAY-1的基本结构"></li>
</ul>
<h4 id="3-向量指令类型"><a href="#3-向量指令类型" class="headerlink" title="3. 向量指令类型"></a>3. 向量指令类型</h4><ul>
<li>$V_k ← V_i \,op \,V_j$（两个向量操作）</li>
<li>$V_k ← S_i \,op \,V_j$（一个向量一个标量操作）</li>
<li>$V_k ← Mem$（取数据）</li>
<li>$Mem ← V_k$（存数据）</li>
<li>功能部件冲突：同一功能部件被一条以上的并行工作向量指令所使用</li>
<li>$V_i$ 冲突：并行工作的各向量指令具有相同的源向量或结果向量<br><img src="/bc5a2705/CRAY-1的向量指令类型.png" alt="CRAY-1的向量指令类型.png"></li>
</ul>
<h4 id="4-CRAY-I-体系结构特点"><a href="#4-CRAY-I-体系结构特点" class="headerlink" title="4. CRAY-I 体系结构特点"></a>4. CRAY-I 体系结构特点</h4><ul>
<li>向量寄存器与功能单元的连接通路<ul>
<li>每个 $V_i$ 块都有<strong>单独总线</strong>可连到所有向量功能部件，而每个向量功能部件也各自都有把运算结果送回向量寄存器组的总线（寄存器组和功能部件全相连）</li>
</ul>
</li>
<li>向量链接技术<ul>
<li>一个向量功能部件得到的结果直接送入另一个向量功能部件的操作数寄存器时所发生的连接过程称为链接。<br><img src="/bc5a2705/CRAY-1的链接技术.png" alt="CRAY-1的链接技术"></li>
<li>上图中，当完成 $V_1+V_2$ 时，将值送入 $V_3$ 的同时送入下一个乘法流水线作为其中的被乘数（其实我感觉有点像处理数据相关时的 Forwarding 技术）。</li>
</ul>
</li>
<li>当两条指令出现“写后读”相关时，若它们不存在功能部件冲突和向量寄存器(源或目的) 冲突，就有可能把它们所用的功能部件头尾相接，形成一个链接流水线，进行流水处理。</li>
<li>链接特性实质上是把流水线“定向”的思想引入到向量执行过程的结果</li>
</ul>
<h4 id="5-向量链接技术实例分析"><a href="#5-向量链接技术实例分析" class="headerlink" title="5. 向量链接技术实例分析"></a>5. 向量链接技术实例分析</h4><p><strong>例3.7</strong> 对向量运算 D=A<em>(B+C)，若向量长度 N≤64，向量元素为浮点数，则在B、C取到V0、V1后，就可用以下三条向量指令求解：<br>V3←存储器    (访存，载入A)<br>V2←V0＋V1    (浮点加)<br>V4←V2</em>V3    (浮点乘，将D存入V4) </p>
<p>假设：向量处理机将元素从 $V_i$ 送往功能部件及把结果存入 $V_i$ 都需要1拍；浮点加法和访存操作都需要 6 拍；浮点乘操作需要 7 拍。<br>这样，第一个结果被存入 $V_4$ 需要经过：</p>
<ul>
<li>1(送)+ 6(浮加) +1(入)+1(送)+7(浮乘)+1(入)=17(拍)</li>
<li>此后，每拍将得到一个结果送入 $V_4$。<br>总的完成时间为：17+（N-1）拍</li>
</ul>
<h4 id="6-向量链接技术应考虑的问题"><a href="#6-向量链接技术应考虑的问题" class="headerlink" title="6. 向量链接技术应考虑的问题"></a>6. 向量链接技术应考虑的问题</h4><ul>
<li>设定合适的向量功能部件和操作数寄存器</li>
<li>链接时机问题<ul>
<li>只有在前一条向量指令的第一个结果元素送入结果向量寄存器的那一个时钟周期才可以进行链接</li>
<li>只有当前一条向量指令全部执行完毕，释放相应的向量寄存器资源后才能执行后面的向量指令</li>
<li>所有可以链接执行的向量指令的向量长度应相等</li>
<li>总结链接的时机：普适的原则</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构课程笔记（三）</title>
    <url>/c152688f.html</url>
    <content><![CDATA[<h1 id="第五章-存储层次"><a href="#第五章-存储层次" class="headerlink" title="第五章 存储层次"></a>第五章 存储层次</h1><blockquote>
<p>国防科大计算机体系结构课程第五章笔记<br><span id="more"></span></p>
</blockquote>
<h2 id="5-1-存储器的层次结构"><a href="#5-1-存储器的层次结构" class="headerlink" title="5.1 存储器的层次结构"></a>5.1 存储器的层次结构</h2><h3 id="5-1-1-从单级存储器到多级存储器"><a href="#5-1-1-从单级存储器到多级存储器" class="headerlink" title="5.1.1 从单级存储器到多级存储器"></a>5.1.1 从单级存储器到多级存储器</h3><ul>
<li>主存储器与 CPU 速度差距越来越大，存储墙问题严重制约着计算机性能的提升</li>
<li>系统与应用的规模不断扩大，需要更大的存储器来支撑程序的运行</li>
<li>各类存储器的容量/速度/价格不可兼得，如SRAM（已经可以和 CPU 速度持平）、DRAM、磁盘等，<em>凭现有单种存储器件，无法构建一个可行的存储系统</em></li>
<li>处理器性能与存储系统性能之间存在巨大差距，这叫做<strong>存储墙（Memory Wall）</strong><br>怎么办？</li>
<li>利用多种存储器件，取长补短，构建层次式存储系统<ul>
<li>快速但昂贵的存储器：容量少点，尽量让 CPU 多访问</li>
<li>慢速但容量大的存储器：容量大点， CPU 尽可能少访问</li>
</ul>
</li>
</ul>
<p>能否达到预期效果？</p>
<ul>
<li>访问速度方面：采用快速存储器，尽量让 CPU 多访问快速存储器中的内容（增加 Cache 层次）<ul>
<li>程序局部性原理：<ul>
<li>时间局部性：<em>当前访问的数据</em>存放 Cache 中</li>
<li>空间局部性：把与<em>当前访问地址相邻的数据</em>放入 Cache 中（以块为单位从内存调入）</li>
</ul>
</li>
</ul>
</li>
<li>容量方面：采用慢速但容量大的存储器，内存不够时数据可以放到外存中（增加辅存层次）</li>
</ul>
<h3 id="5-1-2-Cache——主存和主存——辅存层次"><a href="#5-1-2-Cache——主存和主存——辅存层次" class="headerlink" title="5.1.2 Cache——主存和主存——辅存层次"></a>5.1.2 Cache——主存和主存——辅存层次</h3><ul>
<li>这是最主要的两种存储层次</li>
<li>从主存的角度来看<ul>
<li>Cache——主存层次：弥补主存速度的不足</li>
<li>主存——辅存层次：弥补主存容量的不足</li>
</ul>
</li>
<li>失效时 CPU 是否切换：Cache——主存层次不切换，主存——辅存层次需要切换到其他进程</li>
</ul>
<h3 id="5-1-3-存储层次的四个问题"><a href="#5-1-3-存储层次的四个问题" class="headerlink" title="5.1.3 存储层次的四个问题"></a>5.1.3 存储层次的四个问题</h3><ul>
<li>当把一个块调入高一层(靠近CPU)存储器时，可以放在哪些位置上？<ul>
<li>映象规则：调入块可以放在哪些位置</li>
</ul>
</li>
<li>当所要访问的块在高一层存储器中时，如何找到该块？<ul>
<li>查找算法：如何在映象规则规定的候选位置查找</li>
</ul>
</li>
<li>当发生失效时，应替换哪一块？<ul>
<li>替换算法：规定的候选位置均被别的块占用</li>
</ul>
</li>
<li>当进行写访问时，应进行哪些操作？<ul>
<li>写策略：如何处理写操作</li>
</ul>
</li>
</ul>
<h3 id="5-1-4-存储层次的性能参数"><a href="#5-1-4-存储层次的性能参数" class="headerlink" title="5.1.4 存储层次的性能参数"></a>5.1.4 存储层次的性能参数</h3><ul>
<li>$C$(平均每位价格), $H$(命中率), $T_A$(平均访问时间)</li>
<li>假设：<ul>
<li>$S$ ——容量</li>
<li>$T_A$——访问时间</li>
<li>$C$——每位价格</li>
</ul>
</li>
<li>仅考虑 $M_1 M_2$构成的两级存储层次时：<ul>
<li>$M<em>1$的参数：$S_1$，$T</em>{A1}$，$C_1$</li>
<li>$M<em>2$的参数：$S_2$，$T</em>{A2}$，$C_2$</li>
<li>每位价格 $C=\cfrac{C_1S_1+C_2S_2}{S_1+S_2}$</li>
<li>命中率 $H$ 和失效率 $F$<ul>
<li>$H=\cfrac{N_1}{N_1+N_2}$</li>
<li>$F=1-H$</li>
</ul>
</li>
<li>平均访问时间 $T_A$<ul>
<li>$T<em>A=T</em>{A1}+(1-H)T<em>M \; 或 \; T_A=T</em>{A1}+F·T_M$</li>
<li>$T<em>M=T</em>{A2}+T_B$</li>
<li>$T_{A1}$——命中时间</li>
<li>$T_{A2}$——$M2$ 访问时间</li>
<li>$T_M$——失效开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-Cache-基本知识"><a href="#5-2-Cache-基本知识" class="headerlink" title="5.2 Cache 基本知识"></a>5.2 Cache 基本知识</h2><h3 id="5-2-1-映像规则"><a href="#5-2-1-映像规则" class="headerlink" title="5.2.1 映像规则"></a>5.2.1 映像规则</h3><h4 id="1-全相联映象"><a href="#1-全相联映象" class="headerlink" title="1. 全相联映象"></a>1. 全相联映象</h4><ul>
<li>全相联：主存中的任一块可以被放置到 Cache 中的任意一个位置。<ul>
<li>对比： 阅览室位置──随便坐</li>
<li>特点： 空间利用率最高，冲突概率最低，实现最复杂。</li>
</ul>
</li>
</ul>
<h4 id="2-直接映象"><a href="#2-直接映象" class="headerlink" title="2. 直接映象"></a>2. 直接映象</h4><ul>
<li>直接映象：主存中的每一块只能被放置到 Cache 中唯一的一个位置。(循环分配)<ul>
<li>对比：阅览室位置 ── 只有一个位置可以坐</li>
<li>特点：空间利用率最低，冲突概率最高，实现最简单。</li>
</ul>
</li>
</ul>
<h4 id="3-组相联映像"><a href="#3-组相联映像" class="headerlink" title="3. 组相联映像"></a>3. 组相联映像</h4><ul>
<li>组相联：主存中的每一块可以放到Cache中唯一的一个组中的任何一个位置</li>
<li>组的选择常采用位选择算法</li>
<li>n 路组相联，每个组中有 n 个块，n 称为相联度，相联度越高，Cache 空间利用率就越高，块冲突概率就越低，失效率也就越低<ul>
<li>绝大多数计算机的 Cache&lt;=4</li>
<li>相联度不是越大越好</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-查找方法"><a href="#5-2-2-查找方法" class="headerlink" title="5.2.2 查找方法"></a>5.2.2 查找方法</h3><ul>
<li>如何确定 Cache 中是否有所要访问的块？若有的话如何确定其位置？<ul>
<li>Cache 块调入时记录存放的位置到 目录表（标识存储器）<ul>
<li>表项中只需要放入标识（tag）和有效位即可，因 index 都一样，是冗余信息，所以无需放入表项</li>
</ul>
</li>
<li>只需查找候选位置所对应的目录表项</li>
<li>并行查找与顺序查找（减少硬件开销）<ul>
<li>相联存储器（代价高）</li>
<li>单体多字存储器＋比较器<ul>
<li>只有一套访存机制，一次可读多个字</li>
</ul>
</li>
<li>４路组相联 Cache 的查找过程<ul>
<li>首先根据给定的物理地址的组号找到对应的表项，再将该组中的 4 个 cache 块的标记读出，分别与物理地址的 tag 标记字段进行比较，若没有匹配，则 Cache 缺失</li>
<li>若有匹配，则从数据存储体中读取该组中所有的数据（四路），然后再通过 4：1 MUX 选择是哪一路命中了数据，再根据块内偏移确定具体的数据送给 CPU</li>
<li><strong>对于比较器的个数，应等于组相联中的相联度</strong>（2022年408真题中考察了该知识点）<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/四路组相联查找过程.png" alt="四路组相联查找过程"></li>
</ul>
</li>
<li>直接映象 Cache 的查找过程<ul>
<li>先根据 index 选择到对应的 Cache 块，然后将给定的物理地址的 tag 和标识存储体中的标识通过一个标识检查器（比较器）进行比较，若不命中，则 Cache 缺失</li>
<li>若命中，直接访问数据存储体，将数据读出送至 CPU</li>
</ul>
</li>
</ul>
</li>
<li>提高性能的重要思想：主候选位置(MRU块)</li>
</ul>
</li>
</ul>
<h3 id="5-2-3-替换算法"><a href="#5-2-3-替换算法" class="headerlink" title="5.2.3 替换算法"></a>5.2.3 替换算法</h3><p>所要解决的问题：当新调入一块，而该块能够占用的 Cache 位置已被占满时，替换哪一块？</p>
<ol>
<li>随机法</li>
<li>FIFO: 实现简单</li>
<li>LRU（最近最久未使用）：失效率低，但是硬件实现较为复杂</li>
<li>LFU：最不常使用法</li>
</ol>
<h3 id="5-2-4-写策略"><a href="#5-2-4-写策略" class="headerlink" title="5.2.4 写策略"></a>5.2.4 写策略</h3><ol>
<li>“写”操作所占的比例<ul>
<li>Load 指令：26%</li>
<li>Store 指令：9%</li>
<li>“写”在所有访存操作中所占的比例：9%/(100%＋26%＋9%)≈7%</li>
<li>“写”在访问数据 Cache 操作中所占的比例：9%/(26%+9%)≈25%</li>
</ul>
</li>
<li><strong>“写”操作必须在确认是否命中后才能进行</strong></li>
<li>“写”访问可能导致 Cache 和主存内容不一致</li>
<li>两种写策略<ul>
<li>写直达法：执行“写”操作时，不仅写入 Cache ，而且也写入下一级存储器</li>
<li>写回法：执行“写”操作时，只写入<br>Cache，仅当 Cache 中相应的块被替换时，才写回主存（设置“脏位”）</li>
<li>两种写策略比较<ul>
<li>写回法优点：速度快，占用存储器频带低</li>
<li>写直达法易于实现，一致性好</li>
</ul>
</li>
</ul>
</li>
<li>写缓冲器<ul>
<li>将数据写入写缓冲器便完成了一次写操作，无需再写入存储器中</li>
<li>写缓冲器若满，只能等待</li>
</ul>
</li>
<li>写合并<ul>
<li>当把数据写入写缓冲器时，判断本次所写入单元的块地址是否与写缓冲器中某个有效块的地址相同，若是，则把新数据与该块合并</li>
</ul>
</li>
<li>写回法——按写分配</li>
<li>写直达法——不按写分配</li>
</ol>
<h3 id="5-2-3-Cache-结构"><a href="#5-2-3-Cache-结构" class="headerlink" title="5.2.3 Cache 结构"></a>5.2.3 Cache 结构</h3><p>DEC 的 Alpha AXP21064 中的内部数据 Cache</p>
<ol>
<li>简介</li>
</ol>
<ul>
<li>容量： 8KB</li>
<li>块大小： 32B</li>
<li>块数： 256</li>
<li>映象方法：直接映象</li>
<li>“写”策略：写直达——不按写分配</li>
<li>写缓冲器大小： 4 个块</li>
</ul>
<ol>
<li>混合 Cache 与分离 Cache</li>
</ol>
<ul>
<li>优缺点<ul>
<li>两种 Cache 可以采用不同策略，方便进行读写</li>
</ul>
</li>
<li>分离 Cache 平均失效率的计算：<ul>
<li>访问指令 Cache 的百分比 × 指令 Cache 的失效率＋访问数据 Cache 的百分比 × 数据 Cache 的失效率</li>
</ul>
</li>
</ul>
<h3 id="5-2-6-性能分析"><a href="#5-2-6-性能分析" class="headerlink" title="5.2.6 性能分析"></a>5.2.6 性能分析</h3><ol>
<li>平均访问时间<ul>
<li>平均访问时间＝命中时间＋失效率 × 失效开销</li>
</ul>
</li>
<li>CPU 时间<ul>
<li>CPU 时间＝(CPU 执行周期数＋存储器停顿周期数)×时钟周期时间</li>
<li>存储器停顿周期数=访存次数×失效率×失效开销</li>
<li>CPU 时间＝IC×(CPI~exe~＋访存次数/指令数×失效率×失效开销)×时钟周期时间</li>
<li>CPU 时间＝IC×(CPI~exe~ + 每条指令平均存储器停顿周期数)×时钟周期时间<blockquote>
<p>注：$CPI_{exe}$ 表示理想情况下的 CPI</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>例 5.1</strong> 假设 Cache 的命中时间为 1 个时钟周期，失效开销为 50 个时钟周期，在混合 Cache 中一次 load 或 store 操作访问 Cache 的命中时间都要增加一个时钟周期(因为混合 Cache 只有一个端口，无法同时满足两个请求。按照前一章中有关流水线的术语，混合 Cache 会导致结构冲突)，根据表 5-4 所列的失效率，试问：<br>(1) 指令 Cache 和数据 Cache 容量均为 16KB 的分离 Cache 和容量为 32KB 的混合 Cache 相比，哪种 Cache 的失效率更低？<br>(2) 又假设采用写直达策略，且有一个写缓冲器<br>，并且忽略写缓冲器引起的等待。请问上述两种情况下平均访存时间各是多少？</p>
<p><strong>[解析]</strong><br>(1) 75% 的访存为取指令，因此分离 Cache 总体失效率为 (75%×0.64%)+(25%×6.47%)=2.10%<br>根据表 5-4 ，容量为 32KB 的混合 Cache 的失<br>效率略低一些，只有 1.99%<br>(2) 平均访存时间公式可以分为指令访问和数据访<br>问两部分<br>平均访存时间＝指令所占的百分比 ×(指令命中时间＋指令失效率 × 失效开销) ＋ 数据所占的百分比 × (数据命中时间＋数据失效率 × 失效开销)<br>所以，两种结构的平均访存时间分别为<br>平均访存时间~分离~ ＝ 75%×(1＋0.64%×50)＋25%×(1＋6.47%×50)＝(75%×1.32)＋(25%×4.325)＝0.990＋1.059＝2.05<br>平均访存时间~混合~＝ 75%×(1＋1.99%×50)＋25%×(1＋1＋1.99%×50)＝(75%×1.995)＋(25%×2.995)＝1.496＋0.749＝2.24</p>
<p>这里混合 Cache 平均访存时间较长的主要原因是，混合 Cache 共用指令 Cache 和数据 Cache，节约了硬件，但是可能会造成结构冲突</p>
<p><strong>[注意]</strong> 在访问数据段时候同时也在访问指令，因此要多增加一个时钟周期</p>
<p><strong>例 5.2</strong> 我们用一个和 Alpha AXP 类似的机器作为第一个例子。当不考虑存储器停顿时，所有指令的执行时间都是 2.0 个时钟周期。假设  Cache 失效开销为 50 个时钟周期， Cache 的失效率为 2% ，平均每条指令访存 1.33 次。试分析 Cache 对性能的影响。</p>
<p><strong>[分析]</strong><br>CPU 时间＝IC×(CPI~exe~+存储器停顿周期数/指令数)×时钟周期时间<br>考虑 Cache 失效后，性能为</p>
<ul>
<li>CPU 时间~有Cache~＝IC×(2.0+(1.33×2%×50))×时钟周期时间＝IC×3.33×时钟周期时间</li>
<li>实际 CPI＝3.33，3.33/2.0＝1.67倍</li>
<li>CPU 时间增加了 1.67 倍</li>
<li>若不采用 Cache，则：CPI＝2.0+50×1.33＝68.5</li>
<li>差距显而易见</li>
</ul>
<h3 id="5-2-7-改进-Cache-性能"><a href="#5-2-7-改进-Cache-性能" class="headerlink" title="5.2.7 改进 Cache 性能"></a>5.2.7 改进 Cache 性能</h3><ul>
<li>平均访存时间＝命中时间＋失效率 × 失效<br>开销</li>
<li>可以从三个方面改进 Cache 的性能：<br>(1) 降低失效率<br>(2) 减少失效开销<br>(3) 减少 Cache 命中时间</li>
<li>15 种 Cache 优化技术</li>
</ul>
<h4 id="1-降低失效率"><a href="#1-降低失效率" class="headerlink" title="1. 降低失效率"></a>1. 降低失效率</h4><ul>
<li>增加块大小</li>
<li>提高相联度</li>
<li>Victim Cache</li>
<li>伪相联 Cache</li>
<li>硬件预取</li>
<li>编译器控制的预取</li>
<li>用编译器技术减少 Cache 失效</li>
</ul>
<h4 id="2-减少失效开销"><a href="#2-减少失效开销" class="headerlink" title="2. 减少失效开销"></a>2. 减少失效开销</h4><ul>
<li>使读失效优于写</li>
<li>子块放置技术</li>
<li>尽早重启动和关键字优先</li>
<li>非阻塞 Cache</li>
<li>第二级 Cache</li>
</ul>
<h4 id="3-减少命中时间"><a href="#3-减少命中时间" class="headerlink" title="3. 减少命中时间"></a>3. 减少命中时间</h4><ul>
<li>容量小且结构简单的 Cache</li>
<li>对 Cache 索引时，不必进行地址转换</li>
<li>流水化写</li>
</ul>
<p><strong>值得注意的是，要想提高平均访存时间，不是从单一的某一方面去进行优化，而是要从全局进行考虑，这是体系结构的核心观点。</strong><br><strong>比如仅仅减少失效开销，不一定会降低平均访存时间，因为降低失开销率可能需要更改整个体系结构，从而带来失效率的增加，最终反而会增加平均访存时间。</strong></p>
<h2 id="5-3-降低-Cache-失效率的方法"><a href="#5-3-降低-Cache-失效率的方法" class="headerlink" title="5.3 降低 Cache 失效率的方法"></a>5.3 降低 Cache 失效率的方法</h2><h3 id="5-3-1-三种失效（3C）"><a href="#5-3-1-三种失效（3C）" class="headerlink" title="5.3.1 三种失效（3C）"></a>5.3.1 三种失效（3C）</h3><p><strong>1. 强制性失效（Compulsory miss）</strong><br>当第一次访问一个块时，该块不在 Cache 中，需要从下一级存储器中调入 Cache，这就是强制性失效。<br>也叫<strong>冷启动失效</strong>，<strong>首次访问失效</strong></p>
<p><strong>2. 容量失效（Capacity miss）</strong><br>如果程序执行时所需的块不能全部调入 Cache 中，则当某些块被替换后，若又被重新访问，就会发生失效。这种失效成为容量失效。（全相联映射完全是因为容量失效造成的，因为没有替换算法）</p>
<p><strong>3. 冲突失效（Conflict miss）</strong><br>在组相联或直接映像 Cache 中，若太多的块映像到同一组或同一块中，则会出现该组中某个块被别的块替换（即使其他组有空闲块），然后又被重新访问的情况，这就是冲突失效，也叫碰撞失效或干扰失效。若同一个块不断被换进换出，便产生了<strong>颠簸</strong>，要尽量避免颠簸造成的系统损耗。</p>
<p><strong>三种失效所占的比例</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/对于3C失效的研究.png" alt="对于3C失效的研究"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/各种类型的失效率（相对值）.png" alt="各种类型的失效率（相对值）"></p>
<p>通过上图可以看出：<br>(1) 相联度越高，冲突失效就越少；<br>(2) 强制性失效不受 Cache 容量的影响，但容量失效却随着容量的增加而减少；强制性失效和容<br>量失效不受相联度的影响（容量失效一般是在全相联映像下测试出来的）<br>(3) 表中的数据符合 <strong>2:1 的 Cache 经验规则</strong>，即大小为 N 的直接映象 Cache 的失效率约等于大小为 N/2 的两路组相联 Cache 的失效率</p>
<h4 id="减少三种失效的方法"><a href="#减少三种失效的方法" class="headerlink" title="减少三种失效的方法"></a>减少三种失效的方法</h4><ul>
<li>强制性失效：增加块大小，预取<ul>
<li>增加块大小后，每个块包含的内容就更多了，程序局部性更好了，需要读取的块就少了，于是便减少了强制性失效的次数</li>
</ul>
</li>
<li>容量失效：增加容量，防止出现颠簸现象</li>
<li>冲突失效：增加相联度，理想情况是全相联</li>
</ul>
<p>但是许多降低失效率的方法会增加命中时间</p>
<h3 id="5-3-2-增加-Cache-块大小"><a href="#5-3-2-增加-Cache-块大小" class="headerlink" title="5.3.2 增加 Cache 块大小"></a>5.3.2 增加 Cache 块大小</h3><ol>
<li>失效率与块大小的关系<ul>
<li>对于给定的 Cache 容量，当块大小增加失效率开始时下降，后来反而上升</li>
<li>Cache 容量越大，失效率达到最低的块大小就越大</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Cache失效率与块大小的关系.png" alt="Cache失效率与块大小的关系"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Cache失效率与块大小的关系（2）.png" alt="Cache失效率与块大小的关系（2）"></p>
<p>那么这是为什么呢？</p>
<blockquote>
<p>导致 Cache 失效率先下降后上升的原因在于增加块大小会产生双重作用。<br>一方面它减少了强制性失效。因为局部性原理有两方面的含义，即时间局部性和空间局部性，增加块大小便利用了程序的局部性。<br>另一方面由于增加块大小会减少 Cache 中块的数目，所以有可能会增加冲突失效。在 Cache 容量较小时甚至还会增加容量失效。刚开始增加块大小时，由于块大小还不是很大，上述的第一种作用超过第二种作用从而使失效率下降。但等到块大小较大时，第二种作用超过第一种作用使失效率上升。</p>
</blockquote>
<p><strong>例 5.4</strong><br>假定存储系统在延迟 40 个时钟周期后，每 2 个时钟周期能送出 16 个字节。即 : 经过 42 个时钟周期，它可提供 16 个字节；经过 44 个时钟周期，可提供 32 个字节；依此类推。试问：对于表 5-6 中列出的各种容量的 Cache ，在块大小分别为多少时，平均访存时间最小？假设命中时间为一个时钟周期。</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/例5.4（1）.png" alt="例5.4（1）"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/例5.4（2）.png" alt="例5.4（2）"></p>
<h3 id="5-3-3-提高相联度"><a href="#5-3-3-提高相联度" class="headerlink" title="5.3.3 提高相联度"></a>5.3.3 提高相联度</h3><ol>
<li>采用相联度超过 8 的方法实际意义不大（一般 n 为 4 或 2）</li>
<li>2:1 Cache 经验规则：容量为 N 的直接映象 Cache ≈ 容量为 N/2 的两路组相联 </li>
<li>提高相联度是以增加命中时间为代价 Cache<ul>
<li>TTL 或 ECL 板级 Cache ，两路组相联：增加 10 ％</li>
<li>定制的 CMOS Cache, 两路组相联：增加 2 ％</li>
</ul>
</li>
</ol>
<p><strong>例 5.5</strong><br>假定提高相联度会按下列比例增大处理器时钟周期：<br>时钟周期~2路~ ＝ 1.10 × 时钟周期~1路~<br>时钟周期~4路~ ＝ 1.12 × 时钟周期~1路~<br>时钟周期~8路~ ＝ 1.14 × 时钟周期~1路~<br>假定命中时间为 1 个时钟，直接映象情况下失效开销为 50 个时钟周期，而且假设不必将失效开销<br>取整。使用表 5-5 中的失效率，试问当 Cache 为多大时，以下不等式成立？<br>平均访存时间~8路~ &lt; 平均访存时间~4路~<br>平均访存时间~4路~ &lt; 平均访存时间~2路~<br>平均访存时间~2路~ &lt; 平均访存时间~1路~<br>解：<br>在各种相联度的情况下，平均访存时间分别为：<br>平均访存时间~8路~＝命中时间~8路~ + 失效率~8路~ × 失效开销~8路~＝ 1.14＋失效率~8路~ × 50<br>平均访存时间~4路~ = 1.12 ＋失效率~4路~ × 50<br>平均访存时间~2路~ = 1.10 ＋失效率~2路~ × 50<br>平均访存时间~1路~ = 1.00 ＋失效率~1路~ × 50</p>
<p>例如， 1KB 的直接映象 Cache 的平均访存时间为：<br>平均访存时间~1路~ ＝ 1.00 ＋ (0.133×50) ＝ 7.65<br>容量为 128KB 的 8 路组相联 Cache 的平均访存时间为：<br>平均访存时间~8路~ ＝ 1.14 ＋ (0.006×50) ＝ 1.44</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/不同容量下不同相联度对平均访问时间的影响.png" alt="不同容量下不同相联度对平均访问时间的影响"></p>
<p>提高相联度可以减少失效率，但是总体性能可能下降</p>
<h3 id="5-3-4-Victim-Cache"><a href="#5-3-4-Victim-Cache" class="headerlink" title="5.3.4 Victim Cache"></a>5.3.4 Victim Cache</h3><ol>
<li>基本思想<ul>
<li>在 Cache 和它从下一级存储器调数据的通路之间设置一个全相联的小 Cache ，用于存放被替换出去的块 (称为 Victim)，以备重新使用。</li>
<li>当颠簸发生时，被调出去的块很快就要被重新调入，那么从外存中重新写回到内存很浪费时间，于是就增加了一个小 Cache，减少颠簸对系统性能的影响</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Victim%20Cache.png" alt="Victim Cache"></p>
<ol>
<li>作用<ul>
<li>对于减小冲突失效很有效，特别是对于小容量的直接映象数据 Cache ，作用尤其明显。例如，项数为 4 的 Victim Cache: 使 4KB Cache 的冲突失效减少 20% ～ 90%</li>
<li>开销大。不仅需要 Cache 所需的一切硬件和布线，并且如果在 Victim Cache 中找到数据，而在数据 Cache 中没有找到，还要进行交换，因为此时 Victim Cache 中的数据局部性更好</li>
</ul>
</li>
</ol>
<h3 id="5-3-5-伪相联-Cache"><a href="#5-3-5-伪相联-Cache" class="headerlink" title="5.3.5 伪相联 Cache"></a>5.3.5 伪相联 Cache</h3><p>取直接映象及组相联两者的优点：命中时间小，失效率低<br>缺点 :多种命中时间会使 CPU 流水线的设计复杂化，时钟周期要按照较慢的过程执行时间为标准，降低了计算机整体的性能</p>
<p>这里并不是真的是两路组相联，只是每次查找有两次选择，用指针相连，这样就不用经过多路选择器了。</p>
<p>(1) 基本思想及工作原理</p>
<ul>
<li>在逻辑上把直接映象 Cache 的空间上下平分为两个区。对于任何一次访问，伪相联 Cache 先按直接映象 Cache 的方式去处理。若命中，则其访问过程与直接映象 Cache 的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器。</li>
</ul>
<p>(2) 快速命中与慢速命中</p>
<ul>
<li>要保证绝大多数命中都是快速命中，将命中概率较高的块交换到主位上</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/伪相联.png" alt="伪相联"></p>
<h3 id="5-3-6-硬件预取技术"><a href="#5-3-6-硬件预取技术" class="headerlink" title="5.3.6 硬件预取技术"></a>5.3.6 硬件预取技术</h3><ol>
<li>指令和数据都可以预取</li>
<li>预取内容既可放入 Cache ，也可放在外缓冲器中，例如：指令流缓冲器</li>
<li>预取效果</li>
</ol>
<p>(1) Joppi 的研究结果</p>
<ul>
<li>指令预取： (4KB ，直接映象 Cache, 块大小＝16 字节)<ul>
<li>1 个块的指令流缓冲器： 捕获 15%～25%的失效</li>
<li>4 个块的指令流缓冲器： 捕获 50%</li>
<li>16 个块的指令流缓冲器：捕获 72%</li>
</ul>
</li>
<li>数据预取： (4KB, 直接映象 Cache)<ul>
<li>1 个数据流缓冲器：捕获 25% 的失效，还可以采用多个数据流缓冲器<br>(2) Palacharla 和 Kessler 的研究结果</li>
</ul>
</li>
<li>流缓冲器：既能预取指令又能预取数据</li>
<li>对于两个 64KB 四路组相联 Cache 来说：8 个流缓冲器能捕获 50%～70%的失效</li>
</ul>
<h3 id="5-3-7-由编译器控制的预取"><a href="#5-3-7-由编译器控制的预取" class="headerlink" title="5.3.7 由编译器控制的预取"></a>5.3.7 由编译器控制的预取</h3><p>由编译器加入预取指令，在数据被用到之前发出预取请求。</p>
<ol>
<li>预取的类型</li>
</ol>
<ul>
<li>寄存器预取：把数据取到寄存器中</li>
<li>Cache 预取： 只将数据取到 Cache 中</li>
<li>故障性预取：预取时，若出现虚地址故障或违反访问权限，就会发生异常</li>
<li>非故障性预取：预取时，若出现虚地址故障或违反访问权限，并不会导致异常，只是转变为“不预取”</li>
</ul>
<ol>
<li>在预取数据的同时，处理器应能继续执行，只有这样，预取才有意义。</li>
</ol>
<ul>
<li>非阻塞 Cache (非锁定 Cache)<ul>
<li>Cache 可以接受多个读写请求，当 CPU 在访问 Cache 时，同时还能对 Cache 进行预取</li>
</ul>
</li>
</ul>
<ol>
<li><strong>循环是预取优化的主要对象</strong></li>
</ol>
<ul>
<li>失效开销小时：循环体展开 1～2 次</li>
<li>失效开销大时：循环体展开许多次</li>
</ul>
<p><strong>例 5.7</strong> 对于下面的程序，判断哪些访问可能会导致数据 Cache 失效。然后，加入预取指令以减少失效。最后，计算所执行的预取指令的条数以及通过预取避免的失效次数。假定：<br>(1) 我们用的是一个容量为 8KB、块大小为 16B 的直接映象 Cache，它采用写回法并且按写分配。<br>(2) a、b 分别为 3×100(3 行 100 列)和 101×3 的双精度浮点数组，每个元素都是 8 个字节。当程序开始执行时，这些数据都不在 Cache 内。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">    a[i][j] = b[j][<span class="number">0</span>] * b[j + <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p>
<p><strong>[分析]</strong></p>
<ol>
<li>首先可以得到数组 a 有 3*100=300 个元素，每个块为 16B，一个元素为 8B，因此一个块能放 2 个元素。所以数组 a 的 300 个元素要失效 300/2=150 次</li>
<li>数组 b 没有空间局部性，因为他是按照列访问的。但是却具有较好的时间局部性：</li>
</ol>
<ul>
<li>对于 i 的循环，每次 b 都访问同一个元素</li>
<li>对于 j 的循环，b 的每次访问都会有一个和上一次访问重复的元素</li>
<li>因此数组 b 失效 101 次，如下图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/数组b的时间局部性.png" alt="数组b的时间局部性"></p>
<p>综上，在没有指令预取时，这个循环引起的数据 Cache 失效次数为 150+101=251 次</p>
<ol>
<li>指令预取<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先展开 i = 0 这一层循环</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">prefetch</span>(b[j + <span class="number">7</span>][<span class="number">0</span>]);    <span class="comment">//预取7次循环后所需的b(j,0)</span></span><br><span class="line">  <span class="built_in">prefetch</span>(a[<span class="number">0</span>][j + <span class="number">7</span>]);    <span class="comment">//预取7次循环后所需的a(0,j)</span></span><br><span class="line">  a[<span class="number">0</span>][j] = b[j][<span class="number">0</span>] * b[j + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">prefetch</span>(a[i][j + <span class="number">7</span>]);  <span class="comment">//预取7次循环后所需的a(i,j)</span></span><br><span class="line">    a[i][j] = b[j][<span class="number">0</span>] * b[j + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/没有被预取的数据.png" alt="没有被预取的数据"></li>
</ol>
<p>将 i = 0 展开是为了预取 b 数组，因为 b 数组只用到了第一列。<br>然后在七次循环之后（七次循环是一个比较合适的次数）预取数组 a 的元素，这样一共失效 12 + 7 = 19 次，远远小于没有指令预取时的 251 次。</p>
<p><strong>例 5.8</strong> 在以下条件下，计算例 5.7 中所节约的时间：<br>(1) 假设预取可以被重叠或与 Cache 失效重叠执行，从而能以最大的存储带宽传送数据。<br>(2) 不考虑 Cache 失效时，修改前的循环每 7 个时钟周期循环一次。修改后的程序中，第一个预取循环每 9 个时钟周期循环一次，而第二个预取循环每 8 个时钟周期循环一次(包括外层 for 循环的开销) 。<br>(3) 1 次失效需 100 个时钟周期<br><strong>[分析]</strong></p>
<ol>
<li>修改前</li>
</ol>
<ul>
<li>循环时间：300 * 7 = 2100</li>
<li>失效开销：251 * 100 = 25100</li>
<li>总时间：2100 + 25100 = 27200</li>
</ul>
<ol>
<li>修改后</li>
</ol>
<ul>
<li>循环时间：100 <em> 9 + 200 </em> 8 = 2500</li>
<li>失效时间：(4 + 7) <em> 100 + 8 </em> 100 = 1900（一共失效 19 次）</li>
<li>总时间：2500 + 1900 = 4400</li>
<li>加速比：27200 / 4400 = 6.2</li>
</ul>
<h3 id="5-3-8-编译器优化"><a href="#5-3-8-编译器优化" class="headerlink" title="5.3.8 编译器优化"></a>5.3.8 编译器优化</h3><ol>
<li>基本思想<br>在编译时，对程序中的指令和数据进行重新组织，以降低 Cache 失效率</li>
<li>McFaring 发现：通过对指令进行重新排序，可有效地降低指令 Cache 的失效率</li>
<li>数据对存储位置的限制比指令的少，因此更便于优化通过把数据重新组织，使一块数据被从 Cache 替换出去之前，能最大限度利用其中的数据(访问次数最多)</li>
</ol>
<h4 id="1-数组合并"><a href="#1-数组合并" class="headerlink" title="1. 数组合并"></a>1. 数组合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="type">int</span> val [SIZE];</span><br><span class="line"><span class="type">int</span> key [SIZE];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">merge</span> &#123;</span><br><span class="line">  <span class="type">int</span> val ;</span><br><span class="line">  <span class="type">int</span> key ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">merge</span> merged_array[size];</span><br></pre></td></tr></table></figure>
<p>在没有优化之前，<code>val</code> 和 <code>key</code> 单独定义，这样在内存中就不是连续存放，这样空间局部性就差了。优化之后两个数组在内存中实现连续存放，提高了空间局部性。</p>
<h4 id="2-内外循环交换"><a href="#2-内外循环交换" class="headerlink" title="2. 内外循环交换"></a>2. 内外循环交换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    x[i][j] = <span class="number">2</span> * x[i][j];</span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++)</span><br><span class="line">    x[i][j] = <span class="number">2</span> * x[i][j];</span><br></pre></td></tr></table></figure>
<p>这个例子不用过多解释了，计组里面计算 Cache 失效率经常用的例子，就是数组按行存放，但是按列读取，增加了 Cache 的失效率</p>
<h4 id="3-循环融合"><a href="#3-循环融合" class="headerlink" title="3. 循环融合"></a>3. 循环融合</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    a[i][j] = <span class="number">1</span> / b[i][j] * c[i][j];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    d[i][j] = a[i][j] + c[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    a[i][j] = <span class="number">1</span> / b[i][j] * c[i][j];</span><br><span class="line">    d[i][j] = a[i][j] + c[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看修改前的两次循环，第一次循环中用到了 a，c 数组，满足了空间局部性，但是第二次循环中仍然用到了 a，c 两个数组，并且都是读取，于是就要把刚刚的循环再来一遍，没有利用好时间局部性，降低了整体效率，也增加了 Cache 失效率。<br>解决方法就是将两次循环合并起来。</p>
<h4 id="4-分块"><a href="#4-分块" class="headerlink" title="4. 分块"></a>4. 分块</h4><p>把对数组的整行或整列访问改为按块进行<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改前</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">      r = r + y[i][k] * z[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">    x[i][j] = r;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>失效次数：$2N^3+N^2$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="keyword">for</span> (jj = <span class="number">0</span>; jj &lt; N; jj += B) </span><br><span class="line">  <span class="keyword">for</span> (kk = <span class="number">0</span>; kk &lt; N; kk += B)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      <span class="keyword">for</span> (j = jj; j &lt; <span class="built_in">min</span>(jj + B - <span class="number">1</span>, N); j++) &#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = kk; k &lt; <span class="built_in">min</span>(kk + B - <span class="number">1</span>, N); k++) &#123;</span><br><span class="line">          r = r + y[i][k] * z[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        x[i][j] = r;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>失效次数：$(N/B)×(N/B)×N×2B+N^2= 2N^3/B+N^2$</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/编译器优化：分块.png" alt="编译器优化：分块"></p>
<p>（问号脸？？上面这些略过吧，我觉得现在没人这样写代码了）</p>
<h2 id="5-4-减少-Cache-失效开销"><a href="#5-4-减少-Cache-失效开销" class="headerlink" title="5.4 减少 Cache 失效开销"></a>5.4 减少 Cache 失效开销</h2><h3 id="5-4-1-写缓冲及写合并"><a href="#5-4-1-写缓冲及写合并" class="headerlink" title="5.4.1 写缓冲及写合并"></a>5.4.1 写缓冲及写合并</h3><ul>
<li>写直达 Cache 中，因为所有的写请求都必须发送到下级存储层次中，所以经常使用一个写缓冲来降低失效开销</li>
<li>如何提高写缓冲的效率和利用率——写合并</li>
<li>在写回法 Cache 中，也可采用写缓冲器</li>
</ul>
<h3 id="5-4-2-让读失效优先于写"><a href="#5-4-2-让读失效优先于写" class="headerlink" title="5.4.2 让读失效优先于写"></a>5.4.2 让读失效优先于写</h3><ul>
<li>Cache 中的写缓冲器导致对存储器访问的复杂化</li>
<li>解决问题的方法（读失效的处理）<ul>
<li>推迟对读失效的处理直到写缓冲排空（缺点：读失效的开销增加）</li>
<li>检查写缓冲器的中的内容：增加硬件</li>
</ul>
</li>
</ul>
<h3 id="5-4-3-子块放置技术"><a href="#5-4-3-子块放置技术" class="headerlink" title="5.4.3 子块放置技术"></a>5.4.3 子块放置技术</h3><ul>
<li>当一个块比较大的时候，可能需要多次访存，如果失效的话，失效开销会很大。如果当失效的时候，将 Cache 块划分成更小的块（子块），并给每个子块赋予一位有效位，用于指明该子块中的数据是否有效<ul>
<li>但是块变小了，程序局部性可能没有以前好，失效率可能会增加</li>
</ul>
</li>
<li>Cache 与下一级存储器之间以子块为单位传送数据，但标识仍以块为单位</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/直接映像Cache中的子块.png" alt="直接映像Cache中的子块"></p>
<h3 id="5-4-4-请求字处理技术"><a href="#5-4-4-请求字处理技术" class="headerlink" title="5.4.4 请求字处理技术"></a>5.4.4 请求字处理技术</h3><ol>
<li>请求字<ul>
<li>从下一级存储器调入 Cache 的块中，只有一个字是立即需要的，这个字称为请求字</li>
<li>实际上 CPU 请求的数据并不是整个 Cache 块，而是块内的某个字或字节</li>
</ul>
</li>
<li>应尽早把请求字发送给 CPU<ul>
<li>尽早重启动：调块时，从块的起始地址开始读，一旦请求字到达，就立即发送给 CPU，让 CPU 继续执行</li>
<li>请求字优先：调块时，从请求字所在的位置读起，这样第一个读出的字便是请求字，将其立即发送个 CPU</li>
</ul>
</li>
<li>这种技术在以下情况下效果不大：</li>
</ol>
<ul>
<li>Cache 块较小</li>
<li>下一条指令正好访问同一 Cache 块的另一部分</li>
</ul>
<h3 id="5-4-5-多级-Cache"><a href="#5-4-5-多级-Cache" class="headerlink" title="5.4.5 多级 Cache"></a>5.4.5 多级 Cache</h3><ul>
<li>应把 Cache 做得更快？还是更大？<ul>
<li>二者兼顾：再增加一级 Cache：<ul>
<li>第一级 Cache(L1)小而快</li>
<li>第二级 Cache(L2)容量大</li>
</ul>
</li>
</ul>
</li>
<li>性能分析<ul>
<li>平均访问时间=L1命中开销+L1失效率*L1失效开销</li>
<li>其中L1失效开销=L2命中时间+L2失效率*L2失效开销</li>
</ul>
</li>
<li>局部失效率和全局失效率<ul>
<li>局部失效率=该级 Cache 的失效次数/到达该级 Cache 的访问次数，如上述式子中的失效率L2</li>
<li>全局失效率=该级 Cache 的失效次数/CPU 发出的访存次数</li>
<li>全局失效率为各级 Cache 局部失效率的乘积</li>
<li>评价多级 Cache 时，应使用全局失效率这个指标</li>
<li>当第二级 Cache 比第一级 Cache 大得多时，两级 Cache 的全局失效率与容量和第二级 Cache 相同的单级 Cache 的失效率非常接近</li>
</ul>
</li>
<li>第二级 Cache 的参数<ul>
<li>第二级 Cache 不会影响 CPU 的时钟频率，因此其设计有更大的考虑空间</li>
<li>两个问题：<ul>
<li>能否降低 CPI 中的平均访存时间部分？</li>
<li>成本是多少？</li>
</ul>
</li>
<li>(1) 容量：第二级 Cache 的容量一般比第一级的大许多，如 512KB</li>
<li>(2) 相联度：第二级 Cache 可采用较高的相联度或伪相联</li>
</ul>
</li>
</ul>
<p><strong>例 5.12</strong><br>给出有关第二级 Cache 的以下数据：<br>⑴ 对于直接映象，命中时间 L2=10 个时钟周期<br>⑵ 对于两路组相联，命中时间增加 10%×CPU 时钟周期<br>⑶ 对于直接映象，局部失效率 L2=25%<br>⑷ 对于两路组相联，局部失效率 L2=20%<br>⑸ 失效开销 L2=50 个时钟周期<br>试问第二级 Cache 的相联度对失效开销的影响如何？</p>
<p><strong>[分析]</strong> </p>
<ul>
<li>对于直接映像的第二级 Cache 来说，第一级 Cache 失效开销为：10 + 25% * 50 = 22.5 个时钟周期</li>
<li><p>对于两路组相联来说，命中时间增加了 10% 个时钟周期，因此第一级 Cache 失效开销为：10 + 10 <em> 10% + 20% </em> 50 = 20.1 个时钟周期，将命中时间取整（10或11），得到失效开销为 20 或 21 个时钟周期</p>
<ul>
<li>(3) 块大小：第二级 Cache 可采用 大的块，如64、128、256 字节。为减少平均访问时间，可以让容量较小的第一级 Cache 采用较小的块，而让容量较大的第二级 Cache 采用较大的块</li>
</ul>
</li>
</ul>
<h3 id="5-4-6-非阻塞-Cache-技术"><a href="#5-4-6-非阻塞-Cache-技术" class="headerlink" title="5.4.6 非阻塞 Cache 技术"></a>5.4.6 非阻塞 Cache 技术</h3><ul>
<li>非阻塞 Cache ： Cache 失效时仍允许 CPU 进行其它的命中访问。即允许“失效下命中” </li>
<li>进一步提高性能：多重失效下命中存储器必须能够处理多个失效</li>
<li>重叠失效个数对平均访问时间的影响</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/非阻塞Cache技术.png" alt="非阻塞Cache技术"></p>
<h2 id="5-5-减少命中时间"><a href="#5-5-减少命中时间" class="headerlink" title="5.5 减少命中时间"></a>5.5 减少命中时间</h2><h3 id="5-5-1-采用容量小、结构简单的-Cache"><a href="#5-5-1-采用容量小、结构简单的-Cache" class="headerlink" title="5.5.1 采用容量小、结构简单的 Cache"></a>5.5.1 采用容量小、结构简单的 Cache</h3><ul>
<li>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是 Cache 的访问时间限制了处理器的时钟频率</li>
<li>硬件越简单，速度就越快</li>
<li>应该使 Cache 足够小，以便可以与 CPU 放在同一块芯片上，如果放在 CPU 外面，内部总线的延迟会增加</li>
</ul>
<h3 id="5-5-2-虚拟-Cache"><a href="#5-5-2-虚拟-Cache" class="headerlink" title="5.5.2 虚拟 Cache"></a>5.5.2 虚拟 Cache</h3><ul>
<li>虚拟 Cache <ul>
<li>背景：现代计算机几乎都使用虚拟存储技术，程序运行时都是将虚拟地址转化成物理地址再执行</li>
<li>检查 Cache 是否命中首先要将虚拟地址转化成物理地址，然后在 Cache 中找到组号，比较 tag，看是否命中</li>
<li>虚拟 Cache 希望能够仅通过虚拟地址访问 Cache 索引，其中 Cache 的索引以及 Cache 中的标识都是虚拟地址(一部分)</li>
</ul>
</li>
<li>并非都采用虚拟 Cache 的原因<ul>
<li>因为许多进程运行时，有大量虚拟地址可能重叠，若当前进程的数据按照虚拟地址写入虚拟 Cache，当下一个进程运行时，要<strong>清空虚拟 Cache</strong>，否则取到的就是上一个进程的数据，而清空虚拟 Cache 很耗时</li>
</ul>
</li>
<li>虚拟 Cache 的清空问题<ul>
<li>解决办法：在地址标识字段中增加 PID 字段（进程 ID）</li>
<li>PIDs 与单进程相比：时间开销增加 0.3%~0.6%</li>
<li>PIDs 与清空相比：时间开销减少 0.6%~4.3%<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/虚拟Cache失效率.png" alt="虚拟Cache失效率"></li>
</ul>
</li>
<li>同义/别名问题<ul>
<li>多个虚拟地址对应同一个物理地址<ul>
<li>若两个进程共享同一块物理地址，两个程序中对应的虚拟地址是不同的</li>
</ul>
</li>
<li>解决方法：反别名法，页着色</li>
<li>具体略</li>
</ul>
</li>
<li><p>虚拟索引+物理标识</p>
<ul>
<li>利用虚拟地址找到索引读 Cache，同时进行虚实地址转换：前提是虚拟索引=物理索引</li>
<li>而页内位移在虚实地址变换时不变，可以将索引 index 放在页内偏移中</li>
<li>优点：兼得虚拟 Cache 和物理 Cache 的好处</li>
<li>局限性：Cache 容量受限于<strong>页大小*相联度</strong></li>
<li>举例：IBM3033 的 Cache，页大小＝ 4KB，相联度＝16<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/虚拟索引+物理标识举例.png" alt="虚拟索引+物理标识举例"></li>
</ul>
</li>
<li><p>另一种方法：硬件散列变换（不展开）</p>
</li>
</ul>
<h3 id="5-5-3-写操作流水化"><a href="#5-5-3-写操作流水化" class="headerlink" title="5.5.3 写操作流水化"></a>5.5.3 写操作流水化</h3><p>设置延迟写缓冲器</p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/写操作流水化.png" alt="写操作流水化"></p>
<h3 id="5-5-4-Cache优化技术总结"><a href="#5-5-4-Cache优化技术总结" class="headerlink" title="5.5.4 Cache优化技术总结"></a>5.5.4 Cache优化技术总结</h3><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Cache优化技术总结（1）.png" alt="Cache优化技术总结（1）"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Cache优化技术总结（2）.png" alt="Cache优化技术总结（2）"></p>
<p>[注]：+ 表示对某方面产生有利影响，- 表示不利影响</p>
<h2 id="5-6-主存"><a href="#5-6-主存" class="headerlink" title="5.6 主存"></a>5.6 主存</h2><ul>
<li>存储层次的性价比特征<ul>
<li>速度越快，每位价格就越高</li>
<li>容量越大，每位价格就越低</li>
<li>容量越大，速度越慢</li>
</ul>
</li>
<li>寄存器访问（M1），Cache访问（M2），存储器访问（M3），磁盘存储器访问（M4）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">寄存器</th>
<th style="text-align:center">Cache</th>
<th style="text-align:center">主存</th>
<th>磁盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>典型大小</td>
<td style="text-align:center">&lt;1KB</td>
<td style="text-align:center">&lt;16MB</td>
<td style="text-align:center">&lt;512G</td>
<td>&gt;1TB</td>
</tr>
<tr>
<td>实现技术</td>
<td style="text-align:center">定制多端口存储器，CMOS</td>
<td style="text-align:center">片上或片外CMOS SRAM</td>
<td style="text-align:center">CMOS DRAM</td>
<td>磁介质盘</td>
</tr>
<tr>
<td>访问时间（ns）</td>
<td style="text-align:center">0.25-0.5</td>
<td style="text-align:center">0.5-25</td>
<td style="text-align:center">50-250</td>
<td>5,000,000</td>
</tr>
<tr>
<td>带宽（MB/s）</td>
<td style="text-align:center">50,000-500,000</td>
<td style="text-align:center">5000-20,000</td>
<td style="text-align:center">2500-10,000</td>
<td>50-500</td>
</tr>
<tr>
<td>管理</td>
<td style="text-align:center">编译器</td>
<td style="text-align:center">硬件</td>
<td style="text-align:center">操作系统</td>
<td>操作系统和用户</td>
</tr>
<tr>
<td>后备</td>
<td style="text-align:center">Cache</td>
<td style="text-align:center">主存</td>
<td style="text-align:center">磁盘</td>
<td>CD或磁带</td>
</tr>
</tbody>
</table>
</div>
<p><strong>主存的主要性能指标：延迟和带宽</strong></p>
<ul>
<li>以往：Cache 主要关心延迟，I/O 主要关心带宽</li>
<li>现在：Cache 关心两者</li>
</ul>
<p>本节讨论几种提高主存性能的存储器组织技术在下面的讨论中，以处理 Cache 失效为开销例来说明各种存储器组织结构的好处。</p>
<ul>
<li>为了减少失效开销 $T_M$，应该：<ul>
<li>减少主存延迟</li>
<li>提高主存带宽</li>
</ul>
</li>
<li>增加 Cache 块大小能利用主存带宽增加所来的好处 </li>
<li>==假设基本存储器结构性能为：==<ul>
<li>送地址需要 4 个时钟周期</li>
<li>每个字的访问时间为 24 个时钟周期</li>
<li>传送一个字的数据需要 4 个时钟周期</li>
<li>如果 Cache 大小为 4 个字，则：失效开销为4*(4+24+4)=128 时钟周期</li>
<li>带宽 = 16 / 128 = 0.0125(字节/时钟周期)</li>
</ul>
</li>
</ul>
<h3 id="5-6-1-存储器组织技术"><a href="#5-6-1-存储器组织技术" class="headerlink" title="5.6.1 存储器组织技术"></a>5.6.1 存储器组织技术</h3><h4 id="1-增加存储器的宽度"><a href="#1-增加存储器的宽度" class="headerlink" title="1. 增加存储器的宽度"></a>1. 增加存储器的宽度</h4><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/增加存储器宽度.png" alt="增加存储器宽度"></p>
<ul>
<li>性能分析（按照之前的假设）<ul>
<li>当宽度为 4 个字时，失效开销为 1 * 32 = 32 时钟周期，带宽 = 0.5 (字节/时钟周期)</li>
</ul>
</li>
<li>缺点<ul>
<li>增加 CPU 和存储器之间的连接通路宽度</li>
<li>CPU 和 Cache 之间有一个多路选择器，增加了硬件开销，使得在关键路径上的时间开销增加</li>
<li>扩充主存的最小增量增加了相应的倍数</li>
<li>写入有可能变得复杂</li>
<li>实例： DEC 的 Alpha Axp21064 ：256 位宽</li>
</ul>
</li>
</ul>
<h4 id="2-采用简单的多体交叉存储器"><a href="#2-采用简单的多体交叉存储器" class="headerlink" title="2. 采用简单的多体交叉存储器"></a>2. 采用简单的多体交叉存储器</h4><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/采用简单的多体交叉存储器.png" alt="采用简单的多体交叉存储器"></p>
<p>在多体交叉存储器中，存储系统采用多个 DRAM，利用他们潜在的<strong>并行性</strong>，他们可以同时工作，但是向 Cache 传送数据的通路不变，是比较窄的，只有一个送地址部件</p>
<p><strong>高位交叉与低位交叉编址</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/高位交叉与低位交叉编址.png" alt="高位交叉与低位交叉编址"></p>
<p><strong>低位交叉编址</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/低位交叉编址.png" alt="低位交叉编址"></p>
<p>能够很好的利用其并行性</p>
<p><strong>高位交叉编址</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/高位交叉编址.png" alt="高位交叉编址"></p>
<p>无法利用其并行性</p>
<p>那么如何充分发挥多体交叉的并行性呢？</p>
<p><strong>1. 同时启动</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/同时启动.png" alt="同时启动"></p>
<p>前提：要取的存储体内的字必须是同一个偏移地址</p>
<p><strong>2. 分时启动</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/分时启动.png" alt="分时启动"></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/分时启动2.png" alt="分时启动2"></p>
<ul>
<li>性能分析（参照之前的假设）<ul>
<li>失效开销 = 4 + 24 + 4 * 4 = 44 时钟周期（低位交叉编址 4 个字可同时取出，但是写进 Cache 还是要按字节写入，因为存储体和 Cache 之间的总线宽度仍然是一个字）</li>
<li>带宽 = 0.4 （字节/时钟周期）</li>
</ul>
</li>
<li>存储器的各个体一般是按照字交叉，低位字交叉存储器非常适合处理 Cache 读失效，写回法 Cache 中的写回</li>
</ul>
<p><strong>例 5.14</strong><br>假设某台机器的特性及其 Cache 的性能为：<br>· 块大小为 1 个字<br>· 存储器总线宽度为 1 个字（32 位）<br>· Cache 失效率为 3 %<br>· 平均每条指令访存 1.2 次<br>· Cache 失效开销为 32 个时钟周期 (和上面相同)<br>· 平均 CPI(忽略 Cache 失效) 为 2<br>试问多体交叉和增加存储器宽度对提高性能各有何作用？</p>
<p>如果当把 Cache 块大小变为 2 个字时，失效率降为 2%；块大小变为 4 个字时，失效率降为 1%。根据 5.6.2 小节中给出的访问时间，求在采用 2 路、4 路多体交叉存取以及将存储器和总线宽度增加一倍时，性能分别提高多少？</p>
<p><strong>[分析]</strong></p>
<ul>
<li>在改变前的机器中，Cache 块大小为一个字，其 CPI 为：2 + (1.2 <em> 3% </em> 32) = 3.15</li>
<li>将块大小增加为 2 个字时，在下面三种情况下的 CPI 分别为<ul>
<li>32 位总线和存储器，不采用多体交叉 CPI = 2 + (1.2 <em> 2% </em> 2 <em> 32) = 3.54 （公式里的 </em>2 是因为 32 位总线和存储器传送 2 个字失效时需要传送两次）</li>
<li>32 位总线和存储器，采用多体交叉 CPI = 2 + (1.2 <em> 2% </em> (4 + 24 + 8)) = 2.86（多体交叉传送地址需要 4 个周期，数据取出来要 24 个周期，总线宽度只有一个字，传送一个字要 4 个时钟周期，传送两个字则是 8 个时钟周期） <strong>性能提高了 10%</strong></li>
<li>64 位总线和存储器，不采用多体交叉 CPI = 2 + (1.2 <em> 2% </em> 1 <em> (4 + 24 + 4)) = 2.77（64 字节为两个字，读一次即可，故失效开销为 32 个时钟周期）<em>*性能提高了14%</em></em></li>
</ul>
</li>
<li>如果将块大小增加到 4 个字，则：<ul>
<li>32 位总线和存储器，不采用多体交叉 CPI = 2 + (1.2 <em> 1% </em> 4 * 32) = 3.54 （传送四次）</li>
<li>32 位总线和存储器，采用多体交叉 CPI = 2 + (1.2 <em> 1% </em> (4 + 24 + 16)) = 2.53（多体交叉传送地址需要 4 个周期，数据取出来要 24 个周期，总线宽度只有一个字，传送一个字要 4 个时钟周期，传送四个字则是 16 个时钟周期） <strong>性能提高了 25%</strong></li>
<li>64 位总线和存储器，不采用多体交叉 CPI = 2 + (1.2 <em> 1% </em> 2 <em> (4 + 24 + 4)) = 2.77（64 字节为两个字，读两次，每次失效开销为 32 个时钟周期）<em>*性能提高了14%</em></em></li>
</ul>
</li>
</ul>
<p>在采用简单的多体交叉存储器时，体的数目 ≥ 访问体中一个字所需的时钟周期</p>
<h4 id="3-独立存储体"><a href="#3-独立存储体" class="headerlink" title="3. 独立存储体"></a>3. 独立存储体</h4><p>设置多个存储控制器，使多个体能独立操作，以便能同时进行多个独立的访存</p>
<ul>
<li>每个体有独立的地址线</li>
<li>非阻塞 Cache 与多体结构<ul>
<li>Cache 失效时仍允许 CPU 进行其它的访存。这样的设计对于独立多体结构才有意义</li>
<li>IO 访存</li>
</ul>
</li>
<li>体和超体</li>
</ul>
<h3 id="5-6-2-存储器芯片技术"><a href="#5-6-2-存储器芯片技术" class="headerlink" title="5.6.2 存储器芯片技术"></a>5.6.2 存储器芯片技术</h3><h4 id="1-DRAM-与-SRAM"><a href="#1-DRAM-与-SRAM" class="headerlink" title="1. DRAM 与 SRAM"></a>1. DRAM 与 SRAM</h4><ul>
<li>容量： 4～8:1</li>
<li>存储周期： 8～16:1</li>
<li>价格： 1：8～16</li>
<li>一般来说：主存一般是DRAM，Cache一般是SRAM</li>
<li><p>Amdahl 经验规则：</p>
<ul>
<li>为了保持系统平衡，存储容量应随 CPU 速度的提高而线性增加。（每 3 年增加 4 倍）</li>
</ul>
</li>
<li><p>各代 DRAM 的典型参数</p>
<ul>
<li>DIMM(dual inline memory modules)<ul>
<li>多个 DRAM 芯片经常被组装在称为条的小型板上，构成“双列直插式存储模块”。</li>
<li>一个 DIMM 通常包含 4~16 片 DRAM 芯片，这些芯片常被组织成 8 字节宽的主存(带 ECC 校验)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-DRAM-芯片优化技术"><a href="#2-DRAM-芯片优化技术" class="headerlink" title="2. DRAM 芯片优化技术"></a>2. DRAM 芯片优化技术</h4><ul>
<li>芯片内部优化技术是提高主存系统性能的一个重要方面</li>
<li>快页模式：内部缓冲一行的数据以便进行列访问</li>
<li>SDRAM : Synchronous DRAM，DRAM 接口增加一个时钟信号可使 DRAM 能针对一个请求连续同步地传输多个数据而不需同步开销</li>
<li>DDR(Double Data Rate，双数据率)：在 DRAM 时钟的上沿和下沿都进行数据传输，可把数据传输率提高一倍。<br>现代 DRAM 的名称和性能</li>
</ul>
<p>总结：</p>
<ul>
<li>DDR 技术规定的标准电压为 2.5V ， DDR2 技术的电压将为 1.8V ，工作频率范围为 266MHz~400MHz，DDR3 的电压将为 1.5V，最大工作频率为 800MHz</li>
<li>存储器优化技术都是通过增加少量逻辑来开发 DRAM 内部潜在的高带宽，这种优化代价很小，却能使带宽显著提高</li>
</ul>
<h2 id="5-7-虚拟存储器"><a href="#5-7-虚拟存储器" class="headerlink" title="5.7 虚拟存储器"></a>5.7 虚拟存储器</h2><p>……系统被设计成将主存储器和后备存储器组合在一起，在程序员看来好像只有一级存储，必须进行的地址变换是自动完成的。<br>——Kilburn et al.(1962)</p>
<h3 id="5-7-1-虚拟存储器基本原理"><a href="#5-7-1-虚拟存储器基本原理" class="headerlink" title="5.7.1 虚拟存储器基本原理"></a>5.7.1 虚拟存储器基本原理</h3><p>虚存系统：</p>
<ul>
<li>由价格较贵、速度较快、容量较小的主存储器 M1 和一个价格低廉、速度较慢、容量很大的辅助存储器 M2(通常是硬盘)组成</li>
<li>在系统软件和辅助硬件的管理下，就象一个单一的、可直接访问的大容量主存储器</li>
<li>程序员可以用机器指令的地址码对整个程序统一编址，就如同应用程序员具有对应于这个地址码宽度的存储空间(称为程序空间)一样，而不必考虑实际主存空间的大小</li>
</ul>
<h4 id="1-虚拟存储器的特点"><a href="#1-虚拟存储器的特点" class="headerlink" title="1. 虚拟存储器的特点"></a>1. 虚拟存储器的特点</h4><ul>
<li>程序员可以利用巨大的逻辑空间，而不必做存储管理工作</li>
<li>多个进程可以共享主存空间</li>
<li>采用动态重定位，简化了程序的装入<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/虚拟存储器基本原理.png" alt="虚拟存储器基本原理"></li>
</ul>
<h4 id="2-虚存管理方式"><a href="#2-虚存管理方式" class="headerlink" title="2. 虚存管理方式"></a>2. 虚存管理方式</h4><p>分两类：页式和段式</p>
<ul>
<li>页式虚存把空间划分为大小相同的块，称为页<br>面。常用页大小为 4KB～64KB。</li>
<li>段式虚存把空间划分为可变长的块，称为段。<br>段最小长度为 1 个字节，最大因机器而异，常为 $2^{16}B～2^{32}B$。</li>
<li>页面是对空间的机械划分，而段则往往是按程序的逻辑意义进行划分</li>
</ul>
<p>采用页式虚存还是段式虚存对 CPU 有不同的影响</p>
<ul>
<li>页式虚存：地址是单一、固定长度的地址字，由页号和页内位移两部分组成</li>
<li>段式虚存：地址需要用两个字表示，一个为段号，另一个为段内位移。因为段的长度是可变的</li>
<li>段页式：每段被划分成若干个页面。既保持了段作为逻辑单位的优点，又简化了替换的实现，而且段不必作为整体全部一次调入主存，而是可以以页面为单位部分调入</li>
</ul>
<h4 id="3-存储层次中-Cache-和虚存的对比"><a href="#3-存储层次中-Cache-和虚存的对比" class="headerlink" title="3. 存储层次中 Cache 和虚存的对比"></a>3. 存储层次中 Cache 和虚存的对比</h4><ul>
<li>虚存处于“主存—辅存”层次</li>
<li>与“ cache——主存”层次的相似点<ul>
<li>都是分块方式： Cache 块、页、段</li>
<li>都有失效问题： Cache 块失效、页故障、地址故障</li>
</ul>
</li>
<li>与“cache——主存”层次的不同点<ul>
<li>失效替换：Cache 由硬件完成，虚存主要由 OS</li>
<li><strong>处理器地址大小决定虚存大小</strong>，但与 Cache 大小无关</li>
<li>辅存除用做主存的后备存储器外，还用于文件系统</li>
</ul>
</li>
</ul>
<h4 id="4-存储层次中-Cache-和虚存的典型指标"><a href="#4-存储层次中-Cache-和虚存的典型指标" class="headerlink" title="4. 存储层次中 Cache 和虚存的典型指标"></a>4. 存储层次中 Cache 和虚存的典型指标</h4><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/存储层次中Cache和虚存的典型指标.png" alt="存储层次中Cache和虚存的典型指标"></p>
<h4 id="5-有关虚拟存储器的四个问题"><a href="#5-有关虚拟存储器的四个问题" class="headerlink" title="5. 有关虚拟存储器的四个问题"></a>5. 有关虚拟存储器的四个问题</h4><ul>
<li>映像规则<ul>
<li>全相联。以降低失效率为主要目标，不在关键路径上，因此降低命中时间没那么重要了</li>
</ul>
</li>
<li>查找算法<ul>
<li>页表，段表，TLB</li>
<li>页表和段表：索引页号或段号的数据结构，含有所要查找的块的物理地址。</li>
<li>段式系统：段内位移加上段的物理地址就是最终的物理地址。</li>
<li>页式系统：只需简单地将页内位移拼接在相应页面的物理地址之后</li>
</ul>
</li>
<li>替换算法<ul>
<li>LRU。尽可能减少页故障，OS 为每个页面设置“使用位”</li>
</ul>
</li>
<li>写策略<ul>
<li>写回法</li>
</ul>
</li>
</ul>
<p>（具体例子和相关图片就不放了，计组和 OS 里面重点中的重点）</p>
<h3 id="5-7-2-快表-TLB"><a href="#5-7-2-快表-TLB" class="headerlink" title="5.7.2 快表 TLB"></a>5.7.2 快表 TLB</h3><ol>
<li>TLB （ Table Look-aside buffer ）</li>
</ol>
<ul>
<li>TLB 是一个专用的高速缓冲器，用于存放近期经常使用的页表项</li>
<li>TLB 中的内容是<strong>页表部分内容的一个副本</strong></li>
<li>TLB 也利用了局部性原理</li>
</ul>
<ol>
<li>Alpha Axp 21064 的地址转换过程</li>
<li>TLB 一般比 Cache 的标识存储器更小、更快</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/TLB.png" alt="Alpha Axp 21064 的地址转换过程"></p>
<h2 id="5-8-进程保护和虚存实例"><a href="#5-8-进程保护和虚存实例" class="headerlink" title="5.8 进程保护和虚存实例"></a>5.8 进程保护和虚存实例</h2><p>进程：程序呼吸所需的空气和生存的空间</p>
<h3 id="5-8-1-进程保护"><a href="#5-8-1-进程保护" class="headerlink" title="5.8.1 进程保护"></a>5.8.1 进程保护</h3><p><strong>1. 界地址寄存器</strong><br>基地址，上界地址<br>检测条件：（基地址 + 地址）≤上界地址<br><strong>2. 虚拟存储器</strong><br>给每个页面增加访问权限标识<br><strong>3. 环形保护</strong><br><strong>4. 加锁和解锁</strong></p>
<h3 id="5-8-2-页式虚存举例"><a href="#5-8-2-页式虚存举例" class="headerlink" title="5.8.2 页式虚存举例"></a>5.8.2 页式虚存举例</h3><p>Alpha Axp 的存储管理和 21064 的 TLB<br>Alpha Axp 体系结构采用段页相结合的方式</p>
<p><strong>1. Alpha 的地址空间分为 3 段</strong><br>kseg(地址最高两位：10) (内核)<br>sego(最高位：0) (用户)<br>seg1(最高两位：11) (用户)</p>
<p><strong>2. Alpha 采用三级页表</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Alpha机器中虚地址的变换过程.png" alt="Alpha机器中虚地址的变换过程"></p>
<p><strong>3. Alpha 的页表项</strong><br>（PTE，8 字节）</p>
<p><strong>4. Alpha Axp21064 TLB 的参数</strong></p>
<ul>
<li>块大小：1 PTE（8字节）</li>
<li>命中时间：1 个时钟周期</li>
<li>平均失效开销：20 个时钟周期</li>
<li>TLB 容量<ul>
<li>指令 TLB：8 个 PTE 用于大小为 8K 字节的页，4 个 PTE 用于大小为 4MB 的页（共 96 字节）</li>
<li>数据 TLB：32 个 PTE 用于大小为 8KB ，512KB 和 4MB 的页（共 256 字节）</li>
</ul>
</li>
<li>块替换策略：随机</li>
<li>写策略：不适用</li>
<li>块映像策略：全相联</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/Alpha-Axp21064%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="Alpha-Axp21064工作过程"></p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构课程笔记（二)</title>
    <url>/1f2e7710.html</url>
    <content><![CDATA[<h1 id="第四章-指令集并行"><a href="#第四章-指令集并行" class="headerlink" title="第四章 指令集并行"></a>第四章 指令集并行</h1><blockquote>
<p>国防科大计算机体系结构课程第四章笔记<br><span id="more"></span></p>
</blockquote>
<h2 id="4-1-指令集并行的概念"><a href="#4-1-指令集并行的概念" class="headerlink" title="4.1 指令集并行的概念"></a>4.1 指令集并行的概念</h2><ul>
<li>当指令之间不存在相关时，它们在流水线中是可以重叠起来并行执行的。这种指令序列中存在的潜在并行性称为指令级并行<ul>
<li>Instruction-Level Parallelism</li>
<li>简记为 ILP </li>
</ul>
</li>
<li>如何知道指令之间可以并行？硬、软件如何支持指令级并行？如何研究这些问题？<ul>
<li>硬件技术或者软件技术都可以提高指令级并行性</li>
<li>必须要硬件技术和软件技术互相配合，才能够最大限度地挖掘出程序中存在的指令级并行<br><strong>性能评价：CPI计算</strong></li>
</ul>
</li>
<li>流水线处理器的实际CPI（平均每条指令使用的周期数）等于理想流水线的CPI加上各类停顿引起的周期数的总和<br>CPI流水线 = CPI理想 + 停顿结构相关 + 停顿先写后读 + 停顿先读后写 + 停顿写后写 + 停顿控制相关</li>
<li>减少其中的任何一种停顿，都可以有效地减少CPI，从而提高流水线的性能 </li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/指令集并行的技术及克服的停顿.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>软件和硬件的支持</strong></p>
<ul>
<li>上述技术中有些技术主要是硬件支持<ul>
<li>循环展开</li>
<li>寄存器换名的动态调度（基本的Tomasulo’s）</li>
<li>动态分支指令预测</li>
<li>每个周期多发射</li>
<li>前瞻技术</li>
</ul>
</li>
<li>所有的技术都必须和软件，特别是编译器合作完成</li>
</ul>
<p><strong>几个基本概念</strong></p>
<ul>
<li>基本（程序）块：一段除了入口和出口以外不包含其它分支的线性代码段<ul>
<li>程序平均每6~7条指令就会有一个分支</li>
<li>必须在多个基本块之间开发指令级的并行性</li>
</ul>
</li>
<li>循环级并行：循环体中指令之间的并行性</li>
<li>开发循环级并行的基本技术方法<ul>
<li>指令调度（scheduling）</li>
<li>循环展开（loop unrolling）</li>
<li>换名（renaming）</li>
</ul>
</li>
</ul>
<h3 id="4-1-1-循环展开调度的基本方法"><a href="#4-1-1-循环展开调度的基本方法" class="headerlink" title="4.1.1 循环展开调度的基本方法"></a>4.1.1 循环展开调度的基本方法</h3><ul>
<li>循环展开是展开循环体若干次，将循环级并行转化为指令级并行的技术</li>
<li>这个过程既可以通过编译器静态完成，也可以通过硬件动态进行<ul>
<li>开发循环级并行性的另外一个重要技术是向量处理技术</li>
<li>具有向量处理指令的典型机器是向量计算机，有关向量处理和向量计算机的内容本章不作讨论</li>
</ul>
</li>
<li>本章中的分支指令就是指条件转移指令 </li>
</ul>
<p><strong>本章通用浮点流水线延迟表</strong></p>
<ul>
<li>编译器在完成这种指令调度时，受限于以下两个特性<ul>
<li>一是程序固有的指令级并行性</li>
<li>二是流水线功能部件的执行延迟</li>
</ul>
</li>
<li>本章中使用的<strong>浮点流水线的延迟</strong>如下表</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/通用浮点流水线延迟表.png" width="80%" style="margin: 0 auto">
</div>

<h4 id="流水线其他特性说明"><a href="#流水线其他特性说明" class="headerlink" title="流水线其他特性说明"></a>流水线其他特性说明</h4><ul>
<li>整数流水线采用改进的 MIPS 整数流水线<ul>
<li>由于数据的取操作的结果可以毫无停顿的通过相关通路机制传送到数据存部件，所以延迟为 0<ul>
<li>定向通道或旁路机制</li>
</ul>
</li>
</ul>
</li>
<li>分支指令，由整数流水线执行<ul>
<li>分支条件检测调整到 ID 段</li>
<li><strong>如果分支指令使用上一条指令的结果作为分支条件，将要延迟 1 节拍</strong></li>
<li>分支指令有 1 个节拍的延迟槽</li>
</ul>
</li>
<li>浮点运算一般为 64 位</li>
<li>无结构冒险</li>
</ul>
<h4 id="循环展开实例"><a href="#循环展开实例" class="headerlink" title="循环展开实例"></a>循环展开实例</h4><ul>
<li>对于下面的源代码，在不进行指令调度和进行指令调度两种情况下，分析代码一次循环的执行时间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) </span><br><span class="line">    x[i] = x[i] + s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>编译过程</strong></p>
<ul>
<li>每一遍循环之间是不存在相关的<ul>
<li>多遍循环可以同时执行而不会导致结果的错误</li>
</ul>
</li>
<li>变量分配寄存器<ul>
<li>整数寄存器 R1 用作循环计数器，初值为向量中最高端地址元素的地址</li>
<li>浮点寄存器 F2 用于保存常数 S</li>
<li>为简单起见，假定最低端元素的地址为8<ul>
<li>否则需要另外的指令来将它和R1做比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="MIPS汇编语言程序"><a href="#MIPS汇编语言程序" class="headerlink" title="MIPS汇编语言程序"></a>MIPS汇编语言程序</h4><p>程序转换成MIPS汇编语言程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Loop:   LD      F0, <span class="number">0</span>(R1)   ;F0为向量元素</span><br><span class="line">        ADDD    F4, F0, F2  ;加常数F2</span><br><span class="line">        SD      <span class="number">0</span>(R1), F4   ;保存结果</span><br><span class="line">        SUBI    R1, R1, #<span class="number">8</span>  ;修改指针</span><br><span class="line">        BNEZ    R1, Loop    ;循环控制</span><br></pre></td></tr></table></figure>
<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>硬件给编译器更大的空间和支持。编译器用寄存器来进行表达式计算、传递参数、存放变量。</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行（2）.png" width="80%" style="margin: 0 auto">
</div>

<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行（3）.png" width="80%" style="margin: 0 auto">
</div>

<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行（4）.png" width="80%" style="margin: 0 auto">
</div>

<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行（5）.png" width="80%" style="margin: 0 auto">
</div>

<div style="text-align: center;">
<img src="/1f2e7710/循环无调度执行（6）.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>循环无调度执行结果分析</strong></p>
<ul>
<li>每遍循环需要10个时钟节拍</li>
<li>只有3个时钟节拍(L.D, ADD.D, S.D)是有效的关键指令<ul>
<li>有效比率为 30%</li>
<li>空转5个时钟节拍 (50%)</li>
<li>循环控制2个时钟节拍 (20%)</li>
</ul>
</li>
<li>调度代码，减少空转</li>
<li><div style="text-align: center;">
<img src="/1f2e7710/循环调度执行.png" width="80%" style="margin: 0 auto">
</div>



</li>
</ul>
<p>经过调度后，一次循环仅需 6 个时钟周期便可以完成。</p>
<p><strong>如何进行调度</strong></p>
<ul>
<li>通过一个好的编译器来调度可以<ul>
<li>调换 SUBI 和 SD 的位置</li>
<li>将 SD 指令移到 BNEZ 的延迟槽内</li>
<li>改变 SD 存取指令访问内存地址的偏移量</li>
</ul>
</li>
</ul>
<p><strong>调度代码结果分析</strong></p>
<ul>
<li>每遍循环 6 个时钟节拍</li>
<li>和未调度代码比较，加速比 $10/6=1.7$</li>
<li>3个有效时钟节拍 (L.D, ADD.D, S.D)<ul>
<li>节拍有效比率 50%</li>
<li>1拍空转 (占17%)</li>
<li>2拍循环控制 (占33%)</li>
</ul>
</li>
<li>如何进一步减少空转和循环控制占用的比率?</li>
</ul>
<h4 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h4><p>如果将循环展开3次得到4个循环体(假设向量包含了4的倍数的元素)<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Loop:   L.D     F0,<span class="number">0</span>(R1)</span><br><span class="line">        ADD.D   F4,F0,F2</span><br><span class="line">        S.D     <span class="number">0</span>(R1),F4</span><br><span class="line">        L.D     F6,<span class="number">-8</span>(R1)</span><br><span class="line">        ADD.D   F8,F6,F2</span><br><span class="line">        S.D     <span class="number">-8</span>(R1), F8</span><br><span class="line">        L.D     F10,<span class="number">-16</span>(R1)</span><br><span class="line">        ADD.D   F12,F10,F2</span><br><span class="line">        S.D     <span class="number">-16</span>(R1), F12</span><br><span class="line">        L.D     F14,<span class="number">-24</span>(R1)</span><br><span class="line">        ADD.D   F16,F14,F2</span><br><span class="line">        S.D     <span class="number">-24</span>(R1), F16</span><br><span class="line">        DADDUI  R1,R1,#<span class="number">-32</span></span><br><span class="line">        BNE     R1,R2,Loop</span><br></pre></td></tr></table></figure><br><strong>执行时间分析</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Loop:   L.D     F0,<span class="number">0</span>(R1)        <span class="number">1</span></span><br><span class="line">        ADD.D   F4,F0,F2        <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">        S.D     <span class="number">0</span>(R1),F4        <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">        L.D     F6,<span class="number">-8</span>(R1)       <span class="number">7</span></span><br><span class="line">        ADD.D   F8,F6,F2        <span class="number">8</span>,<span class="number">9</span></span><br><span class="line">        S.D     <span class="number">-8</span>(R1), F8      <span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line">        L.D     F10,<span class="number">-16</span>(R1)     <span class="number">13</span></span><br><span class="line">        ADD.D   F12,F10,F2      <span class="number">14</span>,<span class="number">15</span></span><br><span class="line">        S.D     <span class="number">-16</span>(R1), F12    <span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span></span><br><span class="line">        L.D     F14,<span class="number">-24</span>(R1)     <span class="number">19</span></span><br><span class="line">        ADD.D   F16,F14,F2      <span class="number">20</span>,<span class="number">21</span></span><br><span class="line">        S.D     <span class="number">-24</span>(R1), F16    <span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span></span><br><span class="line">        DADDUI	R1,R1,#<span class="number">-32</span>      <span class="number">25</span></span><br><span class="line">        BNE     R1,R2,Loop      <span class="number">26</span>,<span class="number">27</span></span><br><span class="line">        stall                   <span class="number">28</span></span><br></pre></td></tr></table></figure><br><strong>结果分析</strong></p>
<ul>
<li>循环使用 28 个时钟节拍<ul>
<li>14 个空转节拍<ul>
<li>每个 L.D 有 1 个空转节拍 – 共 4 拍</li>
<li>每个 ADD.D 有 2 个空转节拍 - 共 8 拍</li>
<li>DADDUI 有 1 个空转节拍 - 共1拍</li>
<li>BRANCH 有 1 个空转节拍 - 共1拍</li>
</ul>
</li>
<li>有 14 个指令流出节拍</li>
</ul>
</li>
<li>每遍循环 7 个时钟节拍</li>
<li>共计使用 9 个寄存器</li>
<li>代码量增大</li>
</ul>
<h4 id="循环展开-指令调度"><a href="#循环展开-指令调度" class="headerlink" title="循环展开+指令调度"></a>循环展开+指令调度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Loop:   L.D     F0, <span class="number">0</span>(R1)</span><br><span class="line">        L.D     F6, <span class="number">-8</span>(R1)</span><br><span class="line">        L.D     F10, <span class="number">-16</span>(R1)</span><br><span class="line">        L.D     F14, <span class="number">-24</span>(R1)</span><br><span class="line">        ADD.D   F4, F0, F2</span><br><span class="line">        ADD.D   F8, F6, F2</span><br><span class="line">        ADD.D   F12, F10, F2</span><br><span class="line">        ADD.D   F16, F14, F2</span><br><span class="line">        S.D     <span class="number">0</span>(R1), F4</span><br><span class="line">        S.D     <span class="number">-8</span>(R1), F8</span><br><span class="line">        DADDUI	R1,R1, #<span class="number">-32</span></span><br><span class="line">        S.D     <span class="number">16</span>(R1), F12</span><br><span class="line">        BNE     R1, R2, Loop</span><br><span class="line">        S.D     <span class="number">8</span>(R1), F16</span><br></pre></td></tr></table></figure>
<p><strong>“循环展开+指令调度”结果分析</strong></p>
<ul>
<li>每遍循环时间下降为14个时钟节拍<ul>
<li>每个元素平均使用3.5个时钟节拍</li>
</ul>
</li>
<li>比较<ul>
<li>循环展开，没有指令调度<ul>
<li>每个元素7拍</li>
</ul>
</li>
<li>没有循环展开，有指令调度<ul>
<li>每个元素6拍</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>循环展开总结</strong></p>
<ul>
<li>对指令进行移动是有效的</li>
<li>展开是有用的</li>
<li>用不同的寄存器<ul>
<li>换名</li>
<li>更多的寄存器</li>
</ul>
</li>
<li>消除额外的测试开销</li>
<li>在循环展开时分析 LOAD/STORE 指令进行内存地址换名（动态地址具有不确定性，必须完全算出地址才能继续执行下面的代码，无法像静态地址那样可以预测）</li>
<li>保留真相关</li>
<li>不规整？</li>
</ul>
<h2 id="4-2-指令的动态调度"><a href="#4-2-指令的动态调度" class="headerlink" title="4.2 指令的动态调度"></a>4.2 指令的动态调度</h2><ul>
<li>编译器本质上通过对每个循环迭代中寄存器重命名来展开循环</li>
<li>硬件也可通过寄存器重命名和乱序执行来获得同样的效果</li>
<li>动态调度<ul>
<li>记分牌</li>
<li><code>Tomasulo’s</code> 算法</li>
</ul>
</li>
</ul>
<h3 id="4-2-1-冒险的检测和调度"><a href="#4-2-1-冒险的检测和调度" class="headerlink" title="4.2.1 冒险的检测和调度"></a>4.2.1 冒险的检测和调度</h3><ul>
<li>如果存在数据相关，硬件检测机制会做如下的事情直到相关消除动态调度<ul>
<li>暂停指令</li>
<li>停止取指令和发射指令</li>
</ul>
</li>
<li>静态调度（开始于60s，流行于80s）消除动态调度<ul>
<li>软件来负责调度指令减少空转</li>
</ul>
</li>
<li>动态调度<ul>
<li><strong>硬件</strong>对指令的执行重新排序来减少空转</li>
</ul>
</li>
</ul>
<p><strong>动态调度</strong></p>
<ul>
<li>动态调度的目的<ul>
<li>在程序执行的时候，解决WAW,WAR和RAW带来的冒险 </li>
</ul>
</li>
<li>优点：<ul>
<li>处理在编译的时候未知的相关，简化编译器</li>
<li>在不同的流水线上都能有效的运行</li>
</ul>
</li>
<li>缺点：<ul>
<li>很大地增加了硬件的复杂性</li>
</ul>
</li>
<li>两个动态调度技术<ul>
<li>记分牌</li>
<li><code>Tomasulo</code> 算法</li>
</ul>
</li>
</ul>
<h3 id="4-2-2-记分牌算法"><a href="#4-2-2-记分牌算法" class="headerlink" title="4.2.2 记分牌算法"></a>4.2.2 记分牌算法</h3><ul>
<li>记分牌 1964 被 Cray 用于 CDC 6600</li>
<li>记分牌允许指令乱序执行，前提：<ul>
<li>充足的资源，无数据相关</li>
<li>记分牌动态解决了<strong>写后读</strong>（RAW）相关</li>
<li>指令可以乱序执行</li>
</ul>
</li>
<li>基本原理<ul>
<li>每条指令均经过记分牌，记录各指令间数据相关的信息</li>
<li>如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从而决定何时能够执行</li>
</ul>
</li>
</ul>
<h4 id="记分牌处理"><a href="#记分牌处理" class="headerlink" title="记分牌处理"></a>记分牌处理</h4><ul>
<li>流水线 ID 段被分为两级<ul>
<li>流出——解析指令，检查结构相关</li>
<li>读操作数——直到不存在数据相关时，才读取操作数</li>
</ul>
</li>
<li>如果存在 WAR 或者 WAW 相关，记分牌会暂停这条指令的执行，直到相关消除后才继续执行</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/记分牌的结构.png" width="80%" style="margin: 0 auto">
</div>

<h4 id="记分牌执行过程"><a href="#记分牌执行过程" class="headerlink" title="记分牌执行过程"></a>记分牌执行过程</h4><ul>
<li>流出（Issue）<ul>
<li>本指令所需的功能部件有空闲</li>
<li>正在执行指令使用的目的寄存器与本指令不同<ul>
<li>保证 WAW 相关</li>
</ul>
</li>
</ul>
</li>
<li>读操作数（Read operands）<ul>
<li>前面已流出的还在运行的指令不对本指令的源操作数寄存器进行写操作</li>
<li>一个正在工作的功能部件已经完成了对这个寄存器的写操作</li>
<li>动态解决 RAW 相关</li>
</ul>
</li>
<li>前面两步完成了原来ID段的功能</li>
<li>执行（Execution）<ul>
<li>开始于取到操作数后</li>
<li>当结果产生后，修改记分牌</li>
<li>FP 流水部件会占用多个周期</li>
</ul>
</li>
<li>写结果（Write result）：检查 WAR 相关</li>
<li>出现以下情况时，不允许指令写结果：<ul>
<li>前面的某条指令还没有读取操作数</li>
<li>其中某个源操作数寄存器与本指令的目的寄存器相同</li>
</ul>
</li>
</ul>
<h4 id="记分牌结构"><a href="#记分牌结构" class="headerlink" title="记分牌结构"></a>记分牌结构</h4><ul>
<li>功能部件状态表<ul>
<li>记录每条指令的功能状态，包括指令类型，使用的功能部件、寄存器，结束时间以及谁将使用该条指令的数据等</li>
</ul>
</li>
<li>用9个域来记录每个功能部件的状态<ul>
<li>Busy：指示功能部件是否工作</li>
<li>Op：功能部件当前执行的操作</li>
<li>Fi：目的寄存器编号</li>
<li>Fj，Fk：源寄存器编号</li>
<li>Qj，Qk：向Rj，Rk中写结果的功能部件</li>
<li>Rj，Rk：标示Fj，Fk是否就绪，是否已经被使用</li>
</ul>
</li>
</ul>
<h4 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h4><ul>
<li>指令序列如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LD    F6, <span class="number">34</span>(R2)</span><br><span class="line">LD    F2, <span class="number">45</span>(R3)</span><br><span class="line">MULTD F0, F2, F4</span><br><span class="line">SUBD  F8, F6, F2</span><br><span class="line">DIVD  F10, F0, F6</span><br><span class="line">ADDD  F6, F8, F2</span><br></pre></td></tr></table></figure></li>
<li>浮点部件执行时间延迟<ul>
<li>加（减）法2拍</li>
<li>乘法 10 拍</li>
<li>除法 40 拍</li>
</ul>
</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/实例.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>[Cycle 1]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-1.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第一条指令 LD 是访存指令，使用整型功能部件，目的寄存器为 R2，Fk 标记为准备好</li>
</ul>
<p><strong>[Cycle 2]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-2.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第二条指令也是 LD，也是使用整型功能部件，因此无法流出</li>
</ul>
<p>[Cycle 3]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-3.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>因为第二条 LD 指令不能流出，因此第三条指令 MULTD 也无法流出</li>
</ul>
<p><strong>[Cycle 4]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-4.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第四个时钟周期后，我们可以得到第一条指令的结果，于是要将第一条指令的整数部件释放掉，将结果写回到 F6 中</li>
</ul>
<p><strong>[Cycle 5]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-5.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第五拍时流出第二条 LD 指令，他使用整数部件，<strong>因此 F2 是整数部件作为目标寄存器在使用</strong>，查询 R3 有效，并且这条指令占用了目标寄存器 F2。</li>
</ul>
<p><strong>[Cycle 6]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-6.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第六个时钟周期时，乘法功能部件空闲，因此第三条乘法指令 MULTD 可以流出。</li>
<li>然后标记 F2 和 F4 为两个源操作数，但是第一个操作数为立即数，因此标记 F2 为整数功能部件。因为整数功能部件目前正在被使用，因此 F2 的数据没有就绪。</li>
</ul>
<p><strong>[Cycle 7]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-7.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>该节拍中，目标地址生成，R3 不再使用，因此把 R3 的标识符设置为空闲（No）。</li>
<li>同时第三条指令 MULTD 的 F2 整数部分还未拿到（整数功能部件还未就绪），因此无法继续执行。</li>
<li>减法使用加法部件（空闲），因此将 Add 标志送给 F8，<strong>表示 F8 作为 Add 功能部件的目的寄存器使用</strong>，查询 F6，F2 可得，F6 已就绪，F2 使用整数部件，未就绪。</li>
</ul>
<p><strong>[Cycle 8a（前半拍）]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-8a（前半拍）.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>前半拍时，第二条 LD 指令的结果被读出，即将要写入 F2，但是不能立即就被等待整数功能部件的两个寄存器使用，只有到后半拍的时候才能被供给使用</li>
</ul>
<p><strong>[Cycle 8b（后半拍）]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-8b（后半拍）.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>前半拍实际上是读 LD 的结果，后半拍将结果写进去</li>
<li>这样第三条和第四条指令的四个源操作数便都就绪了，整数部件使用的目的操作数 F2 也就绪了</li>
<li>第五条除法指令 DIVD 经检查也可以流出：除法部件空闲，目的寄存器为 F10，因此将 F10 打上 Divide 功能部件的标志</li>
<li>使用的两个源操作数 F0被乘法功能部件使用，未就绪，F6 就绪</li>
</ul>
<p><strong>[Cycle 9]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-9.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第三条乘法指令和第四条减法指令的四个操作数都就绪，根据之前的约定，这两条指令可以同时启动</li>
<li>前面约定，乘法指令将使用 10 拍完成，加减法指令使用 2 拍完成，将这两个设置计数器倒计时</li>
<li>第六条加法指令使用加法部件，而加法部件此时正在被减法指令（SUBD）使用</li>
</ul>
<p>[Cycle 10]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-10.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第六条加法指令仍然不能流出，乘法和减法指令执行一拍</li>
</ul>
<p>[Cycle 11]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-11.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>在第 11 个时钟周期，乘法和减法指令会被执行两拍，减法指令执行完毕</li>
<li>无其他需要使用 F8 寄存器的指令</li>
</ul>
<p>[Cycle 12]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-12.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>减法指令将结果写回 F8 寄存器</li>
</ul>
<p><strong>[Cycle 13]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-13.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>流出第六条加法（ADDD）指令，使用 F6 作为目标寄存器，因此将 F6 打上加法（Add）功能部件的标志</li>
<li>F8，F2 都可以就绪</li>
</ul>
<p>[Cycle 14]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-14.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>启动加法指令执行，需要两个时钟周期</li>
</ul>
<p>[Cycle 15]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-15.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>加法指令还剩一拍，乘法指令计数器还剩 4 拍</li>
</ul>
<p>[Cycle 16]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-16.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>求得加法指令结果</li>
</ul>
<p><strong>[Cycle 17]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-17.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>这时能否将 F6 写回？需要判断是否有<strong>读后写</strong>相关</li>
<li>需要扫描所有源寄存器（源记录）阵列，扫描发现在除法指令中 F6 寄存器已就绪，说明还没有被读走，因此该加法指令不能写入 F6，需等待除法指令读取完 F6 后才能写入</li>
<li>该指令存在读后写相关，被阻塞在原地</li>
</ul>
<p>[Cycle 18]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-18.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>乘法指令还剩一拍</li>
</ul>
<p>[Cycle 19]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-19.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>乘法指令执行完</li>
</ul>
<p><strong>[Cycle 20]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-20.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>释放掉 F0，除法指令的源操作数使用的 F0 寄存器就绪</li>
<li>除法指令继续启动</li>
</ul>
<p>[Cycle 21]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-21.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>除法指令计数器从 40 开始计数</li>
</ul>
<p><strong>[Cycle 22]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-22.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>源寄存器 F6 读完，取消就绪态，加法指令可以写 F6 寄存器</li>
</ul>
<p>[Cycle 61]</p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-61.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>经过 40 个节拍，除法指令执行完毕</li>
</ul>
<p><strong>[Cycle 62]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-62.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>将结果写入 F10 寄存器</li>
</ul>
<p><strong>记分牌最终状态</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/实例：Cycle-end.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>观察最后的结果，我们发现指令流出是顺序的，读操作数和执行是乱序的，结果写回也是乱序的</li>
<li>指令乱序执行，指令乱序写回</li>
</ul>
<p><strong>开销和性能提升</strong></p>
<ul>
<li>CDC6600</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>性能提升</th>
<th>编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.7</td>
<td>FORTRAN</td>
</tr>
<tr>
<td>2.5</td>
<td>手工汇编</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Condition（CDC6600记分牌）<ul>
<li>无软件流水调度</li>
<li>无主存储器</li>
<li>无 Cache</li>
</ul>
</li>
<li>CDC6600 上的记分牌的逻辑电路相当于一个功能部件，器件的耗费是非常低的</li>
<li>但是记分牌需要和每个功能部件进行连线，有了记分牌之后的连线是原来的 4 倍</li>
</ul>
<h3 id="4-2-3-Tomasulo-算法"><a href="#4-2-3-Tomasulo-算法" class="headerlink" title="4.2.3 Tomasulo 算法"></a>4.2.3 Tomasulo 算法</h3><ul>
<li>IBM 360/91比 CDC6600 晚三年推出<ul>
<li>商业计算机使用 Cache 技术之前</li>
</ul>
</li>
<li>整个 360 系列仅一个指令系统和一个编译器<ul>
<li>要求具有很高的浮点性能，但不是通过高端机器的专用的编译器实现</li>
<li>只有四个双精度浮点寄存器，编译器调度的有效性受到很大限制</li>
<li>访存时间和浮点计算时间都很长</li>
<li>可支持循环的多次迭代重叠执行</li>
</ul>
</li>
</ul>
<h4 id="Tomasulo-算法与记分牌"><a href="#Tomasulo-算法与记分牌" class="headerlink" title="Tomasulo 算法与记分牌"></a>Tomasulo 算法与记分牌</h4><ul>
<li>采用了许多记分牌中的理念</li>
<li>两个较大的差异<ul>
<li>Tomasulo 算法中，冲突检测和执行控制是分布的，利用<strong>保留站</strong>实现</li>
<li>Tomasulo 算法不检查 WAR 和 WAW 相关，他们通过算法本身消除掉了</li>
</ul>
</li>
</ul>
<h4 id="在MIPS上实现算法"><a href="#在MIPS上实现算法" class="headerlink" title="在MIPS上实现算法"></a>在MIPS上实现算法</h4><ul>
<li>360/91 浮点功能单元<ul>
<li>3个加法单元</li>
<li>2个乘法单元</li>
<li>6个读单元</li>
<li>3个写单元</li>
</ul>
</li>
<li>MIPS和360/91浮点单元的区别<ul>
<li>360/91: 支持寄存器-存储器指令</li>
<li>360/91: 采用流水化功能单元，不采用多个功能单元</li>
</ul>
</li>
<li>每个功能单元都有保留站：缓冲</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/MIPS浮点单元的基本结构.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>可以看到，结构中有一个指令队列，指令从队列中流出到各个功能部件，有四个浮点寄存器，三个加法部件，两个乘法部件，三个 store 部件，六个 load 部件</li>
<li>但是只有一个加法器和三个缓冲器，一个乘法器和两个缓冲器，这三个加法缓冲器和两个乘法缓冲器加起来叫<strong>保留站</strong>（Reservation Station），对于指令队列来说，流出队列并且进入加法器的指令可以有三条，这就相当于有三个加法器，同理，相当于有两个乘法器，三个 store 部件和六个 load 部件</li>
<li>这些缓冲器又称为<strong>虚拟功能部件</strong>，这样做是为了有更多的部件供请求队列使用</li>
</ul>
<h4 id="Tomasulo-浮点单元具体执行流程"><a href="#Tomasulo-浮点单元具体执行流程" class="headerlink" title="Tomasulo 浮点单元具体执行流程"></a>Tomasulo 浮点单元具体执行流程</h4><ul>
<li>一条指令流出后，可能是加法或其他类型的指令，该指令将被分配到相应的功能部件，指令开始进入执行阶段</li>
<li>在每一个保留站中，便会记录该指令的操作类型（加法还是减法等）以及两个源操作数，这两个源操作数将从浮点寄存器中读取，如果就绪则成功读取，若没有就绪，则记录谁将产生这个操作数</li>
<li>一旦获得了操作数或者知道了将从哪儿产生这个操作数后，该寄存器对于该部件便没有意义了，相当于将其释放了</li>
<li>操作数从其他部件或从自己部件的保留站中产生，实际上完成了一个指针的调整，记录了一个指针等待这个数据从什么地方过来</li>
<li>当两个操作数都成功得到后，该指令便会被流入到功能部件进行运算，运算完成后将结果送入一条总线上，这个总线叫<strong>公共数据总线</strong>，该总线是 Tomasulo 算法的枢纽</li>
<li>将数据放入公共数据总线后，所有需要该数据的地方将同时获得该数据，包括保留站和寄存器，供下一条指令使用</li>
<li>获得两个操作数的指令便可以接着执行，相关的检测是在保留站中执行的，没有一个统一的控制电路</li>
<li><span id="changename">数据指针的调整使得寄存器完成了一次<strong>换名</strong>操作，==由原来的寄存器读数，变成从产生数据的源部件取数==</span></li>
</ul>
<h4 id="MIPS五阶段的流水线的改造"><a href="#MIPS五阶段的流水线的改造" class="headerlink" title="MIPS五阶段的流水线的改造"></a>MIPS五阶段的流水线的改造</h4><ul>
<li>ID和EX阶段被以下三个阶段代替<br>1、流出（Issue）<br>2、执行（Execute）<br>3、结果写回（Write result）</li>
</ul>
<p><strong>流出（Issue）</strong></p>
<ol>
<li>从浮点指令队列中取出一条指令</li>
<li>如果存在一个空的保留站，就流出这条指令</li>
<li>如果操作数在寄存器中，就送到该指令对应的保留站</li>
<li>存储器取/存指令只要有空闲的缓存就可以流出</li>
<li>如果没有空闲的保留站或者缓存，就存在结构相关，指令暂停，直到有空闲的保留站或者缓存</li>
</ol>
<p><strong>执行</strong></p>
<ol>
<li>如果缺少一个或者多个操作数，就监听 CDB<br>这个阶段实际是检测和自动维护 RAW 相关</li>
<li>如果两个操作数都就绪，这条指令就可以执行</li>
</ol>
<p><strong>结果写回</strong>（Write result） </p>
<ol>
<li>如果结果已经产生，将其写到 CDB 上</li>
<li>通过 CDB，把这个结果写到目标寄存器和等待这个结果的所有功能单元的保留站</li>
</ol>
<p><strong>保留站的六个域</strong></p>
<ul>
<li>Op：对源操作数 S1 和 S2 进行的操作</li>
<li>Qj, Qk：产生本条指令所需要的源操作数的保留站<ul>
<li>如果值为 0，意味着源操作已经就绪</li>
</ul>
</li>
<li>Vj, Vk：源操作数的值<ul>
<li>V 域和 Q 域不同时有效，表示一旦获得源操作数的值或者获得源操作数的来源，则寄存器便失效</li>
</ul>
</li>
<li>Busy：这个保留站被占用了</li>
</ul>
<p><strong>寄存器文件和存缓冲都有 Qi 域</strong></p>
<ul>
<li>Qi：保留站的编号<ul>
<li>编号所对应产生结果的保留站</li>
<li>如果 Qi 为空，就是当前没有指令的结果要写到这个寄存器或者缓冲    </li>
</ul>
</li>
<li>Load 缓冲和 Store 缓冲都有<ul>
<li>busy 位</li>
<li>地址域</li>
<li>Store缓冲还有 V 域</li>
</ul>
</li>
</ul>
<p>$\sum$</p>
<h4 id="程序实例-1"><a href="#程序实例-1" class="headerlink" title="程序实例"></a>程序实例</h4><p><strong>用以下指令序列来说明 Tomasulo 算法原理</strong><br>同记分牌算法的指令系列<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LD    F6, <span class="number">34</span>(R2)</span><br><span class="line">LD    F2, <span class="number">45</span>(R3)</span><br><span class="line">MULTD F0, F2, F4</span><br><span class="line">SUBD  F8, F6, F2</span><br><span class="line">DIVD  F10, F0, F6</span><br><span class="line">ADDD  F6, F8, F2</span><br></pre></td></tr></table></figure></p>
<p><strong>假设：</strong></p>
<ol>
<li>加法指令需要 2 个时钟周期</li>
<li>乘法指令需要 10 个时钟周期</li>
<li>除法指令需要 40 个时钟周期</li>
</ol>
<p><strong>数据相关</strong></p>
<ul>
<li>三个 RAW 相关（真数据相关）<ul>
<li>第二个 LD 与 MULTD 和 SUBD</li>
<li>从 MULTD 到 DIVD</li>
<li>从 SUBD 到 ADDD</li>
</ul>
</li>
</ul>
<p><strong>名相关</strong></p>
<ul>
<li>DIVD 和 ADDD 之间的 WAR 相关（反相关）<ul>
<li>Tomasulo 中通过硬件遍历搜索当前指令的目的寄存器是否和之前指令的源操作数寄存器相同，从而避免读后写相关</li>
</ul>
</li>
<li>第一条 LD 和 ADDD 之间的 WAW 相关（输出相关）</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>有三个 Add 保留站，两个 Multi 保留站</li>
<li>三个 Load 缓冲</li>
</ul>
<p><strong>[Cycle 1]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-1.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第一条 LD 指令可以流出，使用一个 Load 功能部件</li>
</ul>
<p><strong>[Cycle 2]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-2.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>Load 功能部件还有剩余，并且使用 F2 作为目标寄存器，因此可以流出，并在 F2 上打上 Load2 标志</li>
<li>第一条 LD 指令进行地址相加计算，进行访存（？）</li>
</ul>
<p><strong>[Cycle 3]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-3.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第三条指令 MULTD 使用一个乘法保留站，目的寄存器为 F0，将 F0 打上 Mult1 标志</li>
<li>检查两个源寄存器 F2 和 F4，F2 未就绪，记录 F2 被 Load1 使用</li>
<li>F4 就绪</li>
<li>MULTD 进入等待状态</li>
<li>第一条 LD 指令进入地址计算阶段</li>
</ul>
<p><strong>[Cycle 4]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-4.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第一条 LD 指令结果写回，释放 Load1</li>
<li>第二条 LD 指令也进入地址计算阶段</li>
<li>第四条指令 SUBD 是减法指令，使用加法保留站，有空闲单元，可以流出，目的寄存器为 F8，将 F8 打上 Add1 的标志（先判断是否能流出，在将寄存器打上标志）</li>
<li>在第一个加法保留站中记录操作类型为 SUBD</li>
<li>检查目的操作数 F6 和 F2，发现 F2 正在被 Load2 使用，进行标记</li>
<li>F6 来自 LD 指令写回的值，通过 CDB 进行传送，写到所有等待该数据的保留站中，于是 F6 就绪</li>
</ul>
<p><strong>[Cycle 5]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-5.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第二条 LD 指令写回 F2， 通过 CDB 传送给 Mult1 中的 F2，第三条指令 MULTD 的两个操作数就绪，开始执行</li>
<li>第四条 SUBD 指令的 F2 也在等待数据，因此 F2 也要传送给 Add1 保留站，于是该指令两个操作数准备就绪，开始执行</li>
<li>第五条指令 DIVD 使用乘法功能部件，Multi2 空闲，可以流出，目的寄存器 F10 空闲，打上 Mult2 标志</li>
<li>检查源操作数 F0 和 F6，检查 F0，记录正在被 Mult1 使用</li>
<li>F6 准备就绪</li>
<li>对于加法和乘法指令，需要使用局部计数器完成对整个运算的计数，Add1 设置计数器为 2，Mult1 设置计数器为 10</li>
</ul>
<p><strong>[Cycle 6]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-6.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>Add1 和 Mult1 分别完成一拍的计算，还剩 1 和 9</li>
<li>第六条指令 ADDD 是加法指令，加法保留站有空闲，可以流出</li>
<li>ADDD 目标操作数是 F6，F6 空闲，将 F6 打上 Add2 标签</li>
<li>检查源操作数 F8 和 F2，检查发现 F8 由 Add1 产生结果，未就绪，F2 已就绪</li>
</ul>
<p><strong>[Cycle 7]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-7.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>加法保留站 Add1 的计数器为0，表示第四条指令 SUBD 已经完成运算</li>
</ul>
<p><strong>[Cycle 8]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-8.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>第八拍时，SUBD 将结果写回 F8，同时写到 CDB 上</li>
<li>检查到 Add2 的一个目的寄存器使用 Add1 输出的结果，因此 Add1 同时将数据通过 CDB 输出到 Add2，ADDD 两个源操作数准备就绪，开始执行，设置计数器为 2</li>
</ul>
<p><strong>[Cycle 9]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-9.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>Add2 计数器还剩 1，Mult1 计数器还剩 6</li>
</ul>
<p><strong>[Cycle 10]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-10.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>Add2 计数器为 0，计算完成</li>
</ul>
<p><strong>[Cycle 11]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-11.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>ADDD 的结果写回 F6，同时送入公共数据总线，除了 Add2，没有其他保留站等待该数据</li>
<li>Mult1 还剩四拍计算完成</li>
</ul>
<p><strong>[Cycle 12-14]</strong><br>图略，等待 MULTD 计算完成</p>
<p><strong>[Cycle 15]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-15.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>MULTD 计算完成</li>
</ul>
<p><strong>[Cycle 16]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-16.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>使用第一个乘法器（Mult1）结果的有两个地方：一个是第二个乘法部件 Mult2，第二个是 F0 寄存器</li>
<li>Mult2 获得 F0 结果后，DIVD 两个寄存器都准备就绪</li>
<li>DIVD 指令开始计算，设置计数器为 40</li>
</ul>
<p><strong>[Cycle 55]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-55.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>除法还剩一个节拍</li>
</ul>
<p><strong>[Cycle 56]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-56.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>除法执行完成</li>
</ul>
<p><strong>[Cycle 57]</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/Tomasulo实例：Cycle-57.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>将结果写回 F10</li>
</ul>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul>
<li>指令流出是顺序的，但是执行结束的顺序是乱序的，写结果的顺序也是乱序的</li>
<li>Tomasulo 算法特点：有序流出，乱序执行，乱序结束</li>
<li>可以将优先获得资源并且可以执行的指令优先结束</li>
</ul>
<p><strong>Tomasulo算法的优点</strong></p>
<ul>
<li>分布式硬件冲突检测</li>
<li>利用保留站和缓冲完成<a href="#changename">寄存器换名</a>，彻底消除 WAW 和 WAR 这两种名相关</li>
<li>如果多个保留站等待同一个操作数，当操作数在 CDB 上广播时，他们可以同时所需的数据</li>
</ul>
<p><strong>动态调度方法评价</strong></p>
<ul>
<li>动态方法能够达到很高的性能</li>
<li>主要缺陷<ul>
<li>高复杂性：需要大量硬件</li>
<li>存在瓶颈：单个公共数据总线（CDB）引发竞争<ul>
<li>额外的 CDB：在每个保留站上需要为每条 CDB 设置重复的硬件接口</li>
<li>现代计算机一般有 3 条 CDB，1 条全局，2 条局部（单独连浮点寄存器和保留站）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-控制相关的动态解决技术"><a href="#4-3-控制相关的动态解决技术" class="headerlink" title="4.3 控制相关的动态解决技术"></a>4.3 控制相关的动态解决技术</h2><ul>
<li>动态分支预测的两个理由<ul>
<li>n流出的处理器加速上限为n倍</li>
<li>Amdahl定律提示：在较低CPI机器上，控制相关导致的<strong>空转</strong>对机器性能影响大</li>
</ul>
</li>
<li>前面解决控制相关的静态策略<ul>
<li>需要编译器将一条或多条指令移动到流水线产生的分支延迟槽中</li>
</ul>
</li>
<li>关于分支预测策略的两部分工作<ul>
<li>预测的分支是否成功</li>
<li>执行分支目标指令</li>
</ul>
</li>
</ul>
<h3 id="4-3-1-分支预测缓冲"><a href="#4-3-1-分支预测缓冲" class="headerlink" title="4.3.1 分支预测缓冲"></a>4.3.1 分支预测缓冲</h3><ul>
<li>预测的准确率</li>
<li>分支的开销<ul>
<li>预测正确的开销</li>
<li>预测错误的开销</li>
</ul>
</li>
</ul>
<h4 id="分支预测缓冲-BPB"><a href="#分支预测缓冲-BPB" class="headerlink" title="分支预测缓冲(BPB)"></a>分支预测缓冲(BPB)</h4><ul>
<li>最简单的分支预测策略</li>
<li>分支预测缓冲是一个小的存储器阵列<ul>
<li>每个单元只有 1 位，记录<strong>最近</strong>一次分支是否成功的信息</li>
<li>预测位为1则预测分支成功，并从目标位置开始取指令</li>
<li>单元由分支指令地址的低位索引进行寻址</li>
<li>BPB 的预测位会被具有相同低位地址的分支设置</li>
</ul>
</li>
<li>BPB也被称为 BHP（branch history buffer 分支历史缓冲）</li>
</ul>
<h4 id="1-位-BPB"><a href="#1-位-BPB" class="headerlink" title="1 位 BPB"></a>1 位 BPB</h4><p><strong>1 位 BPB 状态图</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/1位BPB状态图.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>这种单位预测策略有大约 80% 左右的准确率<ul>
<li>当分支不成功时，单位预测会连续失败两次</li>
<li>2 位预测策略能够改善这种情况</li>
</ul>
</li>
</ul>
<h4 id="2-位-BPB"><a href="#2-位-BPB" class="headerlink" title="2 位 BPB"></a>2 位 BPB</h4><p><strong>2 位 BPB 状态图</strong></p>
<ul>
<li>在 2 位预测策略中，一个预测必须错误两次才会改变</li>
<li>对于一个 4096 条记录的 BPB，利用 2 位预测策略，用 SPEC89 测试，命中率为 82% 到 99%<ul>
<li>准确率最高的测试程序一般包含大量循环</li>
<li>线性代码一般准确率最差</li>
</ul>
</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/2位BPB状态图.png" width="80%" style="margin: 0 auto">
</div>

<p>另一种转换图：</p>
<div style="text-align: center;">
<img src="/1f2e7710/2位BPB状态图2.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>4096 单元 2 位 BPB 的预测准确率</strong></p>
<ul>
<li>测试程序为 SPEC89</li>
<li>整数测试程序: 平均 11%<ul>
<li>gcc, espresso, eqntott, li</li>
</ul>
</li>
<li>浮点测试程序: 平均 4%<ul>
<li>nasa7, matrix300, tomcatv</li>
</ul>
</li>
<li>为什么?<ul>
<li>因为整数程序线性代码较多</li>
<li>浮点主要用于计算，循环程序更多</li>
</ul>
</li>
</ul>
<h4 id="n-位-BPB"><a href="#n-位-BPB" class="headerlink" title="n 位 BPB"></a>n 位 BPB</h4><ul>
<li>1 位或 2 位 BPB 是 n 位 BPB 的特殊情况</li>
<li>n 位策略使用计数器，表示 0~2^n^-1 的值</li>
<li>与 2 位策略类似，对于 n 位 BPB，每次分支成功，计数器 +1，反之则 -1</li>
<li>如果计数器值大于其最大值的一半，则做成功预测，反之则做失败预测</li>
<li>4K 个单元的 BPB 和无穷单元的 BPB 最后结果相差无几</li>
</ul>
<h4 id="BPB-实现"><a href="#BPB-实现" class="headerlink" title="BPB 实现"></a>BPB 实现</h4><ul>
<li>BPB的实现方案<ul>
<li>实现一个小而特殊的“cache”，利用指令地址进行索引，在 IF 流水段访问。</li>
<li>或者，为指令 cache 中每一块增加附加位，与指令一起取出</li>
</ul>
</li>
<li>若一个指令在 ID 段被译码为分支指令，且对应的BPB标志位预测其成功，则<ul>
<li>一旦 PC 已知，立刻从分支目标位置开始取指</li>
<li>或者，继续顺序取指</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-分支目标缓冲-BTB"><a href="#4-3-2-分支目标缓冲-BTB" class="headerlink" title="4.3.2 分支目标缓冲(BTB)"></a>4.3.2 分支目标缓冲(BTB)</h3><ul>
<li>另一个动态分支预测方法：分支目标缓冲<ul>
<li>Branch Target Buffer, BTB</li>
<li>为了减小或消除流水线的分支开销，我们需要在 IF 段结束前知道从哪个地址开始取下一条指令</li>
<li>换句话说，我们在 IF 段就需要知道这条未译码的指令是否为分支指令，并且如果它是分支指令，要尽快知道 NPC 值应当为多少</li>
<li>这个缓冲机制中保存以前分支成功的分支指令的地址，等到下一次在遇到这条指令的时候，当前指令的地址将会和缓冲中保存的分支指令地址进行比较，若相同，则认为当前指令就是曾经执行过的分支成功的指令，因此预测下一次该指令仍然分支成功</li>
</ul>
</li>
</ul>
<h4 id="BTB-实现"><a href="#BTB-实现" class="headerlink" title="BTB 实现"></a>BTB 实现</h4><ul>
<li>分支目标缓存 BTB 每个单元应该包括<ul>
<li>分支指令的地址</li>
<li>分支目标的地址</li>
<li>分支预测标识</li>
</ul>
</li>
<li>取指阶段，所有指令地址都与 BTB 中保存的分支指令的地址做比较，一旦相同，就认为本指令是分支指令，并且分支成功</li>
<li>它的目标地址就是保存在缓冲区中的分支目标地址<ul>
<li>取出后直接送入 NPC</li>
</ul>
</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/BTB结构.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>执行过程</strong></p>
<ul>
<li>当前指令的 PC 将和 BTB 中的 PC 值进行遍历比较，如果有相同的项，那么就认为该指令是曾经成功的分支指令，他的分支目标地址放在列==分支目标PC==中</li>
<li>然后将分支目标PC取出直接放入 PC 寄存器，从该地址取出下一条指令执行<ul>
<li>BTB 可以进一步优化，将分支目标指令也存放在缓冲中，加快指令的读取</li>
</ul>
</li>
<li>如果没有命中，则认为他是普通指令，正常执行</li>
<li>若分支预测成功、不是分支指令或者不在 BTB 中且分支不成功，则流水线无延迟</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/BTB执行过程.png" width="80%" style="margin: 0 auto">
</div>

<p><strong>BPB VS. BTB</strong></p>
<ul>
<li>分支预测技术（BPB）受限于预测精度，以及预测失效后产生的开销，预测精度为 80% 左右</li>
<li>根据不同程序特点以及缓冲区的大小，典型的BTB可以实现 80% 到 95% 的预测精度</li>
<li>降低失效开销技术：在一个时钟周期内同时取出不同分支路径的指令，<strong>即把分支成功和失败的指令都取出来</strong><ul>
<li>会引入其他开销，比如存储系统的端口加倍</li>
<li>降低失效开销的唯一方法，比如<ul>
<li>AS/400 PowerPC 处理器，多分支预测技术</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分支预测局限性</strong></p>
<ul>
<li>预测准确性：80%-90%</li>
<li>预测性能依赖于<ul>
<li>程序类型</li>
<li>缓冲区大小</li>
</ul>
</li>
<li>预测失效开销的优化<ul>
<li>预取不同分支路径指令<ul>
<li>存储端口数目加倍,交叉存取缓冲</li>
</ul>
</li>
<li>在目标缓冲中缓冲多个路径的指令</li>
</ul>
</li>
</ul>
<h2 id="4-4-多指令流出技术"><a href="#4-4-多指令流出技术" class="headerlink" title="4.4 多指令流出技术"></a>4.4 多指令流出技术</h2><ul>
<li>多指令流出处理器<ul>
<li>实现一个时钟周期内流出多条指令时</li>
<li>达到 CPI 小于1</li>
</ul>
</li>
<li>多流出处理器 2 种基本结构    <ul>
<li>超标量（Superscalar）<ul>
<li>超标量每个时钟周期流出的指令数不定</li>
<li>可以编译器静态调度，也可以硬件动态调度</li>
</ul>
</li>
<li>超长指令字（VLIW，Very long Instruction Word）<ul>
<li>每个时钟周期流出的指令数是固定的，只能通过编译静态调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-1-超标量处理机"><a href="#4-4-1-超标量处理机" class="headerlink" title="4.4.1 超标量处理机"></a>4.4.1 超标量处理机</h3><ul>
<li>超标量处理机的原型来自于 IBM 实验室的 “America”处理器<ul>
<li>RS/6000 第一个采用超标量技术</li>
<li>现在，几乎所有高性能处理器都是用该技术</li>
</ul>
</li>
<li>超标量处理机的硬件支持每个时钟周期发出 <strong>1-8</strong> 条不存在相关的指令<ul>
<li>如果指令流中的指令相关或不满足限制条件，则只能流出这条指令前面的指令，因此超标量处理器流出的指令数是不定的</li>
</ul>
</li>
</ul>
<h4 id="超标量处理器"><a href="#超标量处理器" class="headerlink" title="超标量处理器"></a>超标量处理器</h4><ul>
<li>假设有这样一个简单的超标量处理器，每个时钟周期它可以流出两条指令<ul>
<li>一条指令可以是取指令、存指令、分支指令或整数运算操作</li>
<li>另一条指令可以是任意的浮点操作</li>
<li>第一条指令排在第二条指令的前面</li>
<li>这种配置与 HP 7100 结构类似</li>
</ul>
</li>
</ul>
<p><strong>超标量处理机的理想执行情况</strong></p>
<div style="text-align: center;">
<img src="/1f2e7710/超标量处理机的理想执行情况.png" width="80%" style="margin: 0 auto">
</div>

<h4 id="超标量处理机的技术问题"><a href="#超标量处理机的技术问题" class="headerlink" title="超标量处理机的技术问题"></a>超标量处理机的技术问题</h4><ul>
<li>每个时钟周期流出两条指令意味着取指令和解码部件都是64位<ul>
<li>假设：指令按要求组合成对，且与 64 位边界对其，整数指令顺序在前</li>
<li>需要使得浮点部件流水化或增加相关部件来减少结构相关</li>
</ul>
</li>
<li>另一个限制超标量流水线性能发挥的障碍是取操作和分支操作的延迟<ul>
<li>分支指令肯定是指令组合的第一条指令，影响配对指令和后续两条指令，分支延迟也变为 3 条指令</li>
</ul>
</li>
</ul>
<h4 id="超标量处理器举例"><a href="#超标量处理器举例" class="headerlink" title="超标量处理器举例"></a>超标量处理器举例</h4><ul>
<li>为了能有效利用超标量处理器的可获得的并行度，需要采用更有效的编译技术、硬件调度技术和更复杂的指令译码技术<ul>
<li>循环展开成5个副本</li>
</ul>
</li>
<li>使用先前我们用到的代码作为例子<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOOP  LD    F0, <span class="number">0</span>(R1)   ;取出一个向量单元.</span><br><span class="line">      ADDD  F4, F0, F2	;与F2寄存器中的标量相加</span><br><span class="line">      SD    <span class="number">0</span>(R1), F4   ;保存相加后的向量单元</span><br><span class="line">      SUBI	R1, R1, #<span class="number">8</span>  ;R1寄存器值减<span class="number">8</span></span><br><span class="line">      BNEZ 	R1, LOOP    ;如果R1值不为<span class="number">0</span>，则跳转</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="超标量：例子执行情况"><a href="#超标量：例子执行情况" class="headerlink" title="超标量：例子执行情况"></a>超标量：例子执行情况</h4><ul>
<li>在超标量流水线上对上述代码进行调度，以获取更多地指令机并行度</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/超标量：例子执行情况.png" width="80%" style="margin: 0 auto">
</div>

<h4 id="超标量：例子结果分析"><a href="#超标量：例子结果分析" class="headerlink" title="超标量：例子结果分析"></a>超标量：例子结果分析</h4><ul>
<li>每次循环需 12 个时钟周期</li>
<li>每个迭代为 2.4 个时钟周期<ul>
<li>前面在普通的流水线上，通过循环展开和调度，可以达到每个迭代为 3.5 个时钟周期</li>
</ul>
</li>
<li>超标量可以获得更好地性能，代价是硬件复杂性大幅度增加</li>
</ul>
<h3 id="4-4-2-超长指令字技术"><a href="#4-4-2-超长指令字技术" class="headerlink" title="4.4.2 超长指令字技术"></a>4.4.2 超长指令字技术</h3><ul>
<li>一台超标量机器每周期能够流出4-8条指令<ul>
<li>由于必须要用硬件分析指令间的相关，为其实现带来了困难</li>
</ul>
</li>
<li>另一种选择：长指令字（LIW，Long Instruction Word）或称为超长指令字（VLIW，Very Long Instruction Word）体系结构<ul>
<li>第一种商用 LIW 机器是 AP-120B，由 Floating Point Systems 开发</li>
<li>FPS-164 是较新的机器，它的每个指令字含有对应于 10 个不同功能单元的 10 条指令</li>
</ul>
</li>
</ul>
<h4 id="VLIW基本机构"><a href="#VLIW基本机构" class="headerlink" title="VLIW基本机构"></a>VLIW基本机构</h4><ul>
<li>VLIW 采用多个独立的功能单元，多个不同的操作封装在一条长指令字中，每个功能单元在 VLIW 指令中都有一定的对应区域<ul>
<li>一般每个功能单元占用 16-24 位</li>
<li>例如：2个整数、2个浮点、2个访存、1个分支，则该指令的长度为 112-168位</li>
</ul>
</li>
<li>VLIW 硬件只是简单地将指令字中对应的部分送给各个功能单元，功能单元在哪一个时钟周期执行什么操作由编译器来确定<ul>
<li>如果某个功能单元在某个周期没有任务，则执行 NOP（空操作）指令</li>
</ul>
</li>
</ul>
<h4 id="VLIW例子"><a href="#VLIW例子" class="headerlink" title="VLIW例子"></a>VLIW例子</h4><ul>
<li>再次使用先前在解释循环展开及超标量机器时使用过的那段循环代码，来解释VLIW如何工作这一次，我们将循环展开n个副本</li>
<li>VLIW机器每条指令字包含<ul>
<li>两个访存操作</li>
<li>两个浮点操作</li>
<li>一个整数或分支操作</li>
</ul>
</li>
<li>得到如下指令序列</li>
</ul>
<div style="text-align: center;">
<img src="/1f2e7710/VLIW执行情况，n=5.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>5 条结果在 8 个时钟周期中完成计算<ul>
<li>每条结果花费 1.3 时钟周期，比超标量性能更高</li>
<li>有 17/40 的指令槽被放入了有效的操作，利用率很低</li>
</ul>
</li>
</ul>
<p>当循环展开为 7 次时：</p>
<div style="text-align: center;">
<img src="/1f2e7710/VLIW执行情况，n=7.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>9 拍产生 7 个结果<ul>
<li>每个结果 1.29 拍</li>
<li>比前面的超标量，每个结果 2.4 拍，快接近2倍</li>
</ul>
</li>
<li>9 拍里面执行了 23 个操作<ul>
<li>2.5 操作/拍</li>
<li>指令槽利用率不高， 只有 51% (23/45)</li>
</ul>
</li>
<li>使用大量寄存器</li>
<li>7 个循环，共计使用 2×7+1=15 个 64 位浮点寄存器</li>
</ul>
<p>如果我们想减少循环展开的次数，则至少展开三次才能保证流水线中没有空周期：</p>
<div style="text-align: center;">
<img src="/1f2e7710/VLIW执行情况，n=3.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>8 拍 3 个结果，每个结果 2.66 拍</li>
<li>指令槽利用率: 11/40 = 27.5%</li>
<li>寄存器：3×2+1=7 个 64 位浮点寄存器</li>
</ul>
<p>如果我们想尽可能充满指令槽，可以展开 10 次：</p>
<div style="text-align: center;">
<img src="/1f2e7710/VLIW执行情况，n=10.png" width="80%" style="margin: 0 auto">
</div>

<ul>
<li>10 拍 10 个结果，每个结果使用 1 拍</li>
<li>指令槽利用率：36/50 = 72%</li>
<li>寄存器需求：10×2+1=23 个 64 位浮点寄存器<ul>
<li>当前 MIPS 只有 16 个 64 位浮点寄存器或 32 个 32 位寄存器，已经超过了要求</li>
</ul>
</li>
</ul>
<p><strong>VLIW的技术难题</strong></p>
<ul>
<li>第一，从线性代码片段中产生足够的操作需要进行激进的循环展开，这增大了代码大小</li>
<li>第二，无论指令是否被充满，没有被使用的功能单元也在指令字编码过程中占据了相应的位，也就是说将近一半的指令槽是被浪费掉的，这不仅浪费运算资源，还占用了大量存储空间<ul>
<li>解决方式：在主存中压缩指令，在 cache 中解压缩指令</li>
</ul>
</li>
<li>第三，VLIW 带来了二进制代码兼容性问题<ul>
<li>若采用 2 个浮点部件和 3 个浮点部件，将带来二进制指令代码不兼容</li>
<li>采用模拟的方法解决</li>
</ul>
</li>
</ul>
<h2 id="4-5-第四章指令级并行总结"><a href="#4-5-第四章指令级并行总结" class="headerlink" title="4.5 第四章指令级并行总结"></a>4.5 第四章指令级并行总结</h2><ul>
<li>4.1 指令级并行的概念<ul>
<li>循环展开调度的基本方法<ul>
<li>解决跨基本块的指令调度</li>
<li>通过寄存器换名技术解决名相关</li>
</ul>
</li>
</ul>
</li>
<li>4.2 指令的动态调度<ul>
<li>记分牌<ul>
<li>通过硬件解决数据相关</li>
</ul>
</li>
<li>Tomasulo算法<ul>
<li>还可以解决控制相关引发的问题</li>
<li>可以很好解决循环展开的问题，由硬件完成寄存器换名，减少空周期</li>
</ul>
</li>
</ul>
</li>
<li>4.3 控制相关的动态解决技术<ul>
<li>分支预测缓冲<ul>
<li>以较小的存储代价和 1 拍的时间延迟进行分支指令的历史预测，提高机器执行效率</li>
</ul>
</li>
<li>分支目标缓冲<ul>
<li>通过保存分支指令和分支目标的地址，实现没有空转周期的分支预测</li>
</ul>
</li>
<li>这两者都是基于历史信息来进行预测的，分支目标缓冲需要更大的存储空间<ul>
<li>现在的机器上一般将两者结合使用：使用几十上百个分支目标缓冲和若干 K 个分支预测缓冲</li>
<li>这样可以很好的实现控制相关的动态预测，将失效率降低到 10% 左右</li>
</ul>
</li>
</ul>
</li>
<li>4.4 多指令流出技术<ul>
<li>超标量技术<ul>
<li>CPI &lt; 1</li>
<li>指令流出一般在 3-6 条</li>
</ul>
</li>
<li>超长指令字技术<ul>
<li>依赖编译器的静态多指令流出技术</li>
<li>通用领域技术不够成熟</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机体系结构课程笔记（四）</title>
    <url>/767f71ea.html</url>
    <content><![CDATA[<h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h1><blockquote>
<p>国防科大计算机体系结构课程第六-八章笔记<br><span id="more"></span></p>
</blockquote>
<h2 id="6-1-存储设备"><a href="#6-1-存储设备" class="headerlink" title="6.1 存储设备"></a>6.1 存储设备</h2><h3 id="6-1-1-磁盘"><a href="#6-1-1-磁盘" class="headerlink" title="6.1.1 磁盘"></a>6.1.1 磁盘</h3><ul>
<li>磁盘始终占据着后备存储器的主宰地位。原因有二：<ul>
<li>磁盘一直是虚拟存储器技术的物质基础，执行程序时，磁盘用作为交换缓冲区</li>
<li>关机时，磁盘作为操作系统和所有应用程序的非易失性的驻留介质</li>
<li>磁盘是最重要的 I/O 设备，是存储层次中辅存的载体，发展比较平缓</li>
</ul>
</li>
<li>磁盘由一组绕轴旋转的盘片组成，盘片的数量为 1~20 片</li>
<li>磁盘系统的转速一般在每分钟 3600 转到 15000 转之间，即 3600rpm~15000rpm</li>
<li>磁道（每一个盘片有 5000~30000 条磁道）。</li>
<li>扇区（每条磁道分为 100~500 个扇区）。所有磁道具有相同数目的扇区</li>
</ul>
<h4 id="磁盘访问时间计算"><a href="#磁盘访问时间计算" class="headerlink" title="磁盘访问时间计算"></a>磁盘访问时间计算</h4><p><strong>1. 寻道时间</strong></p>
<ul>
<li>若要读写扇区，磁盘控制器发出命令首先将磁头移动到包含有所需数据的磁道上，这个过程称为“寻道”，所需要的时间叫做“寻道时间”</li>
<li>最小寻道时间、最大寻道时间和平均寻道时间。常见的平均寻道时间的公布值约为 6ms 到 20ms，实际应用当中的平均寻道时间约为公布值的 25% 到 33%<br><strong>2. 旋转时间</strong></li>
<li>所需扇区转到磁头之下所需要的时间称为旋转时间。大部分磁盘的转速在3600rpm到10,000rpm，平均延迟是磁盘转半圈的时间，所以对大部分磁盘的平均旋转时间 $T_AR=3ms~8.3ms$<br><strong>3. 传输时间</strong></li>
<li>传输时间是指在磁头下传输一个数据块(通常是一个扇区)所需花的时间。它由块的大小、旋转速度、磁道记录密度和连接磁盘电子器件的速度确定</li>
<li>数据传输率有两个：一是从盘面到缓冲存储器的<strong>内部传输率</strong>；一是从缓冲存储器到主机的<strong>外部传输率</strong><ul>
<li>内部数据传输率：硬盘将数据从盘片上读取出，交给硬盘上的缓冲存储器的速度。也被称作硬盘的持续传输率（Sustained Transfer Rate），它取决于<strong>硬盘转速</strong>和<strong>盘片位密度</strong>。内部传输率等于磁头相对磁盘的线速度与磁盘位密度之积。外部传输率是以内部传输率为基础的，有效地提高硬盘的内部传输率才能对磁盘性能有最直接、最明显的提升</li>
<li>外部传输率：计算机通过磁盘接口从硬盘的缓存中将数据读出，交给相应的控制器的速度；被称为突发数据传输率（Burst Data Transfer Rate）。外部数据传输率和磁盘的接口有关，目前已有 IDE、EIDE、Ultra-EIDE、SCSI、Fast and Wide-SCSI、FC-AL 等接口。ATA-6 接口的速度已经达到 133MB/s</li>
</ul>
</li>
<li>内部传输率等于记录的位密度乘以盘面旋转的线速度。外部传输率则与接口有关<br><strong>4. 控制器时间</strong></li>
<li>控制磁盘及磁盘与主存之间数据传输，需要一系列的控制器和通道来完成</li>
<li>控制器时间是控制器在执行I/O访问时的额外开销</li>
</ul>
<p><strong>因此，磁盘访问时间=寻道时间+旋转时间+传输时间+控制器时间</strong></p>
<p><strong>磁盘访问时间例题</strong><br>对于目前一般的磁盘而言，读或写一个 512 字节的扇区的平均时间是多少？假设此时磁盘空闲，这样没有排队延迟；公布的平均寻道时间是 9ms，传输速度是 4MB/s，转速是 7200rpm，控制器的开销是 1ms</p>
<p><strong>[分析]</strong></p>
<ul>
<li>寻道时间 = 9ms</li>
<li>旋转时间 = 0.5 / 7200rpm = 4.2ms</li>
<li>传输时间 = 0.5KB / 4.0MB/s = 0.125ms</li>
<li>控制器时间 = 1ms</li>
<li>因此访问时间 = 9 + 4.2 + 0.125 + 1 = 14.3ms</li>
</ul>
<h4 id="磁表面记录密度"><a href="#磁表面记录密度" class="headerlink" title="磁表面记录密度"></a>磁表面记录密度</h4><ul>
<li><p>磁盘记录数据的密度一般用“磁表面记录密度”来表示，也就是每平方英寸上的位数：</p>
<ul>
<li>1988年前，每年增长约 29%，即 3 年翻一番；</li>
<li>~1996年后，每年增长 60%，即 3 年翻四番。</li>
<li>~2001年，每年增长 100%，2001 年实验室中可达每平方英寸600亿位</li>
</ul>
</li>
<li><p>提高转速可以提高数据传输速率。旋转速度越高，数据就可以越快到达驱动器读写头能够接触的位置。目前硬盘最大转速为 15000RPM。但转速提高也带来一些弊端，例如工作噪音和发热量变大，工作状态下的抗冲击能力也有所下降等。</p>
</li>
<li>提高记录密度。目前采用的技术主要有：提高单碟容量以及改进信号处理技术。由于单碟容量越大的硬盘数据密度越高，磁头的寻道频率与移动距离可以相应的减少，从而减少了平均寻道时间，内部传输速率也得到了提高</li>
<li>在传统的纵向记录技术中，为了提高面密度以增加总的存储容量，必须压缩数据位并使其更紧密地排列在一起。然而，如果数据位太小，为其定位的磁能也会相应减小，小到一定程度后热能就可能会使其退磁，存储的数据就会丢失，这一现象被称为<em>超顺磁性</em>。为了避免超顺磁性效应，磁盘介质制造商一直在努力提高介质的矫顽磁性(写一个数据位所需要的‘磁场’ ) 。不过，能施加的磁场大小会受到磁头材料的限制</li>
<li>而在垂直记录技术(Perpendicular Magnetic Recording)中，盘片的磁化不像目前水平记录技术那样发生在盘片所在的平面上，而是发生在与盘片相垂直的平面上。这样一来，数据位就是指向上或向下的定向磁化区域。(在水平记录技术中，数据位的磁化是在磁盘平面上，在与磁头运动方向相同和相反的点之间翻转。)介质淀积在软磁衬底上，衬底的作用是作为写磁场返回路径的一部分并有效地生成记录磁头的镜像，这将使记录磁场增强一倍，故能达到比水平记录技术更高的记录密度。值得一提的是，垂直记录并不会因这项强化而提高功率消耗或产生更高热能，这对于对耗电与热量敏感的笔记本领域非常关键。此外，垂直记录也因为能够强化数据对于热衰退的阻抗能力从而提升硬盘可靠性。对于生产厂商来说，垂直记录技术将可延长磁盘储存装置的发展年限，对消费者来说，则可提供更高容量的硬盘容量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/磁盘和半导体存储器之间的访问时间差距.png" alt="磁盘和半导体存储器之间的访问时间差距"></p>
<p>磁盘在后备存储器上的地位曾受到过多次考验，主要原因就是所谓“访问时间差距”问题。磁盘与 DRAM 的性能价格比差异很大。虽然 DRAM 的数据传输率约为磁盘的 50 倍，但是其访问时间却是磁盘的十万分之一</p>
<h3 id="6-1-2-Flash-存储器和固态硬盘-SSD"><a href="#6-1-2-Flash-存储器和固态硬盘-SSD" class="headerlink" title="6.1.2 Flash 存储器和固态硬盘 SSD"></a>6.1.2 Flash 存储器和固态硬盘 SSD</h3><ul>
<li>SSD的优点是：<ul>
<li>永久性；</li>
<li>速度快；</li>
<li>高传送速率和高可靠性。</li>
</ul>
</li>
<li>SSD的最大缺点是：<ul>
<li>有限擦写次数<ul>
<li>磨损均衡（动态、静态）</li>
</ul>
</li>
<li>成本太高，每 MB 的价格大约是磁盘价格的 50 倍</li>
</ul>
</li>
</ul>
<h3 id="6-1-3-磁带"><a href="#6-1-3-磁带" class="headerlink" title="6.1.3 磁带"></a>6.1.3 磁带</h3><ul>
<li>磁盘和磁带性能价格比的差异主要取决于它们的机械构成<ul>
<li>磁盘盘片具有有限的存储面积，并且存储介质被封装在每个读部件内，提供 ms 级的随机访问</li>
<li>磁带绕在可转动轴上，一个读部件可以使用多盘磁带(没有长度限制)，但磁带需要顺序访问，每次访问都可能需要较长的反绕、退出和加载时间，等待时间较长(数秒)</li>
</ul>
</li>
<li>对磁带而言，最大的优点是容量极大、技术成熟、单位价格低廉。最大的缺点是访问时间较长。这种差异恰好使得磁带成为磁盘的备份技术。</li>
<li>宽 0.38cm~1.27cm;长 183m~731.5m;(110G 以上）</li>
<li>磁带技术的主要受限因素是在其线速度不定，为解决该问题，提出了“螺旋扫描磁带(Helical Scan Tapes)”，使磁带保持同样的线速度，这种技术以 20 到 50 的倍数增加记录密度，螺旋扫描磁带目前已被普遍使用在视频录像设备中，大大降低了磁带和读部件的开销</li>
<li>磁带的另外一个缺点是易磨损，螺旋磁带只能使用几百遍，传统的高质量磁带则可以使用几百万遍。螺旋扫描磁头同样容易磨损，通常额定指标为连续使用 2000 小时</li>
<li>为了解除操作中的负担，同时也加速换带速度，便产生了自动磁带库。自动磁带库通过机械手自动地安装和更换磁带，相当于又提供了一个新的存储器层次，这种自动化的磁带库可在无人工干预的情况下，十几秒内访问几TB的信息</li>
<li>STC 的 PowderHorn 可以处理 6000 个磁带，提供的总容量达 60TB</li>
</ul>
<h3 id="6-1-4-光盘"><a href="#6-1-4-光盘" class="headerlink" title="6.1.4 光盘"></a>6.1.4 光盘</h3><ul>
<li>只读类光盘的全称为<code>光学紧密盘(Optical Compact Disk)</code>，简称 CD-ROM。</li>
<li>特点是：<ul>
<li>容量大(640M字节)、存储寿命长；</li>
<li>成本低、读出设备价格便宜；</li>
<li>便于保管、便于携带等。</li>
</ul>
</li>
<li>最大问题是不能够写入。因此 CD-ROM 适于作为软件和资料的载体，基本已经替代了几年前广泛使用的软盘</li>
<li>可写类光盘包括两类：<ul>
<li>一次性写：称为可记录光盘 <code>CD-R(CD-Recordable)</code>，又称为 <code>WORM</code> 盘，出厂时是空白的，用户通过写入设备，将数据写入 <code>CD-R</code> 中。特性与 <code>CD-ROM</code> 相当，可以通过普通的 <code>CD-ROM</code> 读设备读出，因此特别适合于作为数据备案的存储介质。</li>
<li>多次写：称为 <code>WMRM(Write Many Read Many)</code> 盘，主要采用磁光(MO)存储技术</li>
</ul>
</li>
<li>MO光盘的容量更大(有 600MB、1.2GB、2.4GB 等规格)、保存和使用都很方便、便于携带，最大的问题是目前盘片和读写设备的价格昂贵，且各厂家的标准不统一，因此不够普及。这种 WMRM 盘作为大型软件编制、多媒体软件产品研制过程中的备案介质是非常合适的</li>
<li>多台光盘机组合在一起有三种结构：<ul>
<li>光盘库(也叫自动换盘机，即Jukebox)<ul>
<li>光盘库是一种能自动把机框中存放的许多片光盘选出并装入光盘机进行读写的设备</li>
<li>费用低；</li>
<li>可兼容性及低风险；</li>
<li>随机存取；</li>
<li>存储寿命长、保管容易、占用空间少；</li>
<li>具有多媒体功能</li>
</ul>
</li>
<li>光盘塔(CD-ROM Tower)<ul>
<li>优点：<ul>
<li>安装简便；易于管理；使用便利；</li>
<li>资源共享；远程访问；</li>
<li>寿命长；结构简单；造价也低；</li>
<li>读取光盘速度快。</li>
</ul>
</li>
<li>缺点：<ul>
<li>容量较小；光盘塔中光盘机数量受到 SCSI 设备地址数的限制</li>
</ul>
</li>
</ul>
</li>
<li>光盘阵列(CD-ROM Array)<ul>
<li>从阵列技术的基本原理来说，光盘阵列与磁盘阵列有一定的相似性。但光盘具有盘片可换、每道(柱面)只有一个读写头、寻道时间较长等特点，因此光盘阵列技术又有其特殊性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-I-O-系统分析与评价"><a href="#6-2-I-O-系统分析与评价" class="headerlink" title="6.2 I/O 系统分析与评价"></a>6.2 I/O 系统分析与评价</h2><h3 id="1-I-O性能与系统响应时间"><a href="#1-I-O性能与系统响应时间" class="headerlink" title="1. I/O性能与系统响应时间"></a>1. I/O性能与系统响应时间</h3><ul>
<li>衡量I/O系统性能的标准<ul>
<li>I/O系统的容量(能连几个 USB 等)</li>
<li>响应时间</li>
<li>吞吐率</li>
</ul>
</li>
<li>响应时间和吞吐率之间存在矛盾<ul>
<li>生产服务模型</li>
</ul>
</li>
</ul>
<h3 id="2-Little-定律"><a href="#2-Little-定律" class="headerlink" title="2. Little 定律"></a>2. Little 定律</h3><ul>
<li>I/O系统的响应时间和吞吐率的计算<ul>
<li>排队论</li>
<li>黑箱(Black Box)</li>
</ul>
</li>
<li>Little定律<ul>
<li>系统中的平均任务数 = 到达率×平均响应时间</li>
</ul>
</li>
</ul>
<h3 id="3-M-M-1-排队系统"><a href="#3-M-M-1-排队系统" class="headerlink" title="3. M/M/1 排队系统"></a>3. M/M/1 排队系统</h3><ul>
<li>M/M/1排队系统一般假设为：<ul>
<li>系统为一个平衡系统</li>
<li>连续两个到达请求的时间间隔服从<strong>指数分布</strong>，其均值为平均到达时间</li>
<li>请求的个数不受限制</li>
<li>如果排队中有任务，服务员服务完当前任务后立即服务下一个</li>
<li>队列无限长，FIFO 规则</li>
<li>系统只有一个服务员</li>
</ul>
</li>
<li><p>相关结论<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/MM1排队系统的相关结论.png" alt="MM1排队系统的相关结论"></p>
</li>
<li><p>M/M/m 排队系统</p>
<ul>
<li>基于 M/M/1 排队系统</li>
<li>服务员增加为 m 个</li>
<li>相关结论</li>
</ul>
</li>
</ul>
<h3 id="4-I-O-基准测试程序"><a href="#4-I-O-基准测试程序" class="headerlink" title="4. I/O 基准测试程序"></a>4. I/O 基准测试程序</h3><ul>
<li>使用 I/O 基准测试程序来反映响应时间和吞吐率之间的平衡关系</li>
<li>TPC<ul>
<li>事务处理委员会</li>
<li>发布 9 个事务处理基准测试程序</li>
<li>高端商业应用中，通常采用 TPC-C 测试程序进行测试</li>
</ul>
</li>
<li>TPC具有一些独特的性质<ul>
<li>测试结果中给出系统的价格因素</li>
<li>TPC模拟的是实际系统</li>
<li>测试结果经过TPC审核后才能发布</li>
<li>吞吐率指标受到响应时间的限制</li>
<li>通过独立的机构来维护</li>
</ul>
</li>
</ul>
<h3 id="5-I-O-系统的可靠性、可用性和可信性"><a href="#5-I-O-系统的可靠性、可用性和可信性" class="headerlink" title="5. I/O 系统的可靠性、可用性和可信性"></a>5. I/O 系统的可靠性、可用性和可信性</h3><ul>
<li>术语<ul>
<li>故障(fault)，可以恢复</li>
<li>错误(error)，不能恢复，不一定使得机器停掉</li>
<li>失效(failure)</li>
</ul>
</li>
<li>故障产生原因<ul>
<li>硬件</li>
<li>设计</li>
<li>操作</li>
<li>环境(温度等)</li>
</ul>
</li>
<li>故障分类<ul>
<li>暂时性</li>
<li>间歇性</li>
<li>永久性</li>
</ul>
</li>
<li>存储外设可靠性参数<ul>
<li>可靠性</li>
<li>可用性</li>
<li>可信性</li>
</ul>
</li>
<li>提高系统可靠性的方法<ul>
<li>故障避免技术：通过合理构建系统来避免故障</li>
<li>故障容忍技术：采取冗余措施</li>
<li>错误消除技术：通过验证，最大限度地减少潜在的错误</li>
<li>错误预报技术：通过分析，预报错误的出现，以便提前采取应对措施</li>
</ul>
</li>
</ul>
<h2 id="6-3-RAID"><a href="#6-3-RAID" class="headerlink" title="6.3 RAID"></a>6.3 RAID</h2><p><strong>盘阵列(RAID，即 Redundant Array of Inexpensive Disks)，即廉价磁盘冗余阵列，简称盘阵列技术</strong></p>
<blockquote>
<p>1987年，由加州大学伯克利分校的Patterson、Gibson 和 Katz 提出</p>
</blockquote>
<p>既可以提高存储系统的可靠性，又可以提高存储系统的性能。这种技术可以通过使用多个磁盘驱动器（包括多个磁臂）而不是使用一个大容量的磁盘（单个磁臂）来提高磁盘的吞吐率。使用磁盘阵列可以简单地将数据分布到多个磁盘上（称为数据分块技术），这样使得一个数据的访问将导致对多个磁盘的同时访问。</p>
<p>盘阵列容量大、速度快、可靠性高、造价低廉。它是目前解决计算机I/O瓶颈的有效方法之一，有着广阔的发展前景</p>
<h3 id="6-3-1-RAID-0"><a href="#6-3-1-RAID-0" class="headerlink" title="6.3.1 RAID 0"></a>6.3.1 RAID 0</h3><ul>
<li><p><strong>亦称数据分块（Striping）</strong>，即把数据分布在多个盘上，实际上是非冗余阵列，无冗余信息。严格地说，它不属于 RAID 系列<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%200.png" alt="RAID 0"></p>
</li>
<li><p>优点：高性能，磁盘利用率高</p>
</li>
<li>缺点：系统可靠性差，没有冗余</li>
</ul>
<h3 id="6-3-2-RAID-1"><a href="#6-3-2-RAID-1" class="headerlink" title="6.3.2 RAID 1"></a>6.3.2 RAID 1</h3><ul>
<li><p><strong>亦称镜像盘，使用双备份磁盘</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%201.png" alt="RAID 1"></p>
</li>
<li><p>优点：I/O速度快，可靠性高</p>
</li>
<li>缺点：代价高，可扩展性不好</li>
</ul>
<p>一个读请求可由包含请求数据的两个物理磁盘中的某一个提供，只要它的寻道时间加旋转时间延迟较小。这样 RAID 1 的读性能由镜像盘中读性能最好的磁盘决定。故在 I/O 处理中，如果是大批的读请求，RAID 1 的性能能够达到 RAID 0 性能的两倍</p>
<h3 id="6-3-3-RAID-2"><a href="#6-3-3-RAID-2" class="headerlink" title="6.3.3 RAID 2"></a>6.3.3 RAID 2</h3><ul>
<li><p><strong>位交叉式海明编码阵列</strong><br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%202.png" alt="RAID 2"></p>
</li>
<li><p>优点：</p>
<ul>
<li>高速误差校正</li>
<li>数据传输速率高</li>
</ul>
</li>
<li>缺点：<ul>
<li>校正空间较大，盘阵列利用率较低</li>
</ul>
</li>
</ul>
<p>RAID 2 的优点是使用海明编码来进行错误检测和纠正，数据传输率高。海明校验码可以检测磁盘的 2 位错误，并纠正 1 位数据错误。对于单个读，所有磁盘同时读取，请求的数据和相关的海明校验码被传送到阵列管理器。如果出现 1 位错误，则阵列管理器可以立即识别并加以纠正，因此读取时间很短，可以达到很高的数据传输率。对于单个写，所有的数据盘和校验盘都要参加写操作。RAID 2 阵列管理器的设计比后面的 RAID 级别要简单</p>
<p>RAID 2 的缺点是需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。这样，尽管 RAID 2 比 RAID 1 需要的磁盘少，RAID 2 存储容量的利用率仍然不高，尤其是在数据字长较短的情况下。另外，RAID 2 可以达到的数据传输率将受限于整个磁盘阵列中最慢的磁盘以及阵列管理器的校验速度</p>
<h3 id="6-3-4-RAID-3"><a href="#6-3-4-RAID-3" class="headerlink" title="6.3.4 RAID 3"></a>6.3.4 RAID 3</h3><ul>
<li><p><strong>位交叉奇偶校验盘阵列</strong>，是单盘容错并行传输的阵列。即数据以位或字节交叉的方式存于各盘，冗余的奇偶校验信息存储在一台专用盘上<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%203.png" alt="RAID 3"></p>
</li>
<li><p>在RAID3中，将磁盘分组，读写要访问组中所有盘。当一个磁盘出故障时，可以通过奇偶校验磁盘中的校验和来恢复出错数据</p>
</li>
<li>优点：冗余代价低，传输速率高</li>
<li>应用领域：多媒体应用</li>
</ul>
<p>先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。一旦某一个盘失效，只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是失效的盘上的数据。冗余盘中的奇偶校验和通常是模 2 和。这种方法的缺点是恢复时间较长，但由于磁盘失效的可能性很小，因此还是可以接受的</p>
<h3 id="6-3-5-RAID-4"><a href="#6-3-5-RAID-4" class="headerlink" title="6.3.5 RAID 4"></a>6.3.5 RAID 4</h3><ul>
<li><strong>块交叉奇偶校验盘阵列</strong>，即数据以块(块大小可变)交叉的方式存于各盘，冗余的奇偶校验信息存在一台专用盘上<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%204.png" alt="RAID 4"></li>
</ul>
<p>优点：读写速度快；冗余代价低<br>缺点：阵列控制器复杂</p>
<p>由于磁盘扇区中存在错误检测信息，使得磁盘在读数据时就可以检测数据是否正确，因此只要访问的数据以扇区为单位，则每个磁盘都可以同时独立地进行这种操作。与 RAID 3 相比，RAID 4 中对一个数据的读操作是对两个磁盘的两次读操作</p>
<h3 id="6-3-6-RAID-5"><a href="#6-3-6-RAID-5" class="headerlink" title="6.3.6 RAID 5"></a>6.3.6 RAID 5</h3><ul>
<li><p><strong>块交叉分布式奇偶校验盘阵列</strong>，即数据以块交叉的方式存于各盘，但无专用的校验盘，而是把冗余的奇偶校验信息均匀地分布在所有磁盘上<br><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%205.png" alt="RAID 5"></p>
</li>
<li><p>优点：</p>
<ul>
<li>冗余代价较小；</li>
<li>读数据速率高；</li>
<li>写数据相对较快。</li>
</ul>
</li>
<li>缺点：<ul>
<li>控制器设计复杂</li>
</ul>
</li>
</ul>
<p>通过将校验信息分布到多个磁盘中，这样就不会出现 RAID 4 中冗余磁盘成为写操作的瓶颈这个问题</p>
<h3 id="6-3-7-RAID-6"><a href="#6-3-7-RAID-6" class="headerlink" title="6.3.7 RAID 6"></a>6.3.7 RAID 6</h3><ul>
<li><strong>双维奇偶校验独立存取盘阵列</strong>，即数据以块(块大小可变)交叉的方式存于各盘，冗余的检、纠错信息均匀地分布在所有磁盘上。并且，每次写入数据都要访问一个数据盘和两个校验盘，可容忍双盘出错</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%206.png" alt="RAID 6"></p>
<p>目前的计算机实际上是将多种盘阵列技术综合使用</p>
<h2 id="6-4-总线"><a href="#6-4-总线" class="headerlink" title="6.4 总线"></a>6.4 总线</h2><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/总线概述.png" alt="总线概述"></p>
<p><strong>1. 总线特点</strong></p>
<ul>
<li>优点：<ul>
<li>低成本</li>
<li>多样性</li>
</ul>
</li>
<li>缺点：<ul>
<li>可能造成设备信息交换的瓶颈，从而限制了系统中总的I/O吞吐量</li>
</ul>
</li>
</ul>
<p>总线设计存在很多技术难点，一个重要原因就是总线上信息传送的速度极大地受限于各种物理因素，如总线的长度、设备的数目、信号的强度等，这些物理因素限制了总线性能的提高。另外，对 I/O 操作的低延迟要求以及对 I/O 高吞吐量的要求也可能造成设计需求上的冲突</p>
<p><strong>2. 总线设计时因考虑的因素</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/总线设计时因考虑的因素.png" alt="总线设计时因考虑的因素"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><ul>
<li>按设备定时方式分类：<ul>
<li>同步总线；同步总线上所有设备通过统一的总线系统时钟进行同步</li>
<li>异步总线：设备之间没有统一的系统时钟，设备自己内部定时。设备之间的信息传送用总线发送器和接收器控制。但在传输时，异步总线需要额外的同步开销</li>
<li>采用独立的地址和数据线、更宽的数据总线的位数以及多字数据传输块将提高总线的性能，但同时也带来了高成本</li>
</ul>
</li>
</ul>
<p><strong>3. 总线标准</strong></p>
<ul>
<li>只要计算机和 I/O 设备的设计都满足相应的标准，那么 I/O 设备和计算机可以任意连接</li>
<li>I/O 总线标准就是定义设备连接的文件</li>
</ul>
<p><strong>4. 常用的 I/O 总线</strong></p>
<ul>
<li>概况</li>
<li><p>常用的 I/O 总线标准</p>
<ul>
<li>ISA</li>
<li>EISA</li>
<li>PCI：扩展主机设备(PCIE)</li>
<li>USB(含 USB 2.0)：连接各种外部设备到主机</li>
<li>IEEE 1394、……</li>
<li>RS-485/RS-232</li>
<li>CAN(汽车，卫星)</li>
<li>IIC(家电等)</li>
</ul>
</li>
<li><p>主要影响因素：</p>
<ul>
<li>系统中各部件的工作频率</li>
<li>传输数据和编址地址位数</li>
</ul>
</li>
</ul>
<p><strong>5. I/O 总线的发展历程</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO总线的发展历程.png" alt="IO总线的发展历程"></p>
<p><strong>6. 设备的连接</strong></p>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5.png" alt="设备连接"></p>
<ul>
<li>I/O 设备编址方式<ul>
<li>存储器映射 I/O</li>
<li>独立编址(有单独的访问 I/O 指令，如 in, out)</li>
</ul>
</li>
<li><p>I/O 设备控制方式</p>
<ul>
<li>程序查询</li>
<li>中断</li>
<li>DMA(部分单片机内也开始使用这种方式)</li>
<li>I/O 处理机(包含功能较弱的通道)</li>
</ul>
</li>
<li><p>在大型计算机系统中，采用程序控制、中断和 DMA 这三种基本的 I/O 方式来管理外围设备，会引起如下两个问题：</p>
<ul>
<li>所有外围设备的 I/O 工作全部都要由CPU来承担，CPU 的 I/O 负担很重，不能专心于用户程序的计算。低速外围设备每传送一个字符都要由 CPU 执行一段程序来完成，而高速外围设备虽然使用 DMA 方式减少了 CPU 的干预，但初始化工作仍然需要 CPU 用程序来完成</li>
</ul>
</li>
</ul>
<p>（四种设备控制方式为计组重点内容，略）</p>
<h2 id="6-5-通道"><a href="#6-5-通道" class="headerlink" title="6.5 通道"></a>6.5 通道</h2><ul>
<li>接受 CPU 发来的 I/O 指令，根据指令要求选择一台指定的外围设备与通道相连接</li>
<li>执行 CPU 为通道组织的通道程序，从主存中取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令</li>
<li>给出外围设备的有关地址，即进行读／写操作的数据所在的位置。如，磁盘存储器的柱面号、磁头号、扇区号等</li>
<li>给出主存缓冲区的首地址，这个缓冲区用来暂时存放从外围设备上输入的数据，或者暂时存放将要输出到外围设备中去的数据</li>
<li>控制外围设备与主存缓冲区之间数据交换的个数，对交换的数据个数进行计数，并判断数据传送工作是否结束</li>
<li>指定传送工作结束时要进行的操作。例如，将外围设备的中断请求及通道的中断请求送往 CPU 等</li>
<li>检查外围设备的工作状态，是正常或故障。根据需要将设备的状态信息送往主存指定单元保存</li>
<li><p>在数据传输过程中完成必要的格式变换，例如，把字拆卸为字节，或者把字节装配成字等</p>
</li>
<li><p>通道分为三种类型：</p>
<ul>
<li>字节多路通道：简单的共享通道，为多台低速或中速的外围设备服务。采用分时方式工作</li>
<li>选择通道：为高速外围设备（如磁盘存储器等）服务。在传送数据期间，只能为一台高速外围设备服务，在不同的时间内可以选择不同的设备，可以在一段集中的时间内完成高速设备的传输任务，比较适合高速设备</li>
<li>数组多路通道：为高速设备服务。时间片轮转、分时复用的思想，各台高速设备重迭操作，但是传输的单位不是字节，而是一块</li>
</ul>
</li>
</ul>
<h2 id="6-6-I-O-与操作系统"><a href="#6-6-I-O-与操作系统" class="headerlink" title="6.6 I/O 与操作系统"></a>6.6 I/O 与操作系统</h2><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO与Cache的一致性问题.png" alt="IO与Cache的一致性问题"></p>
<p>能够使处理器性能发挥的软件是编译器，而发挥存储性能的软件是操作系统，采用哪种硬件进行 I/O 处理由操作系统决定，所以在设计 I/O 系统时还要注意操作系统的因素</p>
<ul>
<li>数据不一致问题有两个方面<ul>
<li>存储器中可能不是 CPU 产生的最新数据，所以 I/O 系统从存储器中取出来使用的是陈旧数据</li>
<li>I/O 与存储器交换数据之后，在 Cache 中被 CPU 使用的可能就是陈旧数据</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/对一致性问题的思考.png" alt="对一致性问题的思考"></p>
<p>由于 I/O 会在两个方面导致数据不一致的问题，那么我们直接将 I/O 总线挂接在 Cache 上，这样 I/O 从 Cache 读取数据一定是最新的（无论 Cache 写策略是直写还是写回），CPU 访问数据时要先访问 Cache，因此 CPU 使用的数据也是最新的。<br>但是这种方式需要考虑对性能的影响。</p>
<ul>
<li>写直达 Cache 可以保证存储器和 Cache 有相同的数据<ul>
<li>但是这种方式只能解决一个方面的数据不一致问题，即 CPU 读数据时仍然读取到的是 Cache 的旧数据</li>
</ul>
</li>
<li>写回 Cache 则需操作系统帮助进行数据检查</li>
<li><strong>根据 I/O 使用的存储器地址来清除 Cache 相应的块，确保 I/O 使用的数据不在 Cache 中</strong><ul>
<li>这种方式貌似可行，但是相对来说增加了一点开销</li>
</ul>
</li>
<li>地址检查过程也可以使用硬件完成</li>
</ul>
<h3 id="DMA-与虚拟存储器"><a href="#DMA-与虚拟存储器" class="headerlink" title="DMA 与虚拟存储器"></a>DMA 与虚拟存储器</h3><ul>
<li>使用 DMA，I/O 设备直接访问内存（物理地址），如果不使用虚拟存储器，则 DMA 使用物理地址来传输数据</li>
<li>若使用虚拟存储器，使用物理地址进行 DMA，存在以下两个问题：<ul>
<li>对于超过一页的数据，由于缓冲区使用的页面在物理存储器中不一定是连续的，传输会发生问题</li>
<li>DMA 正在存储器和帧缓冲器之间传输数据时，操作系统从存储器中移出一些页面(或重新分配)，DMA 将会在存储器中错误的页面上传输数据</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/虚拟DMA技术.png" alt="虚拟DMA技术"></p>
<p>允许 DMA 设备直接使用虚拟地址，在 DMA 期间由硬件将虚拟地址映射到物理地址。这样，I/O 使用的缓冲区页面在虚拟存储器中是连续的，但物理页面可以分散在物理存储器中，并且虚拟地址提供了对 I/O 操作的保护。如果使用虚拟 DMA 的进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表</p>
<h1 id="第七章-多处理机"><a href="#第七章-多处理机" class="headerlink" title="第七章 多处理机"></a>第七章 多处理机</h1><blockquote>
<p><strong>一个问题</strong>:<br>图书馆将一批新书上架，可以有多种方式。假定将书按类上架，而将书架依据在书库中的位置分成一些组<br><strong>解决办法</strong><br>若由一工人单独完成，不能在要求的时间内完成任务<br>若由多个工人完成， 假定每次一人仅往书架上放一本书。可以采用两种不同的方式<br>（1）将所有的书籍平均分配给每个人去完成。这种划分方法不是太有效，原因是每个工人为了将书上架必须走遍所有的书架。<br>（2）将所有书架分成一些组，且平均分配给各个工人负责，同时将所有图书平均分配给每个工人去上架。如果工人发现一本书属于自己所负责的书架上，则将其放入书架。否则，将这本书传给所在书架对应的工人。这种分法对应的效率比较高<br><strong>结论</strong><br>将一个任务划分成一些子任务，并分配给多个工人去完成，工人们相互合作、并在需要时相互传递图书，这种协调的工作方式可较快地完成任务<br><strong>并行计算就是严格地按照上述原理来完成的</strong></p>
</blockquote>
<p><strong>并行计算相关的两个概念</strong></p>
<ol>
<li><strong>任务划分</strong>(task partitioning)<br>将图书平均分配给所有工人为任务划分的一个例子。</li>
<li><strong>通信</strong>(communication)<br>工人之间传递图书为子任务通信的例子。<br>什么是并行计算？</li>
</ol>
<p>并行计算是指同时对多个任务或多条指令、或对多个数据项进行处理。完成此项处理的计算机系统称为并行计算机系统，它是将多个处理器通过网络以一定的连接方式有序地组织起来</p>
<p><strong>并行计算机的发展原因</strong>：</p>
<ul>
<li>要获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起</li>
<li>体系结构改进能否持续下去？通过复杂度和硅技术的提高得到的性能提升正在减小；</li>
<li>并行计算机应用软件已有缓慢但稳定的发展。</li>
<li>重点：中小规模的机器(处理器的个数不超过128)的多处理机设计技术</li>
</ul>
<p><strong>并行计算的研究内容:</strong><br>(1) 并行计算机设计<br>(2) 有效算法的设计<br>(3) 评价并行算法的方法<br>(4) 并行计算机语言<br>(5) 并行编程环境与工具<br>(6) 并行程序的可移植性<br>(7) 并行计算机的自动编程</p>
<p><strong>并行计算的应用领域：</strong><br>(1) 天气预报<br>(2) 卫星数据处理<br>(3) 石油数据处理（连续优化问题）<br>(4) 调度问题<br>(5) VLSI设计（离散优化问题）<br>(6) ……</p>
<p><strong>美国政府的HPCC计划公布的重大挑战性应用</strong></p>
<ol>
<li>磁记录技术：研究静磁和交互感应以降低高密度磁盘的噪音</li>
<li>新药设计：通过抑制人的免疫故障病毒蛋白酶的作用来研制治疗癌症与艾滋病的药物</li>
<li>高速民航：用计算流体动力学来研制超音速喷气发动机</li>
<li>催化作用：仿生催化剂计算机建模，分析合成过成中的酶作用</li>
<li>燃料燃烧：通过化学动力学计算，揭示流体力学的作用，设计新型发动机</li>
<li>海洋建模：对海洋活动与大气流的热交换进行整体海洋模拟</li>
<li>臭氧耗损：研究控制臭氧损耗过程中的化学与动力学机制</li>
<li>数字解析：实时临床成像、计算层析术、磁共振成像 </li>
<li>大气污染：对大气质量模型进行模拟研究，控制污染的传播，揭示其物理与化学机理</li>
<li>蛋白质结构设计：对蛋白质组成的三维结构进行计算机模拟研究</li>
<li>图像理解：实时绘制图像或动态</li>
<li>密码破译：破译由长位数组成的密码，寻找该数的两个乘积因子</li>
</ol>
<p><strong>并行计算的应用分类</strong></p>
<p>（1）计算密集型（Compute-Intensive）<br>这一类型的应用问题主要集中在大型科学工程计算与数值模拟（气象预报、地球物理勘探等）<br>（2）数据密集型 (Data-Intensive)<br>Internet的发展，为我们提供了大量的数据资源，但有效地利用这些资源，需要进行大量地处理，且对计算机的要求也相当高，这些应用包括数字图书馆、数据仓库、数据挖掘、计算可视化。<br>（3）网络密集型 (Network-Intensive)<br>通过网络进行远距离信息交互，来完成用传统方法不同的一些应用问题。如协同工作、遥控与远程医疗诊断等</p>
<h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><p>单处理机的发展正在走向尽头？<br>并行计算机在未来将会发挥更大的作用。</p>
<ul>
<li>获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起；</li>
<li>自1985年以来，体系结构的改进使性能迅速提高，这种改进的速度能否持续下去还不清楚，但通过复杂度和硅技术的提高而得到的性能的提高正在减小；</li>
<li>并行计算机应用软件已有缓慢但稳定的发展。</li>
</ul>
<p>本章重点:中小规模的机器(处理器的个数＜100 多处理机设计的主流)</p>
<h3 id="7-1-1-并行计算机体系结构的分类"><a href="#7-1-1-并行计算机体系结构的分类" class="headerlink" title="7.1.1 并行计算机体系结构的分类"></a>7.1.1 并行计算机体系结构的分类</h3><ol>
<li>按Flynn分类法，可把计算机分成</li>
</ol>
<ul>
<li>单指令流单数据流（SISD）</li>
<li>单指令流多数据流（SIMD）</li>
<li>多指令流单数据流（MISD）</li>
<li>多指令流多数据流（MIMD）</li>
</ul>
<ol>
<li>MIMD已成为通用多处理机体系结构的选择，原因：</li>
</ol>
<ul>
<li>MIMD具有灵活性</li>
<li>MIMD可以充分利用商品化微处理器在性能价格比方面的优势</li>
</ul>
<p><strong>MIMD的优点</strong>（灵活性/COTS）</p>
<ul>
<li>MIMD机器分类:集中式共享存储器结构(Centralized Shared-Memory Architecture)。,也称为对称式共享存储器结构(SMP, Symmetric shared-memory MultiProcessor)机器或者UMA(Uniform Memory Access)机器。</li>
<li>分布式存储器结构的机器。支持较大数目的处理器，存储器必须分布到各个处理器上，而非采用集中式，否则存储器系统将不能满足处理器带宽的要求。系统中每个结点包含了处理器、存储器、I／O以及互连网络接口</li>
</ul>
<ol>
<li>MIMD机器分为两类（每一类代表了一种存储器的结构和互连策略）</li>
</ol>
<ul>
<li>集中式共享存储器结构<ul>
<li>这类机器有时被称为 UMA(Uniform Memory Access)机器</li>
</ul>
</li>
<li><p>分布式存储器结构</p>
<ul>
<li>每个结点包含：处理器、存储器、I/O</li>
<li>在许多情况下，分布式存储器结构优于采用集中式共享存储器结构。</li>
<li>分布式存储器结构需要高带宽的互连</li>
</ul>
</li>
<li><p>分布式存储器结构的优点</p>
<ul>
<li>如果大多数的访问是针对本结点的局部存储器，则可降低对存储器和互连网络的带宽要求；</li>
<li>对局部存储器的访问延迟低</li>
</ul>
</li>
<li>主要缺点<ul>
<li>处理器之间的通信较为复杂，且各处理器之间访问延迟较大</li>
</ul>
</li>
</ul>
<h3 id="7-1-2-通信模型和存储器的结构模型"><a href="#7-1-2-通信模型和存储器的结构模型" class="headerlink" title="7.1.2 通信模型和存储器的结构模型"></a>7.1.2 通信模型和存储器的结构模型</h3><ol>
<li>两种地址空间的组织方案</li>
</ol>
<ul>
<li>物理上分离的多个存储器可作为一个逻辑上共享的存储空间进行编址。<ul>
<li>这类机器的结构被称为分布式共享存储器(DSM)或可缩放共享存储器体系结构。</li>
<li>DSM 机器被称为 NUMA(non-uniform memory access)机器。</li>
</ul>
</li>
<li>整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址</li>
<li>每一个处理器-存储器模块实际上是一个单独的计算机，这种机器也称为多计算机</li>
</ul>
<p>两种方案：</p>
<ul>
<li>DSM：一个处理器如果具有访问权，就可以访问任何一个其他的局部存储器，<br>DSM机器被称为 NUMA(Non-Uniform Memory Access)机器，这是因为其访问时间依赖于数据在存储器中的存放位置。 </li>
<li>整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址。在这种机器的不同处理器中，相同的物理地址指向不同存储器的不同单元</li>
</ul>
<ol>
<li>两种通信模型</li>
</ol>
<ul>
<li>共享地址空间的机器（共享存储器机器）<ul>
<li>利用 Load 和 Store 指令中的地址隐含地进行数据通信</li>
</ul>
</li>
<li>多个地址空间的机器<ul>
<li>通过处理器间显式地传递消息完成 (消息传递机器)</li>
</ul>
</li>
<li>消息传递机器根据简单的网络协议，通过传递消息来请求某些服务或传输数据，从而完成通信</li>
</ul>
<p>区别：</p>
<ul>
<li>对于共享地址空间的机器，用 load 和 store 指令中的地址隐含地进行数据通讯，因而可称为 <strong>共享存储器机器</strong></li>
<li>对于多个地址空间的机器，数据通讯要通过处理器间显式地传递消息完成，因而这种机器常称为 <strong>消息传递机器</strong></li>
</ul>
<p>例如：<br>一个处理器要对远程存储器上的数据进行访问或操作<br>(1) 发送消息，请求传递数据或对数据进行操作；<br>远程进程调用(RPC， remote process call)<br>(2) 目的处理器接收到消息以后，执行相应的操 作或代替远程处理器进行访问，并发送一个   应答消息将结果返回</p>
<p>对于通信机制的性能，可以通过下面三个关键的性能指标来进行衡量：</p>
<ol>
<li>通信带宽──理想状态下的通信带宽受限于处理器、存储器和互连网络的带宽。进行通信时，结点内与通信相关的资源被占用，这种占用限制了通信速度。</li>
<li>通信延迟──理想状态下通信延迟应尽可能地小。通信延迟的构成为：<br><strong>通信延迟＝发送开销＋跨越时间＋传输延迟＋接收开销</strong>（?）<blockquote>
<p>（老师讲 “跨越时间”是指第一位数据从发送端口到接收端口所需的时间，“传输延迟”是指最后一位通信数据从发送端口到接收端口之间的延迟，我没怎么听懂，这两个有什么区别吗？这和计网里的数据包传送有什么不一样吗？）</p>
</blockquote>
</li>
<li>通讯延迟的隐藏──如何才能较好地将通信和计算或多次通信之间重叠起来，以实现通讯延迟的隐藏 </li>
</ol>
<p><strong>每种通信机制各有优点，共享存储器通信主要有以下优点：</strong><br>(1) 与常用的对称式多处理机使用的通信机制兼容。<br>(2) 当处理器通信方式复杂或程序执行动态变化时易于编程，同时在简化编译器设计方面也占有优势(都统一翻译成存储指令即可)。<br>(3) 当通信数据较小时，通信开销较低，带宽利用较好。<br>(4) 通过硬件控制的 Cache 减少了远程通信的频度，减少了通信延迟以及对共享数据的访问冲突。</p>
<p><strong>消息传递通信机制的主要优点包括：</strong></p>
<ul>
<li>硬件较简单。  </li>
<li>通信是显式的，从而引起编程者和编译程序的注意，着重处理开销大的通信。<ul>
<li>当然，可在支持上面任何一种通信机制的硬件模型上建立所需的通信模式平台。</li>
<li>在共享存储器上支持消息传递相对简单，因为发送一条消息可通过将一部分地址空间的内容复制到另一部分地址空间来实现。</li>
<li>但在消息传递的硬件上支持共享存储器就困难得多</li>
</ul>
</li>
</ul>
<h3 id="7-1-3-并行处理面临的挑战"><a href="#7-1-3-并行处理面临的挑战" class="headerlink" title="7.1.3 并行处理面临的挑战"></a>7.1.3 并行处理面临的挑战</h3><ol>
<li>程序中有限的并行性<ul>
<li>有限的并行性使机器要达到好的加速比十分困难</li>
<li>通过所给的例子，100 个处理器达到 80 的加速比，并行比例要达到 99.75%，即 0.25% 的串行比例影响了 20 的加速比。因此我们得到结论：串行对于并行处理的加速比具有至关重要的影响</li>
</ul>
</li>
<li>相对较高的通信开销（可通过 Amdahl 定律解释）<ul>
<li>面临的第二个挑战主要是指多处理机中远程访问的较大延迟。在现有的机器中，处理器之间的数据通信大约需要 50～10000 个时钟周期 </li>
</ul>
</li>
</ol>
<p>并行性不足： 通过采用并行性更好的算法来解决<br>远程访问延迟的降低： 靠体系结构支持和编程技术</p>
<p>在并行处理中，负载平衡、同步和存储器访问延迟等影响性能的因素常依赖于高层应用特点，如应用程序中数据的分配，并行算法的结构以及数据在空间和时间上的访问模式等。</p>
<p>依据应用特点可把多机工作负载大致分成两类：单个程序在多处理机上的并行工作负载和多个程序在多处理机上的并行工作负载</p>
<h2 id="7-2-对称式共享存储器体系结构"><a href="#7-2-对称式共享存储器体系结构" class="headerlink" title="7.2 对称式共享存储器体系结构"></a>7.2 对称式共享存储器体系结构</h2><p>反映并行程序性能的一个重要的度量是计算与通信的比率。如果比值较高，就意味着应用程序中相对于每次数据通信要进行较多的计算。</p>
<p>通信在并行计算中的开销是很大的，因而较高的计算／通信比率十分有益。在一个并行处理环境下，当要增加处理器的数目，或增大所求解问题的规模，或者两者同时都增大时，都要对计算／通信比率的变化加以分析。</p>
<p>例如，在增加处理器数目的同时知道这个比率的变化，会对应用能获得的加速比有清楚的了解。</p>
<p>通常状况下，计算／通信比率随着处理的数据规模增大而增加，随着处理器数目的增加而降低。</p>
<p>用更多的处理器来求解一个固定大小的问题会导致不利因素的增加，因为处理器之间通信量加大了。</p>
<p>增加处理器时应该调整数据的规模，从而使通信的时间保持不变。</p>
<h3 id="7-2-1-多处理机-Cache-一致性"><a href="#7-2-1-多处理机-Cache-一致性" class="headerlink" title="7.2.1 多处理机 Cache 一致性"></a>7.2.1 多处理机 Cache 一致性</h3><ul>
<li>多个处理器共享一个存储器。</li>
<li>当处理器规模较小时，这种机器十分经济。</li>
<li>支持对共享数据和私有数据的Cache缓存。<ul>
<li>私有数据供一个单独的处理器使用，而共享数据供多个处理器使用</li>
</ul>
</li>
<li>共享数据进入Cache产生了一个新的问题：<strong>Cache 的一致性问题</strong><ul>
<li>对共享数据，不同处理器的 Cache 都保存有对应存储器单元的内容，因而在操作中就可能产生数据的不一致，称为 Cache一致性（Coherence）问题 </li>
</ul>
</li>
</ul>
<h4 id="1-不一致产生的原因（Cache-一致性问题）"><a href="#1-不一致产生的原因（Cache-一致性问题）" class="headerlink" title="1. 不一致产生的原因（Cache 一致性问题）"></a>1. 不一致产生的原因（Cache 一致性问题）</h4><ul>
<li>I／O 操作<ul>
<li>Cache中的内容可能与由 I／O 子系统输入输出形成的存储器对应部分的内容不同</li>
</ul>
</li>
<li>共享数据<ul>
<li>不同处理器的 Cache 都保存有对应存储器单元的内容</li>
</ul>
</li>
</ul>
<h4 id="2-存储器是一致的（非正式地定义）"><a href="#2-存储器是一致的（非正式地定义）" class="headerlink" title="2. 存储器是一致的（非正式地定义）"></a>2. 存储器是一致的（非正式地定义）</h4><p>如果对某个数据项的任何读操作均可得到其最新写入的值，则认为这个存储系统是一致的</p>
<ul>
<li>存储系统行为的两个不同方面<ul>
<li>返回给读操作的是什么值</li>
<li>什么时候才能将已写入的值返回给读操作</li>
</ul>
</li>
<li>满足条件<ul>
<li>处理器 P 对 X 进行一次写之后又对 X 进行读，读和写之间没有其它处理器对 X 进行写，则读的返回值总是写进的值。（一个处理器）</li>
<li>一个处理器对 X 进行写之后，另一处理器对X进行读，读和写之间无其它写，则读 X 的返回值应为写进的值。（多个处理器）</li>
<li>对同一单元的写是顺序化的，即任意两个处理器对同一单元的两次写，从所有处理器看来顺序都应是相同的</li>
</ul>
</li>
</ul>
<p>假设:直到所有的处理器均看到了写的结果，一次写操作才算完成；允许处理器无序读，但必须以程序规定的顺序进行写</p>
<p>三条已充分地保证了一致性，什么时候才能获得写进去的值仍是一个重要的问题</p>
<h3 id="7-2-2-实现一致性的基本方案"><a href="#7-2-2-实现一致性的基本方案" class="headerlink" title="7.2.2 实现一致性的基本方案"></a>7.2.2 实现一致性的基本方案</h3><p>在一致的多处理机中，Cache 提供两种功能</p>
<ul>
<li>共享数据的迁移<ul>
<li>降低了对远程共享数据的访问延迟</li>
</ul>
</li>
<li>共享数据的复制<ul>
<li>不仅降低了访存的延迟，也减少了访问共享数据所产生的冲突</li>
</ul>
</li>
</ul>
<p>小规模多处理机不是采用软件而是采用硬件技术实现 Cache 一致性</p>
<p>(1) Cache 一致性协议<br>    对多个处理器维护一致性的协议<br>(2) 关键：跟踪共享数据块的状态<br>(3) 共享数据状态跟踪技术 </p>
<ul>
<li>目录<ul>
<li>物理存储器中共享数据块的状态及相关信息均被保存在目录中。</li>
</ul>
</li>
<li>监听<ul>
<li>每个 Cache 除了包含物理存储器中块的数据拷贝之外，也保存着各个块的共享状态信息</li>
<li>监听：Cache 通常连在共享存储器的总线上，各个 Cache 控制器通过监听总线来判断它们是否有总线上请求的数据块</li>
</ul>
</li>
<li>两种协议<ul>
<li>写作废协议<ul>
<li>在一个处理器写某个数据项之前保证它对该数据项有唯一的访问权，即在某个 CPU 往内存中写入数据时，将其他拥有该单元的拷贝全部作废，写完后其他处理器再从该内存单元中重新读取数据，此时便是新的数据</li>
</ul>
</li>
<li>写更新协议<ul>
<li>当一个处理器写某数据项时，通过广播使其它 Cache 中所有对应的该数据项拷贝进行更新</li>
</ul>
</li>
<li>写作废和写更新协议性能上的差别<ul>
<li>对同一数据的多个写而中间无读操作的情况，写更新协议需进行多次写广播操作，而在写作废协议下只需一次作废操作。</li>
<li>对同一块中多个字进行写，写更新协议对每个字的写均要进行一次广播，而在写作废协议下仅在对本块第一次写时进行作废操作。</li>
<li>从一个处理器写到另一个处理器读之间的延迟通常在写更新模式中较低。而在写作废协议中，需要读一个新的拷贝。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在基于总线的多处理机中，写作废协议成为绝大多数系统设计的选择</p>
<h3 id="7-2-3-监听协议及其实现"><a href="#7-2-3-监听协议及其实现" class="headerlink" title="7.2.3 监听协议及其实现"></a>7.2.3 监听协议及其实现</h3><ul>
<li>小规模多处理机中实现写作废协议的关键利用总线进行作废操作,每个块的有效位使作废机制的实现较为容易。 </li>
<li>写直达 Cache，因为所有写的数据同时被写回主存，则从主存中总可以取到最新的数据值。</li>
<li>对于写回 Cache，得到数据的最新值会困难一些，因为最新值可能在某个 Cache 中，也可能在主存中。</li>
</ul>
<p>当某个处理器进行写数据时，必须先获得总线的控制权，然后将要作废的数据块的地址放在总线上。其它处理器一直监听总线，它们检测该地址所对应的数据是否在它们的 Cache 中。若在，则作废相应的数据块。获取总线控制权的顺序性保证了写的顺序性，因为当两个处理器要同时写一个单元时，其中一个处理器必然先获得总线控制权，之后它使另一处理器上对应的拷贝作废，从而保证了写的严格顺序性</p>
<ul>
<li>在写回Cache条件下的实现技术<ul>
<li>用Cache中块的标志位实现监听过程。</li>
<li>给每个Cache块加一个特殊的状态位说明它是否为共享。</li>
<li>因为每次总线任务均要检查Cache的地址位，这可能与CPU对Cache的访问冲突。可通过下列两种技术之一降低冲突：<ul>
<li>复制标志位</li>
<li>采用多级包含 Cache</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-3-分布式共享存储器体系结构"><a href="#7-3-分布式共享存储器体系结构" class="headerlink" title="7.3 分布式共享存储器体系结构"></a>7.3 分布式共享存储器体系结构</h2><h3 id="7-3-1-基于目录的-Cache-一致性"><a href="#7-3-1-基于目录的-Cache-一致性" class="headerlink" title="7.3.1 基于目录的 Cache 一致性"></a>7.3.1 基于目录的 Cache 一致性</h3><p>存储器分布于各结点中，所有的结点通过网络互连。访  问可以是本地的，也可是远程的。</p>
<p>不支持Cache一致性：</p>
<ul>
<li>规定共享数据不进入Cache，仅私有数据才能保存在Cache中。</li>
<li>优点： 所需的硬件支持很少(因为远程访问存取量仅是一个字(或双字)而不是一个Cache块)</li>
<li>缺点：<br>(1) 实现透明的软件 Cache 一致性的编译机制能力有限<br>(2) 没有 Cache 一致性，机器就不能利用取出同一块中的多个字的,开销接近于取一个字的开销这个优点，这是因为共享数据是以 Cache 块为单位进行管理的。当每次访问要从远程存储器取一个字时，不能有效利用共享数据的空间局部性<br>(3) 诸如预取等延迟隐藏技术对于多个字的存取更为有效，比如针对一个 Cache 块的预取</li>
</ul>
<p>对远程存储器访问的巨大延迟与对本地Cache访问的短延迟相比，突出地反映出了这些缺点。例如，Cray T3E本地访问延迟为两个时钟周期，并且可被流水化，而一次远程访问则需约400个时钟周期(T3E-900, 450MHz Alpha)</p>
<p><strong>解决Cache一致性问题的关键</strong>：</p>
<ul>
<li>目录协议<ul>
<li>目录：用一种专用的存储器所记录的数据结构，它记录着可以进入Cache的每个数据块的访问状态、该块在各个处理器的共享状态以及是否修改过等信息。</li>
<li>对每个结点增加目录表后的分布式存储器的系统结构</li>
<li>而当系统的规模变大时，它又是致命的弱点。此外，监听的访问量与处理器个数的平方（N2）成正比，即使总线的带宽随系统规模线性增长（N），而实际的性能还是下降到1/N</li>
</ul>
</li>
<li>目录协议的基本点<ul>
<li>在每个结点增加了目录存储器用于存放目录；</li>
<li>存储器的每一块在目录中对应有一项；</li>
<li>每一个目录项主要有状态和位向量两种成分。<ul>
<li>状态描述该目录所对应存储块的当前情况；</li>
<li>位向量共有N位，其每一位对应于一个处理器的局部 Cache，用于指出该Cache中有无该存储块的拷贝</li>
</ul>
</li>
</ul>
</li>
<li>目录必须跟踪每个 Cache 块的状态<ul>
<li>Cache 块状态有三种：<ul>
<li>共享：在一个或多个处理器上具有这个块的拷贝，且主存中的值是最新值(所有 Cache 均相同)。</li>
<li>未缓冲：所有处理器的Cache都没有此块的拷贝。</li>
<li>专有：仅有一个处理器上有此块的拷贝，且已对此块进行了写操作，而主存的拷贝仍是旧的。这个处理器称为此块的拥有者。 </li>
</ul>
</li>
</ul>
</li>
<li>由于写作废操作的需要，还必须记录共享此块的处理器信息。<ul>
<li>方法：对每个主存块设置一个位向量。</li>
<li>当此块被共享时，每个位指出与之对应的处理器是否有此块的拷贝。</li>
<li>当此块为专有时，可根据位向量来寻找此块的拥有者。</li>
</ul>
</li>
<li>宿主结点<ul>
<li>存放有存储器块和对应地址目录项的结点</li>
</ul>
</li>
</ul>
<h3 id="7-3-2-目录协议及其实现"><a href="#7-3-2-目录协议及其实现" class="headerlink" title="7.3.2. 目录协议及其实现"></a>7.3.2. 目录协议及其实现</h3><p>基于目录的协议中，目录承担了一致性协议操作的主要功能。 </p>
<ul>
<li>(1) 发往一个目录的消息会产生两种不同类型的动作<ul>
<li>更新目录状态</li>
<li>发送消息满足请求服务</li>
</ul>
</li>
<li>(2) 目录项可能接收到三种不同的请求（注意请求的完备性）<ul>
<li>读失效</li>
<li>写失效</li>
<li>数据写回 </li>
</ul>
</li>
<li>(3) 在各个状态下所接收到的请求和相应的操作<ul>
<li>①当一个块处于未缓冲状态时，对此块发出的请求及处理操作为: </li>
<li>读失效<ul>
<li>将存储器数据送往请求方处理器，且本处理器成为此块的唯一共享结点，本块的状态转换为共享</li>
</ul>
</li>
<li>写失效<ul>
<li>将存储器数据送往请求方处理器，此块成为专有</li>
</ul>
</li>
<li>②当一个块是共享状态时，存储器中的数据是其当前最新值，对此块发出的请求及处理操作为:<ul>
<li>读失效<ul>
<li>将存储器数据送往请求方处理器，并将其加入共享集合</li>
</ul>
</li>
<li>写失效<ul>
<li>将数据送往请求方处理器，对共享集合中所有的处理器发送写作废消息，且将共享集合置为仅含有此处理器，本块的状态变为专有</li>
</ul>
</li>
</ul>
</li>
<li>③当某块处于专有状态时，本块的最新值保存在共享集合指出的拥有者处理器中，从而有三种可能的目录请求<ul>
<li>读失效<ul>
<li>将“取数据”的消息发往拥有者处理器，使该块的状态转变为共享，并将数据送回目录结点写入存储器，进而把该数据返送请求方处理器，将请求方处理器加入共享集合</li>
</ul>
</li>
<li>写失效   <ul>
<li>本块将有一个新的拥有者。</li>
</ul>
</li>
<li>数据写回<ul>
<li>拥有者处理器的 Cache 要替换此块时必须将其写回，从而使存储器中有最新拷贝(宿主结点实际上成为拥有者)，此块成为非共享，共享集合为空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对基于目录的Cache一致性的多种改进<ul>
<li>有限映射目录</li>
<li>链式结构目录</li>
</ul>
</li>
</ul>
<p>基于目录的 Cache 一致性协议采取了“以空间换时间”的策略，减少了访问次数但增加了目录存储器，它的大小与系统规模 N 的平方成正比。<br>基于目录的 Cache 一致性协议是<strong>完全由硬件实现</strong>的</p>
<h2 id="7-4-互连网络"><a href="#7-4-互连网络" class="headerlink" title="7.4 互连网络"></a>7.4 互连网络</h2>]]></content>
      <categories>
        <category>课程笔记</category>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>重构：改善既有代码的设计 学习笔记</title>
    <url>/ea380076.html</url>
    <content><![CDATA[<h2 id="重构：改善既有代码的设计-学习笔记"><a href="#重构：改善既有代码的设计-学习笔记" class="headerlink" title="重构：改善既有代码的设计 学习笔记"></a>重构：改善既有代码的设计 学习笔记</h2><blockquote>
<p>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。</p>
</blockquote>
<span id="more"></span>
<h3 id="一、重构是什么以及为什么"><a href="#一、重构是什么以及为什么" class="headerlink" title="一、重构是什么以及为什么"></a>一、重构是什么以及为什么</h3><ol>
<li>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。</li>
<li>重构是一种经济适用行为，而非道德使然，如果它不能让我们更快更好的开发，那么它是毫无意义。</li>
<li>代码的写法应该使别人理解它所需要的时间最小化，进而变更代码需要的时间也会最小化。</li>
<li>重构对个体程序员的意义是提高ROI。<ol>
<li>更快速的定位问题，节省调试时间。</li>
<li>最小化变更风险，提高代码质量，减少修复事故的时间。</li>
<li>得到程序员同行的认可，更好的发展机会。</li>
</ol>
</li>
<li>重构对整个研发团队的意义是战斗力的提升。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230105141740.png?token%3DAJSITSOUMKEAVRFBFDZNT7DDWZV4E" alt="重构与不重构"></p>
<p>尽管重构会让我们的开发变慢，但是可以让我们将来的开发变快。如果我们要对一个项目进行长期跟进，那么重构是必不可少的。</p>
<h3 id="二、重构的原则"><a href="#二、重构的原则" class="headerlink" title="二、重构的原则"></a>二、重构的原则</h3><ol>
<li>重构的目标: 提高迭代效率，如果你确定这段代码你将来只会用到一次，且别人也不会去看你的代码，那么就没有重构的必要。</li>
<li>获得同行认可的方法: 每一次提交代码，都应该使代码变得更好，先重构，再开发。</li>
<li>增量式重构 = 自动化测试 + 持续集成 + TDD驱动重构。</li>
</ol>
<h3 id="三、代码的坏味道"><a href="#三、代码的坏味道" class="headerlink" title="三、代码的坏味道"></a>三、代码的坏味道</h3><p><a href="https://github.com/a1029563229/blogs/tree/master/Introduction/refactor">24重代码的坏味道和例子</a></p>
<p>一般我们能接触到的一些常见的问题：</p>
<ul>
<li>命名不规范</li>
<li>代码重复</li>
<li>代码过长</li>
<li>函数参数列表不易理解</li>
<li>相关联的一些数据没有成组（数据泥团）</li>
</ul>
<h3 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a>四、一些例子</h3><h4 id="4-1-依赖传递"><a href="#4-1-依赖传递" class="headerlink" title="4.1 依赖传递"></a>4.1 依赖传递</h4><p>变更放大：一次迭代需要修改 N 个位置，容易遗漏或失误。</p>
<p>关注放大：为完成修改任务，需要通读修改点上下文若干行代码，而由于依赖被传递，附近的代码会牵扯出更多需要关注的代码，往往阅读的代码量是本身要修改部分的若干倍。演化到最后就会导致不知道该次修改会不会导致问题。</p>
<h4 id="4-2-神秘命名"><a href="#4-2-神秘命名" class="headerlink" title="4.2 神秘命名"></a>4.2 神秘命名</h4><p>代码/注释都是一堆符号的集合，如果这些符合不能被人或者因为其信息的冗余无效性增加了阅读负担就会降低可理解性。<br>好的命名应该有三种境界:  信，达，雅。<br>信:  准确无误地表达清楚行为的意义，做到见名之意。<br>达: 考虑命名对整体架构的影响，与架构的设计哲学风格统一。<br>雅: 生动形象，看到名字即可准确理解其在整个程序之中的作用，并能产生辅助理解的形象。</p>
<p><a href="https://ggithub.com/dgraph-io/dgraph">坏的例子</a></p>
<h4 id="4-3-过度设计"><a href="#4-3-过度设计" class="headerlink" title="4.3 过度设计"></a>4.3 过度设计</h4><p>当过分的考虑程序未来所要面对的需求时，将陷入过度设计的陷阱，为了未来用不上的能力，而使当下的程序变得复杂。</p>
<p>设计变得复杂，是因为考虑了过多的设计约束，而这些约束很可能是现在和未来都不需要的，错把这些约束条件当作了目的，而使得目标被放大，设计出没有解决实际问题的系统。</p>
<p>过分放大未来的某行风险，这些风险发生的概率过低，在项目可见的生命周期内都不可能遇到，因此也没必要进行设计。</p>
<h4 id="4-4-结构泥团"><a href="#4-4-结构泥团" class="headerlink" title="4.4 结构泥团"></a>4.4 结构泥团</h4><p>对于核心的数据结构，没有规范化的设计将导致混乱</p>
<h5 id="4-4-1-艰难引用"><a href="#4-4-1-艰难引用" class="headerlink" title="4.4.1 艰难引用"></a>4.4.1 艰难引用</h5><p>未充分的考虑数据结构的读取场景，导致在需要使用某些数据的时候无法简单的获得其引用，或者为了使用某个字段，需要了解一堆中间封装的数据结构。</p>
<p>例如：<code>a.b.c.d.e();</code></p>
<h5 id="4-4-2-全局盲区"><a href="#4-4-2-全局盲区" class="headerlink" title="4.4.2 全局盲区"></a>4.4.2 全局盲区</h5><p>大型项目的开发中，由于大家缺乏全局视角，对数据结构或者接口的设计不可避免的造成冗余或混乱，接口与结构的设计充满局部最优解，但从项目整体上看却成为一团泥球。</p>
<h3 id="五、什么时候需要重构"><a href="#五、什么时候需要重构" class="headerlink" title="五、什么时候需要重构"></a>五、什么时候需要重构</h3><ol>
<li>Code review: 在给别人 code review 时嗅出坏味道，在不失礼貌的前提下提出建议。</li>
<li>每次 commit 代码时: 每一次经你之手提交的代码都应该比之前更加干净。</li>
<li>当你接手一个异常难读的项目时: 说服项目组将重构作为一项需求任务来做。</li>
<li>当迭代效率低于预期时: 将重构当作一个项任务专门来做，必要的时候停下来迭代需求。</li>
</ol>
<h3 id="六、重构的基本步骤"><a href="#六、重构的基本步骤" class="headerlink" title="六、重构的基本步骤"></a>六、重构的基本步骤</h3><h4 id="6-1-代码分析"><a href="#6-1-代码分析" class="headerlink" title="6.1 代码分析"></a>6.1 代码分析</h4><blockquote>
<p>通读代码，分析现状，找到代码在各个层面的坏味道。</p>
</blockquote>
<h4 id="6-2-重构计划"><a href="#6-2-重构计划" class="headerlink" title="6.2 重构计划"></a>6.2 重构计划</h4><blockquote>
<p>重构应该永远是一种经济驱动的决定。</p>
</blockquote>
<ul>
<li>对坏味道进行宣讲，并向团队给出重构的理由，以及重构的计划。</li>
<li>确定重构的目标，明确的描述出重构后能达到的预期是什么。</li>
<li>重构计划中必须给出测试验证方案，保证重构前与重构后软件的行为一致。</li>
<li>如果没有这样的方案，那就必须先让软件具有可测试性。</li>
<li>如果无法得到团队的认可,那就偷偷进行,因为重构始终是对自己有利的(减少工作量以及获得同事的认可)</li>
<li>将重构任务当作项目来管理，对指定任务的人明确的排期和进度同步。</li>
</ul>
<h4 id="6-3-小步子策略"><a href="#6-3-小步子策略" class="headerlink" title="6.3 小步子策略"></a>6.3 小步子策略</h4><ul>
<li>将重构任务拆分成每周都能见到一点效果的小任务。</li>
<li>每一步重构都要具有收益，并且可测试，不能阻断当前需求的迭代。</li>
<li>重构任务必须被跟踪，要定期的开会同步进度，来不断加强团队的重构意识。</li>
</ul>
<h4 id="6-4-测试驱动"><a href="#6-4-测试驱动" class="headerlink" title="6.4 测试驱动"></a>6.4 测试驱动</h4><ul>
<li>对于小型软件，需要先补充单元测试再进行重构。</li>
<li>对于大型软件，先搭建自动化测试流程，再进行重构。</li>
<li>对于复杂的不确定性业务，也可以使用ab test来验证重构对指标的影响，避免造成效果/广告的损失。</li>
<li>要保证测试的完备性与可复用性，尽可能的做到团队级的复用。</li>
<li>保证测试环境与生产环境的一致性也是测试驱动的重要环节。</li>
</ul>
<h4 id="6-5-提交规范"><a href="#6-5-提交规范" class="headerlink" title="6.5 提交规范"></a>6.5 提交规范</h4><ul>
<li>每次提交尽量控制在2分钟可以给code review的同事讲明白的程度</li>
<li>重构应该被当作一次专门的commit中完成，在commit中写清楚改动点&amp;测试点</li>
<li>提交规范有助于定位bug，也是代码可读性的一个重要环节</li>
</ul>
<h4 id="6-6-自动化测试"><a href="#6-6-自动化测试" class="headerlink" title="6.6 自动化测试"></a>6.6 自动化测试</h4><ul>
<li>构建可测试的软件，首先要构建可测试的环境。</li>
<li>对于简单应用软件可以使用单元测试，mock数据进行测试，并与ci/cd流程集成。</li>
<li>对于复杂应用软件可以采样收集线上真实用户行为日志，mock数据周期性巡检测试。</li>
<li>对于幂等性业务，可以mock user进行全方位的端到端自动化巡检测试。</li>
<li>每一次功能的提交应该对应一套完整的自动化测试的策略脚本以及&amp;监控指标与报警规则</li>
</ul>
<h4 id="6-7-调试BUG"><a href="#6-7-调试BUG" class="headerlink" title="6.7 调试BUG"></a>6.7 调试BUG</h4><ol>
<li>亲自复现问题，关注第一现场，确定是必现还是偶现?</li>
<li>区分是人的问题还是环境的问题?</li>
<li>如果是人的问题，那是配置参数的问题还是代码逻辑的问题?</li>
<li>如果是配置参数的问题，则通过对比正常运行的配置参数发现问题</li>
<li>如果是代码逻辑的问题，则通过cimmit的历史二分查找缩小出现问题的逻辑范围</li>
<li>如果是机器的问题，确定是单机问题还是集群问题。</li>
<li>如果是单机问题，则替换机器，如果是集群问题则考虑升级硬件设备。</li>
</ol>
<h3 id="七、一些实际的问题"><a href="#七、一些实际的问题" class="headerlink" title="七、一些实际的问题"></a>七、一些实际的问题</h3><h4 id="7-1-代码所有权"><a href="#7-1-代码所有权" class="headerlink" title="7.1 代码所有权"></a>7.1 代码所有权</h4><p>代码仓库的所有权会阻碍重构，调用方难以重构被调用方的代码(接口)，进而导致自身重构的受阻，使得效率降低，为提高开发的效能，允许代码仓库在内部开源化，其他团队的工程师可以通过 pr 自己来实现代码，并提交给仓库的 onwer，来 code review 即可。</p>
<h4 id="7-2-没有时间重构"><a href="#7-2-没有时间重构" class="headerlink" title="7.2 没有时间重构"></a>7.2 没有时间重构</h4><p>这是重构所面临最多的借口，是自己也是团队的借口。 为此必须要明确重构是经济行为而不是一种道德行为，重构使得开发效率变得更高，因此仅对必要的代码进行重构，某个工作行为如果重复三次就可以认为未来也会存在重复，因此通过重构使得下次工作更加高效，这是一种务实的作法，而重构不一定是需要大规模的展开的任务，重构应该是不断持续进行的，将任务拆解为多个具有完备性的任务，每周完成一个，每个任务的上线都不会引起问题，并使项目变得更好，这是一种持续重构的精神态度，是高效能程序员最应该具有的工作习惯。</p>
<p>如果你在给项目添加新的特性，发现当前的代码不能高效的完成这个任务，并且同样的任务出现三次以上，那么这时你应该先重构，再开发新特性。</p>
<h4 id="7-3-重构导致-bug"><a href="#7-3-重构导致-bug" class="headerlink" title="7.3 重构导致 bug"></a>7.3 重构导致 bug</h4><p>历史遗留的代码实在太多，难以阅读理解，如果无法理解谁也不敢轻易重构，害怕招致 bug 引起线上事故，因此在重构之前必须有一套相对完备的测试流程，他能给予程序员信心，也是重构的开始，反过来想对于谁也不愿意重构的代码进行重构，将收益巨大(这个项目还会继续迭代时)。</p>
]]></content>
      <categories>
        <category>生产力工具</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>代码架构</tag>
      </tags>
  </entry>
</search>
