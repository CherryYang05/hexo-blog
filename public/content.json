{"meta":{"title":"北极熊不吃企鹅宝宝","subtitle":"为什么呢？","description":"","author":"Cherry","url":"https://cherryyang05.github.io/hexo-blog","root":"/hexo-blog/"},"pages":[{"title":"about","date":"2023-06-06T01:52:47.000Z","updated":"2023-08-08T12:35:27.553Z","comments":true,"path":"about/index.html","permalink":"https://cherryyang05.github.io/hexo-blog/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-04T06:04:45.000Z","updated":"2023-08-08T12:35:27.553Z","comments":true,"path":"categories/index.html","permalink":"https://cherryyang05.github.io/hexo-blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-04T05:38:28.000Z","updated":"2023-08-08T12:35:27.553Z","comments":true,"path":"tags/index.html","permalink":"https://cherryyang05.github.io/hexo-blog/tags/index.html","excerpt":"","text":""},{"title":"Rust轻量级IO库","date":"2023-11-28T05:46:25.000Z","updated":"2024-03-27T06:14:34.968Z","comments":true,"path":"about/Rust轻量级IO库.html","permalink":"https://cherryyang05.github.io/hexo-blog/about/Rust%E8%BD%BB%E9%87%8F%E7%BA%A7IO%E5%BA%93.html","excerpt":"mio是rust实现的一个轻量级的I&#x2F;O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。","text":"mio是rust实现的一个轻量级的I&#x2F;O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。 一、关于mio1、重要特性 非阻塞TCP，UDP I&#x2F;O事件通知epoll,kqeue,IOCP实现 运行时零分配 平台可扩展 2、基础用法其使用方法与Linux中epoll差不多，mio底层封装了epoll，使用步骤思路： 创建Poll 注册事件 事件循环等待与处理事件 mio提供可跨平台的sytem selector访问，不同平台如下表，都可调用相同的API。不同平台使用的API开销不尽相同。由于mio是基于readiness(就绪状态)的API，与Linux epoll相似，可以看到很多API在Linux上都可以一对一映射。相比之下，Windows IOCP是基于完成（completion-based）而非基于就绪的API，所以两者间会有较多桥接。 同时mio提供自身版本的TcpListener、TcpStream、UdpSocket，这些API封装了底层平台相关API，并设为非阻塞且实现Evented trait。 OS Selector Linux epoll OS X, iOS kqueue Windows IOCP FreeBSD kqueue Android epoll mio实现的是一个单线程事件循环，并没有实现线程池及多线程事件循环，如果需要线程池及多线程事件循环等需要自己实现。 二、源码分析先给出mio的源码目录结构，只列出了关键的部分，如下所示： 12345678910111213141516171819202122232425mio代码目录结构mio|----&gt;test|----&gt;src|--------&gt;deprecated //事件循环代码|--------------&gt;event_loop.rs //EventLoop的实现，内部封装了Poll 【1】|--------------&gt;handler.rs //供上层实现的接口|--------&gt;net|------------&gt;mod.rs|------------&gt;tcp.rs|------------&gt;udp.rs|--------&gt;sys //不同系统下的实现|------------&gt;mod.rs |------------&gt;fuchsia|------------&gt;unix //Linux下封装的epoll|------------------&gt;mod.rs|------------------&gt;epoll.rs 【3】|------------------&gt;awakener.rs|------------&gt;windows //windows下封装的iocp|--------&gt;lib.rs |--------&gt;poll.rs //定义Poll 【2】|--------&gt;channel.rs 【4】|--------&gt;event_imp.rs|--------&gt;timer.rs 【5】|--------&gt;...... 对涉及不同操作系统的部分代码，以Linux操作系统为例。在Linux操作系统中，mio封装了epoll。后面会给出相应的代码。 【1】Eventloop代码分析结合前面的代码示例给出相应的关键代码如下：EventLoop事件循环定义，可以看到里面封装了Poll，以Linux系统举例，Poll又封装了epoll。在使用Poll或Linux中epoll时，最重要的代码是epoll_wait()等待事件Event并针对每个Event进行不同的处理。这里EventLoop将epoll_create()、epoll_wait()、epoll_ctl()进行进一步的封装，将对Event的处理抽象成Handler，供上层实现具体的逻辑处理。 12345678910// Single threaded IO event loop. //这里是单线程事件循环，更多的时候我们需要加线程池，以此为基础，再进行一次封装，供上层使用pub struct EventLoop&lt;H: Handler&gt; &#123; run: bool, poll: Poll, events: Events, //对应epoll中的epoll_event timer: Timer&lt;H::Timeout&gt;, notify_tx: channel::SyncSender&lt;H::Message&gt;, notify_rx: channel::Receiver&lt;H::Message&gt;, config: Config,&#125; 抽象出接口供上层应用实现不同事件的逻辑处理。这里有点类似于回调函数，上层用户需要在此实现业务逻辑代码，实际运行时需要将函数指针传递给底层事件循环，底层事件循环运行时会调用用户传递过来的函数。在Rust中，可能描述的不是很精准，不过可以这样理解。 12345678910111213141516171819202122232425262728pub trait Handler: Sized &#123; type Timeout; type Message; /// Invoked when the socket represented by `token` is ready to be operated /// on. `events` indicates the specific operations that are /// ready to be performed. /// This function will only be invoked a single time per socket per event /// loop tick. fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, token: Token, events: Ready) &#123; &#125; //【1】 /// Invoked when a message has been received via the event loop&#x27;s channel. fn notify(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, msg: Self::Message) &#123; &#125; //【2】 /// Invoked when a timeout has completed. fn timeout(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, timeout: Self::Timeout) &#123; &#125; //【3】 /// Invoked when `EventLoop` has been interrupted by a signal interrupt. fn interrupted(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) &#123; &#125; //【4】 /// Invoked at the end of an event loop tick. fn tick(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) &#123; &#125; //【5】&#125; 这里把Poll进行了封装，主要实现了Eventloop::new()—-&gt;Poll::new()—-&gt;epoll_create()，Eventloop::run()—&gt;Selecter::select()—-&gt;epoll_wait()，还有register()、reregister()、deregister()等等…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172impl&lt;H: Handler&gt; EventLoop&lt;H&gt; &#123; /// Constructs a new `EventLoop` using the default configuration values. /// The `EventLoop` will not be running. pub fn new() -&gt; io::Result&lt;EventLoop&lt;H&gt;&gt; &#123; EventLoop::configured(Config::default()) &#125; fn configured(config: Config) -&gt; io::Result&lt;EventLoop&lt;H&gt;&gt; &#123; // Create the IO poller let poll = Poll::new()?; //Linux内部调用epoll_create() let timer = timer::Builder::default() .tick_duration(config.timer_tick) .num_slots(config.timer_wheel_size) .capacity(config.timer_capacity) .build(); // Create cross thread notification queue let (tx, rx) = channel::sync_channel(config.notify_capacity); //这里创建的是同步管道,可配置同步管道内部的buffer queue bound size. // Register the notification wakeup FD with the IO poller poll.register(&amp;rx, NOTIFY, Ready::readable(), PollOpt::edge() | PollOpt::oneshot())?; //NOTIFY和TIMER由mio实现 poll.register(&amp;timer, TIMER, Ready::readable(), PollOpt::edge())?; Ok(EventLoop &#123; run: true, poll: poll, timer: timer, notify_tx: tx, notify_rx: rx, config: config, events: Events::with_capacity(1024), &#125;) &#125; /// Keep spinning the event loop indefinitely, and notify the handler whenever /// any of the registered handles are ready. pub fn run(&amp;mut self, handler: &amp;mut H) -&gt; io::Result&lt;()&gt; &#123; self.run = true; while self.run &#123; // Execute ticks as long as the event loop is running self.run_once(handler, None)?; //Linux下调用epoll_wait() &#125; Ok(()) &#125; pub fn run_once(&amp;mut self, handler: &amp;mut H, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;()&gt; &#123; trace!(&quot;event loop tick&quot;); // Check the registered IO handles for any new events. Each poll // is for one second, so a shutdown request can last as long as // one second before it takes effect. let events = match self.io_poll(timeout) &#123; Ok(e) =&gt; e, Err(err) =&gt; &#123; if err.kind() == io::ErrorKind::Interrupted &#123; handler.interrupted(self); //调用Handler::interrupted() 【4】 0 &#125; else &#123; return Err(err); &#125; &#125; &#125;; self.io_process(handler, events); //处理就绪的事件，handler为如何处理各种事件的实例 handler.tick(self); //一轮事件处理后，最后调用Handler::tick() 调用【5】 Ok(()) &#125; #[inline] fn io_poll(&amp;mut self, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;usize&gt; &#123; self.poll.poll(&amp;mut self.events, timeout) &#125; // Process IO events that have been previously polled fn io_process(&amp;mut self, handler: &amp;mut H, cnt: usize) &#123; let mut i = 0; trace!(&quot;io_process(..); cnt=&#123;&#125;; len=&#123;&#125;&quot;, cnt, self.events.len()); // Iterate over the notifications. Each event provides the token // it was registered with (which usually represents, at least, the // handle that the event is about) as well as information about // what kind of event occurred (readable, writable, signal, etc.) while i &lt; cnt &#123; //遍历所有就绪的事件，进行处理 let evt = self.events.get(i).unwrap(); trace!(&quot;event=&#123;:?&#125;; idx=&#123;:?&#125;&quot;, evt, i); // mio在epoll之上，增加了NOTIFY和TIMER match evt.token() &#123; NOTIFY =&gt; self.notify(handler), //channel处理 ，这个epoll中是没有的，mio实现 TIMER =&gt; self.timer_process(handler), //Timer处理， 这个epoll中也是没有的，mio实现 _ =&gt; self.io_event(handler, evt) //IO事件的处理， 这个epoll有 &#125; i += 1; &#125; &#125; fn io_event(&amp;mut self, handler: &amp;mut H, evt: Event) &#123; handler.ready(self, evt.token(), evt.readiness()); //调用Handler::ready() 【1】 &#125; fn notify(&amp;mut self, handler: &amp;mut H) &#123; for _ in 0..self.config.messages_per_tick &#123; match self.notify_rx.try_recv() &#123; //从channel中接收数据，内部实现是std::sync::mpsc::sync_channel() Ok(msg) =&gt; handler.notify(self, msg), //调用Handler::notify() 【2】 _ =&gt; break, &#125; &#125; // Re-register let _ = self.poll.reregister(&amp;self.notify_rx, NOTIFY, Ready::readable(), PollOpt::edge() | PollOpt::oneshot()); //PollOpt::oneshot(),必须重新reregister. &#125; fn timer_process(&amp;mut self, handler: &amp;mut H) &#123; while let Some(t) = self.timer.poll() &#123; handler.timeout(self, t); //调用Handler::timeout() 【3】 &#125; &#125; /// Registers an IO handle with the event loop. pub fn register&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) -&gt; io::Result&lt;()&gt; where E: Evented &#123; self.poll.register(io, token, interest, opt) &#125; /// Re-Registers an IO handle with the event loop. pub fn reregister&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) -&gt; io::Result&lt;()&gt; where E: Evented &#123; self.poll.reregister(io, token, interest, opt) &#125; /// Deregisters an IO handle with the event loop. pub fn deregister&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E) -&gt; io::Result&lt;()&gt; where E: Evented &#123; self.poll.deregister(io) &#125; /// Returns a sender that allows sending messages to the event loop in a /// thread-safe way, waking up the event loop if needed. pub fn channel(&amp;self) -&gt; Sender&lt;H::Message&gt; &#123; Sender::new(self.notify_tx.clone()) &#125; /// Schedules a timeout after the requested time interval. When the /// duration has been reached, pub fn timeout(&amp;mut self, token: H::Timeout, delay: Duration) -&gt; timer::Result&lt;Timeout&gt; &#123; self.timer.set_timeout(delay, token) &#125; /// If the supplied timeout has not been triggered, cancel it such that it /// will not be triggered in the future. pub fn clear_timeout(&amp;mut self, timeout: &amp;Timeout) -&gt; bool &#123; self.timer.cancel_timeout(&amp;timeout).is_some() &#125; /// Tells the event loop to exit after it is done handling all events in the current iteration. pub fn shutdown(&amp;mut self) &#123; self.run = false; &#125; /// Indicates whether the event loop is currently running. If it&#x27;s not it has either /// stopped or is scheduled to stop on the next tick. pub fn is_running(&amp;self) -&gt; bool &#123; self.run &#125;&#125; 【2】Poll代码分析Poll屏蔽了不同系统的实现，给出了统一的抽象。Poll的实现代码这里只能列出较为重要的部分代码，有一部分代码省略掉了，详细代码可查看mio&#x2F;src&#x2F;poll.rs： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151pub struct Poll &#123; // Platform specific IO selector selector: sys::Selector, // Custom readiness queue // The second readiness queue is implemented in user space by `ReadinessQueue`. It provides a way to implement purely user space `Evented` types. readiness_queue: ReadinessQueue, //区别于系统就绪队列（sys::Selector），这是上层自己实现的就绪队列 // Use an atomic to first check if a full lock will be required. This is a // fast-path check for single threaded cases avoiding the extra syscall lock_state: AtomicUsize, // Sequences concurrent calls to `Poll::poll` lock: Mutex&lt;()&gt;, // Wakeup the next waiter condvar: Condvar,&#125;impl Poll &#123; /// Return a new `Poll` handle. pub fn new() -&gt; io::Result&lt;Poll&gt; &#123; is_send::&lt;Poll&gt;(); is_sync::&lt;Poll&gt;(); let poll = Poll &#123; selector: sys::Selector::new()?, readiness_queue: ReadinessQueue::new()?, lock_state: AtomicUsize::new(0), lock: Mutex::new(()), condvar: Condvar::new(), &#125;; // Register the notification wakeup FD with the IO poller poll.readiness_queue.inner.awakener.register(&amp;poll, AWAKEN, Ready::readable(), PollOpt::edge())?; Ok(poll) &#125; /// Wait for readiness events /// /// Blocks the current thread and waits for readiness events for any of the /// `Evented` handles that have been registered with this `Poll` instance. /// The function will block until either at least one readiness event has /// been received or `timeout` has elapsed. A `timeout` of `None` means that /// `poll` will block until a readiness event has been received. pub fn poll(&amp;self, events: &amp;mut Events, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;usize&gt; &#123; self.poll1(events, timeout, false) //Poll::poll()非常最重要的一个方法， poll()--&gt;poll1()--&gt;poll2() &#125; fn poll1(&amp;self, events: &amp;mut Events, mut timeout: Option&lt;Duration&gt;, interruptible: bool) -&gt; io::Result&lt;usize&gt; &#123; let zero = Some(Duration::from_millis(0)); let mut curr = self.lock_state.compare_and_swap(0, 1, SeqCst); if 0 != curr &#123; ... &#125; //&#123; ... &#125;代表中间有很多代码被省略掉了. let ret = self.poll2(events, timeout, interruptible); // Release the lock if 1 != self.lock_state.fetch_and(!1, Release) &#123; ... &#125; //&#123; ... &#125;代表中间有很多代码被省略掉了. ret &#125; #[inline] fn poll2(&amp;self, events: &amp;mut Events, mut timeout: Option&lt;Duration&gt;, interruptible: bool) -&gt; io::Result&lt;usize&gt; &#123; // Compute the timeout value passed to the system selector. If the // readiness queue has pending nodes, we still want to poll the system // selector for new events, but we don&#x27;t want to block the thread to // wait for new events. if timeout == Some(Duration::from_millis(0)) &#123; // If blocking is not requested, then there is no need to prepare // the queue for sleep // // The sleep_marker should be removed by readiness_queue.poll(). &#125; else if self.readiness_queue.prepare_for_sleep() &#123; // The readiness queue is empty. The call to `prepare_for_sleep` // inserts `sleep_marker` into the queue. This signals to any // threads setting readiness that the `Poll::poll` is going to // sleep, so the awakener should be used. &#125; else &#123; // The readiness queue is not empty, so do not block the thread. timeout = Some(Duration::from_millis(0)); &#125; //poll系统就绪队列 loop &#123; let now = Instant::now(); // First get selector events let res = self.selector.select(&amp;mut events.inner, AWAKEN, timeout); //Linux下调用epoll_wait(),就绪事件放入events中 match res &#123; Ok(true) =&gt; &#123; // Some awakeners require reading from a FD. self.readiness_queue.inner.awakener.cleanup(); break; &#125; Ok(false) =&gt; break, Err(ref e) if e.kind() == io::ErrorKind::Interrupted &amp;&amp; !interruptible =&gt; &#123; // Interrupted by a signal; update timeout if necessary and retry if let Some(to) = timeout &#123; let elapsed = now.elapsed(); if elapsed &gt;= to &#123; break; &#125; else &#123; timeout = Some(to - elapsed); &#125; &#125; &#125; Err(e) =&gt; return Err(e), &#125; &#125; // Poll custom event queue self.readiness_queue.poll(&amp;mut events.inner); //Poll用户就绪队列 // Return number of polled events Ok(events.inner.len()) &#125; /// Register an `Evented` handle with the `Poll` instance. pub fn register&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; where E: Evented &#123; validate_args(token)?; // Register interests for this socket handle.register(self, token, interest, opts)?; Ok(()) &#125; /// Re-register an `Evented` handle with the `Poll` instance. pub fn reregister&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; where E: Evented &#123; validate_args(token)?; // Register interests for this socket handle.reregister(self, token, interest, opts)?; Ok(()) &#125; /// Deregister an `Evented` handle with the `Poll` instance. pub fn deregister&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E) -&gt; io::Result&lt;()&gt; where E: Evented &#123; // Deregister interests for this socket handle.deregister(self)?; Ok(()) &#125;&#125; 【3】Selector代码分析下面这段代码出自mio&#x2F;src&#x2F;sys&#x2F;unix&#x2F;epoll.rs是对底层Linux系统epoll的封装抽象，可以看到Selector::new()内部实际上调用了epoll_create()，Selector::select()内部实际上调用了epoll_wait()，register()、reregister()、deregister()实内部实际上调用了epoll_ctl()。如果你非常熟悉epoll，就会感觉下面的代码很熟悉，详细代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107pub struct Selector &#123; id: usize, epfd: RawFd,&#125;impl Selector &#123; pub fn new() -&gt; io::Result&lt;Selector&gt; &#123; let epfd = unsafe &#123; // Emulate `epoll_create` by using `epoll_create1` if it&#x27;s available // and otherwise falling back to `epoll_create` followed by a call to // set the CLOEXEC flag. dlsym!(fn epoll_create1(c_int) -&gt; c_int); match epoll_create1.get() &#123; Some(epoll_create1_fn) =&gt; &#123; cvt(epoll_create1_fn(libc::EPOLL_CLOEXEC))? &#125; None =&gt; &#123; let fd = cvt(libc::epoll_create(1024))?; drop(set_cloexec(fd)); fd &#125; &#125; &#125;; // offset by 1 to avoid choosing 0 as the id of a selector let id = NEXT_ID.fetch_add(1, Ordering::Relaxed) + 1; Ok(Selector &#123; id: id, epfd: epfd, &#125;) &#125; pub fn id(&amp;self) -&gt; usize &#123; self.id &#125; /// Wait for events from the OS pub fn select(&amp;self, evts: &amp;mut Events, awakener: Token, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;bool&gt; &#123; let timeout_ms = timeout .map(|to| cmp::min(millis(to), i32::MAX as u64) as i32) .unwrap_or(-1); // Wait for epoll events for at most timeout_ms milliseconds evts.clear(); unsafe &#123; let cnt = cvt(libc::epoll_wait(self.epfd, evts.events.as_mut_ptr(), evts.events.capacity() as i32, timeout_ms))?; let cnt = cnt as usize; evts.events.set_len(cnt); for i in 0..cnt &#123; if evts.events[i].u64 as usize == awakener.into() &#123; evts.events.remove(i); return Ok(true); &#125; &#125; &#125; Ok(false) &#125; /// Register event interests for the given IO handle with the OS pub fn register(&amp;self, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; &#123; let mut info = libc::epoll_event &#123; events: ioevent_to_epoll(interests, opts), u64: usize::from(token) as u64 &#125;; unsafe &#123; cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_ADD, fd, &amp;mut info))?; Ok(()) &#125; &#125; /// Register event interests for the given IO handle with the OS pub fn reregister(&amp;self, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; &#123; let mut info = libc::epoll_event &#123; events: ioevent_to_epoll(interests, opts), u64: usize::from(token) as u64 &#125;; unsafe &#123; cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_MOD, fd, &amp;mut info))?; Ok(()) &#125; &#125; /// Deregister event interests for the given IO handle with the OS pub fn deregister(&amp;self, fd: RawFd) -&gt; io::Result&lt;()&gt; &#123; // The &amp;info argument should be ignored by the system, // but linux &lt; 2.6.9 required it to be not null. // For compatibility, we provide a dummy EpollEvent. let mut info = libc::epoll_event &#123; events: 0, u64: 0, &#125;; unsafe &#123; cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_DEL, fd, &amp;mut info))?; Ok(()) &#125; &#125;&#125; 【4】Notify channel代码分析这个涉及的代码比较多，比较杂，也较为难以理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// `ReadinessQueue` is backed by a MPSC queue that supports reuse of linked// list nodes. This significantly reduces the number of required allocations.// Each `Registration` / `SetReadiness` pair allocates a single readiness node// that is used for the lifetime of the registration.//// The readiness node also includes a single atomic variable, `state` that// tracks most of the state associated with the registration. This includes the// current readiness, interest, poll options, and internal state. When the node// state is mutated, it is queued in the MPSC channel. A call to// `ReadinessQueue::poll` will dequeue and process nodes. The node state can// still be mutated while it is queued in the channel for processing.// Intermediate state values do not matter as long as the final state is// included in the call to `poll`. This is the eventually consistent nature of// the readiness queue.//// The readiness node is ref counted using the `ref_count` field. On creation,// the ref_count is initialized to 3: one `Registration` handle, one// `SetReadiness` handle, and one for the readiness queue. Since the readiness queue// doesn&#x27;t *always* hold a handle to the node, we don&#x27;t use the Arc type for// managing ref counts (this is to avoid constantly incrementing and// decrementing the ref count when pushing &amp; popping from the queue). When the// `Registration` handle is dropped, the `dropped` flag is set on the node, then// the node is pushed into the registration queue. When Poll::poll pops the// node, it sees the drop flag is set, and decrements it&#x27;s ref count.//// The MPSC queue is a modified version of the intrusive MPSC node based queue// described by 1024cores [1].#[derive(Clone)]struct ReadinessQueue &#123; inner: Arc&lt;ReadinessQueueInner&gt;,&#125;struct ReadinessQueueInner &#123; // Used to wake up `Poll` when readiness is set in another thread. awakener: sys::Awakener, // Head of the MPSC queue used to signal readiness to `Poll::poll`. head_readiness: AtomicPtr&lt;ReadinessNode&gt;, // Tail of the readiness queue. // // Only accessed by Poll::poll. Coordination will be handled by the poll fn tail_readiness: UnsafeCell&lt;*mut ReadinessNode&gt;, // Fake readiness node used to punctuate the end of the readiness queue. // Before attempting to read from the queue, this node is inserted in order // to partition the queue between nodes that are &quot;owned&quot; by the dequeue end // and nodes that will be pushed on by producers. end_marker: Box&lt;ReadinessNode&gt;, // Similar to `end_marker`, but this node signals to producers that `Poll` // has gone to sleep and must be woken up. sleep_marker: Box&lt;ReadinessNode&gt;, // Similar to `end_marker`, but the node signals that the queue is closed. // This happens when `ReadyQueue` is dropped and signals to producers that // the nodes should no longer be pushed into the queue. closed_marker: Box&lt;ReadinessNode&gt;,&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// Node shared by a `Registration` / `SetReadiness` pair as well as the node/// queued into the MPSC channel.struct ReadinessNode &#123; // Node state, see struct docs for `ReadinessState` // // This variable is the primary point of coordination between all the // various threads concurrently accessing the node. state: AtomicState, // The registration token cannot fit into the `state` variable, so it is // broken out here. In order to atomically update both the state and token // we have to jump through a few hoops. // // First, `state` includes `token_read_pos` and `token_write_pos`. These can // either be 0, 1, or 2 which represent a token slot. `token_write_pos` is // the token slot that contains the most up to date registration token. // `token_read_pos` is the token slot that `poll` is currently reading from. // // When a call to `update` includes a different token than the one currently // associated with the registration (token_write_pos), first an unused token // slot is found. The unused slot is the one not represented by // `token_read_pos` OR `token_write_pos`. The new token is written to this // slot, then `state` is updated with the new `token_write_pos` value. This // requires that there is only a *single* concurrent call to `update`. // // When `poll` reads a node state, it checks that `token_read_pos` matches // `token_write_pos`. If they do not match, then it atomically updates // `state` such that `token_read_pos` is set to `token_write_pos`. It will // then read the token at the newly updated `token_read_pos`. token_0: UnsafeCell&lt;Token&gt;, token_1: UnsafeCell&lt;Token&gt;, token_2: UnsafeCell&lt;Token&gt;, // Used when the node is queued in the readiness linked list. Accessing // this field requires winning the &quot;queue&quot; lock next_readiness: AtomicPtr&lt;ReadinessNode&gt;, // Ensures that there is only one concurrent call to `update`. // // Each call to `update` will attempt to swap `update_lock` from `false` to // `true`. If the CAS succeeds, the thread has obtained the update lock. If // the CAS fails, then the `update` call returns immediately and the update // is discarded. update_lock: AtomicBool, // Pointer to Arc&lt;ReadinessQueueInner&gt; readiness_queue: AtomicPtr&lt;()&gt;, // Tracks the number of `ReadyRef` pointers ref_count: AtomicUsize,&#125; 1234567891011/// Handle to a user space `Poll` registration.////// `Registration` allows implementing [`Evented`] for types that cannot work/// with the [system selector]. A `Registration` is always paired with a/// `SetReadiness`, which allows updating the registration&#x27;s readiness state./// When [`set_readiness`] is called and the `Registration` is associated with a/// [`Poll`] instance, a readiness event will be created and eventually returned/// by [`poll`].pub struct Registration &#123; inner: RegistrationInner,&#125; 12345/// Updates the readiness state of the associated `Registration`.#[derive(Clone)]pub struct SetReadiness &#123; inner: RegistrationInner,&#125; 未完，待续…… 参考文档：Intrusive MPSC node-based queue 【5】Timer定时器代码分析12345678910111213141516171819pub struct Timer&lt;T&gt; &#123; // Size of each tick in milliseconds tick_ms: u64, // Slab of timeout entries entries: Slab&lt;Entry&lt;T&gt;&gt;, // Timeout wheel. Each tick, the timer will look at the next slot for // timeouts that match the current tick. wheel: Vec&lt;WheelEntry&gt;, // Tick 0&#x27;s time instant start: Instant, // The current tick tick: Tick, // The next entry to possibly timeout next: Token, // Masks the target tick to get the slot mask: u64, // Set on registration with Poll inner: LazyCell&lt;Inner&gt;,&#125; 未完，待续…… 三、mio用法示例下面的2个示例都很简单，其实直接看mio的测试代码mio&#x2F;test&#x2F;就好了，不用看下面的2个示例。 1、代码示例1直接使用Poll示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#[macro_use]extern crate log;extern crate simple_logger;extern crate mio;use mio::*;use mio::tcp::&#123;TcpListener, TcpStream&#125;;use std::io::&#123;Read,Write&#125;;fn main() &#123; simple_logger::init().unwrap(); // Setup some tokens to allow us to identify which event is for which socket. const SERVER: Token = Token(0); const CLIENT: Token = Token(1); let addr = &quot;127.0.0.1:12345&quot;.parse().unwrap(); // Setup the server socket let server = TcpListener::bind(&amp;addr).unwrap(); // Create a poll instance let poll = Poll::new().unwrap(); // Start listening for incoming connections poll.register(&amp;server, SERVER, Ready::readable(), PollOpt::edge()).unwrap(); // Setup the client socket let sock = TcpStream::connect(&amp;addr).unwrap(); // Register the socket poll.register(&amp;sock, CLIENT, Ready::readable(), PollOpt::edge()).unwrap(); // Create storage for events let mut events = Events::with_capacity(1024); loop &#123; poll.poll(&amp;mut events, None).unwrap(); for event in events.iter() &#123; match event.token() &#123; SERVER =&gt; &#123; // Accept and drop the socket immediately, this will close // the socket and notify the client of the EOF. let (stream,addr) = server.accept().unwrap(); info!(&quot;Listener accept &#123;:?&#125;&quot;,addr); &#125;, CLIENT =&gt; &#123; // The server just shuts down the socket, let&#x27;s just exit // from our event loop. info!(&quot;client response.&quot;); return; &#125;, _ =&gt; unreachable!(), &#125; &#125; &#125;&#125; 通过上面的代码示例1，我们可以看到其用法与epoll非常相似。 2、代码示例2上面的代码编程时较为麻烦，下面使用事件循环EventLoop的方式，代码能看起来更清晰一些（相对的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#[macro_use]extern crate log;extern crate simple_logger;extern crate mio;use mio::*;use mio::timer::&#123;Timeout&#125;;use mio::deprecated::&#123;EventLoop, Handler, Sender, EventLoopBuilder&#125;;use std::thread;use std::time::Duration;fn main() &#123; simple_logger::init().unwrap(); let mut event_loop=EventLoop::new().unwrap(); let channel_sender=event_loop.channel(); thread::spawn(move ||&#123; channel_sender.send(IoMessage::Notify); thread::sleep_ms(5*1000); channel_sender.send(IoMessage::End); &#125;); let timeout = event_loop.timeout(Token(123), Duration::from_millis(3000)).unwrap(); let mut handler=MioHandler::new(); let _ = event_loop.run(&amp;mut handler).unwrap();&#125;pub enum IoMessage&#123; Notify, End,&#125;pub struct MioHandler&#123;&#125;impl MioHandler&#123; pub fn new()-&gt;Self&#123; MioHandler&#123;&#125; &#125;&#125;impl Handler for MioHandler &#123; type Timeout = Token; type Message = IoMessage; /// Invoked when the socket represented by `token` is ready to be operated on. fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, token: Token, events: Ready) &#123; &#125; /// Invoked when a message has been received via the event loop&#x27;s channel. fn notify(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, msg: Self::Message) &#123; match msg &#123; IoMessage::Notify=&gt;info!(&quot;channel notify&quot;), IoMessage::End=&gt;&#123; info!(&quot;shutdown eventloop.&quot;); event_loop.shutdown(); &#125; &#125; &#125; /// Invoked when a timeout has completed. fn timeout(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, timeout: Self::Timeout) &#123; match timeout&#123; Token(123)=&gt;info!(&quot;time out.&quot;), Token(_)=&gt;&#123;&#125;, &#125; &#125; /// Invoked when `EventLoop` has been interrupted by a signal interrupt. fn interrupted(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) &#123; &#125; /// Invoked at the end of an event loop tick. fn tick(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) &#123; &#125;&#125; 这个示例说明了超时及channel，围绕EventLoop编程，其实与上一个例子没有什么不同，只是EventLoop对Poll做了封装。 参考文档：【譯】Tokio 內部機制：從頭理解 Rust 非同步 I&#x2F;O 框架使用mio开发web framework - baseMy Basic Understanding of mio and Asynchronous IOMIO for Rustmio-github"}],"posts":[{"title":"使用patchelf解决vscode远程连接不支持低版本glibc的问题","slug":"使用patchelf解决vscode远程连接不支持低版本glibc的问题","date":"2024-03-27T08:52:56.000Z","updated":"2024-03-27T13:02:37.343Z","comments":true,"path":"2cbef437.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/2cbef437.html","excerpt":"VScode 1.86 版本的 remote 要求 glibc 2.28 及以上，于是在各种旧版本服务器上就不支持了。 新版本刚发布就在 github 上的 issue 上讨论起来了，VScode 官方文档 中也说明了，从 VS Code 版本 1.86.1（2024 年 1 月）开始提高了远程服务器构建工具链的最低要求。VS Code 分发的预构建服务器与基于 glibc 2.28 或更高版本的 Linux 发行版兼容。 当然给服务器升级 glibc 是一个极其危险的操作，本人曾经就瞎捣鼓升级了 glibc，结果导致系统崩溃，不得已重装了系统。 我们可以利用 patchelf 手动指定动态库，避免了重新编译系统的 glibc。","text":"VScode 1.86 版本的 remote 要求 glibc 2.28 及以上，于是在各种旧版本服务器上就不支持了。 新版本刚发布就在 github 上的 issue 上讨论起来了，VScode 官方文档 中也说明了，从 VS Code 版本 1.86.1（2024 年 1 月）开始提高了远程服务器构建工具链的最低要求。VS Code 分发的预构建服务器与基于 glibc 2.28 或更高版本的 Linux 发行版兼容。 当然给服务器升级 glibc 是一个极其危险的操作，本人曾经就瞎捣鼓升级了 glibc，结果导致系统崩溃，不得已重装了系统。 我们可以利用 patchelf 手动指定动态库，避免了重新编译系统的 glibc。 1. 动态链接库下载github 上有较为方便的下载 glibc 的仓库 glibc-all-in-one 根据仓库的 README，查看支持的版本：cat list 我选择的是 2.31-0ubuntu9.14_amd64，然后执行 ./download 2.31-0ubuntu9.14_amd64 在当前文件夹下会生成 libs 文件夹，就是刚刚下载的 2.31-0ubuntu9.14_amd64 的动态库。 然后执行 ./build 2.31 arm64，这一步会在根目录下编译生成 /glibc 文件夹，可以将其移动到 glibc-all-in-one 文件夹中。 2. 用 patchelf 修改 vscode-server 依赖的 glibc 版本在执行命令前，先删除 .vscode-server 文件夹，用 vscode 连接服务器，让它自动重新下载 vscode-server 相关文件，这个时候在 ~/.vscode-server/bin 中应该只有一个由数字和字母组成随机字符串的文件夹（我的服务器上是 863d2581ecda6849923a2118d93a088b0745d9d6，不同人应该不一样），进入这个文件夹，有一个 node 二进制文件，我们要重新 patch 的就是这个文件。 执行命令： patchelf --set-interpreter ~/pack/glibc-all-in-one/libs/2.31-0ubuntu9.14_amd64/ld-linux-x86-64.so.2 --set-rpath ~/pack/glibc-all-in-one/libs/2.31-0ubuntu9.14_amd64/:~/pack/glibc-all-in-one/glibc/2.31/amd64/lib --force-rpath ~/.vscode-server/bin/863d2581ecda6849923a2118d93a088b0745d9d6/node --set-interpreter 后面跟的是可执行文件的解释器路径，需要指定动态链接器的路径，路径为 ./glibc-all-in-one/libs/[your downloaded glibc version]/ld-linux-x86-64.so.2，动态链接器负责在程序运行时加载所需的共享库。 --set-rpath 这部分设置了可执行文件的运行时搜索路径（Runtime PATH），指定了程序在运行时搜索共享库时应该查找的路径。这里指定了两个路径包含了 glibc 核心库和其他库。这里的路径为 glibc-all-in-one/libs 文件夹下的你下载的不同版本的 glibc 文件夹和编译生成的 glibc/[version]/[arch]/lib 文件夹。 --force-rpath 后面跟的就是要修改的 vscode-server 的 node 文件。 如果执行命令时提示：patchelf: open: Text file busy，将本机上 vscode 运行的远程连接关掉再执行就可以了。 重新打开 vscode，就不会有操作系统版本不支持的提示了~~ 参考链接","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux/"},{"name":"glibc","slug":"glibc","permalink":"https://cherryyang05.github.io/hexo-blog/tags/glibc/"}]},{"title":"清理git记录中的大文件","slug":"清理git记录中的大文件","date":"2024-03-27T07:26:55.000Z","updated":"2024-03-27T08:05:05.503Z","comments":true,"path":"f6c73689.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/f6c73689.html","excerpt":"前几天我想把一个本地仓库推送到 github 仓库中时提示： 1234567remote: error: Trace: 9222dcf96227a19766567c1da4183cfef7b9ec21689a2ee21f6c1c3b2f1fab7aremote: error: See https://gh.io/lfs for more information.remote: error: File 18T.trace is 771.88 MB; this exceeds GitHub&#x27;s file size limit of 100.00 MBremote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.To https://github.com/CherryYang05/DiskPine.git ! [remote rejected] master -&gt; master (pre-receive hook declined)错误：无法推送一些引用到 &#x27;https://github.com/CherryYang05/DiskPine.git&#x27; 发现在之前的 git 记录中有一个大文件（18T.trace 771.88MB），但是在最新的提交记录中，我已经将其删除了，却依然无法推送。 经过查询资料，找到了解决方法： 若文件还没有删除，并且需要将其推送到远程仓库，使用 LFS(Large File Storage) 修改文件大小的限制； 若文件已经删除，使用 BFG Repo-Cleaner 清理 git 历史记录中对大文件的引用。","text":"前几天我想把一个本地仓库推送到 github 仓库中时提示： 1234567remote: error: Trace: 9222dcf96227a19766567c1da4183cfef7b9ec21689a2ee21f6c1c3b2f1fab7aremote: error: See https://gh.io/lfs for more information.remote: error: File 18T.trace is 771.88 MB; this exceeds GitHub&#x27;s file size limit of 100.00 MBremote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.To https://github.com/CherryYang05/DiskPine.git ! [remote rejected] master -&gt; master (pre-receive hook declined)错误：无法推送一些引用到 &#x27;https://github.com/CherryYang05/DiskPine.git&#x27; 发现在之前的 git 记录中有一个大文件（18T.trace 771.88MB），但是在最新的提交记录中，我已经将其删除了，却依然无法推送。 经过查询资料，找到了解决方法： 若文件还没有删除，并且需要将其推送到远程仓库，使用 LFS(Large File Storage) 修改文件大小的限制； 若文件已经删除，使用 BFG Repo-Cleaner 清理 git 历史记录中对大文件的引用。 1. LFSGit LFS 是一个命令行扩展，用于使用 Git 管理大文件。git-lfs Github 链接 1.1 安装1curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash 1.2 使用 初始化 lfs： 1git lfs install 添加需要上传的文件： 1git lfs track &quot;your_big_file&quot; 将文件添加到暂存区： 1git add &quot;your_big_file&quot; 提交文件： 1git commit -m &quot;Add big file&quot; 推送到远程仓库： 1git push 1.3 注意 LFS 仅支持新的提交记录，无法修改历史记录中的引用； 若需要清理历史记录中的引用，需要使用 BFG Repo-Cleaner。 其他使用方式见 Example Usage。 2. BFGBFG Repo-Cleaner 是一个由 Scala 编写的命令行工具，用于快速、精确地从 Git 仓库中删除不需要的数据。相比于 git-filter-branch 命令，BFG 的速度更快，使用也更简单。无论是大文件还是敏感数据，只需简单的命令，就能将其从所有提交历史中移除。 2.1 安装在 这里 下载 bfg-1.14.0.jar 包，或者使用 curl 下载： 1curl -o bfg.jar -L https://repo1.maven.org/maven2/com/madgag/bfg/1.14.0/bfg-1.14.0.jar 2.2 使用 首先，将要清理的文件添加到 .gitignore 文件中，以免再次出现在提交中； 然后，使用 BFG 清理大文件： 1java -jar bfg.jar --strip-blobs-bigger-than 100M &lt;repo&gt;.git 其中，--strip-blobs-bigger-than 100M 表示删除大于 100M 的文件。 接着，清理 git 历史记录中的引用： 12cd &lt;repo&gt;git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive 最后，推送到远程仓库： 1git push 2.3 注意 BFG Repo-Cleaner 只会修改本地仓库，不会修改远程仓库； BFG Repo-Cleaner 会修改 commit 的 hash 值，因此不要使用 git pull 同步远程仓库，而是使用 git fetch； BFG Repo-Cleaner 会修改提交记录，因此可能会导致冲突，需要手动解决。 2.4 参考链接 BFG Repo-Cleaner [BFG Repo-Cleaner - GitHub]( 2.1 安装jar 包下载链接","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"生产力工具/git","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux/"},{"name":"git","slug":"git","permalink":"https://cherryyang05.github.io/hexo-blog/tags/git/"}]},{"title":"log4rs日志库解析","slug":"log4rs日志库解析","date":"2023-11-28T05:44:55.000Z","updated":"2024-03-27T06:14:44.861Z","comments":true,"path":"faf96547.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/faf96547.html","excerpt":"log4rs 是rust实现的高度可配置日志库，该库配置的方式比较灵活，功能相对丰富，可以满足绝大部分的项目需要。","text":"log4rs 是rust实现的高度可配置日志库，该库配置的方式比较灵活，功能相对丰富，可以满足绝大部分的项目需要。 一、用法示例首先先给个简单示例，通过这个示例就可以看出log4rs进行日志配置非常的灵活： 12345678#[macro_use]extern crate log;extern crate log4rs;fn main() &#123; log4rs::init_file(&quot;log.yaml&quot;,Default::default()).unwrap(); info!(&quot;Hello, world!&quot;);&#125; 日志配置文件如下：（文件格式不唯一，可以是yaml,json,toml等格式，下面是yaml格式的配置文件） 123456789101112131415161718192021222324252627282930313233# Scan this file for changes every 30 secondsrefresh_rate: 30 secondsappenders: # An appender named &quot;stdout&quot; that writes to stdout stdout: kind: console # An appender named &quot;requests&quot; that writes to a file with a custom pattern encoder requests: kind: file path: &quot;log/requests.log&quot; encoder: pattern: &quot;&#123;d&#125; - &#123;m&#125;&#123;n&#125;&quot;# Set the default logging level to &quot;info&quot; and attach the &quot;stdout&quot; appender to the rootroot: level: info appenders: - stdoutloggers: # Raise the maximum log level for events sent to the &quot;app::backend::db&quot; logger to &quot;info&quot; app::backend::db: level: info # Route log events sent to the &quot;app::requests&quot; logger to the &quot;requests&quot; appender, # and *not* the normal appenders installed at the root app::requests: level: info appenders: - requests additive: false 运行结果： 12345sl@Li:~/Works/study/helloworld$ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.09s Running `target/debug/helloworld`2018-12-10T10:11:45.240346970+08:00 INFO helloworld - Hello, world! 这里因为appenders配置的是stdout对应的输出到控制台，所以日志信息输出在了控制台上，如果选择的是requests，则日志信息就输出在了对应路径文件上。 当然日志配置的方式除了配置文件，还可以在程序代码中进行配置，代码如下： 123456789101112131415161718192021222324252627282930313233extern crate log;extern crate log4rs;use log::LogLevelFilter;use log4rs::append::console::ConsoleAppender;use log4rs::append::file::FileAppender;use log4rs::encode::pattern::PatternEncoder;use log4rs::config::&#123;Appender, Config, Logger, Root&#125;;fn main() &#123; let stdout = ConsoleAppender::builder().build(); let requests = FileAppender::builder() .encoder(Box::new(PatternEncoder::new(&quot;&#123;d&#125; - &#123;m&#125;&#123;n&#125;&quot;))) .build(&quot;log/requests.log&quot;) .unwrap(); let config = Config::builder() .appender(Appender::builder().build(&quot;stdout&quot;, Box::new(stdout))) .appender(Appender::builder().build(&quot;requests&quot;, Box::new(requests))) .logger(Logger::builder().build(&quot;app::backend::db&quot;, LogLevelFilter::Info)) .logger(Logger::builder() .appender(&quot;requests&quot;) .additive(false) .build(&quot;app::requests&quot;, LogLevelFilter::Info)) .build(Root::builder().appender(&quot;stdout&quot;).build(LogLevelFilter::Warn)) .unwrap(); let handle = log4rs::init_config(config).unwrap(); //配置完成，下面输出日志信息即可 // use handle to change logger configuration at runtime&#125;//可以看到用代码的方式比较麻烦，所以推荐使用配置文件的方式，程序简洁，修改方便，配置灵活，何乐不为啊。 log4rs有上面的两种配置形式，函数如下： init_config —— Initializes the global logger as a log4rs logger with the provided config.（通过代码配置） init_file —— Initializes the global logger as a log4rs logger configured via a file.（通过配置文件配置） 其实init_file函数实现的内部调用了init_config函数，也就是说是通过读配置文件通过序列化的方式得到config，再调用init_config。（源代码：https://docs.rs/log4rs/0.7.0/src/log4rs/priv_file.rs.html#23-51） 通过程序配置较好理解，通过配置文件的话，是有一定的格式及定义要求的，yaml,json,toml等要按一定的规则才能生成正确的配置文件，下面以yaml格式为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# If set, log4rs will scan the file at the specified rate for changes and# automatically reconfigure the logger. The input string is parsed by the# humantime crate.refresh_rate: 30 seconds#配置文件的刷新速率，可以理解为每隔30s重新读取一次配置文件# The &quot;appenders&quot; map contains the set of appenders, indexed by their names.appenders: foo: # All appenders must specify a &quot;kind&quot;, which will be used to look up the # logic to construct the appender in the `Deserializers` passed to the # deserialization function. kind: console # Filters attached to an appender are specified inside the &quot;filters&quot; # array. filters: - # Like appenders, filters are identified by their &quot;kind&quot;. kind: threshold # The remainder of the configuration is passed along to the # filter&#x27;s builder, and will vary based on the kind of filter. level: error # The remainder of the configuration is passed along to the appender&#x27;s # builder, and will vary based on the kind of appender. # Appenders will commonly be associated with an encoder. encoder: # Like appenders, encoders are identified by their &quot;kind&quot;. # # Default: pattern kind: pattern # The remainder of the configuration is passed along to the # encoder&#x27;s builder, and will vary based on the kind of encoder. pattern: &quot;&#123;d&#125; [&#123;t&#125;] &#123;m&#125;&#123;n&#125;&quot;# The root logger is configured by the &quot;root&quot; map.root: # The maximum log level for the root logger. # # Default: warn level: warn # The list of appenders attached to the root logger. # # Default: empty list appenders: - foo# The &quot;loggers&quot; map contains the set of configured loggers, indexed by their# names.loggers: foo::bar::baz: # The maximum log level. # # Default: parent logger&#x27;s level level: trace # The list of appenders attached to the logger. # # Default: empty list appenders: - foo # The additivity of the logger. If true, appenders attached to the logger&#x27;s # parent will also be attached to this logger. # Default: true additive: false 通过上面的示例，基本用法就差不多了，下面继续深入学习一下log4rs。 二、log4rslog4rs由4部分组成：appenders（输出到什么地方去）， encoders（按什么格式输出）， filters（那些可以输出，那些不能输出），loggers（日志实例）。 【1】appenders An appender takes a log record and logs it somewhere, for example, to a file, the console, or the syslog. appenders主要有以下三种： console —— The console appender.（输出到控制台） file ——The file appender.（输出到文件） rolling_file —— A rolling file appender.（实现文件回滚） 分别实现了输出到控制台，输出到文件，实现文件回滚等功能。其中较为复杂的是rolling_file，这也是我们工程中常用到的，比如实现日志大小的控制（控制日志文件大小为10MB，到达10MB后，自动清空日志，重新开始记录），实现日志文件数量的控制(限制数量的同时限制单个文件大小)等等。下面给一个rolling_file的示例程序，说明一下它的用法。 123456789101112131415161718192021#[macro_use]extern crate log;extern crate log4rs;use std::default::Default;use std::thread;use std::time::Duration;fn main() &#123; log4rs::init_file(&quot;config/log4rs.yaml&quot;,Default::default()).unwrap(); for i in 1..2&#123; info!(&quot;booting up &#123;&#125;&quot;,i); error!(&quot;error test &#123;&#125;&quot;,i); &#125; //无限循环，不断记录日志 loop&#123; thread::sleep(Duration::from_secs(1)); info!(&quot;booting up &quot;); error!(&quot;error test&quot;); &#125;&#125; 重点是配置文件，通过不同的配置去实现不同功能： 12345678910111213141516171819202122232425262728293031323334353637#实现了限制日志文件大小为1024Byte的功能。appenders: stdout: kind: console requests: kind: file path: &quot;requests.log&quot; encoder: pattern: &quot;&#123;d&#125; [&#123;t&#125;] &#123;l&#125; &#123;M&#125;:&#123;m&#125;&#123;n&#125;&quot; ################################################## roll:#定义rooling_file的appenders kind: rolling_file path: &quot;roll.log&quot; append: true encoder: kind: pattern policy: kind: compound trigger: kind: size limit: 1024 #限制大小为1024Byte roller: kind: delete#回滚方式为直接删除 ################################################## root: level: info appenders: - roll#使用roll appendersloggers: app::backend::db: level: info app::requests: level: info appenders: - requests additive: false 另为附加限制日志文件大小的配置文件及限制日志文件数量的配置参考代码： 123456789101112131415161718192021222324#yaml文件appenders: foo:#限制日志文件大小的配置 kind: rolling_file path: &#123;0&#125;/foo.log policy: trigger: kind: size limit: 1024 roller: kind: delete bar:#限制日志文件数量的配置 kind: rolling_file path: &#123;0&#125;/foo.log policy: kind: compound trigger: kind: size limit: 5 mb roller: kind: fixed_window pattern: &#x27;&#123;0&#125;/foo.log.&#123;&#123;&#125;&#125;&#x27; base: 1 count: 5 对应的配置项的解说： 12345678910111213141516171819202122232425262728293031/// # Configuration////// ```yaml/// kind: rolling_file////// # The path of the log file. Required./// path: log/foo.log////// # Specifies if the appender should append to or truncate the log file if it/// # already exists. Defaults to `true`./// append: true////// # The encoder to use to format output. Defaults to `kind: pattern`./// encoder:/// kind: pattern////// # The policy which handles rotation of the log file. Required./// policy:/// # Identifies which policy is to be used. If no kind is specified, it will/// # default to &quot;compound&quot;./// kind: compound////// # The remainder of the configuration is passed along to the policy&#x27;s/// # deserializer, and will vary based on the kind of policy./// trigger:/// kind: size/// limit: 10 mb////// roller:/// kind: delete/// ``` 为什么是这样配置呢，或者说，这些配置项是从哪里来的，就要分析源代码了，以rolling_file为例：rolling_file中含有5个结构体，分别是： LogFile —— Information about the active log file. RollingFileAppender —— An appender which archives log files in a configurable strategy. RollingFileAppenderBuilder —— A builder for the RollingFileAppender. RollingFileAppenderConfig —— Configuration for the rolling file appender. RollingFileAppenderDeserializer —— A deserializer for the RollingFileAppender. 1234567/// Configuration for the rolling file appender.pub struct RollingFileAppenderConfig &#123; path: String, append: Option&lt;bool&gt;, encoder: Option&lt;EncoderConfig&gt;, policy: Policy,&#125; 这个就列出了rolling_file appender的需要的配置项，其他的配置也是在***Config中，道理是一样的。 【2】encoders An encoder is responsible for taking a log record, transforming it into the appropriate output format, and writing it out. encoders主要由以下三部分组成： json —— An encoder which writes a JSON object. pattern —— A simple pattern-based encoder. writer —— Implementations of the encode::Write trait. 最常用的是pattern，所以着重分析一下pattern。这个有些类似与其他语言的格式化器或者日志属性等概念，链接：https://docs.rs/log4rs/0.7.0/log4rs/encode/pattern/index.html 1234567891011121314151617181920d, date - The current time. By default, the ISO 8601 format is used. A custom format may be provided in the syntax accepted by chrono. The timezone defaults to local, but can be specified explicitly by passing a second argument of utc for UTC or local for local time.&#123;d&#125; - 2016-03-20T14:22:20.644420340-08:00&#123;d(%Y-%m-%d %H:%M:%S)&#125; - 2016-03-20 14:22:20&#123;d(%Y-%m-%d %H:%M:%S %Z)(utc)&#125; - 2016-03-20 22:22:20 UTCf, file - The source file that the log message came from, or ??? if not provided.h, highlight - Styles its argument according to the log level. The style is intense red for errors, red for warnings, blue for info, and the default style for all other levels.&#123;h(the level is &#123;l&#125;)&#125; - the level is ERRORl``, level - The log level.L, line - The line that the log message came from, or ??? if not provided.m, message - The log message.M, module - The module that the log message came from, or ??? if not provided.n - A platform-specific newline.t, target - The target of the log message.T, thread - The name of the current thread.I, thread_id - The ID of the current thread.X, mdc - A value from the MDC. The first argument specifies the key, and the second argument specifies the default value if the key is not present in the MDC. The second argument is optional, and defaults to the empty string.&#123;X(user_id)&#125; - 123e4567-e89b-12d3-a456-426655440000&#123;X(nonexistent_key)(no mapping)&#125; - no mappingAn &quot;unnamed&quot; formatter simply formats its argument, applying the format specification.&#123;(&#123;l&#125; &#123;m&#125;)&#125; - INFO hello","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"},{"name":"log4rs","slug":"log4rs","permalink":"https://cherryyang05.github.io/hexo-blog/tags/log4rs/"}]},{"title":"Rust入门教程（十四）：异步编程","slug":"Rust入门教程（十四）","date":"2023-11-02T07:54:33.000Z","updated":"2024-03-27T06:14:44.845Z","comments":true,"path":"1bd98bb8.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1bd98bb8.html","excerpt":"Rust 异步编程","text":"Rust 异步编程 一、异步编程介绍 有两种方式调用异步函数，一种是 block_on()，另一种是 await。 block_on() 函数会阻塞，不会继续向下执行。 在异步函数中执行异步操作需要用 await 来 “激活” 该函数，因为 Future 本身不会自己做任何事，它是一个惰性函数，需要被调用才能执行。在异步函数或异步块中，通过 await 来执行，在非异步函数中通过执行器的 block_on() 来执行。 用 sleep() 阻塞某个函数，但是线程并不会切换到另一个函数执行。因为使用的 sleep() 函数是标准库中的函数，我们应该使用异步包中的函数，例如 tokio、async-std、futures 的 crate。在这些库中，实现了 executor、reactor 等功能，也实现了 sleep() 等函数。 原因： Future 会返回 Ready 或 Pending 两种状态，当一个函数执行完会通知 Reactor，然后 Reactor 通知 executor。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"执行 yum 提示CRITICAL","slug":"执行yum提示CRITICAL","date":"2023-09-16T14:29:32.000Z","updated":"2024-03-27T07:28:46.565Z","comments":true,"path":"3b07dfa1.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/3b07dfa1.html","excerpt":"","text":"执行 yum 命令提示 CRITICAL:yum.cli:Config Error: Error accessing file for config file:&#x2F;&#x2F;&#x2F;etc&#x2F;yum.conf关于这个问题，网上可以找到很多解决方案，包括但不限于： 重新安装 yum 重新创建 &#x2F;etc&#x2F;yum.conf文件 使用 rpm 卸载当前安装的包 但是最后仍然报同样的错误。 因为之前在更换 libc 版本，手动编译安装了 glibc，最后搜到这个博客，得知是 curl 出了问题，是 libcurl 版本过低，libcurl 是 c&#x2F;cpp 使用时的链接库，常用的 http get，post 请求，http，ftp 下载等都支持 curl 的功能实现是依赖 libcurl.so 这个动态链接库的，通常位于 &#x2F;lib64 或者 &#x2F;usr&#x2F;lib64 中，4.x 版本的链接库地址为 libcurl.so.4 最后发现 libcurl 版本为 4.3.0，可能不支持 glibc-2.30 高版本的运行时，因此重新下载了高版本的 libcurl，具体操作见博客","categories":[{"name":"运维","slug":"运维","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/"},{"name":"配置","slug":"运维/配置","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux/"},{"name":"yum","slug":"yum","permalink":"https://cherryyang05.github.io/hexo-blog/tags/yum/"},{"name":"配置","slug":"配置","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E9%85%8D%E7%BD%AE/"},{"name":"Centos","slug":"Centos","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Centos/"}]},{"title":"Rust入门教程（八）：编写和运行测试","slug":"Rust入门教程（八）","date":"2023-08-08T12:35:27.400Z","updated":"2023-08-25T05:19:53.961Z","comments":true,"path":"290a7a7a.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/290a7a7a.html","excerpt":"Rust入门教程（八）：编写和运行测试 这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。 测试函数体通常执行下面三个操作，也称 3a 操作： 准备数据或状态（arrange）； 运行被测试的代码（act）； 断言结果（assert）。","text":"Rust入门教程（八）：编写和运行测试 这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。 测试函数体通常执行下面三个操作，也称 3a 操作： 准备数据或状态（arrange）； 运行被测试的代码（act）； 断言结果（assert）。 一、测试的使用及演示 测试函数需要使用 test 属性（attribute）进行标注 attribute 就是一段代码的元数据 在函数紧接着上面一行添加 #[test]，就将函数变成测试函数了 运行测试 使用 cargo test 命令运行所有测试 Rust 会构建一个 Test Runner 可执行文件，会运行标注的 test 函数，并报告运行是否成功 当使用 cargo 创建 library 项目时，会生成一个 test module，里面有默认的 test 函数 可以添加任意数量的 test module 和 test 函数 1.1 测试演示我们输入命令 cargo new test_demo --lib 创建一个项目，在 lib.rs 文件中看到这样的函数： 12345678#[cfg(test)]mod tests &#123; #[test] fn it_works() &#123; let result = 2 + 2; assert_eq!(result, 4); &#125;&#125; 这里 assert_eq! 是一个断言的宏，判断两个数是否相等。 然后运行 cargo test，结果如下： 123456789101112131415➜ ~/code/rust/test_demo git:(master) ✗ cargo test Compiling test_demo v0.1.0 (/home/cherry/code/rust/test_demo) Finished test [unoptimized + debuginfo] target(s) in 2.33s Running unittests (target/debug/deps/test_demo-357c557c333f0e0d)running 1 testtest tests::it_works ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Doc-tests test_demorunning 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s 1.2 测试失败 测试函数 panic 就表示测试失败 每个测试都运行在一个新线程中 当主线程看到测试线程挂掉后，那个测试就被标记为失败 我们单独编写一个带有 panic 的测试函数，测试结果如下： 12345678910111213#[cfg(test)]mod tests &#123; #[test] fn it_works() &#123; let result = 2 + 2; assert_eq!(result, 4); &#125; #[test] fn another() &#123; panic!(&quot;Test Failed!&quot;) &#125;&#125; 12345678910111213141516171819202122➜ ~/code/rust/test_demo git:(master) ✗ cargo test Compiling test_demo v0.1.0 (/home/cherry/code/rust/test_demo) Finished test [unoptimized + debuginfo] target(s) in 0.28s Running unittests (target/debug/deps/test_demo-357c557c333f0e0d)running 2 teststest tests::another ... FAILEDtest tests::it_works ... okfailures:---- tests::another stdout ----thread &#x27;tests::another&#x27; panicked at &#x27;Test Failed!&#x27;, src/lib.rs:11:9note: run with `RUST_BACKTRACE=1` environment variable to display a backtracefailures: tests::anothertest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00serror: test failed, to rerun pass &#x27;--lib&#x27; 二、断言2.1 使用 assert! 宏检查测试结果 assert! 来自于标准库，用来确定某个状态是否为 true 如果为 true，表示测试通过 如果为 false，则调用 panic! 宏，测试失败 我们用之前写的一个小例子，判断矩形 r1 是否能容纳矩形 r2（为了简单起见，只判断正着放，而不考虑斜着放进去）。 123456789101112struct Rect &#123; x: u32, y: u32,&#125;impl Rect &#123; fn can_hold(&amp;self, other: &amp;Rect) -&gt; bool &#123; let x = if other.x &gt; other.y &#123; other.x &#125; else &#123; other.y &#125;; let y = if other.x &lt; other.y &#123; other.x &#125; else &#123; other.y &#125;; self.x &gt; x &amp;&amp; self.y &gt; y &#125;&#125; 测试函数： 123456#[test]fn larger_can_hold_smaller() &#123; let r1 = Rect &#123; x: 12, y: 8 &#125;; let r2 = Rect &#123; x: 5, y: 10 &#125;; assert!(r1.can_hold(&amp;r2));&#125; 显然返回是 true，测试通过。 2.2 使用 assert_eq! 和 assert_ne! 测试相等性 都来自标准库 判断两个参数是否相等或不等 实际上，它们使用的就是 == 和 != 运算符 如果断言失败，该宏会自动打印出两个参数的值 使用 debug 格式打印参数 要求参数实现 PartialEq 和 Debug Traits（所有基本类型和标准库里大部分类型基本都实现了） 如果使用 assert! 宏，则只会告知测试结果而不会打印出两个参数的值 我们再写一个简单的例子，将一个数加 2，判断两个值是否相等。 12345678fn add_two(a: i32) -&gt; i32 &#123; a + 2&#125; #[test]pub fn it_add_two() &#123; assert_eq!(4, add_two(2));&#125; 结果显然是正确的，若我们更改函数逻辑，把加 2 改成加 3，则运行测试结果为： 12345678910111213141516171819202122232425➜ ~/code/rust/test_demo git:(master) ✗ cargo test Compiling test_demo v0.1.0 (/home/cherry/code/rust/test_demo) Finished test [unoptimized + debuginfo] target(s) in 0.39s Running unittests (target/debug/deps/test_demo-357c557c333f0e0d)running 3 teststest tests::it_add_two ... FAILEDtest tests::it_works ... oktest tests::larger_can_hold_smaller ... okfailures:---- tests::it_add_two stdout ----thread &#x27;tests::it_add_two&#x27; panicked at &#x27;assertion failed: `(left == right)` left: `4`, right: `5`&#x27;, src/lib.rs:37:9note: run with `RUST_BACKTRACE=1` environment variable to display a backtracefailures: tests::it_add_twotest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00serror: test failed, to rerun pass &#x27;--lib&#x27; 编译器将会自动给出两个参数的值（左值和右值），若将宏改成 assert_ne! 测试结果又将变成正确。 三、自定义错误消息TODO","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"用 gdb 调试程序","slug":"GDB的使用","date":"2023-07-08T14:29:49.000Z","updated":"2023-08-23T05:19:20.257Z","comments":true,"path":"1ea0c606.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1ea0c606.html","excerpt":"学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～","text":"学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～ 1. gdb 调试 run 和 start 的区别一般来说，在启动 gdb 之后，执行 r 或者 run 之后，就开始执行程序了，直到遇到第一个断点。 start 指令会执行程序至 main() 主函数的起始位置，即在主函数的第一行停止执行（改行代码还没有执行）。 另外，程序执行过程中使用 run 或 start 指令，表示重新启动程序。 2. gdb tui：在 gdb 中显示程序源码我们使用 gdb 的时候，想要看源码，需要输入 list 命令查看断点前后的代码，但是 list 没有代码高亮，也无法实时跟踪。用 gdb tui 自带的界面可以方便的查看并跟踪源码。输入命令 gdb -tui 打开窗口。 gdb 还有其他窗口类型，输入如下命令可以打开相应的窗口。 1234layout cmd // 命令窗口，可以输入调试命令layout src // 源代码窗口，显示当前行、断点等信息layout asm // 汇编代码窗口layout reg // 寄存器窗口 要想使用这些窗口，需要通过源码编译 gdb，在编译时添加参数 --enable-tui。 123./configure --prefix=/usr/local/gdb-11.2 --enable-tuimake -j32make install 在编译安装时可能会出现如下错误： 1configure: error: no enhanced curses library found; disable TUI 在 CentOS 下需要安装 yum install ncurses-devel 包，Ubuntu 下安装 libncurses5-dev 提示这个错误： 1GMP is missing or unusable 需要安装 yum install gmp-devel.x86_64 gcc 编译安装可能会提示：致命错误： zlib.h：没有那个文件或目录，需要安装 yum install zlib-devel Log 的使用123➜ ~ logger &quot;Hello World&quot;➜ ~ log show --last 1m | grep Hello2022-10-04 22:42:30.438584+0800 0x81a171 Default 0x0 47131 0 logger: Hello World","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"GDB","slug":"生产力工具/GDB","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/GDB/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://cherryyang05.github.io/hexo-blog/tags/GDB/"}]},{"title":"C 语言预处理器和宏的高级用法","slug":"C语言预处理器和宏的高级用法","date":"2023-01-22T14:27:45.000Z","updated":"2023-09-19T07:01:43.821Z","comments":true,"path":"aaaac292.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/aaaac292.html","excerpt":"本篇文章介绍 C 语言中类似 #define, #if, #ifdef 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。本篇文章将不会介绍简单的宏用法，例如 #define ADD(a, b) ((a)+(b))本篇文章大部分参考《C Primer Plus 第六版》第 16 章","text":"本篇文章介绍 C 语言中类似 #define, #if, #ifdef 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。本篇文章将不会介绍简单的宏用法，例如 #define ADD(a, b) ((a)+(b))本篇文章大部分参考《C Primer Plus 第六版》第 16 章 一、预处理及宏1.1 “#” 运算符# 是一个预处理运算符，可以将记号转化成字符串。例如 #define TYPE(x) #x，若使用宏 TYPE(int)，则将其替换成字符串 &quot;int&quot;，#x 就是转换为 x 的形参名。 下面是一个例子。 1234567#include&lt;stdio.h&gt;#define TYPE(x) #xint main() &#123; printf(&quot;The num 3 is an &quot;TYPE(int)&quot; type&quot;); return 0;&#125; 输出结果为：The num 3 is an int type 1.2 “##” 运算符与 # 运算符类似，## 运算符可以用于类函数宏的替换部分，而且还可以用于对象宏的替换部分。## 运算符将两个记号组合成一个记号，例如 #define TEST(n) TEST_##n，然后宏 TEST1 将其展开为 TEST_1。 下面是一个具体的例子。 123456789101112#include&lt;stdio.h&gt;#define XNAME(n) x##n#define PRINT_XN(n) printf(&quot;x&quot;#n&quot; = %d\\n&quot;, x##n) int main() &#123; int XNAME(1) = 14; // 展开成 int x1 = 14; int XNAME(2) = 20; // 展开成 int x2 = 20; int x3 = 30; PRINT_XN(1); // 展开成 printf(&quot;x1 = %d\\n&quot;, x1); PRINT_XN(2); // 展开成 printf(&quot;x2 = %d\\n&quot;, x2); PRINT_XN(3); return 0;&#125; 注意，# 运算符组合成字符串，而 ## 运算符组合成为一个新的标识符。 1.3 #undef 指令#undef 指令用于取消已定义的 #define 指令。若之前没有定义某个宏，取消对其的定义也是有效的，如果想使用一个名称，但不确定之前是否已经用过，使用 #undef 先取消定义是一个安全的方法。 1.4 条件编译指令1.4.1 #ifdef、#else 和 #endif 指令先用一个简单的例子来说明这三个条件编译指令。 1234567#ifdef MAVIS #include &quot;horse.h&quot; #define STABLES 5#else #include &quot;cow.h&quot; #define STABLES 15#endif 上述代码理解起来应该挺简单，若用 #define 定义了 MAVIS，就引入 horse.h 头文件，若没有定义 MAVIS 就引入头文件 cow.h。 #ifdef 测试的宏可以是对象宏，也可以是函数宏。 1.4.2 #ifndef#ifndef 用法和 #ifdef 类似，但是意思相反。除此之外 #ifndef 还可以防止相同的宏被重复定义，例如下面的例子。 12#ifndef _MATH_H_#define _MATH_H_ 通过 #ifndef 也可以避免头文件被引入多次。 1.4.3 #if、#elif#if 和 #elif 后面跟一个常量表达式，如果表达式的值为非零，则表达式为真，类似于 C 语言中的 if else，可以使用关系运算符和逻辑运算符。 #if 和 #elif 后面的宏只能是对象宏，不能是函数宏。 1.4.4 #defined#defined 用于判断宏是否已经被定义，可以是对象宏，也可以是函数宏，可以和 #elif 嵌套使用。 条件编译可以让程序更容易移植，改变文件开头的几个关键定义，可以根据不同的架构或系统设置不同的值和包含不同的文件。 1.5 预定义宏C 标准规定了一些预定义宏，如下列表格所示。 宏 含义 DATE 预处理的日期（“Mmm dd yyyy”形式的字面量，如 Nov 12 2023） FILE 表示当前源代码文件名的字符串字面量 LINE 表示当前源代码文件中行号的整型量 STDC 设置为 1 时表示遵循 C 标准 STDC_HOSTED 本机环境设置为 1，否则设置为 0 STDC_VERSION 支持 C99 标准，设置为 199901L；支持 C11标准，设置为 201112L TIME 翻译代码的时间，格式为 “hh:mm:ss” 1.6 #line 和 #error#line 指令重置 __LINE__ 和 __FILE__ 宏报告的行号和文件名，用法如下。 12#line 1000 // 将当前行号重置为 1000#line 10 cool.c // 将当前行号重置为 10，文件名重置为 cool.c #error 指令让预处理器发出一条错误信息，该消息包含指令中的文本，用法如下。 123#if __STDC_VERSION__ != 201112L#error Not C11#endif 编译上述代码将会产生 error，并且提示 Not C11。 1.7 变参宏 … 和 __VA_ARGS__一些函数可以接受数量可变的参数，例如 printf，在头文件 stdvar.h 中提供了相关操作。 同样，宏定义中也可以实现可变参数，通过将宏列表中最后的参数写成 ... 来实现这一功能。这样，预定义宏 __VA_ARGS__ 可用在替换部分中，用来表示省略号代表什么。例如定义 #define PRINT(...) printf(__VA_ARGS__)，调用宏 PRINT(&quot;Hello&quot;)，__VA_ARGS__ 展开为一个参数 Hello，调用宏 PRINT(&quot;My name is %s&quot;, name)，__VA_ARGS__ 展开为两个参数 &quot;My name is %s&quot; 和 name。 1.8 attributeGNU C 的一大特色就是 __attribute__ 机制。__attribute__ 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute）。 具体内容请参见链接 C语言__attribute__的使用、attribute 机制详解 二、宏模板由于 C 语言中库比较少，而一些比较基础的操作又无需通过函数实现，因此可以将一些基础功能写成宏进行展开，并集成到头文件中，在今后的项目中可以很方便的进行调用。 在这里我自己总结并整理了若干个常用的宏。 宏名称 功能 LOG 打印调试信息（带颜色） UPPERCASE 转化为大写字母 LOWERCASE 转化为小写字母 FPOS 获取结构体成员偏移量 FSIZ 获取结构体成员所占用字节数 container_of 根据成员指针、结构体类型、结构体成员名称获取结构体起始地址 offsetof 获取结构体成员偏移量 2.1 打印调试信息调试信息是任何项目必不可少的内容，下面的宏可以在终端中输出带颜色的调试标签，方便观察错误和警告信息。 123456789101112131415#include&lt;stdio.h&gt;#define _LOG_#ifdef _LOG_#define LOG_ERROR_STYLE &quot;\\x1b[31m&quot;#define LOG_INFO_STYLE &quot;\\x1b[32m&quot;#define LOG_WARNING_STYLE &quot;\\x1b[33m&quot;#define LOG_DEBUG_STYLE &quot;\\x1b[34m&quot;#define LOG_STYLE_CLEAR &quot;\\x1b[0m &quot;#define LOG_ERROR(...) printf(LOG_ERROR_STYLE&quot;[ERROR]&quot;LOG_STYLE_CLEAR __VA_ARGS__)#define LOG_INFO(...) printf(LOG_INFO_STYLE&quot;[INFO]&quot;LOG_STYLE_CLEAR __VA_ARGS__)#define LOG_WARNING(...) printf(LOG_WARNING_STYLE&quot;[WARN]&quot;LOG_STYLE_CLEAR __VA_ARGS__)#define LOG_DEBUG(...) printf(LOG_DEBUG_STYLE&quot;[DEBUG]&quot;LOG_STYLE_CLEAR __VA_ARGS__)#define LOG(TYPE, ...) LOG_##TYPE(__VA_ARGS__) 调用上面的 LOG 宏，可以看到结果如下。 123456int main() &#123; LOG(ERROR, &quot;%s\\n&quot;, &quot;This is an error msg...&quot;); LOG(DEBUG, &quot;%s\\n&quot;, &quot;This is a debug msg...&quot;); LOG(INFO, &quot; %s\\n&quot;, &quot;This is an info msg...&quot;); LOG(WARNING, &quot; %s\\n&quot;, &quot;This is a warning msg...&quot;);&#125; 2.2 大小写转化12#define UPPERCASE(c) (c &amp; 0xdf)#define LOWERCASE(c) (c | 0x20) 2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量1#define FPOS(type, member) (&amp;((type*)0)-&gt;member) 2.4 得到一个结构体中某个成员字段 member 所占用的字节数1#define FSIZ(type, member) sizeof(((type*)0)-&gt;member) 2.5 container_of123#define container_of(ptr, type, member) (&#123; \\const typeof(((type *)0)-&gt;member) *__mptr = (ptr); \\(type *)((char *)__mptr - __offsetof(type,member)); &#125;) container_of 宏函数的作用是 已知结构体 type 的成员 member 的地址 ptr，得到结构体 type 的起始地址。 第一行用于“类型检查”。它确保 type 有一个名为 member 的成员（不过我认为这也是由 offsetof 宏完成的），并且如果 ptr 不是指向正确类型（成员的类型）的指针，编译器将打印警告，这对调试很有用。 在上述宏的第三行，用了 char * 进行指针转化，这是因为 offsetof 指针偏移量是按照字节计算的，同时 char * 的指针也是以字节计算的，若转化为例如 int * 等类型，则 C 的指针算法将会计算 sizeof(int) * offsetof 作为最终的结果，也就是 4 字节乘以偏移量。 具体说明参考链接 container of()函数简介 和 linux 内核宏container_of剖析 2.6 offsetof1#define offsetof(type, member) ((size_t) &amp; ((type *)0)-&gt;member) offsetof 宏函数的作用是 得到结构体 type 的成员 member 所在的内存偏移量 对于 container of 以及 offsetof 我会单独用一篇博客进行详细讲解。 2.72.82.92.102.112.122.13","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"宏","slug":"宏","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%AE%8F/"}]},{"title":"Rust实现进度条功能","slug":"Rust实现进度条功能","date":"2023-01-12T07:57:27.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"84b8101e.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/84b8101e.html","excerpt":"本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。","text":"本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。 一、代码实现先上代码。 123456789101112131415pub fn bar_show() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123; const BAR_FRONT: &amp;str = &quot;-\\\\|/&quot;; for index in 0..=100 &#123; print!( &quot;\\r&#123;&#125; \\u&#123;1b&#125;[42m&#123;&#125;\\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;, BAR_FRONT.chars().nth(index % 4).unwrap(), &quot; &quot;.repeat(index / 3), index ); stdout().flush()?; sleep(Duration::from_millis(30)); &#125; println!(); Ok(())&#125; 因为终端输出的进度条是带颜色的，在这里没法显示，只能通过截图看。 二、代码解释进度条前面的指示字符是 &quot;-\\\\|/&quot; 交替显示，呈现出动态效果，因为 \\ 需要转义，所以是两个反斜杠 \\\\。 然后就是进度条从 0-100 开始，每一次循环输出指示字符(模 4)，空白字符重复 (index &#x2F; times) 次，根据进度条长度进行调整除数。然后刷新输出流，要不然输出会在缓存中，每隔一段时间才会输出到设备，不会实时显示进度条进度，最后再睡眠 30ms，让进度条缓慢加载。 最重要的是这一句：&quot;\\r&#123;&#125; \\u&#123;1b&#125;[42m&#123;&#125;\\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;。 首先，\\r 表示将光标置于本行行首，使用 print! 可以使得每次输出覆盖之前输出的行。然后 \\u 表示输出后面的 UniCode 字符，&#123;&#125; 就不用说了，是 Rust 里用来控制格式化输出的。 注：Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\\n”；Windows 系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\\n\\r”；Mac 系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix&#x2F;Mac 系统下的文件在 Windows里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix&#x2F;Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。所以，如果你需要跨平台处理文本文件，可能会被回车换行搅得有点头大。0x0D（ascii 码是 13） 指的是“回车” \\r 是把光标置于本行行首0x0A（ascii 码是 10） 指的是“换行” \\n 是把光标置于下一行的同一列0x0D + 0x0A 回车换行 \\r\\n 是把光标置于下一行行首 \\u&#123;1b&#125;[42m 这句的格式是 \\x1b[&lt;代码&gt;;&lt;代码&gt;，其中 \\x1b[ 是十六进制 1b，写成八进制 \\033 也行，然后一个左中括号，是特殊的终端控制符，格式固定。然后后面跟上一个数字和一个字母，这里 42m 就是将背景设置为绿色，字母 m 表示设置的属性类别，数字代表属性值。 下面是一些其他属性，可以设置文本的颜色，背景色，设置是否加粗，下划线等。 12345678910111213141516171819202122\\033[0m 关闭所有属性\\033[1m 设置加粗\\033[2m 设置模糊，有的终端可能不支持\\033[3m 设置斜体，有的终端可能不支持\\033[4m 下划线（单线）\\033[5m 闪烁（慢）\\033[5m 闪烁（快），有的终端可能不支持\\033[7m 交换背景色与前景色\\033[8m 隐藏所有\\033[30m 至 \\033[37m 设置前景色\\033[40m 至 \\033[47m 设置背景色\\033[nA 光标上移n行 \\033[nB 光标下移n行\\033[nC 光标右移n行\\033[nD 光标左移n行\\033[y;xH 设置光标位置\\033[2J 清屏\\033[K 清除从光标到行尾的内容\\033[s 保存光标位置 \\033[u 恢复光标位置\\033[?25l 隐藏光标\\033[?25h 显示光标 各个数字代表的颜色如下。 123456789101112131415161718字背景颜色范围:40--49 40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色 46:深绿 47:白色字颜色: 30--39 30:黑 31:红 32:绿 33:黄 34:蓝色 35:紫色 36:深绿 37:白色 另外，同类的多种设置项可以组合在一起，中间用分号 ; 隔开。 例如 print!(&quot;\\u&#123;1b&#125;[31;1;3;4m&#123;&#125;\\u&#123;1b&#125;[0m&quot;, &quot;Rosa&quot;);，其中 \\u&#123;1b&#125;[31;1;3;4m 中，31 表示前景色（字的颜色）是红色，1 表示加粗，3 表示设置斜体，4 表示设置下划线。则上述代码输出的是一个红色加粗加下划线的斜体字符串 Rosa。最后的 \\u&#123;1b&#125;[0m 表示将格式清除掉，否则下面输出的任何字符都将使用刚刚的样式。 同样，在 C 语言中也可以实现。 12int color = 32;printf(&quot;\\033[20;1H\\033[1;4;%dmHello, world.\\033[0m&quot;, color); 这行命令首先 \\033[20;1H 将光标移动到终端第 20 行第 1 列，之后的 \\033[1;4;32m 将文本属性设置为高亮、带下划线且颜色为绿色，然后输出 Hello,world，最后 \\033[0m 将终端属性恢复为默认值。 三、一些参考实现3.1 bash 中输出带样式的字符在 bash 中，通常我们可以使用 echo 命令加 -e 选项输出各种颜色的文本，echo -e 表示处理特殊字符，开启转义。 123456echo -e &quot;\\033[31mRed Text\\033[0m&quot;echo -e &quot;\\033[32mGreen Text\\033[0m&quot;echo -e &quot;\\033[33mYellow Text\\033[0m&quot;echo -e &quot;\\033[34mBlue Text\\033[0m&quot;echo -e &quot;\\033[35mMagenta Text\\033[0m&quot;echo -e &quot;\\033[36mCyan Text\\033[0m&quot; 3.2 C 语言中输出颜色表12345678910111213141516#include &lt;stdio.h&gt;int main(void)&#123; int i, j, n; for (i = 0; i &lt; 11; i++) &#123; for (j = 0; j &lt; 10; j++) &#123; n = 10 * i + j; if (n &gt; 108) break; printf(&quot;\\033[%dm %3d\\033[m&quot;, n, n); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 四、参考文档浅析 \\x1B[1;3;31mxterm.js\\x1B[0m 是什么？如何在终端输出带颜色等格式的字符串 ANSI escape code 控制台终端输出颜色 Rust 官方有进度条实现的 indicatif crate，用法比较全面，这里是 源码解析","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"},{"name":"小工具","slug":"小工具","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"Makefile的简单使用","slug":"Makefile的简单使用","date":"2023-01-05T07:50:03.000Z","updated":"2023-08-08T12:35:27.392Z","comments":true,"path":"31dce7e5.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/31dce7e5.html","excerpt":"Makefile 的简单使用 makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。","text":"Makefile 的简单使用 makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。 一、环境及样例源代码本机环境： MacBook M1测试用源代码： main.cpp print.cpp add.cpp func.h makefile main.cpp: 1234567#include &quot;func.h&quot;int main() &#123; printHappyNewYear(); cout &lt;&lt; add_one(3) &lt;&lt; endl; return 0;&#125; print.cpp: 12345#include &quot;func.h&quot;void printHappyNewYear() &#123; cout &lt;&lt; &quot;Happy New Year!!&quot; &lt;&lt; endl;&#125; add.cpp: 12345#include &quot;func.h&quot;int add_one(int a) &#123; return a + 1;&#125; func.h: 12345678910#define _FUNC_H_#ifdef _FUNC_H_#include&lt;iostream&gt;using namespace std;void printHappyNewYear();int add_one(int a);#endif 二、编译方式2.1 手动编译这种方式很简单，直接输入下面的命令。 1g++ main.cpp add.cpp print.cpp -o main 但这种显然不是我们想要的。 2.2 makefile 脚本编译如果我们只让他编译但是不链接，可以使用 -c 参数。 1g++ main.cpp -c 结果可以看到生成一个 main.o 文件，.o 文件便是 Unix 下的中间目标文件（Objective File） 然后我们逐个编译每个文件。 12g++ add.cpp -cg++ print.cpp -c 然后将所有 .o 文件链接到一起，生成可执行文件 main。 1g++ *.o -o main 当我们只修改某个源文件时，只需要单独编译某个文件而不需要重新编译所有文件。最后重新链接即可。但是当源文件太多的时候，这样也是不方便的，于是使用 makefile 脚本实现自动化。 Makefile（Version 1）123456## VERSION 1main: main.cpp print.cpp add.cpp @g++ main.cpp add.cpp print.cpp -o mainclean: rm *.o main 语法格式：main 这个文件依赖于后面的三个 cpp 文件，下一行的命令前面必须是一个 tab，否则语法错误。 运行 make 运行 makefile 脚本，或 make -f Makefile 根据指定文件名运行脚本。 首先脚本先去找 main，如果 main 不存在，则尝试生成 main。若已经生成了 main，则根据后面的依赖项判断该 main 是不是最新的，若不是最新的，则重新生成，否则不做任何操作。 第一个版本的缺点是若源文件太多，则命令显得很冗长。 Makefile（Version 2）1234567891011121314## VERSION 2CXX = g++TARGET = mainOBJ = main.o print.o add.o$(TARGET): $(OBJ) $(CXX) $(OBJ) -o $(TARGET)main.o: main.cpp $(CXX) -c main.cppprint.o: print.cpp $(CXX) -c print.cppadd.o: add.cpp $(CXX) -c add.cpp 第二个版本中使用了 CXX，TARGET，OBJ 变量，依次查找依赖，只编译已经修改过的文件，而不会编译所有文件。 Makefile（Version 3）1234567891011121314151617## VERSION 3CXX = g++TARGET = mainOBJ = main.o print.o add.oCXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) $^ -o $@%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 符号说明： $@: 目标文件，$^: 所有的依赖文件，$&lt;: 第一个依赖文件 .PHONY 表示的意思：若在该目录下有一个名叫 clean 的文件，那么脚本便无需生成该文件，也就不会执行相应的命令，但是这跟我们期望的不一致。加上 .PHONY 之后，依赖 clean，因此就会去执行 clean。 .PHONY 是一个伪目标，可以有效防止在 Makefile 文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突的问题。 第三个版本中，若将来有其他新的源文件加入之后，只需要在 OBJ 变量后面加入新的源文件即可。 Makefile（Version 4）123456789101112131415161718## VERSION 4CXX = g++TARGET = mainSRC = $(wildcard *.cpp)OBJ = $(patsubst %.cpp, %.o, $(SRC))CXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) $^ -o $@%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 在 Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 wildcard，它的用法是：$(wildcard PATTERN...) wildcard: 扩展通配符patsubst：替换通配符notdir：去除路径 SRC = $(wildcard *.cpp) 表示获得工作目录下所有 .cpp 文件并生成列表 SRC。OBJ = $(patsubst %.cpp, %.o, $(SRC)) 表示将所有 .cpp 后缀替换为 .o 并生成文件列表 OBJ。 这样下来，makefile 文件就相对比较智能化了，新增加文件之后也无需修改脚本了， 总之，脚本使你越懒惰，这个脚本的功能就越强大。","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"脚本","slug":"生产力工具/脚本","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Makefile","slug":"Makefile","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Makefile/"}]},{"title":"重构：改善既有代码的设计 学习笔记","slug":"重构：改善既有代码的设计-学习笔记","date":"2023-01-05T06:09:07.000Z","updated":"2023-08-08T12:35:27.553Z","comments":true,"path":"ea380076.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/ea380076.html","excerpt":"重构：改善既有代码的设计 学习笔记 重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。","text":"重构：改善既有代码的设计 学习笔记 重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。 一、重构是什么以及为什么 重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。 重构是一种经济适用行为，而非道德使然，如果它不能让我们更快更好的开发，那么它是毫无意义。 代码的写法应该使别人理解它所需要的时间最小化，进而变更代码需要的时间也会最小化。 重构对个体程序员的意义是提高ROI。 更快速的定位问题，节省调试时间。 最小化变更风险，提高代码质量，减少修复事故的时间。 得到程序员同行的认可，更好的发展机会。 重构对整个研发团队的意义是战斗力的提升。 尽管重构会让我们的开发变慢，但是可以让我们将来的开发变快。如果我们要对一个项目进行长期跟进，那么重构是必不可少的。 二、重构的原则 重构的目标: 提高迭代效率，如果你确定这段代码你将来只会用到一次，且别人也不会去看你的代码，那么就没有重构的必要。 获得同行认可的方法: 每一次提交代码，都应该使代码变得更好，先重构，再开发。 增量式重构 &#x3D; 自动化测试 + 持续集成 + TDD驱动重构。 三、代码的坏味道24重代码的坏味道和例子 一般我们能接触到的一些常见的问题： 命名不规范 代码重复 代码过长 函数参数列表不易理解 相关联的一些数据没有成组（数据泥团） 四、一些例子4.1 依赖传递变更放大：一次迭代需要修改 N 个位置，容易遗漏或失误。 关注放大：为完成修改任务，需要通读修改点上下文若干行代码，而由于依赖被传递，附近的代码会牵扯出更多需要关注的代码，往往阅读的代码量是本身要修改部分的若干倍。演化到最后就会导致不知道该次修改会不会导致问题。 4.2 神秘命名代码&#x2F;注释都是一堆符号的集合，如果这些符合不能被人或者因为其信息的冗余无效性增加了阅读负担就会降低可理解性。好的命名应该有三种境界: 信，达，雅。信: 准确无误地表达清楚行为的意义，做到见名之意。达: 考虑命名对整体架构的影响，与架构的设计哲学风格统一。雅: 生动形象，看到名字即可准确理解其在整个程序之中的作用，并能产生辅助理解的形象。 坏的例子 4.3 过度设计当过分的考虑程序未来所要面对的需求时，将陷入过度设计的陷阱，为了未来用不上的能力，而使当下的程序变得复杂。 设计变得复杂，是因为考虑了过多的设计约束，而这些约束很可能是现在和未来都不需要的，错把这些约束条件当作了目的，而使得目标被放大，设计出没有解决实际问题的系统。 过分放大未来的某行风险，这些风险发生的概率过低，在项目可见的生命周期内都不可能遇到，因此也没必要进行设计。 4.4 结构泥团对于核心的数据结构，没有规范化的设计将导致混乱 4.4.1 艰难引用未充分的考虑数据结构的读取场景，导致在需要使用某些数据的时候无法简单的获得其引用，或者为了使用某个字段，需要了解一堆中间封装的数据结构。 例如：a.b.c.d.e(); 4.4.2 全局盲区大型项目的开发中，由于大家缺乏全局视角，对数据结构或者接口的设计不可避免的造成冗余或混乱，接口与结构的设计充满局部最优解，但从项目整体上看却成为一团泥球。 五、什么时候需要重构 Code review: 在给别人 code review 时嗅出坏味道，在不失礼貌的前提下提出建议。 每次 commit 代码时: 每一次经你之手提交的代码都应该比之前更加干净。 当你接手一个异常难读的项目时: 说服项目组将重构作为一项需求任务来做。 当迭代效率低于预期时: 将重构当作一个项任务专门来做，必要的时候停下来迭代需求。 六、重构的基本步骤6.1 代码分析 通读代码，分析现状，找到代码在各个层面的坏味道。 6.2 重构计划 重构应该永远是一种经济驱动的决定。 对坏味道进行宣讲，并向团队给出重构的理由，以及重构的计划。 确定重构的目标，明确的描述出重构后能达到的预期是什么。 重构计划中必须给出测试验证方案，保证重构前与重构后软件的行为一致。 如果没有这样的方案，那就必须先让软件具有可测试性。 如果无法得到团队的认可,那就偷偷进行,因为重构始终是对自己有利的(减少工作量以及获得同事的认可) 将重构任务当作项目来管理，对指定任务的人明确的排期和进度同步。 6.3 小步子策略 将重构任务拆分成每周都能见到一点效果的小任务。 每一步重构都要具有收益，并且可测试，不能阻断当前需求的迭代。 重构任务必须被跟踪，要定期的开会同步进度，来不断加强团队的重构意识。 6.4 测试驱动 对于小型软件，需要先补充单元测试再进行重构。 对于大型软件，先搭建自动化测试流程，再进行重构。 对于复杂的不确定性业务，也可以使用ab test来验证重构对指标的影响，避免造成效果&#x2F;广告的损失。 要保证测试的完备性与可复用性，尽可能的做到团队级的复用。 保证测试环境与生产环境的一致性也是测试驱动的重要环节。 6.5 提交规范 每次提交尽量控制在2分钟可以给code review的同事讲明白的程度 重构应该被当作一次专门的commit中完成，在commit中写清楚改动点&amp;测试点 提交规范有助于定位bug，也是代码可读性的一个重要环节 6.6 自动化测试 构建可测试的软件，首先要构建可测试的环境。 对于简单应用软件可以使用单元测试，mock数据进行测试，并与ci&#x2F;cd流程集成。 对于复杂应用软件可以采样收集线上真实用户行为日志，mock数据周期性巡检测试。 对于幂等性业务，可以mock user进行全方位的端到端自动化巡检测试。 每一次功能的提交应该对应一套完整的自动化测试的策略脚本以及&amp;监控指标与报警规则 6.7 调试BUG 亲自复现问题，关注第一现场，确定是必现还是偶现? 区分是人的问题还是环境的问题? 如果是人的问题，那是配置参数的问题还是代码逻辑的问题? 如果是配置参数的问题，则通过对比正常运行的配置参数发现问题 如果是代码逻辑的问题，则通过cimmit的历史二分查找缩小出现问题的逻辑范围 如果是机器的问题，确定是单机问题还是集群问题。 如果是单机问题，则替换机器，如果是集群问题则考虑升级硬件设备。 七、一些实际的问题7.1 代码所有权代码仓库的所有权会阻碍重构，调用方难以重构被调用方的代码(接口)，进而导致自身重构的受阻，使得效率降低，为提高开发的效能，允许代码仓库在内部开源化，其他团队的工程师可以通过 pr 自己来实现代码，并提交给仓库的 onwer，来 code review 即可。 7.2 没有时间重构这是重构所面临最多的借口，是自己也是团队的借口。 为此必须要明确重构是经济行为而不是一种道德行为，重构使得开发效率变得更高，因此仅对必要的代码进行重构，某个工作行为如果重复三次就可以认为未来也会存在重复，因此通过重构使得下次工作更加高效，这是一种务实的作法，而重构不一定是需要大规模的展开的任务，重构应该是不断持续进行的，将任务拆解为多个具有完备性的任务，每周完成一个，每个任务的上线都不会引起问题，并使项目变得更好，这是一种持续重构的精神态度，是高效能程序员最应该具有的工作习惯。 如果你在给项目添加新的特性，发现当前的代码不能高效的完成这个任务，并且同样的任务出现三次以上，那么这时你应该先重构，再开发新特性。 7.3 重构导致 bug历史遗留的代码实在太多，难以阅读理解，如果无法理解谁也不敢轻易重构，害怕招致 bug 引起线上事故，因此在重构之前必须有一套相对完备的测试流程，他能给予程序员信心，也是重构的开始，反过来想对于谁也不愿意重构的代码进行重构，将收益巨大(这个项目还会继续迭代时)。","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"代码规范","slug":"生产力工具/代码规范","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"重构","slug":"重构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E9%87%8D%E6%9E%84/"},{"name":"代码架构","slug":"代码架构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"}]},{"title":"自旋锁","slug":"自旋锁","date":"2022-10-30T12:12:56.000Z","updated":"2023-08-08T12:35:27.421Z","comments":true,"path":"6d00129c.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/6d00129c.html","excerpt":"自旋锁 该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 GitHub 仓库 中查看。","text":"自旋锁 该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 GitHub 仓库 中查看。 一、前置知识关于自旋锁的内容，需要有以下几个方面的基础知识：基本数据结构（链表，队列）、操作系统中进程调度、锁及死锁、计算机体系结构中 cache 一致性、计算机组成原理中 cache 结构、Java 基本语法及 concurrent 包的基本用法。 二、背景介绍在如今多线程环境下对于共享临界资源的访问，需要加锁实现互斥。拿到锁的线程获得 CPU 执行临界区代码，而未拿到锁的线程通常来说有两种处理方式，一种是该线程进入循环等待，直到它等待的那个 CPU 空闲，然后获得 CPU 开始执行；另一种便是将自己阻塞，等待操作系统重新调度。 前一种锁叫 自旋锁，后一种锁叫 互斥锁。 先举一个很容易理解的例子。有两个进程，分别为 P1 和 P2，这两个线程做的工作都是将变量 a 加 1，就像这样： 123456789int a = 0;int P1() &#123; return a + 1; &#125;int P2() &#123; return a + 1; &#125; 如果执行这两个线程各 100 次，我们预期的结果是 a = 200，但是实际上结果并不是我们想象的这样，它有可能是 200，但是更多的情况是一个小于 200 的数。 在计算机底层上，对一个数执行加一操作，编译器会将其编译成下面三条指令： 123mov ax, memadd ax, 1mov mem, ax 当多线程执行时，代码执行顺序将不可控，因此会出现一个线程还未将值写进内存的时候，其他线程就读取内存中的值，造成数据相关问题。 三、TAS 锁与 TTAS 锁3.1 TAS 锁TAS(testAndSet) 是一个原子操作，它的功能是将 true 原子地写入变量，然后获取变量之前的值，即用 true 来交换变量的值。 为什么这个操作是原子的呢？因为在 x86 汇编中有个指令叫 xchg，它的功能便是交换两个数。 在 Java 中，有个与其功能一致的函数叫 getAndSet()，下面是 TASLock 的实现。 1234567891011public class TASLock &#123; AtomicBoolean state = new AtomicBoolean(false); public void lock() &#123; while (state.getAndSet(true)) &#123;&#125; &#125; public void unlock() &#123; state.set(false); &#125;&#125; 这里的 AtomicBoolean 是原子布尔类型，能够实现原子的赋值，来自 java.util.concurrent.atomic.AtomicBoolean。 这个锁通过代码很容易理解：当线程 A 获取锁时，将 state 置为 true，若线程 A 还未释放锁时，其他线程 B 若也要申请锁，便会在 while (state.getAndSet(true)) &#123;&#125; 空转，直到 state 为 false，然后线程 B 便可以申请到锁了。 我们先来看一下另一种形式的 TAS 锁，然后将两者进行比较。 3.2 TTAS 锁直接看具体实现。 123456789101112131415public class TTASLock &#123; AtomicBoolean state = new AtomicBoolean(false); public void lock() &#123; while (true) &#123; while (state.get()) &#123;&#125;; if (!state.getAndSet(true)) return; &#125; &#125; public void unlock() &#123; state.set(false); &#125;&#125; TTAS 锁并没有每次都直接调用 getAndSet(boolean) 方法，而是先判断 state 变量是否为 true，若为 true 便无需用 true 和原先的值进行交换。而若 state 变量是 false，则再对 state 执行 getAndSet。 因为这里有两次 test，因此该锁叫 TTAS(testTestAndSet) 锁。 当然从加锁的正确性来说，这两种锁是等价的，都可以保证无死锁的互斥，对于简单的情况，这两种并无明显差别。但是在多处理器上运行大量线程，这两种锁将会展现出指数级别的效率差距。 下面是 n 个线程分别执行一段临界区代码所需的时间图，在没有任何争用干扰的情况下，最下面的平直曲线应该是理想情况（实际上并不可能）。可以看出这三条曲线差距非常明显。 上图的情况可以用多处理器的系统结构进行解释。 3.3 比较两种锁的性能差距首先我们要确定的是，现代处理器几乎都包含高速缓存（cache），cache 与内存的一致性问题是现代处理器研究的重要问题；CPU 访问内存的时间时间比访问 cache 的时间多 2～3 个数量级。 多处理器中的 cache 一致性问题这里不展开讲述，大致内容如下。 每个处理器都有一个自己的 cache，考虑以下情况：处理器 A 访问数据 x（假设 x = a），将 x 放入 cache_A 中，处理器 B 也想访问 x，而 cache_B 中没有对 x 的缓存，这个时候处理器 B 便会在 cache_A 中查找 x，找到之后将其放入自己的缓存中（此时 x = a）。这时处理器 A 修改了 x 的值（假设修改为 b），并更新自己的 cache，若此时处理器 B 再次访问 x，它首先会从自己的 cache 中找，而目前 cache_B 中存放了 x = a，但是目前最新的值是 x = b，产生了错误，这就是 cache 一致性问题。 解决 cache 一致性问题的一个解决办法便是在一个处理器更新自己的 cache 后，该处理器在总线上广播这个地址，其他处理器监听总线，如果其他处理器在自己的 cache 中发现了同样的地址，则将对应的 cache 置为无效。 然后我们再来分析 TAS 锁。 在 TAS 锁中，每个线程每次执行都将调用 getAndSet 方法，而这个方法需要写入变量，因此在修改变量前需要在总线上进行广播，通知其他处理器将该 cache 行置为无效。而这便会带来两种问题：一是广播占用了总线流量，当的确需要从内存中读取值时便会造成总线上的延迟；二是每次修改变量是会造成其他处理器的 cache 缺失，即其他自旋的线程每次都会遇到 cache 不命中的情况，便需要通过总线获取新的值。同时，当持有锁的线程尝试释放锁时，因为总线拥挤而不得不被迫延迟，这样的多米诺骨牌效应只会导致效率越来越低。 总结来说，TAS 锁存在着大量的总线占用，每个线程每一次自旋都会产生大量的总线流量，从而使得其他线程也必须延迟，最终造成了系统的效率急剧降低。 而 TTAS 锁中，当线程 A 持有锁时，线程 B 第一次读锁时会发生 cache 缺失，但是只要线程 A 持有锁，线程 B 便只要不断读取值，这样每次 cache 都将命中，不产生总线流量，也不会影响其他线程对总线的使用。 当然当持有锁的线程释放锁时，会导致所有正在自旋的线程的 cache 失效，从而导致大量总线流量，但是短暂过后所有线程将归于平静，又将回到本地自旋的状态。 四、指数后退锁我们现在考虑如何改进 TTAS 锁的算法，这里先引出一个术语：争用，争用的意思是多个线程试图同时获得一个锁。在上面的 TTAS 锁中，在两个 while 循环之间可能会产生高争用现象，此时线程获得锁的几率非常小，并且还会带来极高的总线流量。我们可以考虑将某些线程推迟一段时间再去尝试获得锁，这样同时申请锁的线程将减少，实际证明这样的效果行之有效。 那么应该将线程退后多长时间呢？了解过计算机网络中 CSMA&#x2F;CD（载波监听多路访问&#x2F;碰撞检测）中的二进制指数退避应该很容易想到，这里的指数后退与其相似。线程随机在 (0, limit) 中后退一段时间，若还未获得锁，那么将 limit 加倍，再次重新在 (0, limit) 获取一个随机值进行后退，直到 limit 到达一个设定的最大值 maxDelay。下面是代码实现。 Backoff.java: 1234567891011121314151617181920212223public class Backoff &#123; int minDelay, maxDelay; // 限定最大和最小时延，避免无意义的过小的后退以及无限制后退 int limit; // 当前的时延限制 Random random = null; public Backoff(int min, int max) &#123; minDelay = min; maxDelay = max; limit = min; random = new Random(); &#125; // 在 0 和 limit 之间随机选取一个值进行退避，然后倍乘 limit，但是不能超过 maxDelay public void backoff() &#123; int delay = random.nextInt(limit); limit = Math.max(maxDelay, limit * 2); try &#123; Thread.sleep(delay); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; BackoffLock.java: 1234567891011121314151617181920212223public class BackoffLock &#123; AtomicBoolean state = new AtomicBoolean(false); private static final int minDelay = 10; private static final int maxDelay = 1000; public void lock() &#123; Backoff backoff = new Backoff(minDelay, maxDelay); while (true) &#123; while (state.get()) &#123;&#125;; if (!state.getAndSet(true)) &#123; return; &#125; else &#123; backoff.backoff(); &#125; &#125; &#125; public void unlock() &#123; state.set(false); &#125;&#125; 对于 BackoffLock 的性能，与 minDelay 和 maxDelay 的值的选取密切相关，要根据实际任务及自身处理器及架构的情况合理设置阈值。 五、队列锁5.0 队列锁的介绍队列锁是一种易于扩展的自旋锁，尽管稍微复杂一点 (亿点)，但是具有更好的移植性。 在指数后退锁中，存在两个问题。 一是所有线程获得锁都依赖于同一个变量 state，因此每个线程都在同一个共享存储单元上自旋，每一次成功的锁访问都会带来 cache 一致性流量（尽管相比之下比 TASLock 低）； 二是临界区利用率低，因为很多线程被“后退”了，因此延迟带来的开销是无法忽略的。 可以将这些线程组织成一个链表（队列）来解决这些问题，在队列中，每个线程只要检测前一个线程是否已经完成来判断自己能否成功获取锁，这样每个线程就在不同存储单元上自旋了，也不会有延迟带来的开销。 下面介绍三种队列锁，基于数组的队列锁，CLH 队列锁和 MCS 队列锁。 5.1 基于数组的队列锁基于数组的队列锁 ALock，其有一个 tail 字段，初始值为 0，它被所有的线程共享，用来表示数组的下标。每个线程原子地增加 tail 字段的值，每个线程还有一个局部变量用来保存这个当前的 tail 值，称为 slot（槽）。如果 flag[j] 为 true，那么表示下标为 j 的线程有权获得锁。 初始状态时，flag 数组只有下标为 0 的那个值为 true，其他均为 false。其他线程调用 lock() 方法尝试获得锁时，会不断地在 flag[slot] 上旋转，直到 flag[slot] == true。在释放锁时，线程将对应于它自己的槽点 flag 设为 false，然后将下一个槽的 slot 设为 true。上述所有操作都要对 n 取模，n 的大小至少为最大的并发线程数。 下面用具体例子来说明基于数组的队列锁。 上图的 a) 中，当前获得锁的线程是 A，flag[2] == true，线程 B 和 C 也尝试获得锁，线程 B 和 C 在 flag[3] 和 flag[4] 上自旋等待。当线程 A 释放锁后，flag[2] 设置为 false，flag[3] 设置为 true，线程 B 获得锁。 ALock.java： 12345678910111213141516171819202122232425262728293031323334public class ALock &#123; // mySLotIndex 是线程的局部变量，线程局部变量无需保存在共享存储器中，无需同步，不产生一致性流量 ThreadLocal&lt;Integer&gt; mySlotIndex = new ThreadLocal&lt;&gt;() &#123; protected Integer initialValue() &#123; return 0; &#125; &#125;; AtomicInteger tail; volatile boolean[] flag; private int size; public ALock(int capacity) &#123; size = capacity; tail = new AtomicInteger(0); flag = new boolean[capacity]; // 为了避免假共享现象，可以将数组开大，让每一个项独占一个 cache 行 // flag = new boolean[capacity * 4]; flag[0] = true; &#125; public void lock() &#123; int slot = tail.getAndIncrement() % size; mySlotIndex.set(slot); while (!flag[slot]) &#123;&#125;; // 当前域为 false 则表明锁被占用，陷入空转等待 &#125; public void unlock() &#123; int slot = mySlotIndex.get(); flag[slot] = false; flag[(slot + 1) % size] = true; &#125;&#125; 在基于数组的队列锁中，mySlotIndex 是线程的局部变量，局部变量不需要与其他线程共享，不需要同步，也就不会产生一致性流量，因为它只能被一个线程访问。尽管 flag 数组是被多个线程共享的，但是在任意特定的时刻，线程对应的 flag 存储单元会被存放在对应的 cache 中，线程是在本地 cache 中旋转，大大降低了无效流量，从而使得对数组的存储单元的争用大大降低。 但是值得注意的是，争用仍然可能发生，因为存在一种“假共享”现象，当相邻的数组元素在同一个 cache 行时，就会发生这样的现象。继续看上面的图 a)，假设一个 cache 行能够存放 4 个数组元素，那么 flag[0] ~ flag[3] 都将存放在同一个 cache 行中。当某一个线程对 cache 行执行写操作时，会导致当前 cache 行无效，从而导致其他在该 cache 旋转的线程产生无效流量。 一种解决办法就是上图中的 b)，于是我们将数组进行填，充让一个 cache 行只存放一个数组元素，具体实现上只需要将 (i + 1) % 8 改成 4 * (i + 1) % 32 即可。 5.2 CLH 队列锁5.3 MCS 队列锁","categories":[{"name":"计算机原理知识","slug":"计算机原理知识","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Java/"},{"name":"并发多核","slug":"并发多核","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%B9%B6%E5%8F%91%E5%A4%9A%E6%A0%B8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Rust中Clap库的使用","slug":"Rust中Clap库的使用","date":"2022-10-26T13:32:39.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"8ce3ab1f.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/8ce3ab1f.html","excerpt":"Clap 库的使用 Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。","text":"Clap 库的使用 Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。 一、版权及说明该文参考了 Rust 语言中文社区的 每周一库，同时参考了官方 crate 以及 clap 官方文档 的用例及介绍 对于命令行解析使用最多的库，可以在 crates.io 首页搜索关键词 Command Line，下载量最多的库便是 clap 二、关于命令行解析三、clap 用于解析并验证用户在运行命令行程序时提供的命令行参数字符串。 你所需要做的只是提供有效参数的列表，clap 会自动处理其余的繁杂工作。 这样工程师可以把时间和精力放在实现程序功能上，而不是参数的解析和验证上。 当 clap 解析了用户提供的参数字符串，它就会返回匹配项以及任何适用的值。 如果用户输入了错误或错字，clap 会通知他们错误并退出（或返回 Result 类型，并允许您在退出前执行任何清理操作）。这样，工程师可以在代码中对参数的有效性做出合理的假设。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"},{"name":"lib","slug":"lib","permalink":"https://cherryyang05.github.io/hexo-blog/tags/lib/"}]},{"title":"Rust入门教程（十六）：最后的项目","slug":"Rust入门教程（十六）","date":"2022-09-29T14:55:08.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"9e622d63.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/9e622d63.html","excerpt":"前言","text":"前言 一、单线程 Web 服务器1.1 构建单线程 Web 服务器 在 socket 上监听 TCP 连接 解析少量的 HTTP 请求 创建一个合适的HTTP响应 使用线程池改进服务器的吞吐量 注意：并不是最佳实践 直接放代码： 123456789101112131415161718192021use std::&#123;net::&#123;TcpListener, TcpStream&#125;, io::&#123;Read, Write&#125;&#125;;fn main() &#123; let listener = TcpListener::bind(&quot;127.0.0.1:9999&quot;).unwrap(); for stream in listener.incoming() &#123; let stream = stream.unwrap(); handle_connection(stream); &#125;&#125;fn handle_connection(mut stream: TcpStream) &#123; let mut buffer = [0; 512]; stream.read(&amp;mut buffer).unwrap(); println!(&quot;Request: &#123;&#125;\\n&quot;, String::from_utf8_lossy(&amp;buffer)); let contents = std::fs::read_to_string(&quot;hello.html&quot;).unwrap(); let response = format!(&quot;HTTP/1.1 200 OK\\r\\nContent-Length:&#123;&#125;\\r\\n\\r\\n&#123;&#125;&quot;, contents.len(), contents); println!(&quot;&#123;&#125;&quot;, response); stream.write(response.as_bytes()).unwrap(); stream.flush().unwrap();&#125; 这里 TcpListener::bind() 方法表示监听所绑定的 IP 及端口，返回一个 Result 枚举，incoming 方法能够将所监听到的流转化成一个个迭代器，然后一依次处理这些流。 在 handle_connection() 函数中，先构造了一个 buffer 用于存放每个流请求的具体内容（请求头），然后写了一个 hello.html 页面，构造一个响应头同时写回请求的流中。在 response 字段中，要注意添加 Content-Length:&#123;&#125;，这样执行该程序，在浏览器中访问 127.0.0.1:9999，便可以返回刚刚写的页面。 控制台输出如下： 1234567891011121314151617181920212223242526272829303132➜ mweb git:(master) ✗ cargo run Compiling mweb v0.1.0 (/Users/cherry/Code/Rust/learning/mweb) Finished dev [unoptimized + debuginfo] target(s) in 0.14s Running `target/debug/mweb`Request: GET / HTTP/1.1Host: 127.0.0.1:9999Connection: keep-aliveCache-Control: max-age=0sec-ch-ua: &quot;Google Chrome&quot;;v=&quot;105&quot;, &quot;Not)A;Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;105&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;macOS&quot;Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=HTTP/1.1 200 OKContent-Length:170&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;p&gt;Hi From Rust&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 浏览器显示的页面如下： 下面我们新建一个 404 页面，用于处理访问其他页面时显示的结果，我们主要修改 handle_connection() 函数： 1234567891011121314151617181920212223242526272829fn handle_connection(mut stream: TcpStream) &#123; let mut buffer = [0; 512]; stream.read(&amp;mut buffer).unwrap(); // println!(&quot;Request: &#123;&#125;\\n&quot;, String::from_utf8_lossy(&amp;buffer)); let get = b&quot;GET / HTTP/1.1\\r\\n&quot;; let mut response = String::from(&quot;&quot;); if buffer.starts_with(get) &#123; let contents = std::fs::read_to_string(&quot;hello.html&quot;).unwrap(); response = format!( &quot;HTTP/1.1 200 OK\\r\\nContent-Length:&#123;&#125;\\r\\n\\r\\n&#123;&#125;&quot;, contents.len(), contents ); // println!(&quot;&#123;&#125;&quot;, response); &#125; else &#123; let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;; let contents = fs::read_to_string(&quot;404.html&quot;).unwrap(); response = format!( &quot;&#123;&#125;\\r\\nContent-Length:&#123;&#125;\\r\\n\\r\\n&#123;&#125;&quot;, status_line, contents.len(), contents ); // println!(&quot;&#123;&#125;&quot;, response); &#125; stream.write(response.as_bytes()).unwrap(); stream.flush().unwrap();&#125; 首先判断请求头是不是以 GET / HTTP/1.1\\r\\n 开头，这表明我们请求的是根目录的资源，这里 let get = b&quot;GET / HTTP/1.1\\r\\n&quot;; 的 b 表示字节字符串，可以将字符串转化成字节，这样就可以用 start_with() 方法进行比较。 在浏览器中访问一个非根目录的资源，控制台输出如下： 1234567891011121314151617181920212223242526272829303132➜ mweb git:(master) ✗ cargo run Compiling mweb v0.1.0 (/Users/cherry/Code/Rust/learning/mweb) Finished dev [unoptimized + debuginfo] target(s) in 0.32s Running `target/debug/mweb`Request: GET /undefined HTTP/1.1Host: 127.0.0.1:9999Connection: keep-alivesec-ch-ua: &quot;Google Chrome&quot;;v=&quot;105&quot;, &quot;Not)A;Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;105&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;macOS&quot;Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-FetHTTP/1.1 404 NOT FOUNDContent-Length:201&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Oops!&lt;/h1&gt; &lt;p&gt;Sorry,I don&#x27;t know what you&#x27; re asking for. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 浏览器页面如下： 重构一下 handle_connection() 函数，用元组来重构： 123456789101112131415161718192021222324fn handle_connection(mut stream: TcpStream) &#123; let mut buffer = [0; 512]; stream.read(&amp;mut buffer).unwrap(); // println!(&quot;Request: &#123;&#125;\\n&quot;, String::from_utf8_lossy(&amp;buffer)); let get = b&quot;GET / HTTP/1.1\\r\\n&quot;; let (status_line, file_name) = if buffer.starts_with(get) &#123; (&quot;HTTP/1.1 200 OK\\r\\n&quot;, &quot;hello.html&quot;) &#125; else &#123; (&quot;HTTP/1.1 404 NOT FOUND\\r\\n&quot;, &quot;404.html&quot;) &#125;; let contents = std::fs::read_to_string(file_name).unwrap(); let response = format!( &quot;&#123;&#125;Content-Length:&#123;&#125;\\r\\n\\r\\n&#123;&#125;&quot;, status_line, contents.len(), contents ); println!(&quot;&#123;&#125;&quot;, response); stream.write(response.as_bytes()).unwrap(); stream.flush().unwrap();&#125; 二、多线程 Web 服务器2.1 阻塞的场景当前我们对于流的处理都是单线程，一旦有某个请求耗费的时间长了，那么其他请求就必须被阻塞等待。我们构造下面这样的场景：当访问 sleep 页面的时候，线程睡眠 5 秒钟再执行处理，运行程序后访问其他页面可以正常被处理，当访问 sleep 页面的时候会卡住 5 秒钟，这时访问其他页面就需要等待这 5 秒钟结束。 12345678910let sleep = b&quot;GET /sleep HTTP/1.1\\r\\n&quot;;let (status_line, file_name) = if buffer.starts_with(get) &#123; (&quot;HTTP/1.1 200 OK\\r\\n&quot;, &quot;hello.html&quot;)&#125; else if buffer.starts_with(sleep) &#123; thread::sleep(Duration::from_secs(5)); (&quot;HTTP/1.1 200 OK\\r\\n&quot;, &quot;hello.html&quot;)&#125; else &#123; (&quot;HTTP/1.1 404 NOT FOUND\\r\\n&quot;, &quot;404.html&quot;)&#125;; 在代码中增加了对 sleep 页面的访问，运行效果与预期一致。 我们用线程池来解决这一问题。 2.2 线程池线程池是一组预先被分配的线程，他们用于等待并随时处理可能的任务。线程池可以实现并发处理请求，当前线程执行完之后，将其放回线程池。首先考虑到使用 thread::spawn() 为每个请求创建线程： 123thread::spawn(||&#123; handle_connection(stream);&#125;); 但是这样显然会导致一个问题：当有黑客对服务器进行洪泛攻击时，服务器的资源将会很快被耗尽，因此我们还需要对线程数量进行限制。 在该项目中，采用编译器驱动开发的方式（笑），先将可能用到的结构体或方法等先写好，再逐步完善，修改 main 如下： 1234567891011fn main() &#123; let listener = TcpListener::bind(&quot;127.0.0.1:9999&quot;).unwrap(); let pool = ThreadPool::new(4); for stream in listener.incoming() &#123; let stream = stream.unwrap(); pool.execute(|| &#123; handle_connection(stream); &#125;); &#125;&#125; 很明显 ThreadPool 和 execute 是未定义的。 新建 lib.rs，实现未定义的部分： 1234567891011121314pub struct ThreadPool;impl ThreadPool &#123; pub fn new(size: usize) -&gt; ThreadPool &#123; ThreadPool &#125; pub fn execute&lt;F&gt;(&amp;self, f: F) where F: FnOnce() + Send + &#x27;static, &#123; &#125;&#125; 对于 execute 方法，我们参考 thread::spawn()，后者实现了 FnOnce() + Send + &#39;static。 然后我们给结构体 ThreadPool 添加一个字段 threads。 123pub struct ThreadPool &#123; threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,&#125; 这个是怎么来的呢，我们看 spawn 的实现： 12345678pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;where F: FnOnce() -&gt; T, F: Send + &#x27;static, T: Send + &#x27;static,&#123; Builder::new().spawn(f).expect(&quot;failed to spawn thread&quot;)&#125; 它返回的是 JoinHandle，其中有一个范型 T，这个 T 就是传进去的闭包的返回值，但是我们实现的方法闭包没有返回值，因此返回单元类型 () 即可。 再次修改 new() 函数： 12345678910pub fn new(size: usize) -&gt; ThreadPool &#123; assert!(size &gt; 0); let mut threads = Vec::with_capacity(size); // 创建线程并存储到 vec 中 for _ in 0..size &#123; todo!() &#125; ThreadPool &#123;threads&#125;&#125; 我们再看spawn 的实现，他会创建一个线程，立即执行接收到的代码。但是我们希望线程创建之后进入等待状态，当有代码传给他们的时候再执行线程。这里我们创建一个新的结构体，叫 Worker，用来管理和实现上述所说的行为。 实现 Worker 相关结构体和函数： 1234567891011pub struct Worker &#123; id: usize, thread: thread::JoinHandle&lt;()&gt;,&#125;impl Worker &#123; fn new(id: usize) -&gt; Worker &#123; let thread = thread::spawn(|| &#123;&#125;); Worker &#123;id, thread&#125; &#125;&#125; 同时将 ThreadPool 中的字段名改成 workers，更改 ThreadPool 的 new() 函数。 12345678910pub fn new(size: usize) -&gt; ThreadPool &#123; assert!(size &gt; 0); let mut workers = Vec::with_capacity(size); // 创建线程并存储到 vec 中 for id in 0..size &#123; workers.push(Worker::new(id)); &#125; ThreadPool &#123;workers&#125;&#125; 目前为止，lib.rs 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445use std::thread;pub struct ThreadPool &#123; workers: Vec&lt;Worker&gt;,&#125;impl ThreadPool &#123; /// 创建一个线程池 /// /// size 表示线程池中线程数量 /// /// # Panics /// /// Panic: size is zero pub fn new(size: usize) -&gt; ThreadPool &#123; assert!(size &gt; 0); let mut workers = Vec::with_capacity(size); // 创建线程并存储到 vec 中 for id in 0..size &#123; workers.push(Worker::new(id)); &#125; ThreadPool &#123;workers&#125; &#125; pub fn execute&lt;F&gt;(&amp;self, f: F) where F: FnOnce() + Send + &#x27;static, &#123; &#125;&#125;pub struct Worker &#123; id: usize, thread: thread::JoinHandle&lt;()&gt;,&#125;impl Worker &#123; fn new(id: usize) -&gt; Worker &#123; let thread = thread::spawn(|| &#123;&#125;); Worker &#123;id, thread&#125; &#125;&#125; 2.3 使用通道下面我们需要考虑如何让 Worker 从线程池中接收任务并执行任务，这里就要使用到通道。 在 ThreadPool 中添加一个字段 sender，表示通道的发送端。线程池持有通道的发送端，而接收者应该是 worker。在通道中，可以有多个发送者，但是只能有一个接收者，我们希望所有线程共享同一个 receiver，从而能够在线程间分发任务。同时从通道队列中取出 receiver 也意味着这是可变的。我们可以用 “智能指针” 那一小节中的 Arc 和 Mutex 来实现线程间多所有权的可变引用。 123456789101112pub fn new(size: usize) -&gt; ThreadPool &#123; assert!(size &gt; 0); let mut workers = Vec::with_capacity(size); let (sender, receiver) = mpsc::channel(); let receiver = Arc::new(Mutex::new(receiver)); // 创建线程并存储到 vec 中 for id in 0..size &#123; workers.push(Worker::new(id, Arc::clone(&amp;receiver))); &#125; ThreadPool &#123;workers, sender&#125;&#125; 同时修改 Worker 结构体的 new 的函数签名： 1fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;&#125; 2.4 实现 execute 方法新建一个 job，然后通过通道的发送端将 job 发送出去，接收端 worker 的 new 函数接收该 job。 1234567891011121314151617pub fn execute&lt;F&gt;(&amp;self, f: F)where F: FnOnce() + Send + &#x27;static,&#123; let job = Box::new(f); self.sender.send(job).unwrap();&#125;fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123; let thread = thread::spawn(move || &#123; let job = receiver.lock().unwrap().recv().unwrap(); println!(&quot;Worker &#123;&#125; get a job; executing&quot;, id); (*job)(); &#125;); Worker &#123;id, thread&#125;&#125; 我们知道 job 是一个 Box 类型，那么实现 FnOnce() 的闭包要想调用就要先将其从 Box 取出来，但是 Rust 不允许这样做，因为不知道 Box 中的类型具体有多大。FnOnce() 中有一个 call_once() 方法，其中的参数便是 self，为了获得其所有权，但是现在不允许。我们可以将 self 改成 Box&lt;Self&gt;，这样方法就可以在类型的 Box 上来调用。 然后为实现了 FnOnce() 的类型实现 FnBox，self 的类型就是 Box&lt;F&gt;，而 F 就是实现了 FnOnce() 的类型，这样就可以获得 Box 里的所有权，再进行闭包调用，同时更改 Job 的类型。 1234567891011trait FnBox &#123; fn call_box(self: Box&lt;Self&gt;);&#125;impl&lt;F: FnOnce()&gt; FnBox for F &#123; fn call_box(self: Box&lt;Self&gt;) &#123; (*self)() &#125;&#125;type Job = Box&lt;dyn FnBox + Send + &#x27;static&gt;; 最后在 Worker 的 new 函数中加入 loop，使得释放锁后还能继续使用该线程。 最终 lib.rs 文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768use std::&#123;thread, sync::&#123;mpsc, Arc, Mutex&#125;&#125;;pub struct ThreadPool &#123; workers: Vec&lt;Worker&gt;, sender: mpsc::Sender&lt;Job&gt;,&#125;// pub struct Job &#123;&#125;impl ThreadPool &#123; /// 创建一个线程池 /// /// size 表示线程池中线程数量 /// /// # Panics /// /// Panic: size is zero pub fn new(size: usize) -&gt; ThreadPool &#123; assert!(size &gt; 0); let mut workers = Vec::with_capacity(size); let (sender, receiver) = mpsc::channel(); let receiver = Arc::new(Mutex::new(receiver)); // 创建线程并存储到 vec 中 for id in 0..size &#123; workers.push(Worker::new(id, Arc::clone(&amp;receiver))); &#125; ThreadPool &#123;workers, sender&#125; &#125; pub fn execute&lt;F&gt;(&amp;self, f: F) where F: FnOnce() + Send + &#x27;static, &#123; let job = Box::new(f); self.sender.send(job).unwrap(); &#125;&#125;pub struct Worker &#123; id: usize, thread: thread::JoinHandle&lt;()&gt;,&#125;trait FnBox &#123; fn call_box(self: Box&lt;Self&gt;);&#125;impl&lt;F: FnOnce()&gt; FnBox for F &#123; fn call_box(self: Box&lt;Self&gt;) &#123; (*self)() &#125;&#125;type Job = Box&lt;dyn FnBox + Send + &#x27;static&gt;;impl Worker &#123; fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123; let thread = thread::spawn(move || loop &#123; let job = receiver.lock().unwrap().recv().unwrap(); println!(&quot;Worker &#123;&#125; get a job; executing&quot;, id); job.call_box(); &#125;); Worker &#123;id, thread&#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（十三）：智能指针","slug":"Rust入门教程（十三）","date":"2022-07-08T08:50:48.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"e9389bfa.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/e9389bfa.html","excerpt":"指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 &amp; 了，没有其他开销。智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。","text":"指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 &amp; 了，没有其他开销。智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。 一、智能指针介绍引用和智能指针的区别 智能指针往往基于结构体实现 引用只借用数据，而智能指针很多时候拥有其指向的数据 智能指针的例子 String 和 Vec&lt;T&gt; 都拥有一片内存区域，且允许用户对其操作 还拥有元数据（例如容量等） 提供额外的功能保障（String 保证其是合法的 UTF-8 数据） 智能指针的实现 智能指针通常使用 struct 实现，并且实现了 Deref 和 Drop 这两个 trait Deref trait：允许智能指针 struct 的实例像引用一样使用 Drop trait：允许你自定义当智能指针实例走出作用域时的代码 本章内容 介绍标准库中常见的智能指针 Box&lt;T&gt;：在 heap内存上分配值 Rc&lt;T&gt;：启用多重所有权的引用计数类型 Ref&lt;T&gt; 和 RefMut&lt;T&gt;，通过 RefCelk&lt;T&gt; 访问：在运行时而不是编译时强制借用规则的类型 此外 内部可变模式（interior mutability pattern）：不可变类型暴露出可修改其内部值的 API 引用循环（reference cycles）：它们如何泄露内存，以及如何防止其发生 二、使用 Box&lt;T&gt;2.1 Box&lt;T&gt;Box&lt;T&gt; 是最简单的智能指针 允许你在 heap 上存储数据（而不是 stack） stack 上是指向 heap 数据的指针 没有性能开销 没有其它额外功能 实现了 Deref trait 和 Drop trait 2.2 使用场景 在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小 当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制 使用某个值时，你只关心它是否实现了特定的 trait，而不关心它的具体类型 2.2.1 Box&lt;T&gt; 如何在 heap 上存储数据来看一段简单的代码： 1234fn main() &#123; let x = Box::new(5); println!(&quot;x = &#123;&#125;&quot;, 5);&#125; 如果不用 Box，那么就会在栈中创建一个变量 x，而使用了 Box 就会在 heap 上创建一个变量。在变量 x 走出作用域时，变量 x 在 stack 上的指针和在 heap 上的值都会被释放。 2.2.2 使用 Box 赋能递归类型比如有这样一个枚举 1234pub enum List &#123; Cons(i32, List), Nil,&#125; 对于 Cons 变体，里面有一个他类型本身（List），这样就会一直递归下去。但是在编译时，Rust 需要知道一个类型所占的空间大小，而这样的递归类型无法确定其大小。在递归类型中使用 Box 就可以解决上述问题。这也是函数式语言中的 Cons List 关于 Cons List Cons List 是来自 Lisp 语言的一种数据结构。Cons List里每个成员由两个元素组成： 当前项的值 下一个元素 Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素。实际上就是 Rust 中的一种链表，但他并不是 Rust 的常用集合。 Rust 如何确定非递归类型所占用的大小的？ 实际上是取结构体或枚举下最大空间的变体的大小作为整个结构体或枚举的大小（非常类似于 C 语言中的联合体 Union）。 因此最终应将代码改成 123456789101112use List::&#123;Cons, Nil&#125;;fn main() &#123; let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));&#125;enum List &#123; Cons(i32, Box&lt;List&gt;), Nil&#125; 使用 Box 来获得确定大小的递归类型 Box&lt;T&gt; 是一个指针，Rust 知道它需要多少空间，因为 指针的大小不会基于它指向的数据的大小变化而变化 Box: 只提供了“间接”存储和 heap 内存分配的功能 没有其它额外功能 没有性能开销 适用于需要“间接”存储的场景，例如 Cons List 实现了 Deref trait 和 Drop trait Deref trait：可以将 Box 的值当做引用来处理 Drop trait：定义了当 Box 值走出作用域时，清理掉栈上的指针和堆上的数据 三、Deref traitDeref 就是 dereference 解引用的意思。 实现 Deref Trait 使我们可以自定义解引用运算符 * 的行为 通过实现 Deref，智能指针可像常规引用一样来处理 3.1 解引用运算符常规引用也是指针。 123456fn test01() &#123; let x = 3; let y = &amp;x; assert_eq!(x, 3); assert_eq!(*y, 3);&#125; 这里没有什么好解释的，和 C 语言一样，*y 表示解引用变量 y。 3.2 定义自己的智能指针Box&lt;T&gt; 被定义成拥有一个元素的 tuple struct。下面来定义自己的 MyBox&lt;T&gt;。 1234567891011121314struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; &#123; fn new(x: T) -&gt; Self &#123; MyBox(x) &#125;&#125;fn main() &#123; let x = 5; let y = MyBox::new(x); assert_eq!(5, x); assert_eq!(5, *y);&#125; 先来看定义，MyBox&lt;T&gt; 实际上就是一个有名称的元组（tuple），这个元组里只有一个元素。 再看第二个断言，这里的 *y 会报错 type &#39;MyBox&lt;&#123;integer&#125;&gt;&#39; cannot be dereferenced，表示 MyBox 类型不能被解引用，这是因为 MyBox 没有实现 Deref trait。 标准库中的 Deref trait 要求我们实现一个 deref 方法 该方法借用 self 返回一个指向内部数据的引用 因此我们为 MyBox 实现 Deref。 12345678use std::ops::Deref;...impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123; type Target = T; fn deref(&amp;self) -&gt; &amp;T &#123; &amp;self.0 &#125;&#125; 这里 type Target = T; 类似于 C 语言中的 typedef struct Person &#123;&#125; P？ 而 *y 实际上是 *(y.deref())，调用 * 之前，先执行 deref 取引用，然后通过 * 运算符解引用。 3.3 隐式解引用转化 隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性。 假设 T 实现了 Deref trait： Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用 当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配 Deref Coercion 就会自动发生 编译器会对 deref 进行一系列调用，来把它转为所需的参数类型 在编译时完成，没有额外性能开销 在上面实现 MyBox 和 Deref 的前提下，增加以下代码： 12345678fn hello(s: &amp;str) &#123; println!(&quot;Hello, &#123;&#125;&quot;, s);&#125;fn main() &#123; let m = MyBox::new(String::from(&quot;Cherry&quot;)); hello(&amp;m);&#125; 我们主要分析 hello 函数中传入的参数类型，是一个字符串切片类型，而 m 是一个实现了 Deref 的结构体类型，但是为什么能传入 &amp;m 呢？ 首先 m 的类型是 MyBox&lt;String&gt;，那么 &amp;m 的类型就是 &amp;MyBox&lt;String&gt;，由于 MyBox 实现了 Deref 方法，因此 Rust 可以调用 deref() 方法，来将 MyBox&lt;String&gt; 的引用转化成 String 的引用。然而在标准库中，String 也实现了 Deref 这个 trait，它返回的是一个字符串切片 &amp;str，因此 Rust 会继续调用 deref()，最终返回一个字符串切片的类型。 而如果 Rust 没有解引用转化功能，则参数应该这样传：hello(&amp;(*m)[..]);，而这却相当繁琐。只要类型实现了 Deref 这个 trait，Rust 就会自动分析类型，并不断尝试调用 deref() 方法来让其与函数或方法签名中的参数类型匹配，而这一切都在编译时执行，因此运行时不会产生额外的性能开销。 解引用与可变性 可使用 DerefMut trait 重载可变引用的 * 运算符 在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion 当 T: Deref&lt;Target=U&gt;，允许 &amp;T 转换为 &amp;U（即类型 T 实现了 Deref trait，而 deref 方法返回的类型是 U，那么 T 的引用可以转化为 U 的引用） 当 T: DerefMut&lt;Target=U&gt;，允许 &amp;mut T 转换为 &amp;mut U 当 T: Deref&lt;Target=U&gt;，允许 &amp;mut T 转换为 &amp;U（反过来不成立，即不能将不可变引用转化为可变引用，违反借用规则） 四、Drop trait 实现 Drop trait，可以让我们自定义当值将要离开作用域的时候发生的动作 例如文件、网络资源的释放等 任何类型都可以实现 Drop trait Drop trait 只要求实现 drop 方法，其参数是对 self 的可变引用 Drop trait 在预导入模块中，无需手动导入 （个人理解：和 C++ 中的析构函数有点类似） 123456789101112131415struct CustomSmartPointer &#123; data: String&#125;impl Drop for CustomSmartPointer &#123; fn drop(&amp;mut self) &#123; println!(&quot;Dropping CustomSmartPointer with data `&#123;&#125;`&quot;, self.data); &#125;&#125;fn test03() &#123; let s1 = CustomSmartPointer &#123;data: String::from(&quot;Rust&quot;)&#125;; let s2 = CustomSmartPointer &#123;data: String::from(&quot;vscode&quot;)&#125;; println!(&quot;CustomSmartPointer created!&quot;);&#125; 输出结果为如下，注意输出顺序（变量声明顺序为 s1，s2，Drop 顺序为 s2，s1） 1234567➜ ~/code/rust/my_box git:(master) ✗ cargo run Compiling my_box v0.1.0 (/home/cherry/code/rust/my_box) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/my_box`CustomSmartPointer created!Dropping CustomSmartPointer with data `vscode`Dropping CustomSmartPointer with data `Rust` 使用 std::mem::drop 来提前 drop 值 很难直接禁用自动的 drop 功能，也没必要 Drop trait 的目的就是进行自动的释放处理逻辑 Rust 不允许手动调用 Drop trait 的 drop 方法 若要强行使用 a.drop() 这样来调用，会提示 explicit destructor calls not allowed，然后后面给的帮助是考虑使用 drop(a) 但可以调用标准库中的 std::mem::drop 函数提前 drop 值 我们手动 drop 一下： 123456fn test03() &#123; let s1 = CustomSmartPointer &#123;data: String::from(&quot;Rust&quot;)&#125;; drop(s1); let s2 = CustomSmartPointer &#123;data: String::from(&quot;vscode&quot;)&#125;; println!(&quot;CustomSmartPointer created!&quot;);&#125; 输出结果为： 1234567➜ ~/code/rust/my_box git:(master) ✗ cargo run Compiling my_box v0.1.0 (/home/cherry/code/rust/my_box) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/my_box`Dropping CustomSmartPointer with data `Rust`CustomSmartPointer created!Dropping CustomSmartPointer with data `vscode` 尽管手动调用了 drop 函数，但是和 drop 方法并不会冲突，不会重复释放同一块内存，设计 Rust 语言的时候显然已经考虑到了这一点。 五、Rc&lt;T&gt;：引用计数智能指针通常情况下，Rust 的所有权都是很清晰的，但是在某些场景中，单个值可能同时被多个所有者持有。例如一个图的数据结构，一个结点有多条边相连，那么这个结点就应该属于所有与其相连的边，只有当所有指向它的边都释放掉，该结点才会被清理，这就是多重所有权。 在 Rust 中，为了支持多重所有权，便有了 Rc&lt;T&gt;，即 reference count（引用计数），这个类型会在实例的内部维护一个用于记录引用次数的计数器，从而判断该值是否仍然被使用，可以追踪所有对其的引用。若引用个数为 0，那么该值就会被清理掉，不会发生引用失效的问题。 5.1 使用场景及实例 需要在 heap 上分配数据，这写数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据 若在编译时能够确定哪个部分最后使用完这些数据，那么直接将这个部分程序成为这些数据的所有者即可，这样就只需要靠编译时期所有权规则，就可以保证程序的正确性 Rc&lt;T&gt; 只能用于单线程场景，后面会介绍如何在多线程场景中使用引用计数 Rc&lt;T&gt; 不在预导入模块中，需要手动导入 use sstd::rc::Rc Rc::clone(&amp;a) 函数：增加引用计数 Rc::strong_count(&amp;a)：获得引用计数 还有 Rc::weak_count函数 例子如下： 要实现两个 List 共享一个 List 的所有权。先看下面的代码： 12345fn test04() &#123; let a = Cons(3, Box::new(Cons(4, Box::new(Cons(5, Box::new(Nil)))))); let b = Cons(1, Box::new(a)); let c = Cons(2, Box::new(a));&#125; 在声明变量 c 处，会报错，提示不能使用被移动的值 use of moved value: &#39;a&#39;。因为在声明 b 时，变量 a 的所有权已经移交给了 b。我们可以改变 Cons 的定义，让其持有 List 的引用而不是所有权，并为其指定声明周期参数，这个生命周期要求 List 中的所有元素的存活时间至少要和 List 本身一样。因此借用检查器会阻止我们编译这样的代码：let a = Cons(1, &amp;Nil)，因为这里 Nil 这个变体值会在 a 取得其引用前就被丢弃。 另一种办法就是将 Box 换成 Rc。如下： 123456789101112131415161718use std::rc::Rc;enum List &#123; Cons(i32, Rc&lt;List&gt;), Nil&#125;fn test04() &#123; let a = Rc::new(Cons(4, Rc::new(Cons(5, Rc::new(Nil))))); println!(&quot;创建 a 后的的强引用计数为 &#123;&#125;&quot;, Rc::strong_count(&amp;a)); let b = Cons(1, Rc::clone(&amp;a)); println!(&quot;创建 b 后的的强引用计数为 &#123;&#125;&quot;, Rc::strong_count(&amp;a)); &#123; let c = Cons(2, Rc::clone(&amp;a)); println!(&quot;创建 c 后的的强引用计数为 &#123;&#125;&quot;, Rc::strong_count(&amp;a)); &#125; println!(&quot;c 离开作用域后的的强引用计数为 &#123;&#125;&quot;, Rc::strong_count(&amp;a));&#125; 最终输出结果为 12345678➜ ~/code/rust/my_box git:(master) ✗ cargo run Compiling my_box v0.1.0 (/home/cherry/code/rust/my_box) Finished dev [unoptimized + debuginfo] target(s) in 0.28s Running `target/debug/my_box`创建 a 后的的强引用计数为 1创建 b 后的的强引用计数为 2创建 c 后的的强引用计数为 3c 离开作用域后的的强引用计数为 2 其实在 Rc&lt;T&gt; 这个类型上也有一个 clone 方法，和 Rc::clone() 的区别是，后者不会对数据进行深拷贝，只会增加引用计数，速度较快。而前者是类型上的 clone 方法，会进行深拷贝，拷贝对象本身，比较耗时。同时 Rc&lt;T&gt; 也实现了 Drop 这个 trait，因此当变量离开作用域时，引用计数会自动减少一。 在 Rc&lt;T&gt; 中，通过不可变引用，使你在程序不同部分之间共享只读数据，若共享的引用可变，将会违反 Rust 的借用规则，即多个指向同一区域的可变引用会导致数据竞争以及数据的不一致。但是在某些情况下，让其共享的数据可变也是非常重要的，这就需要使用 RefCell&lt;T&gt;。 5.2 RefCell&lt;T&gt; 和内部可变性内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改，数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则，使其可变的借用一个不可变的值。 先来回忆一下 Rust 的借用规则：在任何给定的时刻，要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用，且引用总是有效的。 与 Rc&lt;T&gt; 不同，RefCell&lt;T&gt; 类型代表了其持有数据的唯一所有权。而 RefCell&lt;T&gt; 与 Box&lt;T&gt; 的区别是：前者只会在运行时检查借用规则，否则触发 panic；而后者在编译阶段就要强制代码遵守借用规则，否则出现错误，编译不通过。 借用规则在不同阶段进行检查的比较 编译阶段 尽早暴露问题 没有运行时的开销 对大多数场景是最佳选择 是 Rust 的默认行为 运行时 问题暴露延迟，甚至到生产环境 因为借用计数器而导致性能的损失 实现某些特定的内存安全场景（不可变环境中修改自身数据） 实际上 Rust 编译器是比较保守的，有些代码并不是在编译阶段就能分析明白，针对这些代码，Rust 编译器是无法完成分析的，因此编译器就会简单的拒绝所有不符合所有权规则的代码，哪怕这些代码并没有任何问题，这就是 Rust 编译器的保守性。因为一旦 Rust 将某一段有问题的程序通过了，那么 Rust 对安全性的保证将直接破产，尽管拒绝掉某些正确的代码会对开发者带来不便，但是至少不会在生产中带来灾难性的后果。针对 Rust 编译器无法分析的代码，如果开发者能够确保代码能够满足借用规则，这时候就要用到 RefCell&lt;T&gt; 了。 和 Rc&lt;T&gt; 一样 RefCell&lt;T&gt; 只能用于单线程的场景。 Box&lt;T&gt; 同一个数据只有一个所有者 可变和不可变借用，在编译时检查 Rc&lt;T&gt; 同一个数据可以有多个所有者 不可变借用，在编译时检查 RefCell&lt;T&gt; 同一个数据只有一个所有者 可变和不可变借用，在运行时检查 其中，即使 RefCell&lt;T&gt; 本身不可变，但是仍能修改其中存储的值 对于内部可变性，可以可变的借用一个不可变的值。在某些情况下，我们需要一个值，它对外部是不可变的，但能在方法内部修改自身的值，除了这个值本身的方法，其他的方法都不能修改这个值，RefCell&lt;T&gt; 正是获得这种内部可变性的一种方法。但是这种方法并没有完全绕开借用规则，只是通过内部可变性通过了编译检查，但是借用检查也只是从编译阶段延后到运行阶段，如果运行阶段仍然违反了借用规则，那么将会 panic，而不是编译错误。 使用 RefCell&lt;T&gt; 在运行时记录借用信息 RefCell&lt;T&gt; 会记录当前存在多少个活跃的 Ref&lt;T&gt; 和 RefMut&lt;T&gt; 智能指针： 每次调用 borrow：不可变借用计数加1 任何一个 Ref&lt;T&gt; 的值离开作用域被释放时：不可变借用计数减 1 每次调用 borrow_mut：可变借用计数加1 任何一个 RefMut&lt;T&gt; 的值离开作用域被释放时：可变借用计数减 1 以此技术来维护借用检查规则： 任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用 其它可实现内部可变性的类型 Cell&lt;T&gt;：通过复制来访问数据 Mutex&lt;T&gt;：用于实现跨线程情形下的内部可变性模式 六、循环引用导致内存泄露6.1 Rust 可能发生内存泄漏 Rust 的内存安全机制可以保证很难发生内存泄漏，但不是不可能 例如使用 Rc&lt;T&gt; 和 RefCell&lt;T&gt; 就可能创造出循环引用，从而发生内存泄漏： 每个项的引用数量不会变成 0，值也不会被处理掉 例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041use crate::List::&#123;Cons, Nil&#125;;use std::&#123;rc::Rc, cell::RefCell&#125;;#[derive(Debug)]enum List &#123; Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;), Nil&#125;impl List &#123; fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123; match self &#123; Cons(_, item) =&gt; Some(item), Nil =&gt; None, &#125; &#125;&#125;fn main() &#123; test02();&#125;fn test02() &#123; let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil)))); println!(&quot;a initial rc count is &#123;&#125;&quot;, Rc::strong_count(&amp;a)); println!(&quot;a next item is &#123;:?&#125;&quot;, a.tail()); let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a)))); println!(&quot;a rc count after b creation is &#123;&#125;&quot;, Rc::strong_count(&amp;a)); println!(&quot;b initial rc count is &#123;&#125;&quot;, Rc::strong_count(&amp;b)); println!(&quot;b next item is &#123;:?&#125;&quot;, b.tail()); if let Some(link) = a.tail() &#123; *link.borrow_mut() = Rc::clone(&amp;b); &#125; println!(&quot;a rc count after changing a is &#123;&#125;&quot;, Rc::strong_count(&amp;a)); println!(&quot;b rc count after changing a is &#123;&#125;&quot;, Rc::strong_count(&amp;b)); // println!(&quot;a next item is &#123;:?&#125;&quot;, a.tail());&#125; 先创建 a，Cons 第一个元素是 5，第二个元素是 Nil，然后输出 a 的强引用，输出 a 的 Cons 的第二个元素。同理创建 b，Cons 第一个元素是 10，第二个元素引用 a，然后输出此时 a 的强引用和 b 的强引用。 这个时候将 a 的 Cons 第二个元素改成 b 的引用，即这个 List 的 a 和 b 收尾相连了，形成了一个类似于循环链表的结构。这时我们观察输出结果为： 1234567891011➜ smart_pointer git:(master) ✗ cargo run Compiling smart_pointer v0.1.0 (/Users/cherry/Code/Rust/learning/smart_pointer) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/smart_pointer`a initial rc count is 1a next item is Some(RefCell &#123; value: Nil &#125;)a rc count after b creation is 2b initial rc count is 1b next item is Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)a rc count after changing a is 2b rc count after changing a is 2 收尾相连后 a 和 b 的强引用计数都是 2（很显然）。但是这个时候如果要输出 a 的下一个元素，就会发生栈溢出。因为 a 和 b 形成了循环，a 的下一个元素是 b，但是 b 中又包含 a，a 中又包含 b… 如此往复，b 的大小其实是无穷大的，因此会导致栈溢出。取消上面的注释行，再次运行，会得到下面的结果： 1234...RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; thread &#x27;main&#x27; has overflowed its stackfatal runtime error: stack overflow[1] 28287 abort cargo run 6.2 防止内存泄漏的解决办法 依靠开发者来保证，不能依靠 Rust 重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权 循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系 而只有所有权关系才影响值的清理 防止循环引用把 Rc&lt;T&gt; 换成 Weak&lt;T&gt; Rc::clone 为 Rc&lt;T&gt; 实例的 strong_count 加 1，Rc&lt;T&gt; 的实例只有在 strong_count 为 0 的时候才会被清理 Rc&lt;T&gt; 实例通过调用 Rc::downgrade 方法可以创建值的 Weak Reference（弱引用） 返回类型是 Weak&lt;T&gt;（智能指针） 调用 Rc::downgrade 会为 weak_count 加1 Rc&lt;T&gt; 使用 weak_count 来追踪存在多少 Weak&lt;T&gt; weak_count 不为 0 并不影响 Rc&lt;T&gt; 实例的清理 Strong vs Weak Strong Reference（强引用）是关于如何分享 Rc&lt;T&gt; 实例的所有权 Weak Reference（弱引用）并不表达上述意思 使用 Weak Reference 并不会创建循环引用： 当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开 在使用 Weak&lt;T&gt; 前，需保证它指向的值仍然存在： 在 Weak&lt;T&gt; 实例上调用 upgrade 方法，返回 Option&lt;Rc&lt;T&gt;&gt; 6.3 实现树的数据结构的例子1234567891011121314151617#[derive(Debug)]struct Node &#123; value: i32, children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,&#125;fn test03() &#123; let leaf = Rc::new(Node &#123; value: 3, children: RefCell::new(vec![]) &#125;); let branch = Rc::new(Node &#123; value: 5, children: RefCell::new(vec![Rc::clone(&amp;leaf)]) &#125;);&#125; 新建一个叶子结点值为 3，该叶子结点没有孩子结点，再创建一个分支结点，作为叶节点 3 的父节点。此时该叶子结点拥有两个强引用，即叶子结点本身和父节点拥有该叶子结点的所有权。我们可以通过分支结点访问到叶节点，因为他拥有叶节点的引用（这里也是所有权），而叶子结点无法访问到父节点，因为他没有拥有父节点的所有权或引用。 上面这种双向的引用形成了循环引用，这个时候就可以使用 Weak&lt;T&gt; 来避免产生循环引用。 我们修改上面的代码： 123456789101112131415161718192021222324#[derive(Debug)]struct Node &#123; value: i32, parent: RefCell&lt;Weak&lt;Node&gt;&gt;, children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,&#125;fn test03() &#123; let leaf = Rc::new(Node &#123; value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]) &#125;); println!(&quot;leaf parent is &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade()); let branch = Rc::new(Node &#123; value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(&amp;leaf)]) &#125;); *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch); println!(&quot;leaf parent is &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());&#125; 先调用 leaf 的 parent 字段的 borrow 方法获取其不可变引用，然后通过 upgrade 方法将 Weak&lt;T&gt; 转化成 Rc&lt;T&gt;，然后再调用 leaf 的 parent 字段的 borrow_mut 方法获取其可变引用，然后通过调用 Rc::downgrade 将 branch 里的 Rc&lt;Node&gt; 转化成 Weak&lt;Node&gt; 并存在 leaf.parent 里。 输出结果如下： 123456➜ smart_pointer git:(master) ✗ cargo run Compiling smart_pointer v0.1.0 (/Users/cherry/Code/Rust/learning/smart_pointer) Finished dev [unoptimized + debuginfo] target(s) in 0.14s Running `target/debug/smart_pointer`leaf parent is Noneleaf parent is Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;) 我们通过分别打印 leaf 和 branch 的强弱引用来深入理解一下本小节内容： 12345678910111213141516171819202122232425262728293031323334353637383940fn test03() &#123; let leaf = Rc::new(Node &#123; value: 3, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![]), &#125;); println!( &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;leaf), Rc::weak_count(&amp;leaf) ); &#123; let branch = Rc::new(Node &#123; value: 5, parent: RefCell::new(Weak::new()), children: RefCell::new(vec![Rc::clone(&amp;leaf)]), &#125;); *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch); println!( &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;leaf), Rc::weak_count(&amp;leaf) ); println!( &quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;branch), Rc::weak_count(&amp;branch) ); &#125; println!(&quot;leaf parent is &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade()); println!( &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;leaf), Rc::weak_count(&amp;leaf) );&#125; 输出结果如下： 123456789➜ smart_pointer git:(master) ✗ cargo run Compiling smart_pointer v0.1.0 (/Users/cherry/Code/Rust/learning/smart_pointer) Finished dev [unoptimized + debuginfo] target(s) in 0.35s Running `target/debug/smart_pointer`leaf strong = 1, weak = 0leaf strong = 2, weak = 0branch strong = 1, weak = 1leaf parent is Noneleaf strong = 1, weak = 0 刚创建 leaf 时，只有一个 leaf 的强引用，没有弱引用。然后在一个新的作用域内创建 branch，将 branch 和 leaf 关联起来，此时 branch 强引用只有一个（branch 自身），弱引用有一个（leaf）。leaf 强引用有两个，自身和 branch。然后 branch 走出了作用域，强引用计数减 1 变成 0，内存被释放，branch 便不存在了，此时通过 leaf 访问 branch 显然为 None，最后再输出 leaf 的强引用为 1，即 leaf 自身。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（十二）：cargo 和 crates.io","slug":"Rust入门教程（十二）","date":"2022-07-08T08:50:09.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"af9cf945.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/af9cf945.html","excerpt":"本章内容如下： 通过 release profle 来自定义构建 在 https://crates.io/ 上发布库 通过 workspaces 组织大工程 从 https://crates.io/ 来安装库 使用自定义命令扩展 cargo","text":"本章内容如下： 通过 release profle 来自定义构建 在 https://crates.io/ 上发布库 通过 workspaces 组织大工程 从 https://crates.io/ 来安装库 使用自定义命令扩展 cargo 一、通过 release profle 来自定义构建release profile（发布配置） 是预定义的 可自定义：可使用不同的配置，对代码编译拥有更多的控制 每个 profile 的配置都独立于其它的 profile Cargo 主要的两个 profile dev profile：适用于开发，cargo build release profile：适用于发布，cargo build –release 自定义 profile 针对每个 profle，Cargo 都提供了默认的配置 如果想自定义 xxxx profile 的配置 可以在 Cargo.toml 里添加 [profile.xxxx] 区域，在里面覆盖默认配置的子集 例： 1234[profile. dev]opt-level = 0[profile.release]opt-level = 3 opt-level 表示编译优化等级，在开发模式下，一般希望有较快的编译速度，因此编译优化等级较低。而在发布模式下，需要多次运行程序，因此希望有较高等级的优化，从而用较长的编译时间换取较短的运行时间。 对于每个配置的默认值和完整选项，请参见：https://doc.rustlang.ora/cargo/ 二、发布 crate 到 crates.io2.1 crates.io 可以通过发布包来共享你的代码 crate 的注册表在 https://crates.io/ 它会分发己注册的包的源代码 主要托管开源的代码 2.2 文档注释2.2.1 文档注释的使用 文档注释：用于生成文档 生成 HTML 文档 显式公共 API 的文档注释：如何使用 API 使用 /// 支持 Markdown 放置在被说明条目之前 例如： 12345678/// 这个函数是将传入的 u32 类型的值加一，然后返回这个值的所有权/// # 实例/// let a = 3;/// let b = add_one(a);/// assert_eq!(4, b);fn add_one(num: u32) -&gt; u32 &#123; num + 1&#125; 2.2.2 生成 HTML 文档的命令cargo doc 它会运行 rustdoc 工具（Rust 安装包自带） 把生成的 HTML 文档放在 target&#x2F;doc 目录下 cargo doc --open 构建当前 crate 的文档（也包含 crate 依赖项的文档） 在浏览器打开文档 2.2.3 常用章节 ＃ Examples 其它常用的章节 Panics：函数可能发生 panic 的场景 Errors：如果函数返回 Result，描述可能的错误种类，以及可导致错误的条件 Safety：如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提 2.2.4 文档注释作为测试 示例代码块的附加值： 运行 cargo test：将把文档注释中的示例代码作为测试来运行 123456789101112131415161718192021➜ it git:(master) ✗ cargo test Compiling it v0.1.0 (/Users/cherry/Code/Rust/learning/it) Finished test [unoptimized + debuginfo] target(s) in 0.18s Running unittests src/lib.rs (target/debug/deps/it-d31f5191c1eed090)running 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Running unittests src/main.rs (target/debug/deps/it-8c2dc60df354a71a)running 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Doc-tests itrunning 1 testtest src/lib.rs - add_one (line 3) ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.16s 2.2.5 为包含注释的项添加文档注释 符号：//! 这类注释通常用描述 crate 和模块： crate root（按惯例 src&#x2F;lib.rs) 一个模块内，将 crate 或模块作为一个整体进行记录 2.3 pub use使用 pub use 导出方便使用的公共 API 问题：crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便 开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲 例如 麻烦：my_crate::some_module::another_module::UsefulType； 方便：my_crate::UsefulType 解决办法 不需要重新组织内部代码结构 使用 pub use：可以重新导出，创建一个与内部私有结构不同的对外公共结构 main.rs: 123456789use pubuse::PrimaryColor;use pubuse::mix;fn main() &#123; let c1 = PrimaryColor::Blue; let c2 = PrimaryColor::Yellow; let c3 = mix(c1, c2); println!(&quot;The mixed color is &#123;:?&#125;&quot;, c3);&#125; lib.rs: 1234567891011121314151617181920212223242526272829303132//! 这是测试 pub use 使用的 cratepub use kinds::PrimaryColor;pub use kinds::SecondaryColor;pub use utils::mix;pub mod kinds &#123; /// 色彩三原色：红黄蓝 #[derive(Debug)] pub enum PrimaryColor &#123; Red, Yellow, Blue, &#125; /// 两种颜色混合后的颜色 #[derive(Debug)] pub enum SecondaryColor &#123; Orange, Green, Purple, &#125;&#125;pub mod utils &#123; use crate::kinds::*; /// 将红黄蓝中任意两种颜色混合 pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor &#123; SecondaryColor::Green &#125;&#125; 我们从生成的文档看出，就将很深层的函数提到了 crate 的外层，方便用户查看和调用。 2.4 发布 crate 创建并设置 crates.io 账号 发布 crate 前，需要在 crates.io 创建账号并获得 API token 运行命令：cargo login [你的API token] 通知 cargo，你的 API token 存储在本地 ~/.cargo/credentials API token 可以在 https://crates.io/ 进行撤销 为新的 crate 添加元数据 在发布 crate 之前，需要在 Cargo.toml 的 Ipackage] 区域为 crate 添加一些元数据： crate 需要唯一的名称：name description：一两句话即可，会出现在 crate 搜索的结果里 license：需提供许可证标识值（可到 http://spdk.org/licenses/ 查找） 可指定多个 license：用 OR version author 发布：cargo publish 命令 发布到 crates.io crate一旦发布，就是永久性的：该版本无法覆盖，代码无法删除 目的：依赖于该版本的项目可继续正常工作 发布己存在 crate 的新版本 修改 crate 后，需要先修改 Cargo.toml 里面的 version 值，再进行重新发布 参照 htto:&#x2F;&#x2F;semver.orgl 来使用你的语义版本 使用 cargo yank 从 Crates.io 撤回版本 不可以删除 crate 之前的版本 但可以防止其它项目把它作为新的依赖：yank（撤回）一个 crate 版本 防止新项目依赖于该版本 己经存在项目可继续将其作为依赖（并可下载） yank 意味着： 所有己经产生 Cargo.lock 的项目都不会中断 任何将来生成的 Cargo.lock 文件都不会使用被 yank 的版本。 命令： yank 一个版本（不会删除任何代码）：cargo yank -vers 1.0.1 2.5 cargo 工作空间2.5.1 创建工作空间随着项目越来越大，代码也会越来越臃肿，这时就需要将 crate 拆分成多个包，cargo 便提供了工作空间这个功能。 cargo 工作空间：帮助管理多个相互关联且需要协同开发的 crate cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包 创建工作空间 有多种方式来组建工作空间例：1 个二进制 crate，2 个库 crate 二进制 crate：main 函数，依赖于其它2个库 crate 其中1个库 crate 提供 addLone 函数 另外1个库 crate 提供 add_two 函数 在工作空间中依赖外部 crate 工作空间只有一个 Cargo.lock 文件，在工作空间的顶层目录 保证工作空间内所有 crate 使用的依赖的版本都相同 工作空间内所有 crate 相互兼容 参数 -p 可以指定某个 crate 构建、运行或测试。例如 cargo test -p add-one。发布的时候需要手动进入每个 crate 逐个发布。 以上内容参考视频，未做具体记录。 2.6 安装二进制 crate从 CRATES.IO 安装二进制 crate 命令：cargo install 来源： https://crates.io 限制：只能安装具有二进制目标 (binary target）的 crate 二进制目标 binary target：是一个可运行程序 由拥有 src&#x2F;main.rs 或其它被指定为二进制文件的 crate 生成 通常：README 里有关于 crate 的描述： 拥有 library target 拥有 binary target 两者兼备 cargo install cargo install 安装的二进制存放在根目录的 bin 文件夹 如果你用 rustup 安装的 Rust，没有任何自定义配置，那么二进制存放目录是 $HOME/.cargo/bin 要确保该目录在环境变量 ＄PATH 中 使用自定义命令扩展 cargo cargo 被设计成可以使用子命令来扩展 例：如果＄PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行： cargo something 类似这样的自定义命令可以通过该命令列出：cargo –list 优点：可使用 cargo install 来安装扩展，像内置工具一样来运行","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（十一）：闭包和迭代器","slug":"Rust入门教程（十一）","date":"2022-07-08T08:49:31.000Z","updated":"2023-08-25T05:22:16.914Z","comments":true,"path":"1b9cba25.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1b9cba25.html","excerpt":"闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点","text":"闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点 一、闭包1.1 什么是闭包 是匿名函数 保存为变量、作为参数 可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算 可从其定义的作用域捕获值 1.2 例子：生成自定义运动计划的程序 该算法的逻辑并不是重点，重点是算法中的计算过程需要几秒钟时间。 目标：不让用户发生不必要的等待 仅在必要时调用该算法 例子如下： 123456789101112131415161718192021222324252627fn simulated_expensive_calculation(intensity: u32) -&gt; u32&#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(3)); intensity&#125;fn generate_workout(intensity: u32, random_number: u32) &#123; if intensity &lt; 25 &#123; println!( &quot;Today, do &#123;&#125; pushups!&quot;, simulated_expensive_calculation(intensity) ); println!( &quot;Next, do &#123;&#125; situps!&quot;, simulated_expensive_calculation(intensity) ); &#125; else &#123; if random_number == 3 &#123; println!(&quot;Take a break today!&quot;); &#125; else &#123; println!( &quot;Today, run for &#123;&#125; minutes!&quot;, simulated_expensive_calculation(intensity) ); &#125; &#125;&#125; 我们用函数 simulated_expensive_calculation 模拟复杂的计算，我们不希望调用多次该函数，因为非常耗时，对用户不友好，因此首先想出的优化方案就是用一个变量接收该函数值，当 generate_workout 进入条件语句时，便只需要执行一次即可，如下： 12345678910111213141516fn generate_workout(intensity: u32, random_number: u32) &#123; let res = simulated_expensive_calculation(intensity); if intensity &lt; 25 &#123; println!(&quot;Today, do &#123;&#125; pushups!&quot;, res); println!(&quot;Next, do &#123;&#125; situps!&quot;, res); &#125; else &#123; if random_number == 3 &#123; println!(&quot;Take a break today!&quot;); &#125; else &#123; println!( &quot;Today, run for &#123;&#125; minutes!&quot;, simulated_expensive_calculation(intensity) ); &#125; &#125;&#125; 然而这样又会产生一个新的问题：当进入 else 时，随机数值为 3 的时候，是无需执行复杂计算的，这时候用一个变量接收该复杂计算的函数值便会显得浪费。我们真正希望的是，函数定义单独在一个地方，等到函数真正被用到时再被执行，这就是闭包的功能。代码如下： 123456789101112131415161718fn generate_workout(intensity: u32, random_number: u32) &#123; let expensive_closure = |num| &#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(3)); num &#125;; if intensity &lt; 25 &#123; println!(&quot;Today, do &#123;&#125; pushups!&quot;, expensive_closure(intensity)); println!(&quot;Next, do &#123;&#125; situps!&quot;, expensive_closure(intensity)); &#125; else &#123; if random_number == 3 &#123; println!(&quot;Take a break today!&quot;); &#125; else &#123; println!(&quot;Today, run for &#123;&#125; minutes!&quot;, expensive_closure(intensity)); &#125; &#125;&#125; 其中 expensive_closure 只是定义了一个匿名函数，并没有执行。当然在条件语句中，该闭包还是执行了两次，对于这里的优化，后面会讲到。 1.3 闭包的类型推断和标注 闭包不要求标注参数和返回值的类型，和函数不同，无需对外暴露接口 闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型 可以手动添加类型标注 注意：闭包的定义最终只会为参数&#x2F;返回值推断出唯一具体的类型 例子： 123let example_closure = |x| x;let s = example_closure(String::from(Hello));let a = example_closure(3); 变量 s 传给该闭包一个字符串类型，编译器便推断出来闭包中参数 x 是字符串类型，便与其绑定，因此变量 a 再传入一个整型便会报错。 1.4 使用泛型参数和 Fn Trait 来存储闭包1.4.1 继续解决 1.2 中的例子除了创建局部变量存储闭包的值，还有另一种解决方案： 创建一个 struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果。这个模式通常叫做记忆化（memoization）或延迟计算（lazy evaluation） 如何让 struct 持有闭包 struct 的定义需要知道所有字段的类型 需要指明闭包的类型 每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样 所以需要使用：泛型和 Trait Bound（第10章） Fn Trait Fn traits 由标准库提供 所有的闭包都至少实现了以下 trait 之一： Fn FnMut FnOnce 代码如下： 123456789101112131415161718192021222324252627282930struct Cacher&lt;F&gt;where F: Fn(u32) -&gt; u32&#123; calculation: F, value: Option&lt;u32&gt;&#125;impl&lt;F&gt; Cacher&lt;F&gt;where F: Fn(u32) -&gt; u32&#123; fn new(calculation: F) -&gt; Cacher&lt;F&gt; &#123; Cacher &#123; calculation, value: None &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125; &#125; &#125;&#125; 首先定义了一个结构体，该结构体泛型参数要实现 Fn trait，然后为该结构体实现 new 和 value 函数（方法），如果已经执行过该闭包，则返回值，若没有执行过则执行闭包，将值存进结构体变量中。generate_workout 函数实现如下： 123456789101112131415161718fn generate_workout(intensity: u32, random_number: u32) &#123; let mut expensive_closure = Cacher::new(|num| &#123; println!(&quot;calculating slowly...&quot;); thread::sleep(Duration::from_secs(3)); num &#125;); if intensity &lt; 25 &#123; println!(&quot;Today, do &#123;&#125; pushups!&quot;, expensive_closure.value(intensity)); println!(&quot;Next, do &#123;&#125; situps!&quot;, expensive_closure.value(intensity)); &#125; else &#123; if random_number == 3 &#123; println!(&quot;Take a break today!&quot;); &#125; else &#123; println!(&quot;Today, run for &#123;&#125; minutes!&quot;, expensive_closure.value(intensity)); &#125; &#125;&#125; 1.4.2 使用缓存器（Cacher）实现的限制 Cacher 实例假定针对不同的参数 arg，value 方法总会得到同样的值 可以使用 HashMap 代替单个值： key: arg 参数 value：执行闭包的结果 只能接收一个 u32 类型的参数和 u32 类型的返回值 引入两个或多个泛型参数 1.5 使用闭包捕获环境1.5.1 利用闭包捕获环境中的变量闭包可以捕获他们所在的环境 闭包可以访问定义它的作用域内的变量，而普通函数则不能 会产生额外内存开销 例子： 1234let x = 3;let equal_to_x = |z| z == x;let y = 4;assert!(equal_to_x(y)); 上述代码中，闭包内的变量 x 并不是在闭包内定义的，但是却可以访问，因为闭包可以捕获和其在同一作用域内的其他变量，而函数却没有这样的作用。 闭包从所在环境捕获值的方式 与函数获得参数的三种方式一样： 取得所有权：FnOnce 可变借用：FnMut 不可变借用： Fn 创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 frait： 所有的闭包都实现了 FnOnce 没有移动捕获变量的实现了 FnMut 无需可变访问捕获变量的闭包实现了 Fn 注：实现了 Fn trait 的闭包一定实现了 Fn Mut，实现了 Fn Mut 一定实现了 Fn Once。 1.5.2 move 关键字在参数列表前使用 move 关键字，可以强制闭包取得它所使用的环境值的所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。 例子如下： 12345let x = vec![1, 2, 3];let equal_to_x = move |z| z == x;println!(&quot;can&#x27;t use x here：&#123;:?&#125;&quot;, x);let y = vec![1, 2, 3];assert!(equal_to_x(y)); 这里便不能使用 x 变量了。 最佳实践当指定 Fn trait bound 之一时，首先用 Fn，基于闭包体里的情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你。（面向编译器编程实锤 o_O） 二、迭代器什么是迭代器 迭代器模式：对一系列项执行某些任务 迭代器负责： 遍历每个项 确定序列（遍历）何时完成 Rust 的迭代器： 懒惰的：除非调用消费迭代器的方法，否则迭代器本身没有任何效果。 先用一个最简单的迭代器的例子来进入本节的学习： 12345678fn main() &#123; let v1 = vec![3, 9, 100]; let v1_iter = v1.iter(); for val in v1_iter &#123; println!(&quot;Got: &#123;&#125;&quot;, val); &#125;&#125; output： 1234567➜ it git:(master) ✗ cargo run Compiling it v0.1.0 (/Users/cherry/Code/Rust/learning/it) Finished dev [unoptimized + debuginfo] target(s) in 0.33s Running `target/debug/it`Got: 3Got: 9Got: 100 2.1 Iterator trait 和 next 方法 所有迭代器都实现了 Iterator trait Iterator trait 定义于标准库，定义大致如下 12345pub trait Iterator &#123; type ltem; fn next(&amp;mut self) -&gt; Option&lt;Self::tem&gt;; // methods with default implementations elided&#125; type Item 和 Self::Item 定义了与此该 trait 关联的类型 实现 Iterator trait 需要你定义一个 Item 类型，它用于 next 方法的返回类型（迭代器的返回类型） Iterator trait 仅要求实现一个方法：next next: 每次返回迭代器中的一项 返回结果包裹在 Some 里 迭代结束，返回 None 12345let mut v1_iter_mut = v1.iter();assert_eq!(v1_iter_mut.next(), Some(&amp;3));assert_eq!(v1_iter_mut.next(), Some(&amp;9));assert_eq!(v1_iter_mut.next(), Some(&amp;100));println!(&quot;&#123;&#125;&quot;, v1_iter_mut.len()); 上述的例子要定义一个可变的迭代器，因为 next 方法会更改迭代器内部的用来标示顺序的某些值，而上面的 for 之所以不用定义迭代器为可变，是因为用 for 来进行循环，实际上是取得了该迭代器的所有权，在其内部已经将其变成可变的了。 需要注意的是，next 方法是一种消耗型行为，我们最后输出了迭代器 v1_iter_mut 的长度，结果为 0。 几个迭代方法 iter 方法：在不可变引用上创建迭代器 into_iter 方法：创建的迭代器会获得所有权 iter_mut 方法：迭代可变的引用 2.2 消耗&#x2F;产生迭代器2.2.1 消耗迭代器的方法 在标准库中，Iterator trait 有一些带默认实现的方法 其中有一些方法会调用 next 方法 实现 Iterator frait 时必须实现 nex† 方法的原因之一 调用 next 的方法叫做“消耗型适配器” 因为调用它们会把迭代器消耗尽 例如：sum 方法（就会耗尽迭代器） 取得迭代器的所有权 通过反复调用 next，遍历所有元素 每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和 12345fn test02() &#123; let v1 = vec![4, 5, 8]; let sum: i32 = v1.iter().sum(); assert_eq!(sum, 17);&#125; 使用 sum 的时候要注意显示声明类型。 2.2.2 产生其它迭代器的方法(map) 定义在 Iterator trait 上的另外一些方法叫做“迭代器适配器” 把迭代器转换为不同种类的迭代器 可以通过链式调用使用多个迭代器适配器来执行复杂的操作，这种调用可读性较高。 例如：map 接收一个闭包，闭包作用于每个元素 产生一个新的迭代器 collect 方法：消耗型适配器，把结果收集到一个集合类型中 例子如下： 12345fn test03() &#123; let v1 = vec![2, 4, 6]; let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect(); assert_eq!(v2, vec![3, 5, 7]);&#125; 2.3 使用闭包捕获环境(filter) filter 方法： 接收一个闭包 这个闭包在遍历迭代器的每个元素时，返回 bool 类型 如果闭包返回 true：当前元素将会包含在 filter 产生的迭代器中 如果闭包返回 false：当前元素将不会包含在 filter 产生的迭代器中 我们现在实现一个功能，取出一个迭代器中所有为偶数的元素，将取出的元素再放入一个新的迭代器，例子如下： 12345fn test04() &#123; let v1 = vec![1, 2, 3, 4, 5, 6]; let v2: Vec&lt;_&gt; = v1.into_iter().filter(|x| x % 2 == 0).collect(); assert_eq!(v2, vec![2, 4, 6]);&#125; 这里有一点要注意：iter 方法里的元素都是引用类型，且不可变，因此若要进行 x % 2 == 0 操作的话，需要解引用 *x。上述代码中使用 into_iter 方法获得了迭代器中元素的所有权。 2.4 创建自定义迭代器使用 Iterator frait 来创建自定义迭代器 实现 next 方法 12345678910111213141516171819202122232425262728293031struct Counter &#123; count: u32,&#125;impl Counter &#123; fn new() -&gt; Counter &#123; Counter &#123;count: 0&#125; &#125;&#125;impl Iterator for Counter &#123; type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123; if self.count &lt; 5 &#123; self.count += 1; Some(self.count) &#125; else &#123; None &#125; &#125;&#125;fn test05() &#123; let mut counter = Counter::new(); assert_eq!(counter.next(), Some(1)); assert_eq!(counter.next(), Some(2)); assert_eq!(counter.next(), Some(3)); assert_eq!(counter.next(), Some(4)); assert_eq!(counter.next(), Some(5)); assert_eq!(counter.next(), None);&#125; 这个例子很容易理解，就是通过 next 方法不断迭代，范围是 1-5，至于为 Counter 实现 Iterator 特征，将来会介绍。 下面要对迭代器的需求进行改进，有两个迭代器，第一个迭代器就是上面所说的，第二个迭代器的元素是 [2, 3, 4, 5]，现在要求将两个迭代器中的元素按顺序相乘，然后将结果存入一个新的迭代器，然后过滤出能被 3 整除的数，并求和。 代码如下： 12345678fn test06() &#123; let sum: u32 = Counter::new() .zip(Counter::new().skip(1)) .map(|(a, b)| a * b) .filter(|x| x % 3 == 0) .sum(); assert_eq!(sum, 18);&#125; 介绍一下 zip 方法，这个单词本意是“拉链”，这里表示将两个迭代器“捏到一起”，形成一个新的迭代器，里面的每个元素就是一个元组 ，这个元组里有两个元素，这两个元素分别来自原来的两个迭代器。这里第一个迭代器就是通过 Counter::new() 得到的，第二个迭代器就是 zip() 方法内的参数 Counter::new().skip(1)，表示跳过第一个元素后剩下的元素组成的迭代器。 为了更好展示每一个方法的实现过程，我们运行 12let v1 = Counter::new().zip(Counter::new().skip(1));println!(&quot;&#123;:?&#125;&quot;, v1); 对于上例中的两个初始化后的迭代器，输出结果为： 12345➜ it git:(master) ✗ cargo run Compiling it v0.1.0 (/Users/cherry/Code/Rust/learning/it) Finished dev [unoptimized + debuginfo] target(s) in 0.20s Running `target/debug/it`Zip &#123; a: Counter &#123; count: 0 &#125;, b: Skip &#123; iter: Counter &#123; count: 0 &#125;, n: 1 &#125; &#125; 再来看官方文档中的实例就更清楚了： 123456789let a1 = [1, 2, 3];let a2 = [4, 5, 6];let mut iter = a1.iter().zip(a2.iter());assert_eq!(iter.next(), Some((&amp;1, &amp;4)));assert_eq!(iter.next(), Some((&amp;2, &amp;5)));assert_eq!(iter.next(), Some((&amp;3, &amp;6)));assert_eq!(iter.next(), None); 2.5 优化第十章的 I&#x2F;O 项目项目具体内容请参考 Rust入门教程（十） 2.5.1 利用迭代器优化 new 函数我们来看一下 minigrep 项目中 Config 函数的 new() 函数： 123456789101112131415impl Config &#123; pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数错误，请输入两个参数。&quot;); &#125; let search_string = args[1].clone(); let filename = args[2].clone(); let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err(); Ok(Config &#123; search_string, filename, case_sensitive &#125;) &#125;&#125; 在 new() 函数中，传入的参数是字符串切片，为了返回 Config 结构体，需要获得命令行参数这两个变量的所有权，之前的解决方法是将那两个参数进行克隆，但是这样会对性能带来一定的损耗。现在我们学习完了闭包和迭代器，便可以通过迭代器获取其实例，并且可以使用迭代器所带的一些方法进行长度检查和索引。通过迭代器的 next 方法，便将读取具体值的功能分离了出去。 原来的 main 函数中，通过 env::args().collect() 将参数列表转化成 vector，然后将这个 vector 传到 new() 函数中，其实 env::args() 返回的就是迭代器，我们直接把它当做 new() 的参数即可。 1234567fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let config = Config::new(&amp;args).unwrap_or_else(|err| &#123; ... &#125;); ...&#125; 更改过后的 main 函数： 123456fn main() &#123; let config = Config::new(env::args()).unwrap_or_else(|err| &#123; ... &#125;); ...&#125; 修改过后的 new() 函数： 12345678910111213141516171819202122impl Config &#123; pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数错误，请输入两个参数。&quot;); &#125; args.next(); let search_string = match args.next() &#123; Some(args) =&gt; args, None =&gt; return Err(&quot;无法读取要查询的字符串参数&quot;) &#125;; let filename = match args.next() &#123; Some(args) =&gt; args, None =&gt; return Err(&quot;无法读取文件名参数&quot;) &#125;; let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err(); Ok(Config &#123; search_string, filename, case_sensitive &#125;) &#125;&#125; 2.5.2 利用迭代器优化 search 函数原来的 search() 函数实现如下： 123456789fn search&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; let mut vec = Vec::new(); for lines in content.lines() &#123; if lines.contains(query) &#123; vec.push(lines); &#125; &#125; vec&#125; 实现思路是先将文本内容每一行取出来，然后手动遍历，判断当前行是否包含所要查询的字符串，将结果放入新的 vector 中，最后返回这个 vector。但是学完了迭代器适配器的知识点后，应该很容易想到 filter 这个方法。实现如下： 123fn search&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; content.lines().filter(|line| line.contains(query)).collect()&#125; 同理 search_case_insensitive 修改如下： 12345fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; content.lines() .filter(|line| line.to_uppercase().contains(&amp;query.to_uppercase())) .collect()&#125; 现在我们将原来的七行代码简化成了一行，这一行代码和之前的七行实现的功能是相同的，但是显然利用迭代器实现的这一行代码更加易读（熟悉了迭代器的使用之后，这种写法会非常简单），不仅从代码，减少了临时变量，同时消除了可变状态 result，这样可以使得将来通过并行来提升搜索效率，因为并行时不用再考虑并发访问 result 这个变量时会出现的安全问题了。 实际上，对于大多数 Rust 程序员会更喜欢使用迭代器这样的方式来实现，因为这样可以更加专注于实现逻辑本身，而不是总是浪费时间在大量的循环和维护临时变量这些细节工作上。至于两者的效率问题，并非像表面上那样，使用迭代器效率会降低，具体的我们下节再介绍。 2.6 性能比较：循环 vs 迭代器零开销抽象 Zero-Cost Abstraction 使用抽象时不会引入额外的运行时开销 对于迭代器，编译器会自行判断底层代码展开策略，对于某些特定次数的循环，编译器底层会手动将迭代器展开特定的次数，这样对于流水线 CPU 来说，会减少因跳转或延迟槽产生的停顿周期，使得流水线的吞吐量增大，从而使得效率提高。 因此在 Rust 中，尽量使用迭代器实现。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（十）：项目实战","slug":"Rust入门教程（十）","date":"2022-07-03T06:37:57.000Z","updated":"2023-08-25T05:21:29.208Z","comments":true,"path":"461e5b43.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/461e5b43.html","excerpt":"本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。","text":"本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。 要实现的 grep 命令功能很简单，就是在指定文件中查找指定文字。grep 命令接收一个文件名和字符串作为输入参数，然后读取文件内容，搜索包含指定字符串的行，最终将这些匹配的行打印输出。 下面开始实战演示。 一、接收命令行参数我们预计使用如下命令来执行该程序： 1cargo run &lt;string&gt; &lt;filename&gt; 因此我们首先要读取命令行中的参数，我们导入函数 use std::env::args()，args() 函数返回一个迭代器，迭代器部分的内容将在后面才会介绍。然后使用 collect 方法，将迭代器中的值转化成一个集合，但是该函数不能处理命令行中非 Unicode 的字符（这种情况可以使用 env::args _os() 函数，这种情况下返回的迭代器值的类型是 OsString，在这里不做介绍）。 12345678910use std::env;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let search_string = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;&#123;:?&#125;&quot;, args); println!(&quot;Search String &#123;&#125;&quot;, search_string); println!(&quot;In file &#123;&#125;&quot;, filename);&#125; 1234567➜ ~/code/rust/minigrep git:(master) ✗ cargo run string filename Compiling minigrep v0.1.0 (/home/cherry/code/rust/minigrep) Finished dev [unoptimized + debuginfo] target(s) in 0.29s Running `target/debug/minigrep string filename`[&quot;target/debug/minigrep&quot;, &quot;string&quot;, &quot;filename&quot;]Search String stringIn file filename 根据程序执行结果我们能够得知：返回的第一个参数永远都是该程序的二进制文件（对应 args[0]），从第二个参数开始才是从命令行输入的各种参数（对应 args[1] …）。 二、读取文件首先导入模块 use std::fs，用于处理和文件相关的事务，read_to_string() 用来读取文件中的内容，将其转化成字符串。 1234567891011121314use std::env;use std::fs;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let search_string = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;&#123;:?&#125;&quot;, args); println!(&quot;Search String &#123;&#125;&quot;, search_string); println!(&quot;In file &#123;&#125;&quot;, filename); let content = fs::read_to_string(filename).expect(&quot;该文件不存在&quot;); println!(&quot;文件内容:\\n&#123;&#125;&quot;, content);&#125; 输出结果为： 1234567891011121314151617181920➜ ~/code/rust/minigrep git:(master) ✗ cargo run string poem Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/minigrep string poem`[&quot;target/debug/minigrep&quot;, &quot;string&quot;, &quot;poem&quot;]Search String stringIn file poem文件内容:Hold fast to dreamsFor if dreams dieLife is a broken-winged birdThat can never flyHold fast to dreamsFor when dreams goLife is a barren fieldFrozen only with snowTo see a world in a grain of sand,And a heaven in a wild flower,Hold infinity in the palm of your hand,And eternity in an hour. 当然目前看来所有逻辑都放在了主函数中，并且很多错误情况都没有考虑。一般情况下一个函数只做一件事，如果代码逐渐变多，代码维护将变得越来越困难。代码越少重构越简单，因此下一节将对代码进行重构。 三、重构：改进模块和错误处理3.1 四个问题提炼我们仔细观察一下目前的代码，主要有四个方面的问题。 1234567891011121314use std::env;use std::fs;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let search_string = &amp;args[1]; let filename = &amp;args[2]; println!(&quot;&#123;:?&#125;&quot;, args); println!(&quot;Search String &#123;&#125;&quot;, search_string); println!(&quot;In file &#123;&#125;&quot;, filename); let content = fs::read_to_string(filename).expect(&quot;该文件不存在&quot;); println!(&quot;文件内容:\\n&#123;&#125;&quot;, content);&#125; 主函数负责的功能较多，既要负责命令行参数解析，又要负责读取文件。而程序编写的原则就是一个函数负责一个功能，因此要将主函数拆分； search_string、filename 和 content 变量，在程序越来越大之后，变量也会越来越多，将难以追踪每一个变量的实际意义。解决办法是将这些变量放入一个结构体中，从而使其用途更加清晰； 读取文件时，使用 expect 处理错误，但未对其读取错误的原因进行细分，因为文件打不开可能是文件不存在，文件权限不够，文件损坏等原因； 对于命令行参数的错误处理，若输入的参数没有两个，那么程序本身就会报错，并且能够预料到的错误一定是 Out of bound 这类的错误，但是对于使用者来说，可能并不清楚这个所谓的 越界错误 意味着什么，无法清晰解释错误的具体原因。因此最好要将所有错误处理集中到一起，将来开发者要考虑错误处理的时候，就只要处理这一处代码，这样也能保证为用户打印出有意义的错误信息，而不是只有程序员能看懂的 Out of bound。 3.2 二进制程序关注点分离的指导性原则 将程序拆分为 main.rs 和 lib.rs，将业务逻辑放入 lib.rs 当命令行解析逻辑较少时，将它放在 main.rs 也行 当命令行解析逻辑变复杂时，需要将它从 main.rs 提取到 lib.rs 经过上述拆分，留在 main 的功能有： 使用参数值调用命令行解析逻辑 进行其它配置 调用 lib.rs 中的 run 函数 处理 run 函数可能出现的错误 因此放在 main.rs 中的代码量应足够小，小到直接阅读代码就可以确保代码的正确性。将业务逻辑放入 lib.rs 中也方便进行功能测试。 针对上面说的四个方面的问题，我们逐一进行解决。 1. 拆分出命令行参数提取功能 12345678910111213use std::env;use std::fs;fn main() &#123; ... let (search_string, filename) = parse_config(&amp;args); ...&#125;fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) &#123; let search_string = &amp;args[1]; let filename = &amp;args[2]; (search_string, filename)&#125; 我们发现，parse_config 函数目前返回一个元组，但是在主函数中，又将该元组拆分出来，赋值给两个变量，这样感觉有点“脱裤子放屁”的感觉，来回折腾。实际上这种情况就说明程序中这样设计数据结构是不正确的。因此较好的做法就是将返回的元组中的变量放入一个结构体。 2. 创建结构体 12345678910struct Config &#123; search_string: String, filename: String&#125;fn parse_config(args: &amp;[String]) -&gt; Config &#123; let search_string = &amp;args[1]; let filename = &amp;args[2]; Config &#123; search_string, filename &#125;&#125; 这里我们创建一个叫 Config 的结构体，将 search_string 和 filename 两个变量放入结构体。但是上面的代码会报错，这是因为在函数 parse_config 中，args 参数是切片类型，是没有所有权的（它的所有权被 main 函数拥有），而在最后要返回一个 Config 结构体对象，该结构体需要占用所有权，因此会报错。 这里用一个简单的方法来处理，就是创建 args[1] 和 args[2] 的两个副本，尽管这样会损失性能。 12345fn parse_config(args: &amp;[String]) -&gt; Config &#123; let search_string = args[1].clone(); let filename = args[2].clone(); Config &#123; search_string, filename &#125;&#125; 我们再来看 parse_config 函数，它返回的是一个结构体，实际上是要创建一个新的结构体，因此我们最好再实现该结构体的 new 函数。 12345678910impl Config &#123; fn new(args: &amp;[String]) -&gt; Config &#123; let search_string = args[1].clone(); let filename = args[2].clone(); Config &#123; search_string, filename, &#125; &#125;&#125; 这里就是将刚刚的 parse_config 变成了结构体 Config 的函数。重构后的完整代码如下： 12345678910111213141516171819202122232425use std::env;use std::fs;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let config = Config::new(&amp;args); let content = fs::read_to_string(config.filename).expect(&quot;该文件不存在&quot;); println!(&quot;文件内容:\\n&#123;&#125;&quot;, content);&#125;struct Config &#123; search_string: String, filename: String,&#125;impl Config &#123; fn new(args: &amp;[String]) -&gt; Config &#123; let search_string = args[1].clone(); let filename = args[2].clone(); Config &#123; search_string, filename, &#125; &#125;&#125; 3. 错误处理 我们不输入参数进行运行，不出预料的会产生下面的错误： 1234567891011121314➜ ~/code/rust/minigrep git:(master) ✗ cargo run warning: field is never read: `search_string` --&gt; src/main.rs:19:5 |19 | search_string: String, | ^^^^^^^^^^^^^^^^^^^^^ | = note: `#[warn(dead_code)]` on by defaultwarning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/minigrep`thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 1 but the index is 1&#x27;, src/main.rs:25:29note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 即 越界错误，这对于用户来说是无法理解的，我们当然可以在 new 函数中添加这样的判断语句， 123if args.len() &lt; 3 &#123; panic!(&quot;输入参数错误，请输入两个参数。&quot;);&#125; 但是这样仍然会有编译器的其他信息，一般情况下，使用 panic 通常是程序本身的问题，但是像这类输入参数少的问题属于程序使用的问题，因此我们还需要进行改进，可以返回 Result 枚举，代码如下。 1234567891011121314151617181920212223242526272829303132use std::env;use std::fs;use std::process;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let config = Config::new(&amp;args).unwrap_or_else(|err| &#123; println!(&quot;参数解析错误：&#123;&#125;&quot;, err); process::exit(1); &#125;); let content = fs::read_to_string(config.filename).expect(&quot;该文件不存在&quot;); println!(&quot;文件内容:\\n&#123;&#125;&quot;, content);&#125;struct Config &#123; search_string: String, filename: String,&#125;impl Config &#123; fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数个数不足，请输入两个参数。&quot;); &#125; let search_string = args[1].clone(); let filename = args[2].clone(); Ok(Config &#123; search_string, filename, &#125;) &#125;&#125; 如果参数个数超过 2 个，则返回 Err 的变体，否则返回 Ok。主函数中，unwrap_or_else 函数的含义是，如果枚举返回的是 Ok，那么就取出 Ok 变体中的值返回，若枚举返回的是 Err，那么就调用一个闭包（匿名函数，闭包具体内容将来会介绍），然后使用 process::exit(1) 将程序返回，这样就不会有编译器的其他信息了。 12345➜ ~/code/rust/minigrep git:(master) ✗ cargo run Compiling minigrep v0.1.0 (/home/cherry/code/rust/minigrep) Finished dev [unoptimized + debuginfo] target(s) in 0.33s Running `target/debug/minigrep`参数解析错误：输入参数个数不足，请输入两个参数。 4. 功能模块化 一个函数只处理一个功能，因此我们将业务逻辑（即读取文件内容）功能提取到一个新的函数中。 1234fn run(config: Config) &#123; let content = fs::read_to_string(config.filename).expect(&quot;该文件不存在&quot;); println!(&quot;文件内容:\\n&#123;&#125;&quot;, content);&#125; 然后我们进行 run 函数的错误处理。 12345fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123; let content = fs::read_to_string(config.filename)?; println!(&quot;文件内容:\\n&#123;&#125;&quot;, content); Ok(())&#125; 这里 result&lt;(), Box&lt;dyn Error&gt;&gt; 中第一个参数是空，第二个参数只要理解是一个实现了 Error 这个 trait 的类型，这样函数便可以在不同场景下返回不同的错误类型。 因为 expect 会引起恐慌，因此将其去掉，改成 ?，? 运算符遇到错误不会恐慌，它会将错误值返回给函数的调用者，如果没有发生错误，那么我们最后返回一个 Ok()。 这时编译器会在 run(config) 出给予警告：this &#39;Result&#39; may be an &#39;Err&#39; variant, which should be handled，这说明函数返回值是一个 Result 类型，那么就说明可能会产生错误，因此需要对其进行处理。 unwrap 有打开的意思，需要从 Result 中提取数据，但是 run 函数没有返回值，因此也就不需要 unwrap，可以像下面这样解决这一问题。 1234if let Err(e) = run(config) &#123; println!(&quot;程序运行出错：&#123;&#125;&quot;, e); process::exit(1);&#125; 下面我们将业务逻辑迁移到 lib.rs 中。 lib.rs: 123456789101112131415161718192021222324252627use std::fs;use std::error::Error;pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123; let content = fs::read_to_string(config.filename)?; println!(&quot;文件内容:\\n&#123;&#125;&quot;, content); Ok(())&#125;pub struct Config &#123; pub search_string: String, pub filename: String,&#125;impl Config &#123; pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数错误，请输入两个参数。&quot;); &#125; let search_string = args[1].clone(); let filename = args[2].clone(); Ok(Config &#123; search_string, filename, &#125;) &#125;&#125; main.rs: 1234567891011121314151617use minigrep::Config;use std::env;use std::process;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let config = Config::new(&amp;args).unwrap_or_else(|err| &#123; println!(&quot;参数解析错误：&#123;&#125;&quot;, err); process::exit(1); &#125;); if let Err(e) = minigrep::run(config) &#123; println!(&quot;程序运行出错：&#123;&#125;&quot;, e); process::exit(1); &#125;&#125; 要记得所有函数和结构体以及字段前都要加 pub，这样才能让其他 crate 才能进行调用。这样 lib crate 就有了一套公共的可用于测试的 API。 重构到这里就基本完成了，下面就要来编写测试了。 四、使用 TDD（测试驱动开发）开发库功能测试驱动开发 TDD (Test-Driven Development) 编写一个会失败的测试，运行该测试，确保它是按照预期的原因失败 编写或修改刚好足够的代码，让新测试通过 重构刚刚添加或修改的代码，确保测试会始终通过 返回步骤1，继续 测试驱动开发能够对代码的设计起到指导和帮助的作用，先编写测试，然后再编写能够通过测试的代码，也能保证开发过程中能够保持测试较高的覆盖率。 1234567891011121314151617181920212223fn search&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; let mut vec = Vec::new(); for lines in content.lines() &#123; if lines.contains(query) &#123; vec.push(lines); &#125; &#125; vec&#125;#[cfg(test)]mod test &#123; #[test] fn one_result() &#123; use super::*; let query = &quot;Lakers&quot;; let contents = &quot;\\Rust OK,Paul, James, Lakers.What a wonderful day!&quot;; assert_eq!(vec![&quot;Paul, James, Lakers.&quot;], search(query, contents)); &#125;&#125; 注意 search 函数中返回的引用的生命周期与 content 有关，而与 query 无关。content.lines() 函数返回一个的迭代器，取出文件中的每一行。这样测试代码就完成了，运行测试也是成功的。 123456789101112131415161718192021➜ ~/code/rust/minigrep git:(master) ✗ cargo test Compiling minigrep v0.1.0 (/home/cherry/code/rust/minigrep) Finished test [unoptimized + debuginfo] target(s) in 0.36s Running unittests (target/debug/deps/minigrep-662cb87b3d895995)running 1 testtest test::one_result ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Running unittests (target/debug/deps/minigrep-33abce92ed029d2f)running 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s Doc-tests minigreprunning 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s 然后修改 run 函数并运行 cargo run。 12345678pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123; let content = fs::read_to_string(config.filename)?; // println!(&quot;文件内容:\\n&#123;&#125;&quot;, content); for line in search(&amp;config.search_string, &amp;content) &#123; println!(&quot;&#123;&#125;&quot;, line); &#125; Ok(())&#125; 12345➜ ~/code/rust/minigrep git:(master) ✗ cargo run is poem Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/minigrep is poem`Life is a broken-winged birdLife is a barren field 五、使用环境变量这一部分使用环境变量来实现配置选项（例如是否忽略大小写等）。 我们首先编写一个测试： 12345678910#[test]fn case_insensitive() &#123; let query = &quot;LakErS&quot;; let contents = &quot;Rust OK,Paul, James, Lakers.What a wonderful day!blakers championship&quot;; assert_eq!(vec![&quot;Paul, James, Lakers.&quot;, &quot;blakers championship&quot;], search_case_insensitive(query, contents));&#125; 然后编写 search_case_insensitive 函数： 12345678910fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; let mut vec = Vec::new(); let query = query.to_lowercase(); for lines in content.lines() &#123; if lines.to_lowercase().contains(&amp;query) &#123; vec.push(lines); &#125; &#125; vec&#125; 其思路就是将查询的字符串和文件中的都转化成小写。 然后我们在 run 函数中加入如下逻辑。 12345let result = if config.case_sensitive &#123; search(&amp;config.search_string, &amp;content)&#125; else &#123; search_case_insensitive(&amp;config.search_string, &amp;content)&#125;; 结构体的 new 函数也需要修改： 12345678910111213pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数错误，请输入两个参数。&quot;); &#125; let search_string = args[1].clone(); let filename = args[2].clone(); let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err(); Ok(Config &#123; search_string, filename, case_sensitive &#125;)&#125; env::var() 函数返回的是 Result 枚举，若环境中有 CASE_INSENSITIVE 定义或者赋值，那么就会返回 Ok 中的值，我们这里只需要判断是否为 Err 即可。 123456➜ ~/code/rust/minigrep git:(master) ✗ CASE_INSENSITIVE=1 cargo run to poem Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/minigrep to poem`Hold fast to dreamsHold fast to dreamsTo see a world in a grain of sand, 六、将错误消息写进标准错误而不是标准输出当前我们都将错误信息输出到终端上，而大多数终端提供两种输出，一个是标准输出（stdout，println!），另一个叫标准错误（stderr，eprintln!）。 我们将打印错误信息的 println! 改成 eprintln! 即可，然后运行 cargo run &gt; output，错误信息便不会输出到文件中，而是打印在终端了。 七、完整代码main.rs: 1234567891011121314151617use minigrep::Config;use std::env;use std::process;fn main() &#123; let args: Vec&lt;String&gt; = env::args().collect(); let config = Config::new(&amp;args).unwrap_or_else(|err| &#123; println!(&quot;参数解析错误：&#123;&#125;&quot;, err); process::exit(1); &#125;); if let Err(e) = minigrep::run(config) &#123; println!(&quot;程序运行出错：&#123;&#125;&quot;, e); process::exit(1); &#125;&#125; lib.rs: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788use std::error::Error;use std::fs;use std::env;pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123; let content = fs::read_to_string(config.filename)?; // println!(&quot;文件内容:\\n&#123;&#125;&quot;, content); let result = if config.case_sensitive &#123; search(&amp;config.search_string, &amp;content) &#125; else &#123; search_case_insensitive(&amp;config.search_string, &amp;content) &#125;; for line in result &#123; println!(&quot;&#123;&#125;&quot;, line); &#125; Ok(())&#125;pub struct Config &#123; pub search_string: String, pub filename: String, pub case_sensitive: bool&#125;impl Config &#123; pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;str&gt; &#123; if args.len() &lt; 3 &#123; return Err(&quot;输入参数错误，请输入两个参数。&quot;); &#125; let search_string = args[1].clone(); let filename = args[2].clone(); let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err(); Ok(Config &#123; search_string, filename, case_sensitive &#125;) &#125;&#125;fn search&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; let mut vec = Vec::new(); for lines in content.lines() &#123; if lines.contains(query) &#123; vec.push(lines); &#125; &#125; vec&#125;fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, content: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123; let mut vec = Vec::new(); let query = query.to_lowercase(); for lines in content.lines() &#123; if lines.to_lowercase().contains(&amp;query) &#123; vec.push(lines); &#125; &#125; vec&#125;#[cfg(test)]mod test &#123; use super::*; #[test] fn one_result() &#123; let query = &quot;Lakers&quot;; let contents = &quot;\\Rust OK,Paul, James, Lakers.What a wonderful day!&quot;; assert_eq!(vec![&quot;Paul, James, Lakers.&quot;], search(query, contents)); &#125; #[test] fn case_insensitive() &#123; let query = &quot;LakErS&quot;; let contents = &quot;Rust OK,Paul, James, Lakers.What a wonderful day!blakers championship&quot;; assert_eq!( vec![&quot;Paul, James, Lakers.&quot;, &quot;blakers championship&quot;], search_case_insensitive(query, contents) ); &#125;&#125; 七、案例：代码统计7.1 基本功能介绍代码统计以给定的输入参数作为统计对象（可以是文件或文件夹），根据文件后缀名统计代码所使用的语言（暂定只统计 C、C&#x2F;C++ 头文件、C++、Java、Python、Rust、汇编语言、makefile 脚本），然后统计每一种代码文件的有效代码行数、注释行和空行。没有后缀名的文件默认不进行统计。 7.2 可拓展功能 丰富统计的语言种类 命令行中利用参数指定要统计的语言，只统计指定的语言 加入多线程提高文件扫描速度","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（九）：Rust 宏编程","slug":"Rust入门教程（九）","date":"2022-07-02T03:26:35.000Z","updated":"2023-09-05T14:12:10.573Z","comments":true,"path":"c3f8af28.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/c3f8af28.html","excerpt":"C&#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。 【未完】","text":"C&#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。 【未完】 声明宏先来看几个例子。 1234567macro_rules! test &#123; () =&gt; &#123; 10 &#125;;&#125;let a = test!(); // or test![] or test!&#123;&#125;assert_eq!(10, a); 这是最简单的一个宏，执行的时候，从左侧小括号匹配规则，从右侧进行，这里是直接返回一个数字。使用起来也很容易，宏的使用，用小括号，中括号，大括号都可以。 给宏传递参数宏的匹配能力非常强，还可以匹配变量，表达式，函数等。 1234567macro_rules! test &#123; ($var: expr) =&gt; &#123; $var &#125;;&#125;let a = test!(20);assert_eq!(20, a); 这里的 $e 是自己定的，写成 $a, $b, $foo 之类的都可以，不过还是推荐写得语义化一些。expr 是表达式 expression 的缩写，此外还有其他类型。 item: 结构体，函数，mod 之类的 block: 用大括号包起来的语句或者表达式，也就是代码块 stmt: 一段 statement pat: 一段 pattern ty: 一个类型 ident: 标识符 path: 类似 foo::bar 这种路径 meta: 元类型，譬如 #[…], #![…] 内的东西 tt: 一个 token tree 以 pat 为例。 123456789101112macro_rules! test &#123; ($var: expr, $pattern: pat) =&gt; &#123; match $var &#123; $pattern =&gt; true, _ =&gt; false &#125; &#125;&#125;let c = Some(true);let d = test!(c, Some(true));println!(&quot;&#123;&#125;&quot;, d); 上述的三个宏可以合到一起。 1234567891011121314macro_rules! test &#123; () =&gt; &#123; 10 &#125;; ($var: expr) =&gt; &#123; $var &#125;; ($var: expr, $pattern: pat) =&gt; &#123; match $var &#123; $pattern =&gt; true, _ =&gt; false &#125; &#125;&#125; 重复这是 Rust Book 的宏那一节的例子，* 表示重复使用 $() 包裹的内容来处理传进来的值，* 前的 , 是参数的分隔符，* 可以换成正则表达式中的 + 或 ?。这个例子中可以处理传入的多个数字。 123456789101112131415macro_rules! vec &#123; ( $( $x:expr ),* ) =&gt; &#123; &#123; let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec &#125; &#125;;&#125;fn main() &#123; let v = vec![1, 2, 3]; println!(&quot;&#123;:?&#125;&quot;, v);&#125; 过程宏过程宏必须定义在一个独立的 crate 中。 【解释】：过程宏是在编译一个 crate 之前，对 crate 的代码进行加工的一段程序，这段程序也是需要编译后执行的。如果定义过程宏和使用过程宏的代码写在一个 crate 中，那么就会陷入死锁： 要编译的代码首先需要运行过程宏来展开，否则代码就是不完整的，没法编译 crate 不能编译 crate，那么其中的过程宏代码就没法执行，就不能展开被过程宏装饰的代码 要开发 rust 过程宏，需要在 Cargo.toml 文件中添加必备的三个依赖包： 1234[dependencies]proc-macro2 = &quot;1.0.7&quot;quote = &quot;1&quot;syn = &#123; version = &quot;1.0.56&quot;, features = &#123;&quot;full&quot;&#125; &#125; &#x2F;&#x2F; TODO","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（七）：生命周期","slug":"Rust入门教程（七）","date":"2022-06-12T06:34:00.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"3e05ea36.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/3e05ea36.html","excerpt":"Rust入门教程（七）：生命周期 Rust 生命周期机制是与所有权机制同等重要的资源管理机制。生命周期，简而言之就是引用的有效作用域，之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算，但引用往往导致极其复杂的资源管理问题。","text":"Rust入门教程（七）：生命周期 Rust 生命周期机制是与所有权机制同等重要的资源管理机制。生命周期，简而言之就是引用的有效作用域，之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算，但引用往往导致极其复杂的资源管理问题。 [toc] 生命周期 Rust 的每个引用都有自己的生命周期 生命周期：引用保持有效的作用域 大多数情况：生命周期是隐式的、可被推断的 当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期 生命周期的主要目标：避免悬垂引用（dangling reference） 12345678910fn test01() &#123; &#123; let r; &#123; let x = 3; r = &amp;x; &#125; println!(&quot;&#123;&#125;&quot;, r); &#125;&#125; 上面这段代码会在 r = &amp;x; 处报错，因为当打印 r 的值的时候，x 已经离开了他的作用域，这时 r 指向的 x 的内存已经被释放，因此会报错。 Rust 实际上是通过借用检查器来检查一些变量的生命周期。 借用检查器Rust 编译器的借用检查器（borrow checker），用来比较作用域来判断所有的借用是否合法 在上例中，借用检查器检测到 r 的生命周期大于 x，即被引用者的生命周期小于引用者的生命周期，因此编译会报错。 函数中的泛型生命周期1234567891011121314fn test02() &#123; let string1 = String::from(&quot;Congratulations&quot;); let string2 = &quot;fantastic&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125;fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 编译报错： 123456789101112131415➜ ~/Code/rust/life_cycle git:(master) ✗ cargo run Compiling life_cycle v0.1.0 (/home/cherry/Code/rust/life_cycle)error[E0106]: missing lifetime specifier --&gt; src/main.rs:24:33 |24 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; | ---- ---- ^ expected named lifetime parameter | = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`help: consider introducing a named lifetime parameter |24 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; | ++++ ++ ++ ++For more information about this error, try `rustc --explain E0106`. 我们发现编译器会提示缺少一个命名的生命周期参数，这个函数返回一个借用的值，但是没有声明这个借用的值是来自 x 还是来自 y。值得说明的是，这个返回值的借用跟函数体的逻辑没有关系，要从函数签名就要看出返回值借用的值来自哪一个参数。 根据编译器提示，我们声明一个泛型生命周期 &#39;a，代码修改如下： 1234567fn longest&lt;&#x27;a&gt; (x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 生命周期标注语法 生命周期的标注不会改变引用的生命周期长度 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用 生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期 生命周期参数名语法如下： 以 &#39; 开头 通常全小写且非常短 习惯以 &#39;a 表示 生命周期标注的位置： 在引用符号 &amp; 后面标注 使用空格将标注和引用类型区分开 生命周期标注的例子： 123&amp;i32 // 一个引用&amp;&#x27;a i32 // 带有显式生命周期的引用&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用 值得注意的是，单个生命周期标注本身没有意义，我们再看上面的 longest 函数： 1234567fn longest&lt;&#x27;a&gt; (x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 泛型的生命周期参数声明在函数名和参数列表之间的 &lt;&gt; 中。 我们仔细分析这个函数： longest 函数的两个参数都声明了生命周期，就要求这两个引用必须和泛型的生命周期存活相同的时间，而且函数所返回的字符串切片的存活时长也不能小于 &#39;a 这个生命周期。为引用指明生命周期，是要确保当引用失去了所有权后而被移出内存。当在函数参数中指明生命周期时，我们并没有改变参数和返回值的生命周期，只是向调用检查器指出了一些可用于检查非法调用的约束。而 longest 函数本身并不需要知道参数 x 和 y 具体的存活时长，只需要某个可以代替 &#39;a 的作用域，同时满足函数的签名约束。实际上，若函数引用其外部的代码或者被外部代码引用，只靠 rust 本身确定参数和返回值的生命周期时不可能的，这样的话，函数所使用的生命周期在每次调用中都会发生变化，正因为如此，我们才需要手动对生命周期进行标注。 当我们将两个引用传入函数时，x 和 y 作用域重叠的部分将用来代替 &#39;a 这个生命周期的作用域，换句话说，这个泛型生命周期得到的具体的生命周期就是 x 和 y 两者生命周期较短的那个，因为返回值也标注了相同的生命周期，因此返回值的引用在两者比较短的生命周期内都是有效的。 那么生命周期标注是如何对 longest 函数进行限制的？我么修改一下代码： 12345678910111213141516fn test02() &#123; let string1 = String::from(&quot;Congratulations&quot;); &#123; let string2 = &quot;fantastic&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result); &#125;&#125;fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 将 string1 下面三行代码放到一个单独的作用域里，string2 是一个字符串字面值（字符串切片），他的生命周期相当于是一个静态的生命周期，在整个程序运行期间都存活，而 result 引用也会在 Line 7 大括号结束之前保持有效，因此代码不会报错。 【注】：&amp;str 是直接在可执行文件中加载的，即这块内存直接放到可执行文件里面的，所以整个程序运行期间，这块内存比较特殊，不会由于所有权而消失，所以指这块内存的引用，一定会一直指向一个合法内存，所以其引用的生命周期是 &#39;static，也就是全局静态，也不可能出现什么悬垂引用。 再改一下代码，将 result 声明放到外面，然后将 print 也放到外面，将 string2 改成 String 类型： 123456789fn test02() &#123; let string1 = String::from(&quot;Congratulations&quot;); let result; &#123; let string2 = String::from(&quot;fantastic&quot;); result = longest(string1.as_str(), string2.as_str()); &#125; println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125; 我们发现 Line 6 报错了。string1 的生命周期为 Line 29，string2 的生命周期为 Line 57，所以 &#39;a 所表示的生命周期为 Line 57，而 result 的生命周期为 Line 39，不在 &#39;a 的范围内，因此编译报错，我们来看一下编译具体的错误： 1234567891011121314➜ ~/Code/rust/life_cycle git:(master) ✗ cargo run Compiling life_cycle v0.1.0 (/home/cherry/Code/rust/life_cycle)error[E0597]: `string2` does not live long enough --&gt; src/main.rs:30:44 |30 | result = longest(string1.as_str(), string2.as_str()); | ^^^^^^^^^^^^^^^^ borrowed value does not live long enough31 | &#125; | - `string2` dropped here while still borrowed32 | println!(&quot;The longest string is &#123;&#125;&quot;, result); | ------ borrow later used hereFor more information about this error, try `rustc --explain E0597`.error: could not compile `life_cycle` due to previous error 这个报错的含义是，为了让 result 这个变量在打印时是有效的，那么 string2 必须在外部作用域结束之前一直保持有效，因为在函数声明中参数和返回值都使用了相同的生命周期。 在上例中，尽管 string1 的长度大于 string2 的长度，函数返回的是 string1 的引用，但是编译器并不知道这一点，编译器只知道 longest 函数返回引用的生命周期是 x 和 y 生命周期比较短的那个。 深入理解生命周期 指定生命周期参数的方式依赖于函数所做的事情，在上面的例子中，若 longest 函数改为： 123fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; x&#125; 这个时候，函数只返回变量 x，而与 y 无关，因此无需为 y 指定生命周期。 从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配 如果返回的引用没有指向任何参数，那么他只能引用函数内创建的值 这就是悬垂引用，该值在函数结束时就走出了作用域，见下面的例子 1234567891011fn test02() &#123; let string1 = String::from(&quot;Congratulations&quot;); let string2 = &quot;fantastic&quot;; let result = longest(string1.as_str(), string2); println!(&quot;The longest string is &#123;&#125;&quot;, result);&#125;fn longest&lt;&#x27;a&gt; (x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; let res = String::from(&quot;abc&quot;); res.as_str()&#125; 上面的代码中，longest 函数中返回了局部变量 res，当函数执行完毕时，局部变量 res 所指向的内存已经被释放掉，因此 test02 中的 result 变量指向的 res 内存已经被清理，这就造成了悬垂引用，非常类似于 C/C++ 的野指针。 那么我就是想返回函数中的局部变量，应该怎么办呢？解决办法也很简单，就是直接返回这个值而不是返回引用，这样就将变量的所有权移交出去了，如下所示： 1234fn longest&lt;&#x27;a&gt; (x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; String &#123; let res = String::from(&quot;abc&quot;); res&#125; 因此从根本上讲，生命周期这种语法规则，是用来关联函数的不同参数及返回值之间的生命周期，一旦他们取得了某种联系，rust 就会获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其他违反内存安全的行为。 Struct 定义中的生命周期标注struct 里可以包括： 自持有类型（类似于 i32 等） 引用：需要在每个引用上添加生命周期标注 123456789101112struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;fn test04() &#123; let novel = String::from(&quot;Today is Tuesday. And I will take part in a meeting.&quot;); let first_sentence = novel.split(&quot;.&quot;).next().expect(&quot;Can&#x27;t find a &#x27;.&#x27;&quot;); let i = ImportantExcerpt &#123; part: first_sentence, &#125;;&#125; 生命周期的省略每个引用都有生命周期，需要为使用生命周期的函数或 struct 指定生命周期参数 但是下面这个例子，没有任何生命周期的标注，仍然可以通过编译： 123456789fn first_word(s: &amp;str) -&gt; &amp;str &#123; let byte = s.as_bytes(); for (i, &amp;item) in byte.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; return &amp;s[0..i]; &#125; &#125; &amp;s[..]&#125; 按照原来的 rust 规范，函数声明、参数和返回类型前都是要加上生命周期标注的，但是 rust 团队发现程序员总是一遍又一遍地标注同样的生命周期，而且这些场景是可以预测的，有着明确的模式，因此 rust 团队就将这些模式写入了编译器，使得借用检查器可以自动对这些模式进行推导而无需显式标注。 生命周期省略规则 在 Rust 引用分析中所编入的模式称为生命周期省略规则 这些规则无需开发者来遵守 它们是一些特殊情况，由编译器来考虑 如果你的代码符合这些情况，那么就无需显式标注生命周期 生命周期省略规则不会提供完整的推断： 如果应用规则后，引用的生命周期仍然模糊不清→编译错误 解决办法：添加生命周期标注，表明引用间的相互关系 输入、输出生命周期生命周期在： 函数&#x2F;方法的参数中，叫做输入生命周期 函数&#x2F;方法的返回值中，叫输出生命周期 生命周期省略的三个规则编译器使用三个规则在没有显式标注生命周期的情况下，来确定引用的生命周期 规则 1 应用于输入生命周期 规则 2、3 应用于输出生命周期 如果编译器应用完三个规则后，仍然无法确定有效的生命周期，则报错 这些规则适用于 fn 和 impl 块 规则 1： 每个引用类型都有自己的生命周期规则 2： 如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数规则 3： 如果有多个输入生命周期参数，但其中一个是 &amp;self 或 &amp;mut self，那么 self 的生命周期会被赋给所有的输出生命周期参数 生命周期省略的三个规则-例子 假设我们是编译器: fn first_word(s: &amp;str) -&gt; &amp;str &#123;&#125;fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str &#123;&#125;fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;&#125; fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;&#125;fn longest&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str &#123;&#125; 方法定义中的生命周期标注 在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样 在哪声明和使用生命周期参数，依赖于： 生命周期参数是否和字段、方法的参数或返回值有关 struct 字段的生命周期名： 在 impl 后声明 在 struct 名后使用 这些生命周期是 struct 类型的一部分 impl 块内的方法签名中 引用必须绑定于 struct 字段引用的生命周期，或者引用是独立的也可以 生命周期省略规则经常使得方法中的生命周期标注不是必须的 1234567891011121314struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn level(&amp;self) -&gt; u32 &#123; 3 &#125; fn printSome(&amp;self, words: &amp;str) -&gt; &amp;str &#123; println!(&quot;There are some words: &#123;&#125;&quot;, self.part); self.part &#125;&#125; 静态生命周期 &#39;static 是一个特殊的生命周期：整个程序的持续时间 例如：所有的字符串字面值都拥有 &#39;static 生命周期 let s: &amp;&#39;static str = &quot;I have a static lifetime.&quot;; 字符串字面值是存在二进制程序中，总是可用 为引用指定 &#39;static 之前要三思 是否需要引用在整个生命周期内都存活 一个泛型参数类型，Trait Bound 和生命周期的综合例子1234567891011121314use std::fmt::Display;fn longest_with_an announcement&lt;&#x27;a,T&gt; (x: &amp;&#x27;a str, y: &amp;&#x27;a str, ann: T) -&gt; &#x27;a strwhere T: Display,&#123; println! (&quot;Announcement! &#123;&#125;&quot;, ann); if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125; 要注意的是，生命周期也是泛型的一种。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"l2p cache 优化方案","slug":"l2p-cache-优化方案","date":"2022-06-09T06:46:03.000Z","updated":"2023-08-08T12:35:27.415Z","comments":true,"path":"32e63730.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/32e63730.html","excerpt":"l2p cache 优化方案根据已有的 cache 方案，在 SLC 模式下，由于映射表大小不到 400MB，因此将整个映射表存储在 DRAM 中。 先对这种情况的地址映射进行分析。","text":"l2p cache 优化方案根据已有的 cache 方案，在 SLC 模式下，由于映射表大小不到 400MB，因此将整个映射表存储在 DRAM 中。 先对这种情况的地址映射进行分析。 1. 映射表和全局映射目录在原先的方案中有两种映射表，一种是存放每一个 page 表项的映射表，每个表项大小为 4B，这个表项用一维数组来存储，数组的下标记录对应表项的逻辑地址。另一种表存放第一种映射表所在 page 的映射，称为 GTD（Global Table Directory，全局表目录），非常类似于二级页表。GTD 表每个表项也是 4B，也用一维数组来表示。数组下标指明逻辑页号的范围，数组元素存放对应的 page 位置。 根据 page 所设定的大小和项目所采用的硬件参数，一个 page 为 16KB，一个表项为 4B，则一个 page 可以存放 16KB&#x2F;4KB&#x3D;4K 个表项，GTD 的第一个表项指向存放逻辑地址从 0 到 4K-1 的表项所存储的页的物理地址，GTD 第二个表项则指向存放逻辑地址从 4K 到 8K-1 的表项所存储的页的物理地址。。。以此类推，最后大约需要 7 个 page 即可存储所有 GTD。 2. 物理地址的分配先对每个逻辑页分配可用的物理页，（首先确保该逻辑地址是有效的，不能重复分配逻辑地址）若该逻辑页被写过，则覆盖对应的物理页。 同时以块为单位，对每个 page 进行管理，用 free, valid, invalid 标记 page 的三种状态 3. cache 优化方案优化思路为：只将一部分最近使用的映射表以及全部 GTD 放进 DRAM，完整的映射表存放在 flash 中。采用 TPFTL 方案，DRAM 中使用两级 LRU 进行管理。基本思路如下： 缓存中的每个表项根据翻译页进行聚类，即同属于一个翻译页的表项聚合在一个 TP 结点下，TP 结点用一个 LRU 列表进行管理，而每一个 TP 结点下的所有表项也用 LRU 列表进行管理，这样便形成了两级 LRU。 用来管理 TP 结点的 LRU 列表称为页级 LRU，管理每个 TP 结点下表项的 LRU 列表被称为条目级 LRU。每个 TP 结点的热度由该结点下所有表项的平均热度所计算得出，根据这个热度值来决定该 TP 结点在页级 LRU 列表中的位置。 进行 LRU 替换时，先找出页级 LRU 中热度最低的 TP 结点，再从该结点中找出热度最低的表项进行替换，尽管其他 TP 结点中可能有比被替换的热度更低的表项。 另外缓存中还有一个计数器来维护 TP 结点的数量。 DFTL 优化方案实现步骤： 首先获得要访问的逻辑页号，检查 cache 中是否已经存在该页 若存在，直接访问对应的物理页号，将该表项标记为最近使用过，转到 10 若不存在，则进行 4 若 CMT（cached mapping table，即 DRAM 存储的部分映射表）中表项没满，转到 6 若 CMT 表项已满，则在 CMT 中使用 LRU 替换算法，找到要替换的表项，转到 7 根据逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，将其放入 DRAM 的 CMT 中，标记该表项为最近使用过，转到 10 检查该页是否被修改过 若修改过则将其写回 flash 同时修改 GTD 表，转到 6 若没有修改过，删除该表项，转到 6 完成一次逻辑页到物理页的转换，重复 1 TPFTL 优化方案 首先获得要访问的逻辑页号，根据页号检查对应的 TP 结点是否被缓存 若已缓存，检查该结点下的表项，若存在该页，转到 4，若不存在该页，转到 5 若没有缓存，则缓存不命中，转到 5 访问对应的物理页号，将该表项标记为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11 若 LRU 列表没满，转到 7 若 LRU 列表已满，则先在页级 LRU 列表中选出热度最低的 TP 结点，然后再在 TP 结点下找到热度最低的表项，转到 8 根据请求的逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，若 DRAM 中没有缓存该 TP 结点，则创建新 TP 结点，若有 TP 结点而没有表项，则创建新表项，标记该表项为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11 检查该页是否被修改过 若修改过则将其写回 flash 同时修改 GTD 表，转到 7 若没有修改过，删除该表项，转到 7 完成一次逻辑页到物理页的转换，重复 1 流程图如下所示： 两级 LRU 算法实现思路1. 时间戳 通过设置一个全局时间戳，在每次替换新表项时，将表项中的流行度字段设置为当前时间戳，每个 TP 结点的平均热度由其下的所有表项的热度的平均值决定。 但是这样会导致两个严重的问题： 全局时间戳是一个有范围的整型，系统到一定阶段一定会溢出，这时时间戳就会归零。归零之后表项记录热度所表示的时间戳较小，但是却是最近使用过的； 当时间戳较大时（快要到整型所表示的范围时），需要计算 TP 结点的平均热度，这时需要将结点下所有表项的热度相加再取平均，在相加求和的过程中，采用一般的直接相加的方法将会导致溢出。 2. 访问次数 将每个表项的时间戳字段改成访问次数，即根据访问次数来进行替换，先替换访问次数少的，当访问次数相同时，再根据先后次序进行替换。 这样仍然会产生两个问题： 只能体现 “最久” 未使用，而不能体现出 “最近”，若一个刚刚被访问的新的表项，访问次数显然为 1，但是它却是刚来的，显然不能被替换； 对于两级 LRU，需要计算 TP 结点的平均热度，通过平均访问次数也无法体现出 “最近”，即若一个 TP 结点下频繁发生替换（即命中率不高），那么平均访问次数偏低，但是该 TP 结点却是最近访问的。 3. 命中或替换一个表项时将该表项计数器清零 另一种实现思路是命中或替换一个表项时，将该表项的计数器清零，其余的表项加一，TP 结点下所有表项的计数器平均值越低说明该 TP 结点热度越高。 尽管这样不会出现计数器溢出，但是会导致一个问题： 若命中 TP1 结点下的某一表项，将该表项清零后只将该 TP1 结点的其他表项计数器加一，这样仍然会导致算法不能体现出 “最近”（即频繁访问的 TP 结点由于很多计数器被加了一从而导致该 TP 结点计数器平均值较高）。 提出两种解决方案： 在将命中或替换的表项计数器归零时，遍历所有 TP 结点和 TP 结点下的所有表项，将内存中所有表项的计数器全部加一，但是这样可能会导致极大的时间开销（具体的时间开销占比还不清楚，不知道系统是否能容忍这样的时间开销）； 在 TP 结点上再增加一个字段，用来记录在下一次命中自己之前，其他 TP 结点中命中或替换的次数，等待下次自己被命中时，再将 TP 结点下所有表项的计数器加上该字段值。 最终解决方案 综合考虑后，最终的解决方案在访问次数的基础上进行改进。表项级 LRU 列表以访问的先后顺序进行排序，最新访问的表项插入链表的头部，同时维护一个访问次数字段，TP 结点平均热度就是访问次数的平均值。尽管这样可能会使得最近访问的表项的 TP 结点成为热度最低的结点，但这已经是相对完善且资源消耗较少的方案。每个表项的热度被页面级热度所掩盖，这导致利用时间局部性的效率较低。由于缓存空间利用率的提高，缓存命中率略有提高。 4. 结构体定义在原来 l2p 模块基础上新增以下结构体。 1234567891011121314151617181920212223242526272829303132/** * 页级 LRU 列表 */typedef struct _tp_node_list &#123; list_node tp_list_node; // tp 链表头结点 u32 entry_per_tp_node[MAX_TP_NODE]; // 存储每个 tp 结点下有多少表项的表，0 表示当前 tp 结点不存在 u32 tp_node_num; // 有效 TP 结点数量 tp_node *lru_tp_node; // 热度最低（最近最久未使用）的 TP 结点 u32 total_entry_num; // 总表项个数，代表缓存中映射表总容量&#125; tp_node_list;typedef union _tp_entry_node &#123; /* TP 结点数据结构 */ struct &#123; u16 tvpn; // 虚拟翻译页号 u16 entry_num; // 结点下表项数量 u32 ava_popular; // 结点平均热度 list_head entry_list; // 表项链表头结点 list_node tp_node; // tp 链表结点 &#125; tp_node; /* 每个 TP 结点下的表项结点 */ struct &#123; list_node entry_node; // 表项链表结点 psa_entry entry; // psa 结构体，存储 l2p 映射表项 u32 popular; // 表项热度 u32 reserve; // 填充空间，为了结构体和 tp_node 占用空间一样 &#125; entry_node;&#125; tp_entry_node; 下面是结构体之间的关系图。 5. 函数定义在原有 l2p 模块中函数基础上，新增以下函数。 12345678910111213141516171819202122232425262728/** * 获得最近最久未使用的映射表项。 * 在表项链表头结点的前一个结点，（即整个链表的最后一个结点）就是最近最久未使用的表项 */entry_node *l2p_get_least_recent_used_entry(tp_node *entry_list);/** * 当 DRAM 中有表项变化时，更新所有 TP 结点的流行度，更改 tp_node_list 结点信息。 * 当进行替换时，表项会进行变化，同样带来 TP 结点的热度变化，调用函数获得热度最低的 TP 结点，更新字段。 * 该 TP 结点的热度由 tp_node 结构体中 ava_popular 字段指定，该字段由 TP 结点下所有表项的热度之和除以表项数量得出（取整即可）。 * 循环以 tp_node_list 为头结点的链表，选出热度最低的 TP 结点。（算法待定，暂时用循环解决） */void l2p_update_tp_node_list();/* 判断当前的逻辑子页号所属的 TP 结点是否被缓存 */boolean l2p_is_TP_node_cached(l2p_table_index lsn);/* 检查 tp_node_list 结点下的 total_entry_num 字段，判断当前所给内存是否已满 */boolean l2p_is_DRAM_empty();/* 根据物理地址从闪存中读取相应表项放到内存中 */void l2p_read_entry_from_flash(psa_entry *psa);/* * 将被修改的表项写回闪存。 * 有一个小问题：表项在内存中需要有热度字段，在闪存中则无需该字段。 */boolean l2p_write_the_modified_entry_back_to_flash(l2p_table_entry *l2p_entry); 原来模块中的函数定义如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 设置当前 l2p 表项无效 */static inline void l2p_invalid_l2p_entry(l2p_table_index lsn);/* 设置当前 l2p 表项有效 */static inline void l2p_valid_l2p_entry(l2p_table_index lsn);/* 判断当前标状态是否有效 */static inline boolean l2p_if_l2p_entry_valid(l2p_table_index lsn);/* 判断两个 psa 表项所表示的 psa 是否相等 */static inline boolean l2p_if_psa_equal(psa_entry *a, psa_entry *b);/* psa + 1 */static inline boolean l2p_inc_psa(psa_entry *psa);/* 从 block 结构体的 page 状态字段中得到子页的状态 */static inline BIT l2p_get_subpage_status(bitmap_t T, psa_entry psa);/* 设置子页的状态 */static inline void l2p_set_subpage_status(bitmap_t T, psa_entry *psa, BIT bit);/* 初始化 block table，为其分配内存 */static void l2p_init_block_table();/* 给 l2p_table 指针分配地址，初始化 l2p_table */static void l2p_init_l2p_table();/* 初始化 global_table 指针，分配地址，初始化 global_table*/static void l2p_init_global_table();/* 根据逻辑子页号（lsn）查找相应的 l2p 表项 */static boolean l2p_search_l2p_entry(l2p_table_index lsn, l2p_table_entry *l2p_entry);/* 修改逻辑子页号 lsn 对应的 l2p 表项，并设置该表项为有效 */static void l2p_update_l2p_table(l2p_table_index lsn, l2p_table_entry l2p_entry);/* ？ */static psa_entry l2p_get_new_psa();/* */static psa_entry l2p_get_and_update_global_psa();/* 初始化 L2P 模块，为 global_psa 分配内存*/void l2p_init_l2p_module();/* 根据逻辑子页号 lsn 获得一个 l2p entry，此函数是提供给别的模块的 API*/l2p_table_entry l2p_get_l2p_entry(l2p_table_index lsn, u32 opcode, u32 is_searched);/* 根据逻辑子页号 lsn 获得对应表项的翻译页所在的全局翻译目录（GTD） 的表项 */global_table_entry l2p_get_global_table_entry(l2p_table_index lsn); 6. 全局变量在原有 l2p 模块中全局变量的基础上，新增以下全局变量。 1tp_node_list *tp_list; // 管理所有 tp 结点的链表头结点 原有的全局变量如下。 1234567psa_entry global_psa; // 记录下一个待分配地址block_entry *block_table; // 用来记录每个 block，指向一个一维数组的指针global_table_entry *g_table; // 用来记录 global_table，指向一个一维数组的首地址l2p_table_entry *l2p_table; // 用来记录 l2p_table，指向一个一维数组的首地址 疑问 psa 地址更新的优先级为什么是 subpage-&gt;plane-&gt;ch-&gt;ce-&gt;lun-&gt;block-&gt;page? 代码中有两处疑问： l2p.h Line: 42（lun: 1？） l2p.h Line: 48（slc_ppa？） 为什么要记录下一个即将分配的 subpage 物理地址，记录当前的是否能够起到同样的逻辑？ u8 free[PAGE_PER_BLOCK / 8 + 1][PAGE_SIZE / SUB_PAGE_SZ]; 除以 8 是什么意思？（l2p.h Line: 75） 附 psa：physical subpage address，物理子页地址 GTD：global table directory，全局表目录 CMT：cached mapping table，缓存的映射表，存放在 DRAM 中 TP：translation page 一些问题 是否要进行指令缓存，有竞争情况，是否加锁 DFTL 要改成 TPFTL 更新页级 LRU 和条目级 LRU 列表算法 192MB DRAM 给定 TP 结点数量？TP 结点和 entry 结点总和为 8M 个 读写 flash 步骤：先 FCL_get_free_SQ_entry(u32 ch)，返回得到 SQ index，ch 是约定的 flash 中 l2p 表地址的 channel，然后 FCL_set_SQ_entry，最后 FCL_send_SQ_entry 申请一个空的 SQ_entry 之后，如何将参数写入 SQ_entry？ void FCL_set_SQ_entry(u32 hcmd_entry_index, u32 SQ_entry_index, u32 buffer_index, u32 opcode, phy_page_addr *ppa, u32 cmd_sp) 里的参数含义，怎么使用？（hcmd_entry_index、cmd_sp 为 0 即可，buffer_index 是内存中你要读写的地址，phy_page_addr 是你要写入的 flash 的地址，全部自己指定） 若读取 flash 中的数据，send SQ_entry 之后，通过哪些接口取得该数据？ block_entry *block_table; 用来记录 block 中 page 的状态，指向一个 4 维数组的首地址，访问数组元素的形式可为 block_table[ch][ce][lun][plane]（应该是 block_table[ch][ce][lun][plane][block]？） 重新定义了结构体，TP 结点和 entry 结点数量总和为 8M，每个 tp 结点或 entry 结点结构体大小为 20B，总大小约为 160MB，可映射约 8MB * 4KB &#x3D; 32GB 的闪存空间。加上结点的状态位 8MB，一共占用空间约为 168MB block_table 记录的是闪存块中每个页的状态，该数据从何处读取 g_table 和 l2p 表在闪存中有固定的位置，该位置由谁指定？ LRU 实现策略","categories":[{"name":"OpenSSD","slug":"OpenSSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/"},{"name":"文档","slug":"OpenSSD/文档","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"文档","slug":"文档","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%96%87%E6%A1%A3/"}]},{"title":"Rust入门教程（六）：泛型和特性","slug":"Rust入门教程（六）","date":"2022-06-01T04:08:18.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"fb8de022.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/fb8de022.html","excerpt":"Rust入门教程（六）：泛型和特性 泛型是一个编程语言不可或缺的机制。C++ 语言中用”模板”来实现泛型，而 C 语言中没有泛型的机制，这也导致 C 语言难以构建类型复杂的工程。泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。","text":"Rust入门教程（六）：泛型和特性 泛型是一个编程语言不可或缺的机制。C++ 语言中用”模板”来实现泛型，而 C 语言中没有泛型的机制，这也导致 C 语言难以构建类型复杂的工程。泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。 [toc] 1. 泛型1.1 泛型介绍 泛型可以提高代码复用能力，也就是处理重复代码的问题 泛型是具体类型或其它属性的抽象代替: 你编写的代码不是最终的代码，而是一种模板，里面有一些“占位符” 编译器在编译时将占位符替换为具体的类型 例如：fn largest&lt;T&gt;(list: &amp;[T]) -&gt;T &#123;...&#125; 类型参数 很短，通常一个字母 CamelCase T: type 的缩写 1.2 在函数定义中使用泛型泛型函数 参数类型 返回类型 123456789101112131415fn main() &#123; let a = vec![10, 80, 2022, 36, 47]; let largest = largest(&amp;a); println!(&quot;The largest ele is &#123;&#125;&quot;, largest);&#125;fn largest(list: &amp;[i32]) -&gt; i32 &#123; let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 上面这段代码是求一个集合中最大的元素，我们定义的集合是一个 i32 类型，但是这时如果我们要传入 f32 或者字符型，还用同样的逻辑判断函数的话，是会报错的，这时我们就需要用到泛型。 123456789fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 我们声明了一个泛型 T，但是这样是会编译报错的，因为不是所有类型 T 都可以进行大小比较，只有实现了下面的 std::cmp::PartialOrd 的 trait 才能进行大小比较，所以要对 T 进行约束。 1234567891011121314151617➜ ~/Code/rust/pattern git:(master) ✗ cargo run Compiling pattern v0.1.0 (/home/cherry/Code/rust/pattern)error[E0369]: binary operation `&gt;` cannot be applied to type `T` --&gt; src/main.rs:10:17 |10 | if item &gt; largest &#123; | ---- ^ ------- T | | | T |help: consider restricting type parameter `T` |7 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123; | ++++++++++++++++++++++For more information about this error, try `rustc --explain E0369`.error: could not compile `pattern` due to previous error 但是把 std::cmp::PartialOrd 这个 trait 加上又会报其他错误，这里在后面会进行介绍。 1.3 结构体中的泛型可以使用多个泛型的类型参数，但是也不要有太多的类型，否则代码可读性将会下降。例如： 12345678struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn test01() &#123; let integer = Point&#123;x: 2022, y: 6.1&#125;; &#125; 1.4 Enum定义中的泛型可以让枚举的变体持有泛型数据类型，例如：Option, Result&lt;T, E&gt; 123456789enum Option&lt;T&gt; &#123; Some(T), None&#125;enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; 1.5 方法定义中使用泛型12345678910fn test01() &#123; let integer = Point&#123;x: 2022, y: 61&#125;; println!(&quot;&#123;&#125;&quot;, integer.x());&#125;impl&lt;T&gt; Point&lt;T&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125; 注意 把 T 放在 impl 关键字后，表示在类型 T 上实现方法 例如：impl&lt;T&gt; Point&lt;T&gt; 只针对具体类型实现方法（其余类型没实现方法） 例如: impl Point&lt;f32&gt; struct 中的泛型参数可以和方法的泛型参数不同 123456789101112131415161718192021impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; fn x(&amp;self) -&gt; &amp;T &#123; &amp;self.x &#125;&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; fn mixup&lt;V, W&gt;(self, other: Point&lt;V,W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y &#125; &#125;&#125;fn test02() &#123; let p1 = Point&#123;x: 61, y: 85&#125;; let p2 = Point&#123;x: &quot;Hello&quot;, y: &quot;Rust&quot;&#125;; let p3 = p1.mixup(p2); println!(&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;, p3.x, p3.y);&#125; 上面实现的结构体方法实际上是将第一个 Point 中的 x 和第二个 Point 的 y 结合起来形成一个新的 Point。 1.6 泛型代码的性能使用泛型的代码和使用具体类型的代码运行速度是一样的 单态化（monomorphization） 在编译时将泛型替换为具体类型的过程 1234567891011121314151617let ingeter = Some(5);let float = Some(5.0);enum Option_i32 &#123; Some(i32), None&#125;enum Option_f32 &#123; Some(f32), None&#125;fn main() &#123; let integer = Option_i32::Some(5); let float = Option_f64::Some(5.0);&#125; 2. trait Trait 告诉 Rust 编译器 某种类型具有哪些并且可以与其它类型共享的功能 Trait：抽象的定义共享行为 Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型 Trait与其它语言的接口（interface）类似，但有些区别 2.1 定义一个 TraitTrait的定义：把方法签名放在一起，来定义实现某种目的所必需的一组行为。 关键字：trait 只有方法签名，没有具体实现 trait 可以有多个方法：每个方法签名占一行，以 ; 结尾 实现该 trait 的类型必须提供具体的方法实现 123pub trait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125; 2.2 在类型上实现 trait 在类型上实现 trait。与为类型实现方法类似 不同之处：impl Xxxx for Tweet &#123;...&#125; 在 impl 的块里，需要对 Trait 里的方法签名进行具体的实现 文件 lib.rs： 1234567891011121314151617181920212223242526272829pub trait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String&#125;impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content) &#125;&#125; 文件 main.rs： 1234567891011121314use trait_demo::Summary;use trait_demo::Tweet;fn main() &#123; let tweet = Tweet &#123; username: String::from(&quot;Cherry_ICT&quot;), content: String::from(&quot;People in Shanghai are free today...&quot;), reply: false, retweet: false &#125;; println!(&quot;Get 1 new tweet: &#123;&#125;&quot;, tweet.summarize());&#125; 实现的功能很简单，不做具体解释了。 2.3 实现 trait 的约束 可以在某个类型上实现某个 trait 的前提条件是 这个类型或这个 trait 是在本地 crate 里定义的 无法为外部类型来实现外部的trait 这个限制是程序属性的一部分（也就是一致性） 更具体地说是孤儿规则：之所以这样命名是因为父类型不存在 此规则确保其他人的代码不能破坏您的代码，反之亦然 如果没有这个规则，两个 crate 可以为同一类型实现同一个 trait，Rust 就不知道应该使用哪个实现了 默认实现 默认实现的方法可以调用 trait 中的其他方法，即使这些方法没有默认实现，但是注意，无法从方法的重写实现中调用默认实现。 1234567pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;(Read more from &#123;&#125; ...)&quot;, self.summarize_author()) &#125; fn summarize_author(&amp;self) -&gt; String;&#125; 在 trait 中可以有方法的默认实现，在默认实现的基础上，类型可以对该 trait 进行重载。同样，在 trait 中默认实现的方法可以实现 trait 中其他方法。 附刚刚 trait 例子的完整代码如下： lib.rs： 1234567891011121314151617181920212223242526272829303132333435363738394041pub trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;(Read more from &#123;&#125; ...)&quot;, self.summarize_author()) &#125; fn summarize_author(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123; pub headline: String, pub location: String, pub author: String, pub content: String&#125;impl Summary for NewsArticle &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location) &#125; fn summarize_author(&amp;self) -&gt; String &#123; format!(&quot;@&#123;&#125;&quot;, self.author) &#125;&#125;pub struct Tweet &#123; pub username: String, pub content: String, pub reply: bool, pub retweet: bool&#125;impl Summary for Tweet &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content) &#125; fn summarize_author(&amp;self) -&gt; String &#123; format!(&quot;@&#123;&#125;&quot;, self.username) &#125;&#125; main.rs： 1234567891011121314151617181920212223use trait_demo::Summary;use trait_demo::Tweet;use trait_demo::NewsArticle;fn main() &#123; let tweet = Tweet &#123; username: String::from(&quot;Cherry_ICT&quot;), content: String::from(&quot;People in Shanghai are free today...&quot;), reply: false, retweet: false &#125;; println!(&quot;Get 1 new tweet: &#123;&#125;&quot;, tweet.summarize()); let news = NewsArticle &#123; headline: String::from(&quot;WWDC will be held in June 7th&quot;), location: String::from(&quot;USA&quot;), author: String::from(&quot;Tim Cook&quot;), content: String::from(&quot;The Apple will take us a lot of devices.&quot;), &#125;; println!(&quot;You receive a news: &#123;&#125;&quot;, news.summarize());&#125; 最终输出结果为： 123456➜ ~/Code/rust/trait_demo git:(master) ✗ cargo run Compiling trait_demo v0.1.0 (/home/cherry/Code/rust/trait_demo) Finished dev [unoptimized + debuginfo] target(s) in 0.33s Running `target/debug/trait_demo`Get 1 new tweet: Cherry_ICT: People in Shanghai are free today...You receive a news: WWDC will be held in June 7th, by Tim Cook (USA) 2.4 实现 Trait 作为参数 impl Trait 语法：适用于简单情况 Trait bound 语法：可用于复杂情况 impl trait 语法实际上是 trait bound 语法的语法糖 使用 + 指定多个 trait bound Trait bound 使用 where 子句 在方法签名后指定 where 子句 12345678910111213pub trait Summary &#123;&#125;pub struct NewsArticle &#123;&#125;impl Summary for NewsArticle &#123;&#125;pub struct Tweet &#123;&#125;impl Summary for Tweet &#123;&#125;pub fn notify(item: impl Summary) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 这是采用 impl Trait 的语法，这里的 notify 方法要求传入的参数可以是 NewsArticle 类型或者是 Tweet 类型，也就是要求参数要实现 Summary 这个 trait，从而使用 summarize 这个方法。 123pub fn notify&lt;T: Summary&gt;(item: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 这是采用 Trait bound 的写法，下面这个例子讲展示出这种写法的优势： 123pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 当有多个参数时，采用这种写法可以使得代码相对简洁一些。 使用 + 指定多个 trait bound： 1234567pub fn notify1(item: impl Summary + Display) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125;pub fn notify&lt;T: Summary + Display&gt;(item: T) &#123; println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125; 然而如果一个函数中参数过多，那么整个函数声明就会变得非常长，不太直观，可读性差，这里可以使用 where 子句来指定 trait 的约束： 123pub fn notify2&lt;T: Summary + Display, U: Clone + Debug&gt;(a: T, b: U) -&gt; String &#123; format!(&quot;Breaking news! &#123;&#125;&quot;, a.summarize())&#125; 这个例子中函数签名太长，不够直观，采用 where 子句可以使得更加直观： 1234567pub fn notify3&lt;T, U&gt;(a: T, b: U) -&gt; Stringwhere T: Summary + Display, U: Clone + Debug,&#123; format!(&quot;Breaking news! &#123;&#125;&quot;, a.summarize())&#125; 2.5 实现 Trait 作为返回类型 impl trait 语法 注意：impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错 1234567pub fn notify4(flag: bool) -&gt; impl Summary &#123; if flag &#123; NewsArticle &#123;...&#125; &#125; else &#123; Tweet &#123;...&#125; &#125; &#125; 这样的话这个函数便没有了确定的返回类型，这样便会报错。 2.6 使用 trait bound 实现之前泛型 的例子我们再来看一下之前的代码。解决如下： 123456789fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 之前我们说过，实际上比较大小的运算符是实现了 std::cmp::PartialOrd 这样一个 trait，因此我们需要指定实现这个 trait 的泛型才能进行大小比较。 但是这样改完后又会出现一个问题： 12345678910111213141516171819202122232425➜ ~/Code/rust/pattern git:(master) ✗ cargo run Compiling pattern v0.1.0 (/home/cherry/Code/rust/pattern)error[E0508]: cannot move out of type `[T]`, a non-copy slice --&gt; src/main.rs:10:19 |10 | let mut largest = list[0]; | ^^^^^^^ | | | cannot move out of here | move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait | help: consider borrowing here: `&amp;list[0]`error[E0507]: cannot move out of a shared reference --&gt; src/main.rs:11:18 |11 | for &amp;item in list &#123; | ----- ^^^^ | || | |data moved here | |move occurs because `item` has type `T`, which does not implement the `Copy` trait | help: consider removing the `&amp;`: `item`Some errors have detailed explanations: E0507, E0508.For more information about an error, try `rustc --explain E0507`.error: could not compile `pattern` due to 2 previous errors 报错原因是：无法从 list 中移除 T，因为没有实现 Copy trait，建议采用借用 因为上面两个 vector 中的元素分别为整型和字符型，这两种类型有确定的大小并且都是存储在栈中，因此都实现了 Copy trait，于是在 T 的 trait 约束中再加上 Copy 即可： 123456789fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 但是如果将 vec 中元素类型改为 String，那么又会报错，因为 String 是存储在堆中，没有实现 Copy trait，但是实现了 Clone trait 12let str_list = vec![String::from(&quot;Hello&quot;), String::from(&quot;World&quot;)];let largest = get_max_ele(&amp;str_list); 我们将 T 加上 Clone 约束，去掉 Copy 约束： 123456789fn get_max_ele&lt;T: PartialOrd + Clone&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0]; for &amp;item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 这样又会出现错误： 123456789error[E0508]: cannot move out of type `[T]`, a non-copy slice --&gt; src/main.rs:21:23 |21 | let mut largest = list[0]; | ^^^^^^^ | | | cannot move out of here | move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait | help: consider borrowing here: `&amp;list[0]` 是因为这里 list[0] 是字符串切片，是一个借用，没有所有权，因此一个借用给一个变量赋值，这个借用对应的类型必须要实现 Copy trait。因此在 list 前面加上引用，并且将 item 也设为引用，最后返回 &amp;T。 123456789fn get_max_ele&lt;T: PartialOrd + Clone&gt;(list: &amp;[T]) -&gt; &amp;T &#123; let mut largest = &amp;list[0]; for item in list &#123; if item &gt; largest &#123; largest = item; &#125; &#125; largest&#125; 若要最后还是返回 T，则可以使用 clone 方法： 123456789fn get_max_ele&lt;T: PartialOrd + Clone&gt;(list: &amp;[T]) -&gt; T &#123; let mut largest = list[0].clone(); for item in list &#123; if item &gt; &amp;largest &#123; largest = item.clone(); &#125; &#125; largest&#125; 2.7 使用 Trait Bound 有条件的实现方法在使用泛型类型参数的 impl 块上使用 Trait bound，我们可以有条件的为实现了特定 Trait 的类型来实现方法 1234567891011121314151617181920struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y &#125; &#125;&#125;impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmd_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;&#125;&quot;, self.y); &#125; &#125;&#125; 也可以为实现了其它 Trait 的任意类型有条件的实现某个 Trait 为满足 Trait Bound 的所有类型上实现 Trait 叫做覆盖实现 （blanket implementations） 1impl&lt;T: fmt::Display&gt; Tostring for T &#123;&#125; 含义为：为实现了 Display trait 的类型实现 ToString trait，而 ToString 中实现了 to_string 方法。 例如 let s = 3.to_string();","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"C语言代码规范","slug":"C语言代码规范","date":"2022-05-30T04:57:42.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"d5e60d4a.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/d5e60d4a.html","excerpt":"C 语言代码规范","text":"C 语言代码规范 一、命名规范1. 变量命名 小驼峰式：firstName，hexToBinary下划线式：first_name，hex_to_binary不要使用非常见单词的缩写，类似 FTL 这种可以缩写，但是 hexToBinary 不要写成 htb 2. 常量命名 全部大写，单词之间用下划线分隔，OUT_OF_BOUND_EXCEPTION_CODE，也不要使用缩写 3. 函数及结构体命名 下划线式？小驼峰式？ 小驼峰式：firstName，hexToBinary下划线式：first_name，hex_to_binary 二、注释1. 文件开头注释类似这样的注释 123456/* * Date: *** * Author: *** * Version: *** * Description: *** */ 2. 变量声明注释和变量声明同一行，用 // 注释，例如： 12int cacheCapacity = 1024; // cache 容量bool isEndState = false; // 是否到了终止状态 注释尽量用 tab 全对齐 3. 函数功能注释函数体前对函数进行注释，注明函数功能，参数类型及含义，返回值类型及含义，例如： 12345678910/** * 函数功能描述 * * @param parm1 该参数的含义 * @return 若有返回值，则注明返回值含义或其他说明 */int func(int parm1) &#123; // ... return OK;&#125; 4. 代码块注释在函数内对某一个代码块进行注释，使用 /* 注释，例如： 123456789101112void func() &#123; /* * 代码块功能说明 */ if (statement) &#123; // ... &#125; foo(); ...&#125; 当循环或条件判断嵌套过多时，在代码块的结束部分加上注释标记，例如： 12345if (...) &#123; while (index &lt; MAX_INDEX) &#123; // TODO &#125; // 结束 while (index &lt; MAX_INDEX)&#125; // 结束if (...) 三、排版1. 空格和换行if, while 等和后面的括号之间要有一个空格，当有多个参数时，逗号后面也要有一个空格。所有的二元运算符，除了”.”，应该使用空格将之与操作数分开，一元操作符和操作数之间不要加空格。注释和注释标记之间需要一个空格，空行中不要有空格。 123456789101112131415struct ListNode &#123; int num;&#125; LinkList; // 注意这里 &#125; 后面有一个空格 if (num == 1) &#123; // 注意 if 与 &#x27;(&#x27; 之间有一个空格，元素 &#x27;1&#x27; 和 num 与操作符 &#x27;==&#x27; 之间有一个空格 // TODO&#125;void func(int a, int b, int c) &#123; // TODO&#125;// 注释与双斜杠中间需要一个空格/* 这种类型的注释与 &#x27;/*&#x27; 中间也需要一个空格 */ 另外，函数体内逻辑相关的功能的某些代码中间可以加上空行进行区分，例如： 123456789int func() &#123; char hex[10]; char bin[40]; hex = getHex(); hexToBinary(hex, bin); return OK;&#125; 一行代码太长时需要换行，尽量在运算符前换行，并且缩进是八个空格（两个 tab），比如： 12345if ((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4) || !(condition5 &amp;&amp; condition6)) &#123; doSomethingAboutIt(); &#125; 2. 花括号形式花括号在函数名在同一行 123void func() &#123; // TODO&#125; 不在同一行 1234void func()&#123; // TODO&#125; 四、其他 尽量不使用全局变量，尽量将变量作用域限定到最小，例如局部变量或者静态全局变量，重要全局变量尽量使用 getter 及 setter 调用。局部变量最好要初始化。 将指针释放后要将指针置空，否则可能会导致野指针，例如 123456int *p = (int*)malloc(sizeof(int) * 5);if (p != NULL) &#123; free(p); p = NULL;&#125; 3.","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"Rust入门教程（五）：错误处理","slug":"Rust入门教程（五）","date":"2022-05-20T09:10:27.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"1bd17c37.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1bd17c37.html","excerpt":"Rust入门教程（五）：错误处理","text":"Rust入门教程（五）：错误处理 一、panic!1.1 Rust 错误处理概述 Rust 的可靠性：错误处理 大部分情况下：在编译时提示错误，并处理 错误的分类 可恢复 例如文件未找到，可再次尝试 不可恢复 bug，例如访问的索引超出范围 Rust 没有类似异常的机制 可恢复错误：Result&lt;T, E&gt; 不可恢复：panic! 宏 1.2 不可恢复的错误与 panic! 当 panic! 宏执行 你的程序会打印一个错误信息 展开（unwind）、清理调用栈（Stack） 退出程序 为应对 panic，展开或中止（abort）调用栈 默认情况下，当 panic 发生 程序展开调用栈（工作量大） Rust 沿着调用栈往回走 清理每个遇到的函数中的数据 或立即中止调用栈 不进行清理，直接停止程序 内存需要 OS 进行清理 想让二进制文件更小，把设置从“展开”改为“中止” 在 Cargo.toml 中适当的 profile 部分设置: panic = &#39;abort&#39; 使用 panic! 产生的回溯信息 panic!可能出现在 我们写的代码中 我们所依赖的代码中 可通过调用 panic! 的函数的回溯信息来定位引起问题的代码 通过设置环境变量 RUST_BACKTRACE 可得到回溯信息 Windows 下：set RUST_BACKTRACE=1 &amp;&amp; cargo run Unix 系下：RUST_BACKTRACE=1 cargo run 为了获取带有调试信息的回溯，必须启用调试符号（不带 --release） 二、Result 和可恢复的错误2.1 Result 枚举Result 枚举类型的定义： 1234enum Result&lt;T, E&gt; &#123; Ok(T), Err(E),&#125; T：操作成功情况下 Ok 变体里返回的数据的类型E：操作失败情况下 Err 变体里返回的错误的类型 处理 Result 的一种方式：match 表达式。和 Option 枚举一样，Result 及其变体也是由 prelude 带入作用域，例子如下： 123456789fn test02() &#123; let file = File::open(&quot;foo.txt&quot;); let f = match file &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(&quot;Open File Error: &#123;:?&#125;&quot;, error); &#125; &#125;;&#125; 我们鼠标悬停在 file 变量上，可以看到它的类型是：std::result::Result&lt;std::fs::File, std::io::Error&gt;，说明 open 函数返回的是一个 Result 枚举，且其第一个参数就是该文件，第二个参数是 io 下的 Error 类型，包含了错误的具体信息。 最终输出结果如下： 12345678910111213➜ ~/Code/rust/panic git:(master) ✗ cargo run Compiling panic v0.1.0 (/home/cherry/Code/rust/panic)warning: unused variable: `f` --&gt; src/main.rs:17:9 |17 | let f = match file &#123; | ^ help: if this is intentional, prefix it with an underscore: `_f`warning: `panic` (bin &quot;panic&quot;) generated 2 warnings Finished dev [unoptimized + debuginfo] target(s) in 0.46s Running `target/debug/panic`thread &#x27;main&#x27; panicked at &#x27;Open File Error: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:20:13note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 匹配不同的错误 123456789101112fn test03() &#123; let f = match File::open(&quot;foo&quot;) &#123; Ok(file) =&gt; file, Err(error) =&gt; match error.kind()&#123; ErrorKind::NotFound =&gt; match File::create(&quot;foo&quot;) &#123; Ok(file) =&gt; file, Err(error) =&gt; panic!(&quot;Creating File Error: &#123;:?&#125;&quot;, error) &#125; other_error =&gt; panic!(&quot;Open File Error: &#123;:?&#125;&quot;, other_error) &#125; &#125;;&#125; 在 Err 中也会有很多种类型的错误，我们尝试匹配不同的错误类型，例如 NotFound。 这里使用了很多 match，尽管很有用，但是比较原始。我们可以使用 闭包（closure） ，Result&lt;T, E&gt; 有很多方法，他们使用闭包作为参数，使用 match 进行实现，使用这些方法会使得代码更简洁 1234567891011fn test04() &#123; let f = File::open(&quot;foo.txt&quot;).unwrap_or_else(|error| &#123; if error.kind() == ErrorKind::NotFound &#123; File::create(&quot;foo&quot;).unwrap_or_else(|error| &#123; panic!(&quot;Creating File Error: &#123;:?&#125;&quot;, error); &#125;) &#125; else &#123; panic!(&quot;Open File Error: &#123;:?&#125;&quot;, error); &#125; &#125;);&#125; 具体内容到后面再讲。 2.2 unwrap 与 expectunwrap unwrap 是 match 表达式的一个快捷方法，如果 Result 结果是 Ok 则返回 Ok 里面的值，如果 Result 结果是 Err 则调用 panic!宏。以刚刚这段代码举例： 123456789fn test02() &#123; let file = File::open(&quot;foo.txt&quot;); let f = match file &#123; Ok(file) =&gt; file, Err(error) =&gt; &#123; panic!(&quot;Open File Error: &#123;:?&#125;&quot;, error); &#125; &#125;;&#125; unwrap 的作用类似于上面这段代码，当成功打开文件时，unwrap 就会返回 Ok 里面的值，否则就会调用 Err 代码块的代码，上面那段代码用 unwrap 就可以这样写：let f = File::open(&quot;foo.txt&quot;).unwrap(); 但是发生恐慌的信息不可以自定义，这也是 unwrap 的一个缺点，而 Rust 提供了另一个方法：expect。 expect 和 unwrap 类似，但是可以指定错误信息：let f = File::open(&quot;foo&quot;).expect(&quot;Open File Error!!!&quot;);，这样得到的报错信息如下： 12345678910111213➜ ~/Code/rust/panic git:(master) ✗ cargo run Compiling panic v0.1.0 (/home/cherry/Code/rust/panic)warning: unused variable: `f` --&gt; src/main.rs:26:9 |26 | let f = File::open(&quot;foo&quot;).expect(&quot;Open File Error!!!&quot;); | ^ help: if this is intentional, prefix it with an underscore: `_f`warning: `panic` (bin &quot;panic&quot;) generated 1 warnings Finished dev [unoptimized + debuginfo] target(s) in 0.22s Running `target/debug/panic`thread &#x27;main&#x27; panicked at &#x27;Open File Error!!!: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src/main.rs:26:31note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 2.3 传播错误当写的函数中包含可能会执行失败的调用的时候，除了可以在函数中处理这个错误，还可以将错误返回给函数的调用者，让他们来决定如何进一步处理这个错误，这就叫做 传播错误 12345678910111213141516171819fn read_text_from_file() -&gt; Result&lt;String, Error&gt; &#123; let f = File::open(&quot;foo&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(error) =&gt; return Err(error) &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(error) =&gt; Err(error) &#125;&#125;fn main() &#123; let result = read_text_from_file(); println(&quot;&#123;:?&#125;&quot;, result);&#125; 将 Result&lt;T, E&gt; 设置成函数返回值，这样就将错误传递给了调用者，若文件 foo 存在的话，最终便可以输出文件中的内容。 Rust 中还提供了 ? 运算符，用其来简化传播错误的操作。 如果 Result 是 Ok：Ok 中的值就是表达式的结果，然后继续执行程序；如果 Result 是 Err：Err 就是 整个函数 的返回值，就像使用了 return。例子如下： 123456fn read_text_from_file_easy() -&gt; Result&lt;String, Error&gt; &#123; let mut f = File::open(&quot;foo&quot;)?; let mut s = String::new(); f.read_to_string(&amp;mut s)?; Ok(s)&#125; 上面这段简化后的代码的含义就是，若 ? 前 Result 类型的值是 Ok，那么 Ok 里的值就会作为表达式的返回值进行返回，若类型是 Err，那么 Err 就当做整个函数的返回值进行返回。而 f.read_to_string(&amp;mut s)?; 中，若 Result 类型是 Ok，实际上里面值为空，没有用到，因此当表达式返回 Ok 后，返回一个 Ok(s) 作为函数的返回值，若类型为 Err，则将其作为函数返回值进行返回。 上面这个例子还可以继续进行优化，使用链式调用： 12345fn read_text_from_file_easist() -&gt; Result&lt;String, Error&gt; &#123; let mut s = String::new(); File::open(&quot;foo&quot;)?.read_to_string(&amp;mut s)?; Ok(s)&#125; **值得注意的是，要使用 ? 运算符，必须保证函数返回类型为 Result&lt;T, E&gt;**，倘若我们尝试一下函数返回类型不是 Result，将会得到这样一条报错信息：error[E0277]: the &#39;?&#39; operator can only be used in a function that returns &#39;Result&#39; or &#39;Option&#39; (or another type that implements &#39;FromResidual&#39;) 因此，? 运算符只能用于返回类型为 Result 或 Option 的函数 ? 运算符与 main 函数 main 函数返回类型是:() main 函数的返回类型也可以是：Result&lt;T，E&gt; 123456use std::error::Error as error;fn main() -&gt; Result&lt;(), Box&lt;dyn error&gt;&gt; &#123; let f = File::open(&quot;foo&quot;)?; Ok(())&#125; Box&lt;dyn Error&gt; 是 trait 对象，可以简单理解为“任何可能的错误类型”。 这样就可以在 main 函数中使用 ? 运算符了。 （开始玄学 o_o） ? 与 from 函数 Trait std:convert::From 上的 from 函数 用于错误之间的转换 被 ? 所应用的错误，会隐式的被 from 函数处理 当 ? 调用 from 函数时 它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型 用于：针对不同错误原因，返回同一种错误类型 只要每个错误类型实现了转换为所返回的错误类型的 from 函数 2.4 什么时候应该使用 panic!总体原则 在定义一个可能失败的函数时，优先考虑返回 Result，若你觉得这个错误一定无法恢复，那就可以代替调用者调用 panic! 编写示例、原型代码、测试 可以使用panic! 演示某些概念: unwrap 原型代码: unwrap、expect 测试: unwrap、expect 测试的失败是用 panic! 进行标记的 有时你比编译器掌握更多的信息 你可以确定 Result 就是 Ok，那么可以使用 unwrap，例子如下： 1234use std::net::IpAddr;fn test06() &#123; let home: IpAddr = &quot;192.168.3.110&quot;.parse().unwrap();&#125; 这里我们可以确定这个 IP 地址解析出来一定是有效的，因此可以直接使用 unwrap。 错误处理的指导性建议 当代码最终可能处于损坏状态时，最好使用 panic! 损坏状态（Bad state）：某些假设、保证、约定或不可变性被打破 例如非法的值、矛盾的值或空缺的值被传入代码 以及下列中的一条： 这种损坏状态并不是预期能够偶尔发生的事情 在此之后，您的代码如果处于这种损坏状态就无法运行 在您使用的类型中没有一个好的方法来将这些信息（处于损坏状态）进行编码 场景建议 调用你的代码，传入无意义的参数值：panic! 调用外部不可控代码，返回非法状态，你无法修复：panic! 如果失败是可预期的：Result 当你的代码对值进行操作，首先应该验证这些值：panic! 为验证创建自定义类型 创建新的类型，把验证逻辑放在构造实例的函数里。 以第一节的猜数游戏为例： 12345678910111213141516fn main() &#123; loop &#123; //... let guess = &quot;32&quot;; let guess: i32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; if guess &lt; 1 || guess &gt; 100 &#123; println!(&quot;The num must between 1 and 100&quot;); continue; &#125; //... &#125;&#125; 这样一个功能就是判断输入的数是否符合 i32 类型，若符合的话表达式返回 num，然后再判断是否在 1~100 之间，如果不满足则继续循环。如果有多个函数中都需要类似这样的判断，则代码便会显得冗余，我们可以自定义一个验证逻辑： 12345678910111213141516171819202122232425262728293031pub struct Guess &#123; value: i32&#125;impl Guess &#123; pub fn new(value: i32) -&gt; Guess &#123; if value &lt; 1 || value &gt; 100 &#123; panic!(&quot;The guess value must between 1 and 100, got &#123;&#125;&quot;, value); &#125; Guess &#123;value&#125; &#125; //类似 getter 方法 pub fn value(&amp;self) -&gt; i32 &#123; self.value &#125;&#125;fn guess_game() &#123; loop &#123; //... let guess = &quot;32&quot;; let guess: i32 = match guess.trim().parse() &#123; Ok(num) =&gt; num, Err(_) =&gt; continue, &#125;; let guess = Guess::new(guess); &#125;&#125; 如果能够成功创建 Guess 实例的话，那么就说明值通过了验证，而不需要将验证功能写在函数里了。 上述 value 方法是获得 Guess 结构体中的 value 字段值，因为结构体中的字段是私有的，外部无法直接对字段赋值。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"组会纪要","slug":"组会纪要","date":"2022-05-20T08:27:36.000Z","updated":"2023-08-08T12:35:27.418Z","comments":true,"path":"cf54ade6.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/cf54ade6.html","excerpt":"组会纪要 对每周五开会和平时讨论内容的总结整理","text":"组会纪要 对每周五开会和平时讨论内容的总结整理 8.5 组会上周任务 测试 tpftl 模块 问题总结 因 mac 架构问题，导致无法使用模拟器 内存中表项写回 flash 时机：设置阈值即可 连接 VPN 下周任务 连所里服务器继续测试 7.29 组会上周任务 编写代码 主要完成了与 flash 的读写相关逻辑 优化了读写相关逻辑 问题总结 l2p_table_entry l2p_get_l2p_entry(l2p_table_index lsn, u32 opcode, u32 is_searched)写操作时要在 flash 中分配一个空闲页，然后建立逻辑地址到物理地址的映射。通过该 API 进行写操作时，写的数据在哪？ 下周任务 继续编写代码 7.22 组会上周任务 看 12 篇论文并总结 下周任务 继续编写代码 7.15 组会上周任务 继续编写代码 问题总结下周任务 7.7 组会请假 7.1 组会上周任务 编写 tp_l2p 模块代码 学习模拟器的使用 修改文档 问题总结 修改了部分结构体，新增了部分函数 TP 结点数量设置为 1M 个，总结点数量最大也为 1M 个 如何读取和写入 flash（API） LRU 的计数器问题 LRU 可用访问次数来实现 下周任务 继续编写模块代码 6.23 组会上周完成 完成 TPFTL 设计文档 文档用 Latex 完成并推送到 doc 仓库 6.17 组会 完善 l2p 优化，使用 TPFTL 方案 增加函数接口设计，结构体设计和全局变量 （是否要重新开分支） 问题总结 用数组会浪费空间，改成链表。 list.h 链表结构体的使用 6.10 组会 搜集 HPCA 2015-2022 年相关论文并上传到仓库 阅读 Eurosys2015 那篇论文，TPFTL 阅读 Handbook，了解代码整体框架 提出 cache 优化方案 下周工作将 DFTL 方案改成 TPFTL，加上函数接口设计，结构体设计，和全局变量 6.2 组会 和大家讨论 C 语言代码规范 搜集 HPCA MSST 2012-2014 年相关论文并上传到仓库 开始阅读 l2p 相关代码 下周工作 继续阅读 l2p 代码 阅读 Eurosys2015 那篇论文 完成 cache 设计方案 5.30 代码规范 5.27 组会 阅读相关论文，学习了解 DFTL 的结构和原理 将闪存块分为数据块和翻译块，前者存放真正的数据，后者存放存放映射表，并且是在闪存的固定位置 根据工作运行情况将映射表动态调入 SRAM 先查找 SRAM 中的 CMT（Cached Mapping Table），若未找到，再根据 GTD（Global Translation Directory，类似于二级页表）将闪存中的表替换到 SRAM 中，类似于分页机制中的 TLB Cache 采用写回法，当表项替换出去的时候将其最新值写入闪存中 学习了解 SLC Cache 相关内容 下周工作 C 语言代码规范文档讨论 阅读 standard v3 仓库代码的 l2p 模块 5.20 组会进度 学习《深入浅出SSD》1.4, 2.1, 3.1 和第四章的相关内容，对 SSD 有个大致的了解，以及对 SSD 的核心 FTL 有个基本了解（深入浅出SSD（一） 深入浅出SSD（二）） 阅读相关论文，了解 FTL 中虚拟地址映射、垃圾回收、磨损均衡等核心技术 自己学了一点其他的知识 遇到的问题：刚开始阅读论文，速度较慢 建议：论文阅读关注背景、评测部分，理解论文里的思想 未来工作：L2P 优化，DFTL","categories":[{"name":"OpenSSD","slug":"OpenSSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/"},{"name":"组会","slug":"OpenSSD/组会","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/%E7%BB%84%E4%BC%9A/"}],"tags":[{"name":"组会","slug":"组会","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BB%84%E4%BC%9A/"}]},{"title":"Rust入门教程（四）：常用的集合","slug":"Rust入门教程（四）","date":"2022-05-17T06:13:27.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"1bd17c37.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1bd17c37.html","excerpt":"Rust 入门教程（四）：常用的集合这一节介绍 Rust 中常用的几种集合类型：Vector，String 和 HashMap，这些集合类型都是存储在 Heap 中，不需要编译时确定大小，可以在运行时动态改变大小。","text":"Rust 入门教程（四）：常用的集合这一节介绍 Rust 中常用的几种集合类型：Vector，String 和 HashMap，这些集合类型都是存储在 Heap 中，不需要编译时确定大小，可以在运行时动态改变大小。 [toc] 1. VectorVector 概念略，和 C++ STL 中的 Vector 差不多，下面来看使用： 创建 Vector 使用 Vec::new() 函数创建一个空 Vector，let v: Vec&lt;i32&gt; = Vec::new();（注意 V 是大写），也可以设定初始值进行创建，这时就要使用 vec! 宏，注意这里 v 是小写，let v: vec![1, 2, 3];。 更新 Vector 使用 push 方法向 vector 里添加元素 12345678fn main() &#123; let mut vec = Vec::new(); vec.push(1); vec.push(2); vec.push(3); vec.push(4);&#125; 使用 Vec::new() 创建 vector 时，需要显式指明类型，但是若下面用 push 函数添加 vector 元素时，编译器可以根据上下文推断出类型，于是便可以不用显式指定类型了。 删除 Vector 与任何其它 struct 一样，当 Vector 离开作用域后，它就被清理掉了，同时它所有的元素也被清理掉了 读取 Vector 元素 索引 get 方法 123456789fn test01() &#123; let v = vec![1, 2, 38, 4, 45]; let third = &amp;v[2]; println!(&quot;The third element is &#123;&#125;.&quot;, third); match v.get(2) &#123; Some(third) =&gt; println!(&quot;The third element is &#123;&#125;.&quot;, third), None =&gt; println!(&quot;There is no element in the vec.&quot;), &#125;&#125; 因为 Vector 的 get 方法返回一个 Option 枚举类型，因此用 Some 和 None 做模式匹配。 但是如果用索引访问的下标越界的话，就会发生 panic，但是使用 get 的话，会返回 None. 所有权和借用规则 123456fn test02() &#123; let v = vec![1, 12, 3, 4, 5]; let first = &amp;v[1]; v.push(6); println!(&quot;&#123;&#125;&quot;, first);&#125; 上面这段代码在 v.push(); 会报错，原因是 first 已经借用 v 为不可变引用，而 push 操作又将 v 变成可变的，因此会报错。 vector 之所以也有所有权和借用规则这样的机制，是因为 vector 是存储在堆中，并且数据是连续存放，如果在后面添加一个元素，而原来的内存中后面没有多余空间，则编译器将会在内存中重新寻找一块更大的内存来存放新的 vector，所以这是还是用原来 vector 的引用，就会发生错误。 实际上 C++ 中的 vector 也是这样的，但是 Rust 的语言机制从编译时就避免了，而不用等到运行时在发现错了，这也体现了 Rust 的高安全性和可靠性。下面是 C++ 中的 vector 元素首地址改变的例子，参考博客 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr; arr.push_back(1); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(2); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(3); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(4); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(5); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(6); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; arr.push_back(7); cout &lt;&lt; &quot;arr&#x27;s size :&quot; &lt;&lt; arr.size() &lt;&lt; &quot; capacity :&quot; &lt;&lt; arr.capacity() &lt;&lt; &quot; head address :&quot; &lt;&lt; arr.data() &lt;&lt; endl; return 0;&#125; 输出结果为： 1234567arr&#x27;s size :1 capacity :1 head address :0x10516fb0arr&#x27;s size :2 capacity :2 head address :0x10516e30arr&#x27;s size :3 capacity :4 head address :0x10516fb0arr&#x27;s size :4 capacity :4 head address :0x10516fb0arr&#x27;s size :5 capacity :8 head address :0x10516e30arr&#x27;s size :6 capacity :8 head address :0x10516e30arr&#x27;s size :7 capacity :8 head address :0x10516e30 我们发现每次 vector 扩容时元素首地址都会改变。（注意在 vector 中，&amp;vec 和 &amp;vec[0] 是不一样的，这是因为 vector 结构存在栈中，而 vector 的数据存在堆中，&amp;vec 获得的只是栈中 vec 的结构的地址，始终不变，而 &amp;vec[0] 是堆中 vector 存储的真正的元素地址，每次动态扩容后都会改变） 好我们回到 Rust。 遍历 vector 123456fn test03() &#123; let v = vec![1, 2, 3, 4]; for i in &amp;v &#123; println(&quot;&#123;&#125;&quot;, i); &#125;&#125; 要想修改其中的值，看下面的例子： 1234567fn test03() &#123; let mut vec![1, 2, 3, 4]; for i in &amp;mut v &#123; *i += 5; println(&quot;&#123;&#125;&quot;, i); &#125;&#125; 这里 *i 是解引用，我们以后会介绍。 使用 enum 来存储多种数据类型 vector 只能存储一种数据类型，但是我们有时候想存储不同类型的数据，我们可以用可附加数据的枚举来创建 vector。 12345678910111213enum Spreadsheetcell &#123; Int(i32), Float(f64), Text(String),&#125;fn test03() &#123; let v = vec![ Spreadsheetcell::Int(3), Spreadsheetcell::Text(String::from(&quot;Computer Science&quot;)), Spreadsheetcell::Float(6.18), ];&#125; 使用枚举的变体就可以在 vector 中存储不同类型的数据了。 2. StringString 这个数据类型是所有编程语言中都非常重要的一个类型，Rust 开发者经常会被字符串困扰的原因是，Rust 倾向于暴露可能的错误，而且字符串数据结构复杂并且采用了 UTF-8 编码。 编码类型和编码方式 在 Rust 中，字符串是 Byte 的集合，并且有一些方法将 byte 解析为文本。 字符串是什么 从 Rust 语言的核心层面上将，只有一个字符串类型，叫字符串切片 str，它通常以引用的形式出现（即 &amp;str）。 字符串切片是对存储在其他地方，用 UTF-8 编码的字符串的引用。字符串字面值：存储在二进制文件中，也是字符串切片 String 类型，来自标准库，而不是核心语言，他可增长、可修改、可拥有，采用 UTF-8 编码，我们通常所说的字符串是指 String 和 &amp;str 两者，而不是单指某一种。当然这里主要将的是 String。 其它类型的字符串 Rust 的标准库还包含了很多其它的字符串类型，例如：OsString，OsStr、CString、CStr String vs Str 后缀：拥有或借用的变体 可存储不同编码的文本或在内存中以不同的形式展现 Library crate 针对存储字符串可提供更多的选项 2.1 字符串的创建 很多 Vec&lt;T&gt; 都可用于 String 利用 String::new() 创建字符串 使用初始值来创建 String： to_string() 方法，可用于实现了 Display trait 的类型，包括字符串字面值 String::from() 函数，从字面值创建 String 类型 123456fn main() &#123; let mut s1 = String::new(); let mut s2 = String::from(&quot;Hello&quot;); let mut s3 = &quot;Hello, Rust&quot;; let mut s4 = &quot;Hello, Rust&quot;.to_string();&#125; 通过字符串字面值创建的 s3 是切片类型，其他都是 String 类型 【注】：我理解的函数就是没有 self 参数的，通过 :: 来调用，而方法则是带有 &amp;self 为其第一个参数，是通过实例来调用的，使用的是点调用的方式 2.2 字符串更新 使用 push_str() 方法，把一个字符串切片附加到 String，这个方法不会获得参数的所有权 使用 push() 方法，将一个单独的字符附加到 String 后 1234567fn test02() &#123; let mut s = String::from(&quot;Hello&quot;); let s1 = String::from(&quot;, Rust&quot;); s.push_str(&amp;s1); s1.push(&#x27;x&#x27;); println!(&quot;&#123;&#125;&quot;, s1);&#125; 这里还是可以打印出 s1 的值，说明没有获得 s1 的所有权。 + 用来连接字符串，注意加号前是字符串类型，后面是字符串类型的引用 使用了类似这个签名的方法 fn add(self, s: &amp;str) -&gt; String &#123; ... &#125; 标准库中 add 方法使用了泛型 解引用强制转换（deref coercion） 只能把 &amp;str 添加到 String format! 用于连接多个字符串 123456789fn test03() &#123; let s1 = String::from(&quot;Hello&quot;); let s2 = String::from(&quot;, Rust&quot;); let s3 = s1 + &amp;s2; println!(&quot;&#123;&#125;&quot;, s3); println!(&quot;&#123;&#125;&quot;, s1); println!(&quot;&#123;&#125;&quot;, s2);&#125; 上述例子中，我们发现 s1 不能再使用了，而 s2 可以再被使用，因为底层方法中使用了类似这个签名的方法 fn add(self, s: &amp;str) -&gt; String &#123; ... &#125;，是将字符串自身和另一个字符串的切片进行相加组合。但是 s2 是字符串类型，而函数参数中是字符串切片类型，不匹配，为什么代码 let s3 = s1 + &amp;s2; 能够编译通过？ 这是因为标准库中 add 方法使用了泛型，Rust 采用了一种叫 解引用强制转换（deref coercion） 的技术，强制将字符串类型转化成字符串切片类型，因此 s2 的所有权就会被保留，而 add 函数就会取得第一个参数的所有权，当函数调用完毕时，s1 的所有权就会消失。 123456789101112fn test04() &#123; let s1 = String::from(&quot;tic&quot;); let s2 = String::from(&quot;tac&quot;); let s3 = String::from(&quot;toc&quot;); // let s3 = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3; // println!(&quot;&#123;&#125;&quot;, s3); let res = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3); println!(&quot;&#123;&#125;&quot;, res);&#125; 上述例子中将三个字符串之间用 - 连接，如果代码太多显得很繁琐，采用 format! 宏不仅可以使得代码简单易读，更重要的是不会取得所有变量的所有权。这个宏和 println! 很像，只不过 format! 宏是将结果返回，这里可以用一个变量去接收。 2.3 字符串的索引不可以按照索引的语法对 String 某部分进行访问，因为 String 类型没有实现 Index&lt;Integer&gt; trait，例如： 1234fn test() &#123; let s = String::from(&quot;Hello&quot;); let s1 = s[0]; //这样是错误的&#125; 之所以无法通过索引进行访问是因为，字符串是用 UTF-8 进行编码，每一个字符都对应一个 Unicode 编码。在英文中，一个字符是 1B，而对于某些语言，一个字符可能对应 2B，而中文一个字符对应 3B，因此用索引进行访问的话，无法知道应该取一个字节还是两个字节。 当然 Rust 不允许通过索引进行访问的另一个原因是，索引操作理应只消耗 O(1) 的时间，但是为了保证不会越界，需要使用 O(n) 的时间进行遍历字符串长度。 String 内部表示 String 实际上是对 Vec&lt;u8&gt; 进行的包装，可以用 len() 方法获得字符串长度 字节（Bytes），标量值（Scalar Values），字形簇（Grapheme Clusters） Rust有三种看待字符串的方式： 字节 标量值 字形簇（最接近所谓的“字母”） 2.4 切割 String可以使用 [] 和 一个范围 来创建一个字符串的切片 要谨慎使用 如果切割时越过边界就会 panic 12345fn test05() &#123; let hello = String::from(&quot;你好吗&quot;); let s = &amp;hello[0..3]; println!(&quot;&#123;&#125;&quot;, s);&#125; 上面我们说了在 Rust 中一个中文字符占 3B，因此我们获取字符串 hello 的前 3 个字节，输出结果为 你，但是要注意的是，所获取的字节必须能够构成所定义的字符，比如只获取前两字节最后运行就会报错（但是编译不会报错）。 2.5 遍历 String 对于标量值：chars() 方法 对于字节：bytes() 方法 对于字形簇，过于复杂，标准库未提供 12345678910111213fn test05() &#123; let hello = String::from(&quot;你好吗&quot;); for i in hello.chars() &#123; print!(&quot;&#123;&#125; &quot;, i); &#125; println!(); for i in hello.bytes() &#123; print!(&quot;&#123;&#125; &quot;, i); &#125;&#125; 最后输出结果为： 12你 好 吗 228 189 160 229 165 189 229 144 151 String不简单 Rust 选择将正确处理 String 数据作为所有 Rust 程序的默认行为——程序员必须在处理 UTF-8 数据之前投入更多的精力 可防止在开发后期处理涉及非 ASCII 字符的错误 各种类型的编码 1967 年 ASCII，包含英文字母，阿拉伯数字，西文字符和控制字符 1980 年 GB2312，包含简体中文，拉丁字母和日文假名 1984 年 BIG5，增加了繁体字 1993 年 GB130001，包含了中日韩三国文字 1995 年 GBK，不支持韩文 2000 年 GB18030，兼容更多的字符 在 1994 年诞生的 Unicode 实现了编码的全球化。 那么这时候如何表示字符呢，英文所需要表示的二进制位和汉字所要表示的二进制位肯定是不同的，也就是说一个英文字符可能要占 1B，而汉字要占 2B，编码时都是将二进制连接在一起，那么怎么知道当前的一个字节所要表示的是英文还是中文呢？因此直接将每个字符用编号表示无法正确区分每个字符的边界。 一种解决方法是 定长编码，即每个字符都用统一长度表示，位数不够前面补 0。但是这样又出现了一个问题，一个英文字母要占两个字节，要忍受前面全是 0 的情况，只会占用更多的内存。 解决方法也很简单，可以采用 变长编码，那么如何区分字符边界呢？其实和计组中的 拓展操作码，IP 地址，哈夫曼编码 都很类似，如下图所示： 这就是 UTF-8 编码 3. HashMap和各种语言中的 HashMap 一样，也是通过键值对来存储数据，通过键（Key）来寻找数据，而不是索引 3.1 创建 HashMap 创建空 HashMap：new() 函数 添加数据：insert() 方法 123456use std::collections::HashMap;fn main() &#123; let mut hash: HashMap&lt;String, i32&gt; = HashMap::new(); hash.insert(String::from(&quot;Cherry&quot;), 23);&#125; 若声明的时候没有指定类型，则必须要插入数据才不会报错，若声明时已经指定类型了，那么不用插入数据也不会报错。 HashMap 用的较少，不在 Prelude中 标准库对其支持较少，没有内置的宏来创建 HashMap 数据存储在 heap 上 同构的。一个 HashMap 中 所有的 K 必须是同一种类型 所有的 V 必须是同一种类型 另一种创建 HashMap 的方式：collect 方法 在元素类型为 Tuple 的 Vector 上使用 collect 方法，可以组建一个 HashMap 要求 Tuple 有两个值：一个作为 K，一个作为 V collect 方法可以把数据整合成很多种集合类型，包括 HashMap 返回值需要显式指明类型 12345fn test02() &#123; let teams = vec![String::from(&quot;Suns&quot;), String::from(&quot;Lakers&quot;)]; let rank = vec![1, 20]; let nba: HashMap&lt;_, _&gt; = teams.iter().zip(rank.iter()).collect();&#125; 使用 collect 时，要显式声明返回类型，因为它可以生成各种类型。 HashMap 和所有权 对于实现了 Copy trait 的类型（例如i32），值会被复制到 HashMap 中。对于拥有所有权的值（例如String)，值会被移动，所有权会转移给 HashMap。 如果将值的引用插入到 HashMap，值本身不会移动一在 HashMap 有效的期间，被引用的值必须保持有效。 12345678910fn test03() &#123; let key = String::from(&quot;Suns&quot;); let value = String::from(&quot;Champion&quot;); let mut map = HashMap::new(); map.insert(key, value); println!(&quot;&#123;&#125; &#123;&#125;&quot;, key, value); //这里会报错，因为key和value所有权已经没有了 //通常应该是这样插入数据 map.insert(&amp;key, &amp;value);&#125; 这里在堆 HashMap 赋值之后，key 和 value 的所有权就被转移给了 HashMap，通常都是传入字符串的引用。 3.2 访问 HashMapget方法 参数：K 返回：Option&lt;&amp;V&gt; 123456789101112fn test04() &#123; let mut nba = HashMap::new(); nba.insert(&quot;Suns&quot;.to_string(), 1); nba.insert(&quot;Lakers&quot;.to_string(), 20); let team = String::from(&quot;Suns&quot;); let rank = nba.get(&amp;team); match rank &#123; Some(s) =&gt; println!(&quot;&#123;&#125;&quot;, s), None =&gt; println!(&quot;team not exist&quot;) &#125;&#125; HashMap 的 get 方法返回的是一个 Option 枚举，并且 get 方法的参数是 String 的引用。 3.3 遍历 HashMap使用 for 循环： 123456789fn test04() &#123; let mut nba = HashMap::new(); nba.insert(&quot;Suns&quot;.to_string(), 1); nba.insert(&quot;Lakers&quot;.to_string(), 20); for (k, v) in &amp;nba &#123; println!(&quot;&#123;&#125;: &#123;&#125;&quot;, k, v); &#125;&#125; (k, v) 这里是用元组做模式匹配。 3.4 更新 HashMap HashMap 大小可变 每个 K 同时只能对应一个 V 更新 HashMap 中的数据 K 已经存在，对应一个 V 替换现有的 V 保留现有的 V，忽略新的 V 合并现有的 V 和新的 V K 不存在 添加一对新的 K, V 替换现有的 V 如果向 HashMap 插入一对 (K, V)，然后再插入同样的 K，但是不同的 V，那么原来的 V 会被替换掉 123456fn test05() &#123; let mut scores = HashMap::new(); scores.insert(String::from(&quot;Suns&quot;), 115); scores.insert(String::from(&quot;Suns&quot;), 132); //覆盖 println!(&quot;&#123;:?&#125;&quot;, scores);&#125; 只在 K 不对应任何值的情况下，才插入 V entry方法 检查指定的 K 是否对应一个 V 参数为 K 返回 enum Entry：代表值是否存在 Entry 的 or_insert()方法 返回 如果 K 存在，返回到对应的 V 的一个可变引用 如果 K 不存在，将方法参数作为 K 的新值插进去，返回到这个值的可变引用 12345678fn test05() &#123; let mut scores = HashMap::new(); scores.insert(String::from(&quot;Suns&quot;), 115); scores.entry(&quot;Lakers&quot;.to_string()).or_insert(90); println!(&quot;&#123;:?&#125;&quot;, scores);&#125; 这里 scores.entry() 返回 Entry，如果没有值的话，会返回类似于 Entry(VacantEntry(&quot;Lakers&quot;)) 的枚举。 基于现有值来更新 12345678910fn test06() &#123; let text = &quot;What a wonderful world a a a&quot;; let mut map = HashMap::new(); for word in text.split_whitespace() &#123; let count = map.entry(word).or_insert(0); *count += 1; &#125; println!(&quot;&#123;:#?&#125;&quot;, map);&#125; 最终返回结果为： 123456&#123; &quot;wonderful&quot;: 1, &quot;world&quot;: 1, &quot;a&quot;: 4, &quot;What&quot;: 1,&#125; 3.5 Hash 函数默认情况下，HashMap 使用加密功能强大的 Hash 函数，可以抵抗拒绝服务（DoS）攻击。 不是可用的最快的 Hash 算法 但具有更好安全性。 可以指定不同的 hasher 来切换到另一个函数 hasher 是实现 BuildHasher trait 的类型","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"深入浅出SSD（二）：SSD核心技术：FTL","slug":"深入浅出SSD（二）：SSD核心技术：FTL","date":"2022-05-15T01:27:45.000Z","updated":"2023-08-08T12:35:27.418Z","comments":true,"path":"bd809a3f.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/bd809a3f.html","excerpt":"深入浅出 SSD（二）：SSD 核心技术：FTL 本文介绍 SSD 的核心技术 FTL（闪存转换层）","text":"深入浅出 SSD（二）：SSD 核心技术：FTL 本文介绍 SSD 的核心技术 FTL（闪存转换层） 一、FTL 综述FTL（Flash Translation Layer，闪存转换层），是 SSD 固件的核心组成，完成主机（Host）逻辑地址空间到闪存（Flash）物理地址空间的翻译（Translation），或映射（Mapping）。SSD 使用的存储介质一般是 NAND Flash 闪存块的有以下重要特性： 闪存块需要先擦除才能写入，不能覆盖写，当写入新数据时，不能在老地方更改，因为闪存不允许在一个闪存页上重复写入，一次擦除只能写一次。因此 Firmware 固件需要维护一张逻辑地址到物理地址的映射表。当闪存空间不够时，FTL 就需要做垃圾回收，将若干个闪存块中的有效数据搬出，写到某个新的闪存块上，然后把之前的闪存块删除，得到新的闪存块。 闪存块都是有一定寿命的，可以用 PE（Program&#x2F;EraseCount）数衡量，通过 Wear Leveling 让数据均摊到每个闪存块上，保证 SSD 的最大数据写入量。 每个闪存块读的数量是有限的，读的太多会造成读干扰（Read Disturb）问题，FTL 需要处理读干扰问题，当某个闪存块读次数快到一定阈值的时候，FTL 需要将其从闪存块中移走，避免数据出错。 闪存的数据保持问题（Data Retention）问题。（电荷流失） 闪存的坏块。 对 MLC 和 TLC 来说，存在 Lower page corruption 问题。 MLC 或 TLC 的读写速度都不如 SLC，但它们都可以配成 SLC 模式来使用。 FTL 分为 Host Based（基于主机）和 Device Based （基于设备），目前主流 SSD 都是基于设备。 二、映射管理1. 映射种类 基于块的映射 对小尺寸数据写入不友好，对大尺寸数据写入友好 U 盘一般采用块映射 基于页的映射 需要更大的映射表 随机写性能更好 SSD 一般采用页映射 混合映射（Hybrid Mapping） 2. 映射基本原理用户通过 LBA（Login Block Address，逻辑块地址）访问 SSD，用户访问 SSD 的基本单元叫逻辑页，SSD 主控按照闪存页为基本单位读写 SSD，闪存页也叫物理页。 映射表 3. HMB映射表可以放在 DRAM、SRAM 和闪存中，也可以放到主机的内存中 HMB（Host Memory Buffer，主机高速缓冲存储器），主机在内存中专门划出一部分空间给 SSD 用，SSD 可以把它当成自己的 DRAM 使用。在性能上，它应该介于带 DRAM 和不带 DRAM 之间。带 DRAM 的 SSD，性能好，但是能耗高，成本高；不带 DRAM 的 SSD 与其相反，需要访问两次闪存才能得到数据。 4. 映射表刷新映射表在 SSD 掉电前需要将其写入到闪存中。下次上电初始化时，需要把它从闪存中部分或全部加载到 SSD 的缓存（DRAM或者SRAM）中。为防止异常掉电导致这些新的映射关系丢失，SSD 的固件不仅仅只在正常掉电前把这些映射关系刷新到闪存中去，而是在 SSD 运行过程中按照一定策略把映射表写进闪存，这样可以防止异常掉电带来的映射关系的丢失。 触发映射表的写入时机： 新产生的映射关系累积到一定的阈值 用户写入的数据量达到一定的阈值 闪存写完闪存块的数量达到一定的阈值 其他 写入策略一般有: 全部更新 增量更新 三、垃圾回收1. 垃圾回收原理2. 写放大由于 GC 的存在，就有一个问题，用户要写入一定的数据，SSD 为了腾出空间写这些数据，需要额外的做一些数据的搬移，也就是额外的写，最后往往导致 SSD 往闪存中写人的数据量比实际用户写入 SSD 的数据量多。因此，SSD 中有个重要参数，就是 写放大(WA, Write Amplification): $$写放大&#x3D;\\cfrac{写入闪存的数据量}{用户写的数据量}$$ 空盘的写放大一般为 1，写放大越大，意味着额外写入闪存的数据越多，一方面磨损闪存，减少 SSD 寿命，另一方面，写人这些额外数据会占用底层闪存带宽，影响 SSD 性能。因此，SSD 设计的一个目标是让 WA 尽量小。减小写放大，可以使用前面提到的压缩办法（主控决定），顺序写也可以减小写放大（垃圾集中，但顺序写可遇不可求，取决于用户 Workload），还有就是增大OP（这个可控）。 OP 定义：$OP比例&#x3D;(闪存空间-用户空间)&#x2F;用户空间$，增大 OP 能够减小写放大。 总结一下: WA 越小越好，因为越小意味着对闪存的损耗越小，可以延长闪存使用寿命，从而支持更多的用户数据写入量；OP 越大越好，OP 越大，意味着写放大越小，也意味着 SSD 写性能越好。 影响写放大的因素： OP 用户写入数据的 Pattern（顺序写入还是随机写入） GC 策略 磨损均衡 读干扰和数据保存处理 主控：是否对数据有压缩 Trim 3. 垃圾回收实现垃圾回收可以简单分为三步： 挑选源闪存块 从源闪存块中找到有效数据 把有效数据写入到目标闪存块 1. 挑选源闪存块 挑选有效数据最小的块 固件需要记录和维护每个闪存块的有效数据量 这种 BPA 算法叫做 Greedy 算法，是大多数 SSD 使用的算法 有的 BPA 还需要考虑到擦写次数 2. 从源闪存块中找到有效数据 最好的策略当然是只读出块中的有效数据 固件在更新和维护闪存块中的有效数据量时，同时维护一张映射表，标识物理页的有效性 当然这种策略也有一个问题，当 SSD 很大时，一个闪存块有上千个闪存页，一个闪存页有上千个逻辑页，因此每个闪存块需要的映射表就会非常大，对于没有 DRAM 的 SSD，没有那么多的 SRAM 空间存储映射表，只能加载部分映射表，因此还要实现映射表的换入换出，实现起来较为困难 也可以选择把所有数据都读出来，这样就要判断哪些数据是有效的 SSD 在将用户数据写入闪存时，会额外打包一些数据，叫元数据（Meta data），它记录该用户数据的一些信息，例如该数据对应的逻辑地址、数据长度、时间戳等 然后 GC 的时候，FW 读出该数据，得到该数据的逻辑块地址，然后查找映射表，获得物理地址，如果该地址和该数据在闪存中的地址一致，说明数据是有效的，否则无效 该方法显而易见太过繁琐 还有一个折中的办法，除了维护一张 L2P(Logical to Physical) 的表，还维护一张 P2L(Physical to Logical) 的表 该表记录了每个闪存块写入的 LBA，该 P2L 数据写在该闪存块的某个位置（或单独存储）。当回收该闪存块时，首先把该 P2L 表加载上来，然后根据上面的 LBA，依次查找映射表，决定该数据是否有效，有效的数据会被读出来，然后重新写人。采用该方法，不需要把该闪存块上的所有数据一股脑地读出来，但还是需要查找映射表以决定数据是否有效。因此，该方法在性能上介于前面两种方法之间，在资源和固件开销上也是处于中间的。 实际上就是将闪存单元中的逻辑地址信息提取出来放到一张表中，节省的是读取闪存块的时间。 3. 把有效数据写入到目标闪存块 当有效数据读出来时，最后一步就是重写，即把读出来的有效数据写入闪存。 4. 垃圾回收时机 可用闪存块小于一定阈值，就要进行 Foreground GC（前台垃圾回收），这是被动的方式 与之相对应的 Background GC（后台垃圾回收），是在 SSD Idle（空闲）的时候主动进行 GC 四、Trim对一个文件 File A 来说，用户看到的是文件，操作系统把文件划分为若干个逻辑块，然后写入 SSD 的闪存空间。当用户删除掉文件 File A 时，其实它只是切断用户与操作系统的联系，即用户访问不到这些地址空间；而在 SSD 内部，逻辑页与物理页的映射关系还在，文件数据在闪存当中也是有效的。 Trim 是一个新增的 ATA 命令（Data Set Management），专为 SSD 设计。当用户删除一个数据时，操作系统会发 Trim 命令给 SSD，告诉 SSD 该文件对应的数据已经无效。 SCSI 里面的同等命令叫 UNMAP，NVMe 里面叫 Deallocate，它们指的都是同一个功能。 SSD 收到 Trim 命令时，固件要按顺序做以下几件事： 清除 L2P table 到空地址 清除 Valid Page Bit map（VPBM） 上对应的 bit 更新 Valid Page Count（VPC） 重复以上 3 步直到完成每一个 LBA 根据新的 VPC 重新计算 GC 的优先级 回收最少 VPC 的 block 擦除全是垃圾的 block 步骤 5~7 是 Trim 命令处理后，GC 的处理，它们不是 Trim 命令要处理的事情，Trim 命令是不会触发 GC 的。 五、磨损平衡磨损平衡，就是让 SSD 中的每个闪存块的磨损（擦除）都保持均衡。 在这之前，我们先抛出几个概念: 冷数据（Cold Data）和热数据（Hot Data），年老的（Old）块和年轻的（Young）块。 所谓冷数据，就是用户不经常更新的数据，比如用户写入 SSD 的操作系统数据、只读文件数据、小电影等；相反，热数据就是用户更新频繁的数据。数据的频繁更新，会在 SSD 内部产生很多垃圾数据（新的数据写入导致老数据失效）。 所谓年老的块，就是擦写次数比较多的闪存块；擦写次数比较少的闪存块，年纪相对小，我们叫它年轻的块。SSD 很容易区分年老的块和年轻的块，看它们的 EC（Erase Count，擦除次数）就可以了，大的就是老的，小的就是年轻的。 动态磨损平衡（Dynamic WL）：将热数据写到年轻的块上 静态磨损平衡（Static WL）：将冷数据写到年老的块上 动态磨损均衡和静态磨损均衡可能导致冷数据和热数据放到同一个闪存块上，冷数据、用户刚写入的数据和 GC 数据可能混在一起。这样在 GC 的时候冷数据可能就会被经常移动，增大了写放大。 解决的策略：做静态磨损均衡的时候，用专门的闪存块来存放冷数据，不与用户或者 GC 写入同一个闪存块 六、掉电恢复掉电分为两种：正常掉电和异常掉电。 正常掉电 掉电前，主机通过命令通知 SSD，收到命令之后，会做以下几件事： 把 buffer 中缓存的用户数据刷入闪存 把映射表刷入闪存 把闪存的块信息写入闪存（比如当前写的是哪个闪存块，以及写到该闪存块的哪个位置，哪些闪存块已经写过,哪些闪存块又是无效的等） 把 SSD 其他信息写入闪存 正常掉电不会导致数据的丢失，重新上电之后 SSD 只需将上述信息重新加载即可。 异常掉电 SSD 中不只有闪存，还有用来存储映射表等用户数据的缓存，这用的是 RAM（DRAM 或 SRAM）。 一个办法是将 SSD 加上电容，当检测到异常掉电时，电容放电，将 RAM 中的数据刷到闪存中，这样的 SSD 需要有异常掉电处理模块。 还有一种前卫的想法，就是用一种掉电不会丢失数据的材料来代替 RAM，例如 3D XPoint. SSD 的异常掉电恢复主要是映射表的恢复，SSD 在把用户数据写到闪存的时候，会额外打包一些数据，我们叫它元数据（Meta Data），它记录着该笔用户数据的相关信息，比如该笔数据对应的逻辑地址、数据写入时间（时间戳）等，如下图： 以图 4-44 为例，如果我们读取物理地址 Pa x，就能读取到元数据 x 和用户数据 x，而元数据是有逻辑地址 La x 的，因此，我们就能获得映射: La x→Pa x。映射表的恢复原理其实很简单，只要全盘扫描整个闪存空间，就能获得所有的映射关系，最终完成整个映射表的重构。 若同时存在新老数据，那么便会根据时间戳来获得最新的数据，从而构建映射。但是如果 SSD 容量很大的话，这样的全盘检查耗时会很久，其中一种办法就是 SSD 定期把 SSD RAM 中的数据（包括映射表和用户缓存的数据）和 SSD 相关的状态信息（诸如闪存块擦写次数、闪存块读次数、闪存块其他信息等）写到闪存中去，这个操作被称为 Checkpoint（检查点），或 “快照”，这样掉电后只需要扫描局部的物理空间，节省了大量时间。 七、坏块管理来源： 一般来自于出厂自带的坏块和使用中产生的。 坏块鉴别 它会在出厂坏块的第一个闪存页和最后一个闪存页的数据区第一个字节和 Spare 区第一个字节写上一个非 OxFF 的值 一部分厂商会将坏块的信息表存储在闪存中 坏块管理 略过（Skip） 用户写闪存的时候，一遇到坏块就越过，写下一个 Block 替换（Replace） 当某个 Die 上发现坏块时，会被 Die 上某个好块替换，用户写数据时，不是跳过这个坏块，而是写到替换的好块上 整个 Die 空间分为用户空间和预留空间 采用替换策略的话，SSD 内部需要维护一张重映射表（Remap Table），即坏块到替换块的映射 两种策略的优劣： 略过策略的性能不稳定，并行度可能在 1~4 个 Die 之间（假设有 4 个 Die），但是替换策略有木桶效应，如果某个 Die 质量较差，整个 SSD 可用的闪存块受限于那个坏的 Die。 八、SLC CacheSLC 相比 MLC 和 TLC，有更好的性能和寿命，有些 SSD 用其来做 Cache，让 SSD 有更好的突发性能（Brust Performance）。 这里所说的 SLC Cache，不是说单独拿 SLC 闪存来做 Cache，而是把 MLC 或者 TLC 里面的一些闪存块配置成 SLC 模式来访问，而这个特性一般的 MLC 或者 TLC 都是支持的。SLC 模式下的闪存块，相比 MLC 或者 TLC 模式下的闪存块，更快更耐写，可以用来做 Cache。 SLC Cache写入策略有: 强制 SLC 写入 用户写入数据时，必须先写人到 SLC 闪存块，然后通过 GC 搬到 MLC 或者 TLC 闪存块、 能够保护 Lower Page 的数据 非强制 SLC 写入 用户写人数据时，如果有 SLC 闪存块，则写入到 SLC 闪存块，否则直接写到 MLC 或者 TLC 闪存块 具有更好的后期写入性能 SLC Cache 办法： 静态 SLC Cache：拿出一些 Block 专门做 SLC Cache 动态 SLC Cache：所有的 MLC 和 TLC 都可以用来做 SLC Cache 两者混合 九、RD &amp; DRRD 指的是 Read Disturb，DR 指的是 Data Retention。两者都能导致数据丢失，但原理和固件处理方式都不一样，下面分别介绍。 1. RD闪存块在读取时需要在其他字线（Wordline）上施加电压，时间一长，电子进入浮栅极过多，从而导致比特翻转（1-&gt;0），当出错比特数超过 ECC 纠错能力时，数据便会丢失，这就是 RD。 我们要保证每个闪存块读取的次数低于某个阈值，在比特翻转前就将其刷新，这样可以避免 RD。因此 FTL 应该要记录每个闪存块读取次数的表。当然为了避免“过刷新”的问题，可以在读次数超过阈值后，先检测比特翻转数，若不需要刷新，则可以设置一个更大的阈值。最理想的阈值是根据 SSD 的 PE 数动态设置。 对于刷新动作，也分为阻塞（Block）和非阻塞（Non-Block），一般采用非阻塞。 2. DRSSD 使用时间长了之后，会有电子逃逸，当逃逸的电子到一定数量的时候，就会使存储单元的比特发生翻转（0-&gt;1，注意 RD 是 1-&gt;0），解决办法仍然是扫描闪存空间，若检测到比特翻转超出一定阈值，进行刷新。 十、Host Based FTL按照 FTL 放在哪里进行划分，分为 Host Based FTL 和 Device Based FTL 总体来说，Device Based 存在以下缺点: FTL 架构通用，不能针对具体应用做定制化。控制器芯片功能复杂，设计难度大，研发成本高 闪存更新很快，一般每年闪存厂商都会推出新一代产品，有新的使用特性，需要控制器芯片做出修改，但是芯片改版成本很高 企业级应用需要高性能、大容量，通用控制器芯片支持的最大性能和容量有限制企业级市场需求多种多样，有些需求需要控制器提供特殊功能支持，这些是通用 SSD 主控芯片无法提供的。 百度的欧阳剑团队在国际著名的计算机体系结构学术会议 ASPLOS’14 上发表了一篇文章，介绍他们研发的软件定义闪存 SDF（Software Defined Flash）。相比市场上销售的 SSD，SDF 主要的特点有: 没有垃圾回收。SDF 的使用者使用闪存块大小的整数倍为单位来写数据（比如8 MB），所以每个闪存块里面不会有垃圾，或者整体都是垃圾，写之前整体擦除就可以。这样的好处有: SSD 内部不用做垃圾回收，读写带宽得到提高 不需要预留空间，释放出 20% 的额外空间 没有内部搬移数据产生的写操作，闪存没有了写放大，寿命延长 没有闪存级 RAID。SSD 内部其实是闪存阵列，所以为了数据安全性，很多企业级 SSD 会用闪存组成 RAID 组，用一块或几块闪存保存RAID 数据。但是互联网公司的数据一般都有3个备份，所以不担心 SSD 内部数据丢失，因此，RAID是没有必要的 FPGA 作为控制芯片，功能很少:ECC、坏块管理、地址转换、动态磨损均衡。Virtex-5 FPGA 实现了 PCIe 接口和 DMA，Spartan FPGA 则是闪存控制芯片 SSD 内部每个通道都向用户开放，由用户选择写哪个通道 软件接口层非常简单，相比传统的 Linux 存储堆栈，省略了文件系统、块设备、IO 调度、SATA 协议等，用户可以直接使用 IOCTRL（设备驱动程序中对 IO 设备的通道进行管理的函数）来发同步的写命令到 PCIe 驱动","categories":[{"name":"OpenSSD","slug":"OpenSSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/"},{"name":"SSD","slug":"OpenSSD/SSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/SSD/"}],"tags":[{"name":"SSD","slug":"SSD","permalink":"https://cherryyang05.github.io/hexo-blog/tags/SSD/"}]},{"title":"Rust入门教程（三）：Package、Crate 和 Module","slug":"Rust入门教程（三）","date":"2022-05-14T12:30:21.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"280b72d7.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/280b72d7.html","excerpt":"Rust 入门教程（二）[toc] Rust 的代码组织 代码组织主要包括： 哪些细节可以暴露，哪些细节是私有的一作用域内哪些名称有效 模块系统: Package（包）：Cargo 的特性，让你构建、测试、共享 crate Crate（单元包）： 一个模块树，它可产生一个 library 或可执行文件 Module（模块）、use：让你控制代码的组织、作用域、私有路径 Path（路径）：为 struct、function 或 module 等项命名的方式","text":"Rust 入门教程（二）[toc] Rust 的代码组织 代码组织主要包括： 哪些细节可以暴露，哪些细节是私有的一作用域内哪些名称有效 模块系统: Package（包）：Cargo 的特性，让你构建、测试、共享 crate Crate（单元包）： 一个模块树，它可产生一个 library 或可执行文件 Module（模块）、use：让你控制代码的组织、作用域、私有路径 Path（路径）：为 struct、function 或 module 等项命名的方式 1. Package 和 CrateCrate的类型: binary library Crate Root: 是源代码文件 Rust编译器从这里开始，组成你的 Crate 的根Module 一个 Package: 包含 1 个 Cargo.toml，它描述了如何构建这些 Crates 只能包含 0-1 个 library crate 可以包含任意数量的 binary crate 但必须至少包含一个 crate (library 或 binary) Cargo 的惯例 src/main.rs: binary crate 的 crate root crate 名与 package 名相同 src/lib.rs: package 包含一个 library crate library crate 的 crate root crate 名与 package 名相同 Cargo 把 crate root 文件交给 rustc 来构建 library 或 binary 如果 package 下有一个lib.rs，就说明 package 下面有一个 library crate，这个 lib.rs 就是这个 library crate 的入口文件，crate 名字也是叫 my-project. 一个 Package 可以同时包含 src&#x2F;main.r s和 src&#x2F;lib.rs 一个 binary crate，一个 library crate 名称与 package 名相同 一个 Package 可以有多个 binary crate: 文件放在 src&#x2F;bin 每个文件是单独的 binary crate Crate 的作用 将相关功能组合到一个作用域内，便于在项目间进行共享，防止冲突。例如 rand crate，访问它的功能需要通过它的名字:rand 定义 module 来控制作用域和私有性 Module: 在一个crate内，将代码进行分组 增加可读性，易于复用 控制项目（item）的私有性。public、private 建立 module: mod 关键字 可嵌套 可包含其它项（struct、enum、常量、trait、函数等）的定义 123456789101112mod front_of_house &#123; mod hosting &#123; fn add_to_waitlist() &#123;&#125; fn seat_at_table() &#123;&#125; &#125; mod serving &#123; fn take_order() &#123;&#125; fn serve_order() &#123;&#125; fn take_payment() &#123;&#125; &#125;&#125; src/main.rs 和 src/lib.rs 叫做 crate roots: 这两个文件（任意一个）的内容形成了名为 crate 的模块，位于整个模块树的根部 整个模块树在隐式的crate模块下 2. 路径(Path)为了在 Rust 的模块中找到某个条目，需要使用路径。路径的两种形式: 绝对路径:从 crate root开始，使用 crate 名或字面值 crate 相对路径:从当前模块开始，使用 self，super 或当前模块的标识符路径至少由一个标识符组成，标识符之间使用:: 私有边界（privacy boundary） 模块不仅可以组织代码，还可以定义私有边界 如果想把函数或结构体设为私有，可以将它放到某个模块中 Rust中所有的条目（函数，方法，struct，enum，模块，常量）默认是私有的 父级模块无法访问子模块中的私有条目 子模块里可以使用所有祖先模块中的条目 Pub 关键字 使用 pub 关键字将某些条目标记为公共的，同为根下的模块尽管都是私有，也可以访问 super 关键字 用来访问父级模块路径中的内容，类似文件系统中的 ..，例子如下： 12345678910mod back_of_house &#123; fn fix_incorrect_order() &#123; cook_order(); super::serve_order(); crate::serve_order(); &#125; fn cook_order() &#123;&#125;&#125;fn serve_order() &#123;&#125; pub struct pub 放在 struct 前: struct 是公共的 struct 的字段默认是私有的 struct 的字段需要单独设置 pub 来变成公有 1234567891011121314151617181920mod back_of_house &#123; pub struct Breakfast &#123; pub toast: String, fruit: String, &#125; impl Breakfast &#123; pub fn summer(toast: &amp;str) -&gt; Breakfast &#123; Breakfast &#123; toast: String::from(toast), fruit: String::from(&quot;strawberry&quot;), &#125; &#125; &#125;&#125;pub fn eat_at_restaurant() &#123; let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;); println!(&quot;I&#x27;d like &#123;&#125; toast please.&quot;, meal.toast);&#125; pub enum pub 放在 enum 前: enum 是公共的 enum 的变体也都是公共的 123456mod back_of_house &#123; pub enum Appetizer &#123; Soup, Salad &#125;&#125; 3. use 关键字可以使用 use 将路径导入到作用域内，同样遵循私有性原则，即只有公共的才能被使用 123456789101112131415mod front_of_house &#123; pub mod hosting &#123; pub fn add_to_waitlist() &#123;&#125; fn some_function() &#123;&#125; &#125;&#125;use crate::front_of_house::hosting;pub fn eat_at_restaurant() &#123; hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::some_function(); //报错，因为some_function为私有&#125; 使用 use 指定相对路径：use front_of_house::hosting; 可以直接将模块中的函数导入到作用域内，但是这样便无法区分该函数是在模块中定义还是在该文件内定义，因此通常的做法都是只导入到该函数的父模块，通过父模块调用函数。 对于函数和同名条目是这样，但是对于结构体和枚举，通常是指定完整路径，这是 use 的习惯用法。 123456use std::fmt;use std::io;fn f1() -&gt; fmt::Result &#123;&#125;fn f2() -&gt; io::Result &#123;&#125; as 关键字 as 关键字可以为引入的路径指定一个本地的别名，例子如下： 12345use std::fmt::Result;use std::io::IOResult;fn f1() -&gt; Result &#123;&#125;fn f2() -&gt; IOResult &#123;&#125; 使用 pub use 重新导出名称 使用 use 将路径（名称）导入到作用域内后，该名称在此作用域内是私有的 pub use:重导出 将条目引入作用域 该条目可以被外部代码引入到它们的作用域 pub use crate::front_of_house::hosting; 使用外部包 Cargo.toml 添加依赖的包(package) https://crates.io/ use 将特定条目引入作用域 标准库（std）也被当做外部包，但是不需要修改 Cargo.toml 来包含 std，需要使用 use 将 std 中的特定条目引入当前作用域 1use std::collections::HashMap; 使用嵌套路径清理大量 use 语句 如果使用同一个包或模块下的多个条目，可以使用嵌套路径在同一行内将上述路径进行引入 格式如下：路径相同的部分::&#123;路径不同的部分&#125;，例子如下： 123456789101112use std::cmp::Ordering;use std::io;//使用嵌套路径use std::&#123;cmp::Ordering, io&#125;;//若是这样的引用use std::io;use std::io::Write;//简写为use std::io::&#123;self, Write&#125;; 通配符* 使用 * 可以把路径中所有的公共条目都引入到作用域 use std::collections::*; 应用场景: 测试。将所有被测试代码引入到 tests 模块 有时被用于预导入（prelude）模块 4. 将模块拆分为不同文件将模块内容移动到其它文件 模块定义时，如果模块名后边是 ;，而不是代码块，Rust 会从与模块同名的文件中加载内容，同时项目文件夹结构要与模块层级结构一致。随着模块的变大，该技术可以把模块中的内容移动到其他文件中。 例如：文件 main.rs: 1pub mod back_of_house; 文件 back_of_house.rs: 1pub mod hosting; 这时必须在 src 下创建一个 back_of_house 的文件夹，里面创建一个 hosting.rs 文件，即为 src/back_of_house/hosting.rs 文件 hosting.rs: 1pub fn test() &#123;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"Rust入门教程（二）：结构体和枚举","slug":"Rust入门教程（二）","date":"2022-05-13T14:01:36.000Z","updated":"2023-08-08T12:35:27.400Z","comments":true,"path":"48404f67.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/48404f67.html","excerpt":"Rust 入门教程（二）：结构体和枚举","text":"Rust 入门教程（二）：结构体和枚举 [toc] 一、结构体的使用1. 定义和实例化 struct例子： 123456struct User &#123; username: String, email: String, sign_in_count: usize, active: bool,&#125; 需要注意的是，每个字段后面用逗号隔开，最后一个字段后面可以没有逗号。 实例化例子： 123456let user1 = User &#123; email: String::from(&quot;cherry@gmail.com&quot;), username: String::from(&quot;cherry&quot;), active: true, sign_in_count: 244, &#125;; 先创建 struct 实例，然后为每个字段指定值，无需按照声明的顺序指定。 但是注意不能少指定字段。 用点标记法取得结构体中的字段值，一旦 struct 的实例是可变的，那么实例中的所有字段都是可变的，不会同时既存在可变的字段又存在不可变的字段。 结构体作为函数的返回值 12345678fn struct_build() -&gt; User &#123; User &#123; email: String::from(&quot;cherry@gmail.com&quot;), username: String::from(&quot;cherry&quot;), active: true, sign_in_count: 244, &#125;&#125; 字段初始化简写 当字段名与字段值对应变量相同的时候，就可以使用字段初始化简写的方式： 12345678fn struct_build(email: String, username: String) -&gt; User &#123; User &#123; email, username, active: true, sign_in_count: 244, &#125;&#125; struct 更新语法 当想基于某个 struct 实例创建一个新的实例时（新的实例中某些字段可能和原先相同，某些不同），若不使用 struct 更新语法，则是这样写： 123456let user2 = User &#123; email: String::from(&quot;paul@nba.cn&quot;), username: String::from(&quot;Chris Paul&quot;), active: user1.active, sign_in_count: user1.sign_in_count, &#125;; 而使用 struct 更新语法，则是这样写： 12345let user3 = User &#123; email: String::from(&quot;paul@nba.cn&quot;), username: String::from(&quot;Chris Paul&quot;), ..user1 &#125;; 用 ..user1 表示该实例中未赋值的其他字段和实例 user1 中的值一致。 Tuple Struct 可以定义类似 Tuple 的 Struct，叫做 Tuple Struct。Tuple struct 整体有个名，但里面的元素没有名 适用：想给整个 tuple 起名，并让它不同于其它 tuple，而且又不需要给每个元素起名 1234struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black(0, 0, 0);let origin = Point(0, 0, 0); black 和 origin 是不同的类型，是不同 tuple struct 的实例 Unit-Like Struct(没有任何字段) 可以定义没有任何字段的 struct，叫做 Unit-Like struct，因为与 () 和单元类型类似，适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据 struct 数据所有权 再来看这个例子： 123456struct User &#123; username: String, email: String, sign_in_count: usize, active: bool,&#125; 这里的字段使用了 String 而不是 &amp;str，原因如下： 该 struct 实例拥有其所有的数据 只要 struct 实例是有效的，那么里面的字段数据也是有效的 struct 里也可以存放引用，但这需要使用生命周期（以后讲） 若字段为 &amp;str，当其有效作用域小于该实例的作用域，该字段被清理时，实例未清理，访问该字段属于悬垂引用（类似野指针） 生命周期保证只要 struct 实例是有效的，那么里面的引用也是有效的 如果 struct 里面存储引用，而不使用生命周期，就会报错 2. struct 例子一个简单的例子：计算长方形的面积 12345678910fn main() &#123; let width = 25; let length = 12; let area = area_of_rectangle(width, length); println!(&quot;The Area of Rectangle is &#123;&#125;.&quot;, area);&#125;fn area_of_rectangle(width: usize, length: usize) -&gt; usize &#123; width * length&#125; 上面这个例子很简单，但是长方形的长和宽没有联系起来，width 和 length 是两个分离的没有逻辑联系的变量，我们考虑用元组将其联系起来： 12345678fn main() &#123; let rect = (25, 12); println!(&quot;The Area of Rectangle is &#123;&#125;.&quot;, area_of_rectangle(rect));&#125;fn area_of_rectangle(rect: (u32, u32)) -&gt; u32 &#123; rect.0 * rect.1&#125; 但是这样仿佛可读性变差了，我们再用结构体实现： 12345678910111213141516struct Rectangle &#123; width: u32, length: u32,&#125;fn main() &#123; let rect = Rectangle &#123; width: 35, length: 12, &#125;; println!(&quot;The Area of Rectangle is &#123;&#125;.&quot;, area_of_rectangle(&amp;rect));&#125;fn area_of_rectangle(rect: &amp;Rectangle) -&gt; u32 &#123; rect.length * rect.width&#125; 函数的参数使用结构体的借用，是为了不获得该实例的所有权，主函数在函数调用之后还可以继续使用该实例。 此时我们输出实例 rect，会报这样的错误：Rectangle doesn&#39;t implement std::fmt::Display，即该结构体未实现 Display 这个 trait，而 Rust 中很多类型都是实现了这个 trait，才能将其在终端打印出来。因为结构体这种比标量类型更加复杂，打印的类型的可能性很多，因此需要用户自定义实现 Display。 在报错的提示信息里，有个 note 提示我们可以使用 &#123;:?&#125; (或 &#123;:#?&#125;)来打印信息: 1println!(&quot;&#123;:?&#125;&quot;, rect); 然而又出现了错误，这次的报错信息是：Rectangle doesn&#39;t implement Debug，显然 Debug 也是一种格式化方法，再看提示的 note：add #[derive(Debug)] to Rectangle or manually impl Debug for Rectangle，我们在结构体前添加 #[derive(Debug)]，使得该结构体派生与 Debug 这个 trait。 最终完整的程序如下： 12345678910111213141516171819#[derive(Debug)]struct Rectangle &#123; width: u32, length: u32,&#125;fn main() &#123; let rect = Rectangle &#123; width: 35, length: 12, &#125;; println!(&quot;The Area of Rectangle is &#123;&#125;.&quot;, area_of_rectangle(&amp;rect)); println!(&quot;&#123;:?&#125;&quot;, rect);&#125;fn area_of_rectangle(rect: &amp;Rectangle) -&gt; u32 &#123; rect.length * rect.width&#125; 输出结果为： 123456➜ ~/Code/rust/area_of_rectangle git:(master) ✗ cargo run Compiling area_of_rectangle v0.1.0 (/home/cherry/Code/rust/area_of_rectangle) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/area_of_rectangle`The Area of Rectangle is 420.Rectangle &#123; width: 35, length: 12 &#125; 若在输出格式中间加入一个 #，结构体输出将更加清晰：println!(&quot;&#123;:?&#125;&quot;, rect);，输出结果为： 1234Rectangle &#123; width: 35, length: 12,&#125; 3. struct 方法方法和函数类似: fn关键字、名称、参数、返回值 方法与函数不同之处: 方法是在 struct(或 enum、trait 对象）的上下文中定义 第一个参数是 self，表示方法被调用的 struct 实例 上一节我们定义了计算长方形面积的函数，但是该函数只能计算长方形的函数，无法计算其他形状的面积，因此我们希望将函数与长方形这一结构体关联起来，例子如下： 12345678910111213141516171819struct Rectangle &#123; width: u32, length: u32,&#125;impl Rectangle &#123; fn area_of_rectangle(&amp;self) -&gt; u32 &#123; self.length * self.width &#125;&#125;fn main() &#123; let rect = Rectangle &#123; width: 35, length: 12, &#125;; println!(&quot;The Area of Rectangle is &#123;&#125;.&quot;, rect.area_of_rectangle());&#125; 在impl块里定义方法，方法的第一个参数可以是 &amp;self，也可以获得其所有权或可变借用，和其他参数一样。这样写可以有更良好的代码组织。 方法调用的运算符 C&#x2F;C++ 中 object-&gt;something() 和 (*object).something() 一样，但是 Rust 没有 → 运算符 Rust 会自动引用或解引用一在调用方法时就会发生这种行为 在调用方法时，Rust 根据情况自动添加 &amp;、&amp;mut 或 *，以便 object 可以匹配方法的签名 下面这两种写法效果相同 p1.distance(&amp;p2); (&amp;p1).distance(&amp;p2); 方法参数 123456789impl Rectangle &#123; fn area_of_rectangle(&amp;self) -&gt; u32 &#123; self.length * self.width &#125; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.length &gt; other.length &amp;&amp; self.width &gt; other.width &#125;&#125; 关联函数 可以在 impl 块里定义不把 self 作为第一个参数的函数，它们叫关联函数（不叫方法） 例如：String::from() 关联函数通常用于构造器，例子如下： 123456789101112131415161718struct Rectangle &#123; width: u32, length: u32,&#125;impl Rectangle &#123; fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, length: size, &#125; &#125;&#125;fn main() &#123; let s = Rectangle::square(20);&#125; :: 符号 关联函数 模块创建的命名空间 二、枚举与模式匹配1. 枚举的定义枚举允许我们列举所有可能的类型来定义一个类型 例如 IP 地址，目前只有 IPv4 和 IPv6 两种类型，我们可以定义这样的枚举类型并使用： 1234567891011121314enum IpAddrKind &#123; V4, V6,&#125;fn main() &#123; let four = IpAddrKind::V4; let six = IpAddrKind::V6; route(four); route(six); route(IpAddrKind::V6);&#125;fn route(ip_kind: IpAddrKind) &#123;&#125; 枚举的变体都位于标识符的命名空间下，使用两个冒号 :: 进行分隔 枚举类型是一种自定义的类型，因此它可以作为结构体里字段的类型，例子如下： 12345678910111213141516enum IpAddrKind &#123; V4, V6,&#125;struct IpAddr &#123; kind: IpAddrKind, address: String,&#125;fn main() &#123; let home = IpAddr &#123; kind: IpAddrKind::V4, address: String::from(&quot;192.168.3.1&quot;), &#125;;&#125; 将数据附加到枚举的变体中 上述的枚举类型我们可以改为： 1234enum IpAddr &#123; V4(String), V6(String),&#125; 优点是：不需要使用 struct，每个变体可以拥有不同的类型以及相关联的数据量，例如 123456789enum IpAddr &#123; V4(u8, u8, u8, u8), V6(String),&#125;fn main() &#123; let home = IpAddrKind::V4(192, 168, 1, 1); let loopback = IpAddrKind::V6(String::from(&quot;::1&quot;));&#125; 标准库中的 IpAddr 12345678910struct lpv4Addr &#123; // --snip--&#125;struct lpv6Addr &#123; // --snip--&#125;enum lpAddr &#123; V4(lpv4Addr), V6(lpv6Addr),&#125; 为枚举定义方法 也使用 impl 这个关键字 1234567891011121314151617enum Message &#123; Quit, Move &#123;x: u32, y: u32&#125;, Write(String), ChangeColor(i32, i32, i32),&#125;impl Message &#123; fn call(&amp;self) &#123;&#125;&#125;fn main() &#123; let q = Message::Quit; let m = Message::Move&#123;x: 10, y: 12&#125;; let w = Message::Write(String::from(&quot;Hello&quot;)); let c = Message::ChangeColor(0, 255, 255);&#125; 2. Option 枚举 定义于标准库中 在 Prelude（预导入模块）中 描述了某个值可能存在（某种类型）或不存在的情况 Rust 中没有 NULL 其它语言中: Null是一个值，它表示“没有值” 一个变量可以处于两种状态：空值（null）、非空 Null 引用：Billion Dollar Mistake Null 的问题在于:当你尝试像使用非Null值那样使用Null值的时候，就会引起某种错误，但是 Null 的概念还是有用的：因某种原因而变为无效或缺失的值 Rust 中类似与 NULL 的概念的枚举：Option&lt;T&gt; 标准库中的定义： 1234enum Option&lt;T&gt; &#123; Some(T), None,&#125; 它包含在预导入模块（Prelude）中，可以直接使用 Option&lt;T&gt;, Some(T), None。例子如下： 12345fn main() &#123; let some_num = Some(3); let some_string = Some(&quot;The String&quot;); let absent_num: Option&lt;i32&gt; = None;&#125; 其中 Some(3) 编译器可以推断出来 T 类型为 usize，而 None 的话编译器无法推断出来，因此需要显式指定 Option&lt;i32&gt; 这种设计比 NULL 好在哪？ 因为 Option&lt;T&gt; 和 T 是不同的类型，不能将 Option&lt;T&gt; 当成 T 使用，例子如下： 12345fn test02() &#123; let x: i8 = 5; let y: Option&lt;i8&gt; = Some(5); let sum = x + y;&#125; 这样会报错，提示 cannot add Option&lt;i8&gt; to i8，表示两者不是同一个类型，若想使用 Option&lt;T&gt; 中的 T，则必须将其手动转换为 T，这种设计方式可以避免代码中 NULL 值泛滥的情况。 3. match强大的控制流运算符 match 允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码。模式可以是字面值、变量名、通配符… 123456789101112131415161718enum Coin &#123; Penny, Nickel, Dime, Quarter,&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; &#123; println!(&quot;Penny!&quot;); 1 &#125;, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, &#125;&#125; 绑定值的模式 匹配的分支可以绑定到被匹配对象的部分值，因此可以从 enum 变体中提取值，例子如下： 123456789101112131415161718192021222324252627282930313233343536373839#[derive(Debug)]enum USState &#123; California, Texas,&#125;enum Coin &#123; Penny, Nickel, Dime, Quarter(USState),&#125;fn value_in_cents(coin: Coin) -&gt; u8 &#123; match coin &#123; Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; &#123; println!(&quot;State quarter from &#123;:?&#125;&quot;, state); 25 &#125;, /* Coin::Quarter(state) 也可以这样展开写 */ Coin::Quarter(USState::Texas) =&gt; &#123; println!(&quot;State quarter from &#123;:?&#125;&quot;, USState::Texas); 25 &#125;, Coin::Quarter(USState::California) =&gt; &#123; println!(&quot;State quarter from &#123;:?&#125;&quot;, USState::California); 25 &#125; &#125;&#125;fn test03() &#123; let c = Coin::Quarter(USState::California); println!(&quot;&#123;&#125;&quot;, value_in_cents(c));&#125; 匹配 Option 123456789101112fn test04() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None);&#125;fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1) &#125;&#125; 注意：match 匹配必须穷举所有的可能，可以使用 _ 通配符替代其他没有列出的值 123456789fn test05() &#123; let x = 0u8; match x &#123; 1 =&gt; println!(&quot;one&quot;), 3 =&gt; println!(&quot;three&quot;), 5 =&gt; println!(&quot;five&quot;), _ =&gt; () &#125;&#125; 4. if letif let 是一种比 match 简单的控制流，他处理只关心一种匹配而忽略其他匹配的情况，它有更少的代码，更少的缩进，更少的模板代码，但是放弃了穷举的可能，可以把 if let 看作是 match 的语法糖。 if let 的格式如下： 123if let pattern = value &#123; //TODO&#125; 他也可以搭配 else 例子如下： 12345678910111213141516fn test06() &#123; let v = 8u8; match v &#123; 3 =&gt; println!(&quot;Three!&quot;), _ =&gt; () &#125; if let 3 = v &#123; println!(&quot;Three&quot;) &#125; else if let 5 = v &#123; println!(&quot;Five!&quot;) &#125; else &#123; println!(&quot;Others!&quot;) &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"深入浅出SSD（一）","slug":"深入浅出SSD（一）","date":"2022-05-12T08:07:36.000Z","updated":"2023-08-08T12:35:27.418Z","comments":true,"path":"11b7e709.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/11b7e709.html","excerpt":"本文是《深入浅出SSD 固态存储核心技术、原理与实战》的学习笔记","text":"本文是《深入浅出SSD 固态存储核心技术、原理与实战》的学习笔记 一、SSD 介绍SSD(Solid State Drive) 固态硬盘，主要以半导体闪存为介质的存储设备，属于 ROM 的一种。 SSD 硬件包括几大组成部分:主控、闪存、缓存芯片DRAM（可选，有些SSD上可能只有 SRAM，并没有配置 DRAM）、PCB（电源芯片、电阻、电容等）、接口（SATA、SAS、PCle等），其主体就是一块 PCB。 软件角度，SSD 内部运行固件（Firmware, FW）负责调度数据从接口端到介质端的读写，还包括嵌入核心的闪存介质寿命和可靠性管理调度算法，以及其他 SSD 的算法。 SSD 控制器，闪存和固件是 SSD 三大技术核心。 SSD 的容量，性能，可靠性，寿命，尺寸，功耗，噪声，重量，抗震，温度都优于机械硬盘，目前价格也逐渐接近机械硬盘。 二、SSD 基本工作原理SSD 的输入是命令(Command)，输出是数据(Data)和命令状态(Command Status)。SSD 前端(Front End)接收用户命令请求，经过内部计算和处理逻辑，输出用户所需要的数据或状态。 SSD 的三大功能模块： 前端接口和相关的协议模块; 中间的 FTL 层（Flash Translation Layer，闪存转换层）模块; 后端和闪存通信模块 FTL 算法决定了性能、可靠性、功耗等 SSD 的核心参数。 三、SSD 系统架构SSD 作为数据存储设备，其实是一种典型的(System on Chip)单机系统，有主控CPU、RAM、操作加速器、总线、数据编码译码等模块(见图2-1)，操作对象为协议、数据命令、介质，操作目的是写入和读取用户数据。 SSD 系统架构分为前端（Host Interface Controller，主机接口控制器）和后端（Flash Controller，闪存控制器），前端和主机接口打交道，包含 SATA、PCIe、SAS 接口等，后端和闪存打交道，完成数据编解码和 ECC。 1. 前端SATA 的全称是 Serial Advanced Technology Attachment（串行高级技术附件），是一种串行硬件驱动器接口。 SAS（Serial Attached SCSI）即串行连接 SCSI，是新一代的 SCSI 技术。 PCIe（Peripheral Component Interconnect Express）是一种高速串行计算机扩展总线标准，原来被称为 3GIO 2. 主控 CPU3. 后端后端两大模块分别为 ECC 和闪存控制器。 ECC 模块是数据编解码单元，由于闪存存储天生的误码率，要在数据写入是加上 ECC 检验保护，同样读取的时候要通过 ECC 进行解码。 SSD 中的 ECC 算法主要有 BCH 和 LDPC，后者逐渐成为主流。 四、闪存物理结构现在固态硬盘采用 NAND 闪存作为存储介质。闪存在写之前必须先擦除，不能覆盖写，因此 SSD 需要有垃圾回收，一个块读写次数超过一定限度就会损坏，因此要有磨损均衡。 闪存是一种非易失性存储器，基本存储单元是一种类 NMOS 的双层浮栅 MOS 管，电子被上下绝缘层包围，因此掉电不会消失。 施敏发明浮栅晶体管的来源是奶酪蛋糕~~ SLC、MLC、TCL一个存储单元存储 1bit 的数据的闪存，叫做 SLC（Single Level Cell），存储 2bit 数据的闪存叫 MLC（Multiple Level Cell），存储 3bit 数据的闪存为 TLC（Triple Level Cell）。 存储单元存储的值是按照存储单元里的电子相对个数来判断的，电子相对个数通过电压的区间范围来判断。 但同时，一个存储单元电子划分得越多，那么在写入的时候，控制进入浮栅极的电子个数就要越精细，所以写耗费的时间就越长;同样的，读的时候，需要尝试用不同的参考电压去读取，一定程度上加长了读取时间。所以我们会看到在性能上，TLC 不如 MLC，MLC 不如 SLC。 一个闪存内部的存储组织结构如下图所示:一个闪存芯片有若干个 DIE（或者叫LUN），每个 DIE 有若干个 Plane，每个 Plane 有若干个 Block，每个 Block 有若干个 Page,每个 Page 对应着一个 Wordline，Wordline 由成千上万个存储单元构成。 DIE&#x2F;LUN 是接收和执行闪存命令的最基本单元，在一个 LUN 中，不能对某个 Page 写的同时，又对其他 Page 进行读访问。 一个 LUN 又分为若干个 Plane，市面上常见的是 1 个或者 2 个 Plane，现在也有 4 个 Plane 的闪存了。每个 Plane 都有自己独立的 Cache Register 和 Page Register，其大小等于一个 Page 的大小。 固态硬盘主控在写某个 Page 的时候，先把数据从主控传输到该 Page 所对应 Plane 的 Cache Register 中，然后把整个 Cache Register 写到闪存阵列，读的时候相反，先把这个 Page 中的数据从闪存介质读取到 Cache Register 中，然后按需传给主控。 同时有 Cache Register 和 Page Register 的目的是优化闪存的访问速度（类似于二级缓存）。 我们通常所说的闪存读写时间，并不包含数据从闪存到主控之间的数据传输时间，也不包括数据在 Cache Register 和 Page Register 之间的传输时间。闪存写人时间是指一个 Page 的数据从 Page Register 当中写人闪存介质的时间，闪存读取时间是指一个 Page 的数据从闪存介质读取到 Page Register 的时间。 闪存一般都支持 Multi-Plane（或者Dual-Plane）操作，就是将同一个 LUN 中多个 Plane 中 Cache Register 写入数据后同时写入闪存介质，这样可以节省 Page 写入时间。 闪存的擦除是以 block 为单位的，因为在物理结构上，一个 block 中的存储单元共用一个衬底（Substrate）。 读、写、擦原理量子隧道效应 三维闪存3D XPoint相变存储器：PRAM，PCM PCM 通过一种微小的电阻作用使得玻璃融化，相变为晶体，现在 PCM 读取时间已经可以到皮秒级别。 PCM 特点： 掉电数据不丢失 可以按照字节访问 软件简单 写之前不需要擦除操作 功耗低，和闪存差不多 读写速度快 寿命远长于闪存","categories":[{"name":"OpenSSD","slug":"OpenSSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/"},{"name":"SSD","slug":"OpenSSD/SSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/SSD/"}],"tags":[{"name":"SSD","slug":"SSD","permalink":"https://cherryyang05.github.io/hexo-blog/tags/SSD/"}]},{"title":"Rust入门教程（一）","slug":"Rust入门教程（一）","date":"2022-05-08T13:45:21.000Z","updated":"2023-08-09T07:37:07.745Z","comments":true,"path":"5c3fd875.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/5c3fd875.html","excerpt":"Rust入门教程（一）Rust基本介绍 Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。 ——来自菜鸟教程 高性能 - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。可靠性 - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。生产力 - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息，还集成了一流的工具——包管理器和构建工具，智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。","text":"Rust入门教程（一）Rust基本介绍 Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。 ——来自菜鸟教程 高性能 - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。可靠性 - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。生产力 - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息，还集成了一流的工具——包管理器和构建工具，智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。 [toc] 一、变量与可变性声明变量用 let 关键字，默认情况下该变量是不可变的(immutable) 声明变量时在前面添加一个 mut 关键字，便可以使得该关键字可以被修改 变量与常量常量(constant)在绑定值之后也是不可变的，但是它与不可变变量有很多区别： 不可以使用 mut 修饰，常量永远都是不可变的 声明常量用 const 关键字，它的类型必须被标注 常量可以在任何作用域内被声明，包括全局作用域 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值 在程序运行期间，常量在其声明的作用域内一直有效. 命名规范：Rust 中使用全大写字符，每个单词之间用下划线分隔，例如：MAX_NUM。一个声明的例子：const MAX_NUM: u32 = 100_000。（注：数字中也可以添加下划线增强数字的可读性） Shadowing可以使用相同的名字声明新的变量，新的变量会 Shadowing(隐藏) 之前声明的同名变量。 shadow 和把变量标记为 mut 是不一样的： 如果不使用 let 关键字，那么重新给非 mut 变量赋值就会编译错误 而使用 let 声明的新变量，也是不可变的 使用 let 声明的同名变量，类型可以改变 例： 12let string = &quot;STRING&quot;;let string = string.len(); 这样将字符串提取出他的长度，而不用单独再开一个新的变量。 二、数据类型Rust 是静态语言，在编译时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出他的具体类型 但是如果可能的类型很多，（比如 String 转为整数的 parse 方法）那么就要添加类型的标注，否则会报错 标量类型一个标量类型代表一个单独的值 一共有 整数类型，浮点类型，布尔类型，字符类型 四种类型 整数类型： 没有小数部分，如 u32，i32，i64等，表格如下： Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 arch isize usize 其中 isize 和 usize 由计算机架构的位数所决定，主要使用场景是对某种集合进行索引操作 除了 byte 类型外，所有数值的字面值都可以加上类型后缀，例如：58u8。其中 Rust 中整数默认值为 i32 整数溢出 将一个 u8 类型的值设置为 256，在调试模式下编译会发生 panic，但是在发布模式(–release)下，编译器不会检查可能导致 panic 的溢出，如果溢出，将会执行 “环绕”，即 256 为 0，257 为 1，不会导致 panic 浮点类型： 包含 f32（单精度） 和 f64（双精度）两种浮点类型，统一采用 IEEE-754 标准。 浮点类型的默认类型为 f64. 数值操作： 和其他语言一致 布尔类型： 布尔类型有 true 和 false 两个值，占用 1 字节，符号是 bool 字符类型： Rust 语言中使用 char 来表示单个字符，字符的字面值采用单引号，占用 4 字节大小，是 Unicode 的标量值，可以表示比 ASCII 码多得多的内容，例如中文，日文，emoji表情等 Unicode 标量值的范围是从 U+0000 到 U+D7FF，U+E0000 到 U+10FFFF 但 Unicode 中没有字符的概念，所以直觉上认为的字符也许与 Rust 中的概念并不相符 复合类型复合类型可以将多个值放在一个类型里 Rust 提供了两种基础的复合类型：元组（Tuple），数组 Tuple Tuple 可以将多个类型的多个值放在一个类型里 Tuple 长度是固定的，一旦声明就无法改变 创建和调用举例： 12let tup:(u32, i64, f32) = (2022, -461, 6.2);println!(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, tup.0, tup.1, tup.2); 数组 数组是在栈（Stack）上分配的单个块的内存 数组也可以将多个值放在一个类型里，但是数组中每个元素类型必须一致，数组长度也是固定，一旦声明不能改变 创建和调用举例： 12let a = [1, 2, 3, 4, 5];println!(&quot;&#123;&#125;&quot;, arr[2]); 如果想将数据存放在栈中而不是堆中，或者想保留固定数量的元素，可以使用数组。 当然如果希望数组长度变得灵活，可以使用 vector 数组的类型 用 [类型; 长度] 这样的形式表示 例 1let a: [i32; 5] = [1, 2, 3, 4, 5]; 若数组中元素都相同，则有另一种声明数组的方法： 123let a = [3; 5];//这就相当于let a = [3, 3, 3, 3, 3]; 在中括号里先指定初始值，然后是分号，然后是元素个数。 使用索引来访问数组元素，如果访问的索引超过数组范围，编译会通过，运行时会报错，但是 Rust 中不允许继续访问越界的地址（在 C 语言中是允许的，只不过会输出乱码） 三、函数声明函数使用 fn 依照惯例，针对函数和变量名，Rust 使用 snake case 命名规范 所有字母都是小写，单词之间用下划线隔开 Rust 的函数调用不按照声明顺序执行，即在后面声明的函数也可以在前面调用（这点与 C 语言不同） 函数的参数 parameter（定义函数的参数），arguments（调用函数的参数） 必须声明每个参数的类型 函数体中的语句和表达式 语句 statement 和表达式 expression 函数体由一系列语句组成，可选的由一个表达式结束 Rust 是一个基于表达式的语言 语句是执行一些动作的指令 表达式会计算产生一个值 函数的定义也是语句 语句不返回值，因此不能用 let 将一个语句赋值个一个变量 12345let y = &#123; let x = 4; x + 2 &#125;; println!(&quot;y = &#123;&#125;&quot;, y); 这里 let y 后面定义了一个代码块，这个块就是一个表达式，x + 2 后面没有分号，是一个表达式，相当于这个块表达式的返回值，因此最后输出的结果为 y = 6. 而如果 x + 2 后面加了分号，这就是一个语句了，语句返回一个空的元组，即返回 ()，则输出一个空的元组将会报错 函数的返回值 在 -&gt; 符号后面声明函数返回值的类型，但是不可以为返回值命名 在 Rust 中，返回值通常就是函数体中最后一个表达式的值（大多数函数都是默认使用最后一个表达式作为返回值） 若想提前返回，需要使用 return 关键字，并指定一个值 12345678fn main &#123; let x = plus_five(12); println!(&quot;The function return a num &#123;&#125;&quot;, x);&#125;fn plus_five(x: i32) -&gt; i32 &#123; x + 5&#125; 条件判断 只有一点说明：if 条件判断中表达式必须是 bool 类型，（C 语言等语言可以将类型转成 bool 再判断，Rust 中不可以） 当使用了超过一个 else-if 时，最好使用 match 语句进行重构。例： 123456789fn condition_match() &#123; let x = 3; match x % 4 &#123; 4 =&gt; println!(&quot;The number &#123;&#125; can be divided by 4&quot;, x), 3 =&gt; println!(&quot;The number &#123;&#125; can be divided by 3&quot;, x), 2 =&gt; println!(&quot;The number &#123;&#125; can be divided by 2&quot;, x), _ =&gt; println!(&quot;The number &#123;&#125; can&#x27;t be divided by 4; 3 and 2&quot;, x) //_ 表示 default &#125;&#125; 在 let 语句中使用 if 因为 if 是一个表达式，因此可以将其放在 let 语句等号的右边 123let condition = true;let x = if condition &#123; 5 &#125; else &#123; 6 &#125;;println!(&quot;&#123;&#125;&quot;, x); 最后返回 x 的值为 5 四、 控制流Rust 提供三种循环：loop、while 和 for loop循环loop 关键字将反复执行一块代码，直到手动停止，或者使用 break 停止 12345678910fn branch() &#123; let mut counter = 1; let x = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2 &#125; &#125;; println!(&quot;The value of counter is &#123;&#125;&quot;, x);&#125; 最后输出结果为 20 while循环12345678fn fn_while() &#123; let mut number = 3; while number != 0 &#123; println!(&quot;&#123;&#125;!&quot;, number); number = number - 1; &#125; println!(&quot;MOVE! NOW!&quot;);&#125; for循环123456fn fn_for() &#123; let a = [10, 11, 12, 13, 14]; for elem in a.iter() &#123; println!(&quot;The value is &#123;&#125;&quot;, elem); &#125;&#125; 使用 for 循环实现 while 循环 Range 由标准库提供，指定一个开始数字和结束数字，Range 可以生成他们之间的一个数字（左闭右开），rev 方法可以翻转 Range。例： 123456fn fn_range_for() &#123; for elem in (1..4).rev() &#123; println!(&quot;&#123;&#125;!&quot;, elem); &#125; println!(&quot;Go!&quot;);&#125; *五、所有权所有权和堆栈所有权是 Rust 中最独特的特性，它让 Rust 无需 GC 就可以保证内存安全。 什么是所有权 Rust 的核心就是所有权 所有程序在运行时都必须管理它们使用计算机内存的方式 有些语言有垃圾收集机制(GC)，在程序运行时，它们会不断寻找不再使用的内存 在其他例如 C&#x2F;C++ 语言中，程序员必须显式地分配和释放内存 Rust 采用了第三种方式 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则 当程序运行时，所有权特性不会减慢程序的运行速度，因为 Rust 对内存的管理相关的工作都提前到了编译时 堆内存和栈内存 所有存储在 Stack 上的数据必须拥有已知的固定的大小 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 Heap 上 Heap 的分配和 C 语言类似，在内存空间中找到一块足够大的空间，然后返回一个指针。这叫做“分配” 把值压到 Stack 上不叫“分配” 将值压到 Stack 上比在 Heap 上快得多，因为操作系统不需要找用来存储数据的空间，那个位置永远在 Stack 最顶端 访问数据 访问 Heap 的速度比 Stack 慢，因为要通过指针才能找到 在 Heap 上分配大量空间也是需要很多时间的 所有权解决的问题 跟踪代码的哪些部分正在使用 Heap 的哪些数据 最小化 Heap 上的重复数据量 清理 Heap 上未使用的空间以避免空间不足 所有权规则 每个值都有一个变量，这个变量是这个值的所有者 每个值同时只能拥有一个所有者 当所有者超出作用域(Scope)时，该值将被删除 String 在 Heap 上分配，能够存储在编译时未知数量的文本 使用 from 函数从字符串字面值创建出 String 类型 let s = String::from(&quot;Cherry&quot;); 这类字符串是可以被修改的 123456fn main() &#123; let mut s = String::from(&quot;Hello&quot;); s += &quot;, Rust&quot;; s.push_str(&quot;, Rust&quot;); println!(&quot;&#123;&#125;&quot;, s);&#125; 字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里——速度快、高效。是因为其不可变性。 String类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容:操作系统必须在运行时来请求内存。这步通过调用String:from 来实现 当用完String 之后，需要使用某种方式将内存返回给操作系统这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存。没有 GC，就需要我们去识别内存何时不再使用，并调用代码将它返回。―如果忘了，那就浪费内存。 如果提前做了，变量就会非法 如果做了两次，也是 Bug。必须一次分配对应一次释放 但是 Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域时，内存会自动交还给操作系统 drop 函数，当变量走出作用域时，会调用这个函数 变量与数据交互的方式：Move String 的组成由三部分组成：指向数据的指针、长度和容量 这些数据放在 Stack 中 字符串数据存放在 Heap 中 长度 len，就是存放字符串内容所需的字节数 容量 capacity 指的是 String 从系统中获得内存的总字节数 当把 s1 赋值给 s2 时，String 的数据被复制了一份，这实际上只复制了指针、长度和容量这一数据，在堆中的数据并没有被复制。 因此当变量离开作用域的时候，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放掉。而在 s1 和 s2 都离开作用域的时候，它们都会尝试释放相同的内存，这时就出现了严重的二次释放(double free)bug 为了保证内存安全，Rust 中没有尝试复制堆中被分配的内存，Rust 让 s1 失效：当 s1 离开作用域的时候，Rust 不需要释放任何东西 当 s2 创建之后再使用 s1 的效果由下例展示： 12345fn test02() &#123; let s1 = String::from(&quot;Owner of Rust#&quot;); let s2 = s1; println!(&quot;&#123;&#125;&quot;, s1);&#125; 当创建 s2 之后，将 s1 的值赋值给 s2 之后，编译器会报如下的错： 123456789101112131415161718192021222324252627➜ ~/Code/rust/owner git:(master) ✗ cargo run Compiling owner v0.1.0 (/home/cherry/Code/rust/owner)warning: unused variable: `s2` --&gt; src/main.rs:22:9 |22 | let s2 = s1; | ^^ help: if this is intentional, prefix it with an underscore: `_s2` | = note: `#[warn(unused_variables)]` on by defaulterror[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:24:20 |20 | let s1 = String::from(&quot;Owner of Rust#&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait21 | 22 | let s2 = s1; | -- value moved here23 | 24 | println!(&quot;&#123;&#125;&quot;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)For more information about this error, try `rustc --explain E0382`.warning: `owner` (bin &quot;owner&quot;) generated 1 warningerror: could not compile `owner` due to previous error; 1 warning emitted 也许这跟浅拷贝（shadow copy）比较类似，但是 Rust 同时还让 s1 失效了，因此用一个新的术语 move 来形容。同时 Rust 也隐含了一个设计原则：即 Rust 不会自动创建数据的深拷贝，通俗的说就是一块内存只能有一个变量进行操作。就运行时性能而言，任何自动赋值操作都是廉价的。 变量与数据交互的方式：Clone 要想对 heap 上面的数据进行深拷贝，可以使用 clone 方法，clone 是 copy 子集。例子如下： 12345fn test02() &#123; let s1 = String::from(&quot;Owner of Rust#&quot;); let s2 = s1.clone; println!(&quot;&#123;&#125;&quot;, s1);&#125; Stack上的数据:复制 Copy trait，可以用于像整数这样完全存放在stack上面的类型 如果一个类型实现了 Copy 这个 trait，那么旧的变量在赋值后仍然可用 如果一个类型或者该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了 标准库文档里有说，std::ops::Drop 这个 trait 与 Copy_trait 无法共存于一个类型，因为在 Move 时，若发生 Copy 行为，Copy 行为是隐式的，因为是隐式的，编译器很难预测什么时候调用 Drop 函数，而实现了 Clone_trait 的，因为 clone 是显式的，需要 a.clone() 这样，那么编译器就能通过这种显式的 clone，确定被 clone 的变量的位置，决定何时调用 drop 函数。 一些拥有 Copy trait 的类型 任何简单标量的组合类型都可以是 Copy 的 任何需要分配内存或某种资源的都不是 Copy 的 一些拥有 Copy trait 的类型:–所有的整数类型 例如 u32-bool char 所有的浮点类型，例如 f64 Tuple(元组），如果其所有的字段都是 Copy 的 (i32, i32) 是 (i32, String) 不是 12345678910111213141516fn test02() &#123; let s1 = String::from(&quot;Owner of Rust#&quot;); take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s1); //报错，因为 s1 被 take_ownership 调用过后就会释放掉 let x = 20; makes_copy(x); println!(&quot;&#123;&#125;&quot;, x);&#125;fn take_ownership(string: String) &#123; println!(&quot;&#123;&#125;&quot;, string);&#125;fn makes_copy(num: u32) &#123; println!(&quot;&#123;&#125;&quot;, num);&#125; 返回值与作用域 函数在返回值的过程中也会发生所有权的转移，下面的例子可以很好的帮助理解所有权这一概念： 12345678910111213141516fn test03() &#123; let s1 = give_ownership(); let s2 = String::from(&quot;Rust&quot;); let s3 = take_and_give_ownership(s2);&#125;fn give_ownership() -&gt; String &#123; let string = String::from(&quot;$Rust$&quot;); string&#125;fn take_and_give_ownership(string: String) -&gt; String &#123; string&#125; 其中 s2 在函数 take_and_give_ownership 调用后，所有权转移到了函数中，随着函数执行完，s2 的所有权也没有了。实际上函数的作用就是获得 s2 的所有权，然后这个所有权又返回给了 s3. 一个变量的所有权总是遵循同样的模式: 把一个值赋给其它变量时就会发生移动 当一个包含 heap 数据的变量离开作用域时，它的值就会被drop 函数清理，除非数据的所有权移动到另一个变量上 那么如何让函数使用某个值，而不获得其所有权？例子如下： 123456789101112fn test04() &#123; let s1 = String::from(&quot;Welcome!&quot;); let (s2, len) = calc_len(s1); println!(&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;, s2, len);&#125;fn calc_len(str: String) -&gt; (String, usize) &#123; let len = str.len(); (str, len)&#125; 我们将 s1 作为参数传递进去，返回一个包含 String 和 usize 类型的元组，这样就将 s1 的所有权转移给了 s2。 那么如果不要传递参数能做到吗？下一节进行介绍。 引用与借用123456789fn test05() &#123; let s = String::from(&quot;引用与借用&quot;); let len = calc_len_2(&amp;s); println!(&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;, s, len);&#125;fn calc_len_2(str: &amp;String) -&gt; usize &#123; str.len()&#125; 参数类型是 &amp;String 而不是 String &amp;就表示引用，允许引用某些值而不得到其所有权 注：Rust 中解引用的符号和 C&#x2F;C++ 中是一样的，都是 *. 把引用作为函数参数的行为就叫借用 和变量一样，引用也是默认不能被修改的 若要使其能够修改，需要加上 mut 关键字 例子如下： 12345678910fn test05() &#123; let mut s = String::from(&quot;引用&quot;); let len = calc_len_2(&amp;mut s); println!(&quot;The string &#123;&#125;&#x27;s length is &#123;&#125;.&quot;, s, len);&#125;fn calc_len_2(str: &amp;mut String) -&gt; usize &#123; str.push_str(&quot;与借用&quot;); str.len()&#125; 若修改了一个引用对象，则会报这样的错误： cannot borrow *str as mutable, as it is behind a &amp; reference 可变引用 可变引用有一个重要的限制:在特定作用域内，对某一块数据，只能有一个可变的引用。 这样做的好处是可在编译时防止数据竞争 以下三种行为下会发生数据竞争: 两个或多个指针同时访问同一个数据一至少有一个指针用于写入数据 没有使用任何机制来同步对数据的访问 可以通过创建新的作用域，来允许非同时的创建多个可变引用 例： 123456fn test06() &#123; let mut s = String::from(&quot;Hello&quot;); let s1 = &amp;mut s; let s2 = &amp;mut s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, s1, s2);&#125; 这里 s1 和 s2 同时对可变变量 s 进行了引用，就会报这样的错误：cannot borrow s as mutable more than once at a time 通过创建新的作用域，可以允许非同时的创建多个可变引用 1234567fn test06() &#123; let mut s = String::from(&quot;Hello&quot;); &#123; let s1 = &amp;mut s; &#125; let s2 = &amp;mut s;&#125; 另一个限制 不可以同时拥有一个可变引用和一个不变的引用（因为不可变引用的作用就是不让值改变，被可变引用改变后，不可变引用就失去了其作用） 多个不变的引用是可以的 1234567fn test06() &#123; let mut s = String::from(&quot;Hello&quot;); let s2 = &amp;s; let s3 = &amp;s; let s4 = &amp;mut s; //报错 println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, s2, s3, s4);&#125; 这样便会报错：cannot borrow s as mutable because it is also borrowed as immutable 悬空引用 Dangling References 悬空指针（Dangling Pointer): 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了。 在Rust里，编译器可保证引用永远都不是悬空引用 如果你引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域 12345678fn test07() &#123; let r = dangle();&#125;fn dangle() -&gt; &amp;String &#123; let s = String::from(&quot;Dangling reference&quot;); &amp;s&#125; 程序在 dangle 函数中声明了一个字符串，期望返回其的引用，但是函数结束后 s 便离开了他的作用域，即被销毁，因此返回的引用为空。这和 C 语言中返回局部变量的地址如出一辙，但是 Rust 在编译时就将避免这样的问题发生。 报错：missing lifetime specifier 引用的规则 在任何给定的时刻，只能满足下列条件之一:一个可变的引用，或者任意数量不可变的引用，而且引用必须一直有效。 六、切片Rust 的另一种不持有所有权的数据类型：切片（Slice） 下面编写这样一个函数进行示范： 它接收字符串作为参数 返回它在这个字符串里找到的第一个单词 如果函数没有找到任何空格，则返回整个字符串 12345678910111213141516171819202122fn main() &#123; let mut s = String::from(&quot;Hello World&quot;); let space_index = first_word(&amp;s); s.clear(); println!(&quot;The first blank&#x27;s position is in &#123;&#125;.&quot;, space_index);&#125;fn first_word(s: &amp;String) -&gt; usize &#123; let bytes = s.as_bytes(); /* byte 的 iter 方法会为数组 byte 创建一个迭代器，这个方法会依次返回集合中的每个元素 enumerate 方法会将 iter 返回的结果进行包装，并把每个结果作为一个元组的一部分进行返回 元组的第一个元素就是遍历的索引，第二个元素就是数组中的元素（是一个引用），这里实际用到的是模式匹配 声明了两个变量对这个元组进行解构 */ for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; return i; &#125; &#125; s.len()&#125; 实际上这个函数的设计有一个缺陷，这个函数是将字符串空格的索引位置返回，而一旦这个结果脱离了这个字符串的上下文，这个返回值便没有了意义。换句话说，这个索引位置的结果是独立于字符串而存在的，在函数返回以后，我们就再也无法保证其有效性。举个例子，若函数获取 Hello World 这个字符串的空格位置，获取到函数返回值为 5 后，将该字符串清空 s.clear()，但是此时函数返回值 space_index 的值仍然是 5，这跟现在的字符串便没有了任何关联，因此这个返回值便没有了意义了。这样的 API 需要关注两者之间的同步性，但是往往都会比较繁琐。 Rust 提供了切片类型用来解决这一问题。 字符串切片 字符串切片是指向字符串中一部分内容的引用 形式：[开始索引..结束索引]，前闭后开 切片是放在 stack 上，右边的数组是放在 heap 上的。 【更正】：s 切片的长度和容量应该为 11. 12345fn main() &#123; let mut s = String::from(&quot;Hello World&quot;); let hello = &amp;s[0..5]; let world = &amp;s[6..11];&#125; 这里切片有三个语法糖，若切片的开始位置为 0，则可以省略写，若切片的末尾时字符串最后一个位置，即等于字符串长度，那么也可以省略不写，下面的例子和上面是等价的： 12345678910fn main() &#123; let mut s = String::from(&quot;Hello World&quot;); let hello = &amp;s[..5]; let world = &amp;s[6..]; let whole = &amp;s[..]; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, hello, world); //输出为 Hello, World println!(&quot;&#123;&#125;&quot;, whole); //输出为 Hello World&#125; 注意： 字符串切片的范围索引必须发生在有效的 UTF-8 字符边界内。 如果尝试从一个多字节的字符中创建字符串切片，程序会报错并退出 下面用切片重写上面的函数： 12345678910111213141516fn main() &#123; let mut s = String::from(&quot;Hello World&quot;); let space_index_slice = first_word_slice(&amp;s); s.clear(); //报错 println!(&quot;The first world is &#123;&#125;.&quot;, space_index_slice);&#125;fn first_word_slice(s: &amp;String) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 这里函数返回 &amp;str 表示字符串切片，若找到空格，将返回该位置之前的字符串切片，否则返回整个字符串切片。 但是上述代码中 s.clear() 会报错，报错信息为: 1234567891011121314error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:7:5 |5 | let space_index_slice = first_word_slice(&amp;s); | -- immutable borrow occurs here6 | 7 | s.clear(); | ^^^^^^^^^ mutable borrow occurs here...13 | println!(&quot;The first blank&#x27;s position is in &#123;&#125;.&quot;, space_index_slice); | ----------------- immutable borrow later used hereFor more information about this error, try `rustc --explain E0502`.error: could not compile `slice` due to previous error 即不能将变量 s 借用为可变，因为它已经被借用为不可变。在函数参数中用了不可变引用，但是下面 s.clear() 又要修改字符串的值，使其变成可变，这样便会报错。 字符串字面值是切片 字符串字面值被直接存储在二进制程序中 let s = &quot;Hello, World!&quot;; 变量 s 的类型是 &amp;str，它是一个指向二进制程序特定位置的切片 &amp;str 是不可变引用，所以字符串字面值也是不可变的 将字符串切片作为参数传递 有经验的 Rust 开发者会采用 &amp;str 作为参数类型，因为这样就可以同时接收 String 和 &amp;str 类型的参数了 使用字符串切片，直接调用该函数 使用 String，可以创建一个完整的 String 切片来调用该函数 定义函数时使用字符串切片来代替字符串引用会使我们的 API 更加通用，且不会损失任何功能 123fn first_word(s: &amp;str) -&gt; &amp;str &#123; //TODO&#125; 其他类型的切片 12345fn main() &#123; let a = [1, 2, 3, 4, 5]; let slice = &amp;a[1..3]; println!(&quot;&#123;&#125;&quot;, slice[1]);&#125; 这个切片类型为 &amp;[i32]，它存储了一个指向起始元素的位置的指针，还存储了一个长度，该例中为 2","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"}]},{"title":"C语言进阶学习","slug":"C语言进阶学习","date":"2022-04-13T06:39:25.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"1d66df69.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1d66df69.html","excerpt":"C语言进阶学习","text":"C语言进阶学习 1. typedef、void 和 sizeof 的使用typedef 简化 struct 关键字 123456789101112131415161718struct Student &#123; string name; int age;&#125;;//将struct Student类型简化成Stu，就是少写一个structtypedef struct Student Stu;//更简单的写法就是typedef struct Student &#123; string name; int age;&#125; Stu;void test() &#123; struct Student s1 = &#123;Cherry, 20&#125;; //可以直接用Stu定义一个结构体变量 Stu s2 = &#123;Alice, 23&#125;;&#125; 区分数据类型 12345678void test2() &#123; //这里p1是char*类型，而p2是char类型 char *p1, p2; //为了做更好的区分，可以使用typedef定义char* typedef char* PCHAR; //这样两个变量都是char指针类型，这样等价于 char *p1, *p2; PCHAR p1, p2;&#125; 提高移植性 1234567typedef long long MYTYPElong long a = 10;long long b = 20;//可以写成MYTYPE a = 10;MYTYPE b = 10; void 无类型，不能通过无类型创建变量，因为不知道分配多少内存空间 12//这样是错误的，编译器会报错void a = 2; 可以限定函数的返回值，限定函数参数 1234567891011121314#include &lt;stdio.h&gt;func() &#123; return 10;&#125;void test2() &#123; func(10, 20);&#125;int main() &#123; test2(); return 0;&#125; 上面这段 C 代码，看似有很多问题：func 函数没有返回类型，返回了 10，并且函数没有传入参数，调用函数时还传入了参数，但是该 C 语言代码依旧可以运行，可以看出 C 语言并不严谨。 这时将 func 函数改成下面这样，编译器就会报出警告 123func(void) &#123; return 10;&#125; void* 万能指针 12345678910void *p = NULL;int *pInt = NULL;char *pChar = NULL;//不同类型指针之间需要强制转换才不会报警告pChar = (char*)pInt;//通过 void* 万能指针，就不会报警告了pChar = p; sizeof 首先 sizeof 本质上不是一个函数，而是一个运算符，类似于 +-*/ 123456void test01() &#123; double d = 3.14; printf(&quot;sizeof int = %d\\n&quot;, sizeof(int)); //对于统计变量的时候，可以不加小括号，所以他不是函数 printf(&quot;sizeof d = %d\\n&quot;, sizeof d);&#125; sizeof 返回一个无符号整型 12345678void test02() &#123; unsigned int a = 10; if (a - 20 &gt; 0) &#123; printf(&quot;大于0&quot;); &#125; else &#123; printf(&quot;小于0&quot;); &#125;&#125; 这段代码输出结果为 大于0，因为一个无符号整数和有符号整数做运算，最后统一转换为无符号整数。 同理可以验证 sizeof 返回的也是无符号整数： 1234567void test02() &#123; if (sizeof(int) - 5 &gt; 0) &#123; printf(&quot;大于0&quot;); &#125; else &#123; printf(&quot;小于0&quot;); &#125;&#125; 最后得到的结果也是 大于0。 sizeof 其他用法 统计数组占用内存空间大小 123456789101112#include &lt;stdio.h&gt;void test(int arr[]) &#123; printf(&quot;##sizeof arr = %d\\n&quot;, sizeof(arr));&#125;int main() &#123; int arr[] = &#123;1, 2, 3, 4&#125;; printf(&quot;sizeof arr = %d\\n&quot;, sizeof(arr)); test(arr); return 0;&#125; 最后输出为： 12sizeof arr = 16##sizeof arr = 8 这是因为当数组以参数的形式传递时，将得到的是数组的指针，即数组的第一个元素所在的位置，这时打印出的大小便是指针的大小。 2. C语言 %d 等输出格式意义 %d整型输出，%ld长整型输出。 %p指针变量地址，如果输出数据不够8位数，则左边补零。 %o以八进制数形式输出整数。 %x以十六进制数形式输出整数。 %u以十进制数输出unsigned型数据(无符号数)。 %c用来输出一个字符。 %s用来输出一个字符串。 %f用来输出实数，以小数形式输出。 %e以指数形式输出实数。 %g根据大小自动选f格式或e格式，且不输出无意义的零。 3. 内存的四个区域 代码区 共享 只读 数据区 静态变量，全局变量，常量 已初始化（data段） 未初始化（bss段） 栈区 编译器自动分配释放，存放函数的参数值、返回值、局部变量等 局部变量的生存周期为函数内部申请到释放该段栈空间 堆区 容量远大于栈 用于动态内存分配 堆在内存中位于 bss 段和栈区之间，一般由程序员分配和释放，程序结束后由 OS 释放 局部变量在栈空间创建空间举例 123456789char *getString() &#123; char str[] = &quot;Hello World&quot;; return str;&#125;void test02() &#123; char *str = getString(); printf(&quot;%s\\n&quot;, str);&#125; 这段代码是无法正确输出 Hello World 的，因为在 getString 中创建的是局部变量 str，是在栈空间中创建空间，而在函数 getString 运行结束后，栈空间将被释放，因此获得的 str 指针为空。 即不要返回局部变量的地址 堆区举例 123456789101112131415161718192021222324//堆区int *getSpace() &#123; //开辟4*5=20B空间，开辟到了堆区 int *p = (int*)malloc(sizeof(int) * 5); if (p == NULL) &#123; return NULL; &#125; for (int i = 0; i &lt; 5; i++) &#123; p[i] = i + 100; &#125; return p;&#125;void test03() &#123; int *p = getSpace(); for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d &quot;, p[i]); &#125; free(p); //释放掉p指向的内存区域 p = NULL; //释放掉之后将p指向空，避免p成为野指针 for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d &quot;, p[i]); &#125;&#125; 堆区分配内存注意点 12345678910111213//堆区注意点void allocateSpace(char *pp) &#123; char *temp = malloc(100); memset(temp, 0, 100); strcpy(temp, &quot;Hello World&quot;); pp = temp;&#125;void test04() &#123; char *p = NULL; allocateSpace(p); printf(&quot;p = %s&quot;, p);&#125; 上面的代码输出结果实际上是 null，并不会输出字符串 Hello World 因为在 test04 中，传入的参数是 char 指针，是一个局部变量，在栈中分配内存。函数 allocateSpace 中的参数也是在栈中分配内存，只不过 p 是在 test04 的栈中，而 pp 是在 allocateSpace 的栈中。而用 malloc 在堆中分配内存时，返回的首地址指针赋值给了一个局部变量 temp，然后在这个堆空间中复制字符串 Hello World，最后这个首地址指针又赋值给了 pp。因此自始至终都未修改 test04 栈中的 p 指针的值，所以最后输出的是 null。 要想修改 p 指针的值，需要用更高级别的指针进行修改，这时传入函数 allocateSpace 的参数应该是 p 指针的地址，即 p 指针的指针（二级指针），这样才能完成对 p 指针的赋值操作。 将代码改成下面这样，就可以正确输出结果了： 12345678910111213void allocateSpace2(char **pp) &#123; char *temp = malloc(100); memset(temp, 0, 100); strcpy(temp, &quot;Hello World&quot;); *pp = temp;&#125;void test04() &#123; char *p = NULL; allocateSpace2(&amp;p); printf(&quot;p = %s&quot;, p); &#125; 4. 静态变量和全局变量数据区中存放全局变量、静态变量、常量 静态变量 静态变量在程序运行前分配内存，生命周期在程序结束时死亡。默认属于内部链接属性，只能在该文件内部使用。 全局变量 默认在 C 语言下，全局变量前加了关键字 extern。属于外部链接属性。 5. 常量const修饰的常量 1234567891011const int a = 2022; //放在数据区的常量区中，受到保护，无法修改void test01() &#123; //无法直接修改一个 const 修饰的常量 // a = 333; //利用指针修改，实际上也是无法成功，在解引用的时候会出现异常 int *p = &amp;a; *p = 100; printf(&quot;%d&quot;, *p);&#125; 全局常量是无法被直接或间接修改的。 123456789void test02() &#123; //局部常量也无法被直接修改 const int b = 421; // b = 2022; //但是可以被间接修改，因为局部变量存放在栈中，不受常量区保护 int *p = &amp;b; *p = 145; printf(&quot;%d\\n&quot;, b);&#125; 但是局部常量可以被间接修改，因为局部变量存放在栈中，不受常量区保护。 字符串常量 12345678910void test03() &#123; char *p1 = &quot;Hello World&quot;; char *p2 = &quot;Hello World&quot;; char *p3 = &quot;Hello World&quot;; printf(&quot;%p\\n&quot;, p1); printf(&quot;%p\\n&quot;, p2); printf(&quot;%p\\n&quot;, p3); printf(&quot;%p\\n&quot;, &amp;&quot;Hello World&quot;);&#125; 它们输出的指针是同一个，说明同样的字符串常量在内存中只保留一份，节省了内存。 123456//字符串常量也是不可以修改的void test04() &#123; char *p1 = &quot;Hello World&quot;; p1[0] = &#x27;B&#x27;; printf(&quot;%s&quot;, p1);&#125; 但是有些编译器支持修改字符串常量。而且对于相同的字符串常量是否共享，不同的编译器会有不同的结果。 6. 函数调用流程宏函数将一些频繁使用且短小的函数定义成宏函数，定义宏函数时要注意函数的完整性。 优点：以空间换时间，这里的时间就是将宏函数当做普通函数时参数的入栈出栈操作 1234567#define ADD(x, y) ((x) + (y))void test() &#123; int a = 2017; int b = 5; printf(&quot;%d&quot;, ADD(a, b));&#125; 函数调用惯例对于下面这一段代码，分析程序调用的流程。 1234567891011int sum(int a, int b) &#123; int _a = a; int _b = b; return _a + _b;&#125;int main() &#123; int res = 0; res = sum(10, 20); return 0;&#125; 首先将主函数中 ret 进栈，然后调用 sum 函数，将改行的返回地址进栈。接着进入到 sum 函数中，将参数 b 和 a 依次进栈，再在栈中为 _a 和 _b 开辟空间，最后返回两者的和存到一个临时变量中，这个变量也是在栈中，然后函数执行完毕，释放掉栈中的变量，回到返回地址处继续执行代码。 注意点： 参数入栈是从右到左 由主调函数负责出栈 调用惯例 出栈方 参数传递 名字修饰 cdecl（C和C++默认） 函数调用方（主调函数） 从右到左参数入栈 下划线+函数名 stdcall 函数本身（被调函数） 从右到左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身（被调函数） 前两个参数由寄存器传递，其余参数通过栈传递 @+函数名+@+参数字节数 pascal 函数本身（被调函数） 从左到右参数入栈 较为复杂，略 变量传递main -&gt; 子函数1 -&gt; 子函数2 main 函数在栈区开辟的内存，所有子函数都可以使用 main 函数在堆区开辟的内存，所有子函数都可以使用 子函数 1 在栈区开辟的内存，子函数 1 和 2 都可以使用 子函数 1 在堆区开辟的内存，所有函数都可以使用 子函数 2 在全局区开辟的内存，子函数 1 和 main 函数都可以使用 栈扩展方向通过下面的代码可以得到栈顶在低地址，栈底在高地址，是从高地址向低地址扩展的。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void test(int a, int b, int c) &#123; printf(&quot;0x%p\\n&quot;, &amp;a); printf(&quot;0x%p\\n&quot;, &amp;b); printf(&quot;0x%p\\n&quot;, &amp;c);&#125;int main() &#123; test(1, 2, 3); return 0;&#125; 输出结果为： 1230x000000001041FE000x000000001041FE080x000000001041FE10 7. 野指针和空指针空指针指向 NULL，而野指针指向一个已经删除的对象或未申请访问受限区域的指针。野指针只能通过良好的代码习惯来避免，而空指针可以通过判断语句来避免。 野指针的三种情况 指针变量未初始化 指针创建时不会自动设置为 NULL，需要手动置为空或指向有效内存 指针释放后未置空 指针释放后只是释放掉了当前指针指向的内存，并没有修改指针的值 指针变量超出了作用域 即在函数中返回局部变量的地址 对于指针 free 后未置空的情况，下面有个例子可以说明： 1234567void test02() &#123; char *p = malloc(20); strcpy(p, &quot;I want to swim...&quot;); printf(&quot;%s\\n&quot;, p); free(p); printf(&quot;%s\\n&quot;, p);&#125; 第一个 printf 输出的是正确的字符串，而第二个 printf 输出却是不正确的值，因为 free 操作释放掉了原来指针指向的内存，那片内存可以被计算机中其他程序使用，因此数据成了脏数据（尽管可能那段内存没有被使用，数据还和原来一样，但是从逻辑上指针已经失去了对那片内存的控制权）。对于野指针，可以读取（编译器不会报错），但是要写入的话就会报错。 对于函数中返回局部变量的地址，因为在函数中的局部变量是在栈中开辟的，函数调用完后将会清空栈中的变量，这样指针指向的地址也就失去了意义，成为了野指针。 1234567891011int *test() &#123; int a = 10; return &amp;a;&#125;int main() &#123; int *p = test(); printf(&quot;%p&quot;, p); printf(&quot;%p&quot;, p); return 0;&#125; 上述代码两句输出理论上都是无法输出正确结果的，但是代码运行结果确是第一个能正确输出，第二个无法正确输出。这是因为编译器的缘故，编译器会保留一次栈中的变量供之后访问。（不同的编译器可能会有不同的结果，但是尽量不要这样写） 另外：空指针可以重复释放，而野指针不能重复释放 123456789101112void test() &#123; //这样不会报错 int *p = 10; free(p); p = NULL; free(p); //这样会报错 int *pp = 10; free(pp); free(pp);&#125; 8. 指针的步长指针步长指的是指针变量 +1 后跳跃的字节数，也是指指针解引用的时候取出的字节数。下面的例子很好的帮助理解指针的步长： 123456void test05() &#123; char buf[10] = &#123;0&#125;; int a = 2022; memcpy(buf + 1, &amp;a, sizeof(int)); printf(&quot;%d\\n&quot;, *(int*)(buf + 1));&#125; 这样可以成功输出 2022。 下面以一个结构体作为例子，进一步说明指针步长： 12345678910111213141516struct Pointer &#123; char a; //0~3 int b; //4~7 char buf[64]; //8~71 int d; //72~76&#125;;void test06() &#123; struct Pointer p = &#123;&#x27;B&#x27;, 2022, &quot;I will go to Beijing soon...&quot;, 8013&#125;; //p中d字段的偏移量？(包含在 stddef.h 头文件中) /* * #define offsetof(s, m) (size_t)&amp;(((s*)0)-&gt;m) */ printf(&quot;d&#x27;s offset = %d\\n&quot;, offsetof(struct Pointer, d)); printf(&quot;%d\\n&quot;, *(int*)((char*)(&amp;p) + offsetof(struct Pointer, d)));&#125; 上述代码要输出结构体中字段 d，我们首先获取 d 的偏移量：offsetof(struct Pointer, d)，然后取得结构体首地址，将指针类型转成 char*，然后加上偏移量之后再转成 int*，最后再解引用，输出结果 8013。 9. 指针做函数参数指针做函数参数，具有输入和输出两种特性 输入特性：在主调函数分配内存，被调函数中使用输出特性：在被调函数分配内存，主调函数中使用（被调函数中要用比主调函数更高级的指针去修改） 10. 字符串基本操作1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; //当未定义字符数组的长度时，会输出乱码，因为输出直到出现 &#x27;\\0&#x27; 为止 char str1[] = &#123;&#x27;B&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;; printf(&quot;str1 = %s\\n\\n&quot;, str1); //当定义了字符数组的长度时，对字符数组初始化后会在后面默认用 0 填充 char str2[20] = &#123;&#x27;B&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;; printf(&quot;str2 = %s\\n\\n&quot;, str2); //若以字符串初始化，编译器会默认在字符串最后添加 &#x27;\\0&#x27; char str3[] = &quot;Beijing&quot;; printf(&quot;str3 = %s\\n&quot;, str3); printf(&quot;sizeof str3 = %d\\n&quot;, sizeof(str3)); // 8 sizeof 计算 &#x27;\\0&#x27; printf(&quot;strlen str3 = %d\\n\\n&quot;, strlen(str3)); // 7 strlen 不计算 &#x27;\\0&#x27; char str4[20] = &quot;Beijing&quot;; printf(&quot;str4 = %s\\n&quot;, str4); printf(&quot;sizeof str4 = %d\\n&quot;, sizeof(str4)); // 20 printf(&quot;strlen str4 = %d\\n\\n&quot;, strlen(str4)); // 7 char str5[] = &quot;Beijing\\0Welcome&quot;; printf(&quot;str5 = %s\\n&quot;, str5); printf(&quot;sizeof str5 = %d\\n&quot;, sizeof(str5)); // 16 printf(&quot;strlen str5 = %d\\n\\n&quot;, strlen(str5)); // 7 char str6[] = &quot;Beijing\\012Welcome&quot;; printf(&quot;str6 = %s\\n&quot;, str6); printf(&quot;sizeof str6 = %d\\n&quot;, sizeof(str6)); // 16 \\012 是用八进制表示的转义字符，表示换行，再加上末尾的 &#x27;\\0&#x27; printf(&quot;strlen str6 = %d\\n\\n&quot;, strlen(str6)); // 15 return 0;&#125; 最终输出结果为： 1234567891011121314151617181920str1 = Beijing爅€ //后面为乱码str2 = Beijingstr3 = Beijingsizeof str3 = 8strlen str3 = 7str4 = Beijingsizeof str4 = 20strlen str4 = 7str5 = Beijingsizeof str5 = 16strlen str5 = 7str6 = BeijingWelcomesizeof str6 = 16strlen str6 = 15 11. 字符串拷贝这里实现了字符串拷贝的三种实现。 123456789101112131415161718192021222324//第一种实现void copyString01(char *dest, char *src) &#123; //利用下标方式拷贝 int len = strlen(src); for (int i = 0; i &lt; len; i++) &#123; dest[i] = src[i]; &#125; dest[len] = &#x27;\\0&#x27;;&#125;//第二种实现void copyString02(char *dest, char *src) &#123; int i = 0; while (*(src + i) != &#x27;\\0&#x27;) &#123; *(dest + i) = *(src + i); i++; &#125; *(dest + i) = &#x27;\\0&#x27;;&#125;//第三种实现void copyString03(char *dest, char *src) &#123; while (*dest++ = *src++);&#125; 其中第三种实现只有一行代码 while (*dest++ = *src++);，在 while 循环中，当 *src 取到 \\0 时，就把它当做 0 看待，因此 while 循环条件中出现 0 便不会继续循环下去，因此会一直拷贝 src 直到遇到 \\0，结束循环时，src 指向 \\0 的下一个位置。 字符串翻转实现同理。 12. 字符串格式化 sprintf 函数 函数定义： 1int sprintf(char *str, const char *format, ...) 这个函数的参数是可变参数。若成功则返回实际格式化的字符个数，否则返回 -1 具体用法参考 《C++常用函数整理》 这篇博客。 sscanf 函数 函数定义： 1int sscanf(const char *str, const char *format, ...); 功能：从 str 指定的字符串读取数据，并根据参数 format 字符串来转换并格式化数据 返回值：成功返回参数数目，失败返回 -1 格式 作用 %*d 或 %*s 跳过数据 %[width]s 读取指定宽度的数据 %[a-z] 匹配所有小写字母 %[^a] 匹配非字符a的任意字符 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950char *str = &quot;http://192.168.3.107:8080&quot;;void test01() &#123; // char *str = &quot;1234ABCD&quot;; char buf[30] = &#123;0&#125;; sscanf(str, &quot;%*[^/]//%[^:]%*s&quot;, buf); printf(&quot;%s\\n&quot;, buf);&#125;void test02() &#123; // char *str = &quot;ABCD2022&quot;; char buf[30] = &#123;0&#125;; // sscanf(str, &quot;%*s%d&quot;, buf); //这样写的话在 %*s 的时候就已经忽略掉整个 str 了 // printf(&quot;%s\\n&quot;, buf); // 应该像下面这样 char *str = &quot;ABCD 2022&quot;; //加上一个空格 sscanf(str, &quot;%*s%s&quot;, buf); printf(&quot;%s\\n&quot;, buf);&#125;void test03() &#123; char buf[30] = &#123;0&#125;; sscanf(str, &quot;%15s&quot;, buf); printf(&quot;%s\\n&quot;, buf);&#125;//如果第一次匹配失败，后续都不再进行匹配void test04() &#123; char *str = &quot;ccherry20221314&quot;; char buf[30] = &#123;0&#125;; sscanf(str, &quot;%[chery]&quot;, buf); printf(&quot;%s\\n&quot;, buf);&#125;void test05() &#123; char *str = &quot;abcde12345&quot;; char buf[30] = &#123;0&#125;; sscanf(str, &quot;%[^e]&quot;, buf); printf(&quot;%s\\n&quot;, buf);&#125;void test06() &#123; char s[30] = &#123;&quot;http://192.168.3.107:8080&quot;&#125;, ss[10]; char protocol[20], host[20], port[20]; sscanf(s,&quot;%[^:]://%[^:]:%[1-9]&quot;, protocol, host, port); /*这样可以把协议名称，IP名称和端口号分别取出*/&#125; 输出结果为： 12345192.168.3.1072022http://192.168.ccherryabcd 要注意的一点是：如果第一次匹配失败，后续将不再匹配。 sscanf 的练习 1234567891011121314151617//sscanf练习void test06() &#123; char *ip = &quot;192.168.1.109&quot;; int num1 = 0, num2 = 0, num3 = 0, num4 = 0; sscanf(ip, &quot;%d.%d.%d.%d&quot;, &amp;num1, &amp;num2, &amp;num3, &amp;num4); printf(&quot;num1 = %d\\n&quot;, num1); printf(&quot;num2 = %d\\n&quot;, num2); printf(&quot;num3 = %d\\n&quot;, num3); printf(&quot;num4 = %d\\n&quot;, num4);&#125;void test07() &#123; char *str = &quot;GMY#baominyang@hrsoft.net&quot;; char buf[50] = &#123;0&#125;; sscanf(str, &quot;%*[^#]#%[^@]&quot;, buf); printf(&quot;My name is %s\\n&quot;, buf);&#125; 13. malloc、calloc、realloccalloc 1void *calloc(size_t nmemb, size_t size); 功能：在内存动态存储区中分配 nmemb 块长度为 size 字节的连续区域，**calloc 自动将分配的内存置零。** 参数： nmenb：所需内存单元数量 size：每个内存单元的大小（字节） 返回值：内存起始地址，错误则返回 NULL. realloc 1void *realloc(void *ptr, size_t size); 功能： 重新分配用 malloc 和 calloc 分配的空间。realloc不会自动清理增加的内存（即新增加的内存不会赋值为0），需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，否则就会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。 参数： ptr: 为之前分配的内存的起始地址，若为 NULL，则功能和 malloc 一致 size: 重新分配的内存的大小 14. const全局 const 无法被修改，局部 const 当做局部变量使用，可以被间接修改。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"}]},{"title":"Linux中sed、awk、grep命令详解","slug":"Linux中sed、awk、grep命令详解","date":"2022-04-01T11:40:35.000Z","updated":"2023-08-08T12:35:27.384Z","comments":true,"path":"574c20f6.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/574c20f6.html","excerpt":"","text":"Linux中sed、awk、grep命令详解在开始介绍 sed、awk、grep 命令之前，先简单介绍一下 bash. 一、bash 及一些特性1. 命令行展开12345678➜ ~ echo change1 change2 change3 change4 change5change1 change2 change3 change4 change5➜ ~ echo change&#123;1..5&#125;change1 change2 change3 change4 change5➜ ~ echo change&#123;1..10..2&#125;change1 change3 change5 change7 change9➜ ~ echo change&#123;01..10..2&#125;change01 change03 change05 change07 change09 echo 命令后面加上 &#123;&#125; 表示命令行展开，例如上例中 &#123;1..5&#125; 表示从 1 展开到 5，如果后面再加上一个参数，则表示步长，&#123;1..10..2&#125; 表示输出 1 到 10 的奇数，若在参数前面加上 0，则表示用 0 补全。 2. alias输出命令 alias 表示查看当前的命令别名，输入 unalias 可以取消已经设定的命令别名。例如： 1alias rm=&quot;rm -i&quot; 3. 历史命令history 可以查看所有时间内该机器输入过的命令，可以通过 !行号 快捷输入曾经输过的命令，!! 表示上一次输入的命令。 4. 快捷键12345ctrl + a 光标移动到行首ctrl + e 光标移动到行尾ctrl + u 删除光标之前的字符ctrl + k 删除光标之后的字符ctrl + l 清屏，相当于 clear 二、Linux 正则表达式正则表达式 REGEXP 分为两类 基本正则表达式 BRE 扩展正则表达式 ERE Linux 下只有 sed、grep、awk 三个命令可以使用正则表达式，其他命令都无法使用 Linux 三剑客 grep：文本过滤工具，模式工具 sed：stream editor，流编辑器，文本编辑工具 awk：Linux 的文本报告生成器（格式化文本），实际上是链接到 gawk 上 正则表达式的分类 基本正则表达式对应元字符有：^$.[]* 扩展正则表达式在基本正则表达式基础上增加了 ()&#123;&#125;?+| 等字符 基本功能： 符号 作用 ^ 用于模式最左侧，如 ^abc 表示以 abc 开头的行 $ 用于模式最右侧，如 abc$ 表示以 abc 结尾的行 ^$ 组合符，表示空行 . 匹配任意单个字符，不包括空行 \\ 转义符 ^.* 匹配任意多个字符开头的行 .*$ 匹配任意多个字符结尾的行 [abc] 匹配集合内任意一个字符 [^abc] 匹配除了集合中任意一个字符 扩展正则表达式 ERE 集合扩展正则必须用 grep -E 才能生效 符号 作用 + 匹配前一个字符一次或多次 [a]+ 匹配集合中的符号至少一次或多次 ? 匹配前一个字符 0 次或 1 次 () 在括号中的符号表示一个整体 a{n,m} 匹配前一个字符至少 n 次，至多 m 次 a{n,} 匹配前一个字符至少 n 次 a{n} 匹配前一个字符正好 n 次 a{,m} 匹配前一个字符至多 m 次 一些正则表达式的例子三、grep grep 英文全称是 Global search REgular expression and Print out the line. 作用：文本搜索工具，根据用户指定的模式过滤条件，对目标文本逐行进行匹配检查，打印匹配到的行 12345678语法grep [options] [pattern] file命令 参数 匹配模式 文件数据 -i: ignorecase，忽略字符的大小写 -o: 仅显示匹配到的字符串本身 -v, --invert-match: 显示不能被模式匹配到的行 -E: 支持使用扩展的正则表达式元字符 -q, --quiet, --silent: 静默模式，即不输出任何信息 参数选项 参数含义 -v 排除匹配结果 -i 不区分大小写 -n 显示匹配行与行号 -c 只统计匹配的行数 -E 使用拓展正则 –color&#x3D;auto 为过滤结果添加颜色 -w 只匹配过滤的单词 -o 只输出匹配到的内容 例子 1：找出文本文件 bre 中的空行 1234567891011121314➜ ~/code/awk grep -n -E &#x27;^$&#x27; bre2:5:6:➜ ~/code/awk grep -n -E &#x27;^$&#x27; bre -c3➜ ~/code/awk cat -n bre 1 abc is a simple word. 2 3 What is the answer? 4 I am 23 years old. 5 6 7 I come from JiangSu... 例子 2：在上面的文件中增加以 # 开头的注释行，并筛选出非空行和注释行 1234567891011121314151617181920➜ ~/code/awk cat -n bre 1 abc is a simple word. 2 3 What is the answer? 4 I am 23 years old. 5 6 7 I come from JiangSu... 8 #这是一个注释行➜ ~/code/awk grep &#x27;^$&#x27; bre -vabc is a simple word.What is the answer?I am 23 years old.I come from JiangSu...8:#这是一个注释行➜ ~/code/awk grep &#x27;^$&#x27; bre -v | grep -E &#x27;#&#x27; -vabc is a simple word.What is the answer?I am 23 years old.I come from JiangSu... 用管道符将两个命令连接起来。 例子3：匹配以 . 结尾的行 1234➜ ~/code/awk grep &#x27;\\.$&#x27; breabc is a simple word.I am 23 years old.I come from JiangSu... . 前要用转义符 \\ 进行转义 【注】：在 Linux 下，所有文件每一行的结尾最后都有一个 $，可以加上参数 -E 查看，如下所示： 123456789➜ ~/code/awk cat -En bre 1 abc is a simple word.$ 2 $ 3 What is the answer?$ 4 I am 23 years old.$ 5 $ 6 $ 7 I come from JiangSu...$ 8 #这是一个注释行$ 例子4：在 bre 文件中找到以 a 或 w 开头的行，忽略大小写 123➜ ~/code/awk grep -E -n -i &#x27;^[a|w]&#x27; bre1:abc is a simple word.3:What is the answer? grep 整体比较简单，主要是正则表达式的使用。 四、sedsed 是 Stream Editor（字符流编辑器）的缩写，简称流编辑器。 sed 是操作、过滤和转换文本内容的强大工具，常用功能包括结合正则表达式对文件实现快速增删改查，较为重要的两个功能是提取富川和提取整行。 4.1 sed 语法sed 语法如下： 1sed [选项] [sed内置命令字符] [输入文件] 选项 参数选项 解释 -n 取消默认 sed 的输出，常与 sed 内置命令 p 一起用 -i 直接将修改结果写入文件,不用 -i，sed 修改的是内存数据 -e 多次编辑,不需要管道符了 -r 支持正则扩展 内置命令字符 内置命令字符 解释 a append，对文本追加，在指定行后面添加一行&#x2F;多行文本 d Delete，删除匹配行 i insert，表示插入文本,在指定行前添加一行&#x2F;多行文本 p Print，打印匹配行的内容,通常 p 与 -n 一起用 s&#x2F;正则&#x2F;替换内容&#x2F;g 匹配正则内容，然后替换内容(支持正则)，结尾g代表全局匹配 匹配范围 匹配范围 解释 空地址 全文处理 单地址 指定文件某一行 &#x2F;pattern&#x2F; 被模式匹配到的每一行 范围区间 10, 20 十到二十行，10,+5 第10行向下5行, &#x2F;pattern1&#x2F; ,&#x2F;pattern2&#x2F; 步长 12，表示1、3、5、7、9行，22两个步长，表示 2、4、6、8、10、偶数行 4.2 sed 例子下列所有例子都将使用如下测试用例。 1234567891011121314➜ ~/code/awk cat -n bre 1 abc is a simple word. 2 3 What is the answer? 4 I am 23 years old. 5 6 My tel is 12345678999 7 My favirate food is hamburger. 8 I come from JiangSu... 9 10 11 #这是一个注释行 12 xxxx 13 xxxxxxx 1. 输出文件第3、4行123➜ ~/code/awk sed &quot;3,4p&quot; -n breWhat is the answer?I am 23 years old. sed 默认输出是所有的，因此要加上 -n 参数，p 表示打印。 2. 过滤含有 My 的字符串行123➜ ~/code/awk sed &quot;/My/p&quot; -n breMy tel is 12345678999My favirate food is hamburger. 这里要匹配字符串 My，因此要用 /My/ 进行模式匹配，同样要用 -n 参数。 3. 删除有 is 的行12345678910➜ ~/code/awk sed &quot;/is/d&quot; breI am 23 years old.I come from JiangSu...#这是一个注释行xxxxxxxxxxx 我们这里用参数 d，表示删除匹配到的行，然后不用加 -n 参数，但是 bre 文件中的内容并不会被改变，因为 sed 是将文件内容读到内存中进行操作的。如果要对源文件进行修改，则要加上 -i 参数。 4. 删除第 5 行之后的行12345➜ ~/code/awk sed &#x27;5,$d&#x27; breabc is a simple word.What is the answer?I am 23 years old. 这里模式是 5,$d，$ 表示文件末尾。 5. 将文件中的 is 全部替换成 IS，并打印前 5 行12345➜ ~/code/awk sed &#x27;s/is/IS/g&#x27; bre | sed &#x27;1,5p&#x27; -n abc IS a simple word.What IS the answer?I am 23 years old. 替换模式为 s/is/IS/g，这里 / 也可以换成 # 或 @。两个命令用管道连接，后面的 sed 无需指定文件名。 6. 将文件中的 is 全替换成 IS，同时将 23 替换成 351234567891011121314➜ ~/code/awk sed -e &#x27;s/is/IS/g&#x27; -e &#x27;s#23#35#g&#x27; breabc IS a simple word.What IS the answer?I am 35 years old.My tel IS 13545678999My favirate food IS hamburger.I come from JiangSu...#这是一个注释行xxxxxxxxxxx 5 中的例子中有两个操作，是用管道符进行操作的，但是 sed 参数中提供了 -e 进行多次编辑，因此就不需要使用管道了。5 也可以这样写： 12345➜ ~/code/awk sed -e &#x27;s/is/IS/g&#x27; -e &#x27;1,5p&#x27; -n bre abc IS a simple word.What IS the answer?I am 23 years old. 7. 在文件第 4 行后追加一行 Linux is funny..123456789101112131415➜ ~/code/awk sed &#x27;4a ##Today is Wednesday##&#x27; bre abc is a simple word.What is the answer?I am 23 years old.Linux is funny.. My tel is 12345678999My favirate food is hamburger.I come from JiangSu...#这是一个注释行xxxxxxxxxxx 8. 在文件第 1 行后追加一行 ##Today is Wednesday##123456789101112131415➜ ~/code/awk sed &#x27;1i ##Today is Wednesday##&#x27; bre##Today is Wednesday##abc is a simple word.What is the answer?I am 23 years old.My tel is 12345678999My favirate food is hamburger.I come from JiangSu...#这是一个注释行xxxxxxxxxxx 加上 -i 参数将会直接修改文件，且不会输出。 若是不加地址，则表示全文范围，如要在每一行后面加上 ------------，如下： 123456789101112131415161718192021222324252627➜ ~/code/awk sed &#x27;a ---------------&#x27; breabc is a simple word.------------------------------What is the answer?---------------I am 23 years old.------------------------------My tel is 12345678999---------------My favirate food is hamburger.---------------I come from JiangSu...---------------------------------------------#这是一个注释行---------------xxxx---------------xxxxxxx--------------- 4.3 sed 进阶例子：取出 Linux 的 IP 地址以下例子将用 sed 配合正则表达式进行处理文本。 首先输入 ifconfig 命令打印出网络信息，我们要提取出 eth0 网卡中的 inet 后的 IP 地址信息，然后保存到文件 IP_eth0 中。 我们首先打印 eth0 网卡信息： 123456789➜ ~/code/awk ifconfig eth0 eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.19.194.137 netmask 255.255.240.0 broadcast 172.19.207.255 inet6 fe80::215:5dff:feeb:1353 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:eb:13:53 txqueuelen 1000 (Ethernet) RX packets 127 bytes 60337 (60.3 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 109 bytes 13475 (13.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 然后打印出第二行： 12➜ ~/code/awk ifconfig eth0 | sed &#x27;2p&#x27; -n inet 172.19.194.137 netmask 255.255.240.0 broadcast 172.19.207.255 然后用正则匹配将 IP 地址前后内容替换为空： 12➜ ~/code/awk ifconfig eth0 | sed &#x27;2p&#x27; -n | sed &#x27;s/^.*inet //&#x27; | sed &#x27;s/ netmask.*$//&#x27;172.19.194.137 这样便提取出了 IP 地址，然后再写入文件： 12➜ ~/code/awk ifconfig eth0 | sed &#x27;2p&#x27; -n | sed &#x27;s/^.*inet //&#x27; | sed &#x27;s/ netmask.*$//&#x27; | tee IP_eth0172.19.194.137 当然也可以用 -e 参数进行多次编辑： 12➜ ~/code/awk ifconfig eth0 | sed -e &#x27;2s/^.*inet //&#x27; -e &#x27;2s/ netmask.*$//p&#x27; -n | tee IP_eth0 172.19.194.137 注意哪些地方有 p 参数，哪些地方没有，如果两次匹配加了 p，那么就会打印两次信息，一次是删掉前面之后的剩余部分，一次是删掉前后剩下的部分。 五、awkawk 有强大的文本格式化功能，它更像是一门编程语言，支持条件判断、数组、循环等功能。 awk 语法如下： 12awk [option] &#x27;pattern[action]&#x27; file 可选参数 模式 动作 文件/数据 action 指的是动作，awk 擅长文本格式化，且输出格式化之后的结果，因此最常见的动作就是 pirnt 和 printf。 若我们执行的命令是 awk &#39;&#123;print $2&#125;&#39;，没有使用参数和模式，$2 表示输出文本的第二列信息。awk 默认以空格为分隔符，且多个空格也识别为一个空格，作为分隔符。 awk 是按行处理文件，一行处理完毕，处理下一行，根据用户指定的分割符去工作，没有指定则默认空格。 $0 表示整行信息，$1 表示文本第一列信息，$NF 表示当前分割后的最后一列，倒数第二列可以写成 $(NF-1)。 1. awk 变量awk 分为内置变量和自定义变量。 1.1 内置变量一些常用的内置变量如下表所示。 内置变量 解释 $n 指定分隔符后，当前记录的第n个字段 $0 完整的输入记录 FS 输入字段分隔符，默认是空格 OFS 输出字段分隔符，默认是空格 RS 输入记录分隔符（输入换行符），指定输入时的换行符 ORS 输出记录分隔符（输入换行符），指定输入时的换行符 NF(Number of fields) 分割后，当前行一共有多少个字段 NR(Number of records) 当前记录数，行数 FNR 各文件分别计数的行号 FILENAME 当前文件名 ARGC 命令行参数的个数 ARGV 数组，存储命令行所给定的各个参数 更多内置变量可以man手册查看 man awk 例子，一次性输出多列信息： 1awk &#x27;&#123;print $1,$2&#125;&#x27; file.txt 其中参数之间的逗号表示默认分隔符，在输出时每列之间会有一个空格。 再如，自定义输出内容： 1awk &#x27;&#123;print &quot;第一列&quot;,$1,&quot;第二列&quot;,$2&#125;&#x27; file.txt 【注】：awk 必须外层单引号，内层双引号，并且内置变量 $n 不可以加引号，否则会被识别为字符串。 awk 的内置变量 NR、NF 是不用加 $ 的，但是例如 $0、$1 等是需要加 $ 的。 NR 和 NF有如下测试文件 awk1： 12345678Cherry 25 19990101James 35 19850422Anna 22 20000322ChrisTim 48 19731225Qiang 23 19990103Sue 6 20160505Paul 37 19850428Steve 0 00000000 现在要输出第二行内容，命令如下： 12➜ ~/code/awk awk &#x27;NR==2&#x27; awk1 James 35 19850422 注意这里是 ==。如果要输出第二到第五行，则命令如下： 12345➜ ~/code/awk awk &#x27;NR==2,NR==5&#x27; awk1James 35 19850422Anna 22 20000322ChrisTim 48 19731225Qiang 23 19990103 给每一行内容添加行号： 123456789➜ ~/code/awk awk &#x27;&#123;print NR,$0&#125;&#x27; awk11 Cherry 25 199901012 James 35 198504223 Anna 22 200003224 ChrisTim 48 197312255 Qiang 23 199901036 Sue 6 201605057 Paul 37 198504288 Steve 0 00000000 输出第一列和最后一列： 123456789➜ ~/code/awk awk &#x27;&#123;print $1,$(NF)&#125;&#x27; awk1Cherry 19990101James 19850422Anna 20000322ChrisTim 19731225Qiang 19990103Sue 20160505Paul 19850428Steve 00000000 处理多个文件显示行号若我们想对多个文件使用 awk 进行处理并输出每一行的行号，awk 会将所有文件放在一起显示行号，如下： 12345678910111213141516171819➜ ~/code/awk awk -v FS=&#x27;:&#x27; &#x27;&#123;print NR,$1&#125;&#x27; passwd awk1 1 root2 daemon3 bin4 sys5 sync6 games7 root8 lp9 root10 news11 Cherry 25 1999010112 James 35 1985042213 Anna 22 2000032214 ChrisTim 48 1973122515 Qiang 23 1999010316 Sue 6 2016050517 Paul 37 1985042818 Steve 0 00000000 但是我们希望对每个文件分别打印行号，则可以将变量 NR 改为 FNR，如下： 12345678910111213141516171819➜ ~/code/awk awk -v FS=&#x27;:&#x27; &#x27;&#123;print FNR,$1&#125;&#x27; passwd awk11 root2 daemon3 bin4 sys5 sync6 games7 root8 lp9 root10 news1 Cherry 25 199901012 James 35 198504223 Anna 22 200003224 ChrisTim 48 197312255 Qiang 23 199901036 Sue 6 201605057 Paul 37 198504288 Steve 0 00000000 RS 和 ORS我们看这个文件内容： 123456789➜ ~/code/awk awk &#x27;&#123;print NR,$1&#125;&#x27; awk1 1 Cherry2 James3 Anna4 ChrisTim5 Qiang6 Sue7 Paul8 Steve 这个文件一共有 8 行，默认是以换行符为每一行的分隔，若我们要修改其默认的输入换行符，则可以修改参数 RS。 12345678910111213141516171819202122232425➜ ~/code/awk awk -v RS=&#x27; &#x27; &#x27;&#123;print NR,$0&#125;&#x27; awk11 Cherry2 253 19990101James4 355 19850422Anna6 227 20000322ChrisTim8 489 19731225Qiang10 2311 19990103Sue12 613 20160505Paul14 3715 19850428Steve16 017 00000000 我们看到最终将以空格进行每一行的分隔，而不是换行符。我们还可以修改 ORS 修改默认的输出分隔符。 12➜ ~/code/awk awk -v ORS=&#x27; &#x27; &#x27;&#123;print NR,$1&#125;&#x27; awk11 Cherry 2 James 3 Anna 4 ChrisTim 5 Qiang 6 Sue 7 Paul 8 Steve FILENAME该变量显示正在处理文件的名字 123456789➜ ~/code/awk awk &#x27;&#123;print FILENAME,$1&#125;&#x27; awk1awk1 Cherryawk1 Jamesawk1 Annaawk1 ChrisTimawk1 Qiangawk1 Sueawk1 Paulawk1 Steve 变量 ARGV、ARGC1234567891011121314151617181920212223242526272829303132➜ ~/code/awk awk &#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;一共有&quot;,ARGC,&quot;个参数&quot;&#125;&#x27; awk1AWK Start!一共有 2 个参数一共有 2 个参数一共有 2 个参数一共有 2 个参数一共有 2 个参数一共有 2 个参数一共有 2 个参数一共有 2 个参数➜ ~/code/awk awk &#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;第一个awk参数为:&quot;,ARGV[0]&#125;&#x27; awk1AWK Start!第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk第一个awk参数为: awk➜ ~/code/awk awk &#x27;BEGIN&#123;print &quot;AWK Start!&quot;&#125; &#123;print &quot;第一个awk参数为:&quot;,ARGV[1]&#125;&#x27; awk1AWK Start!第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1第一个awk参数为: awk1 我们发现该命令一共有 2 个参数，分别输出为 awk 和 awk1。 1.2 自定义变量2. awk 参数 参数 解释 -F 指定分割字段符 -v 定义或修改一个awk内部的变量 -f 从脚本文件中读取awk命令 更改分隔符见下一节内容。 3. awk 分隔符在 awk 中，默认是以空格进行分隔的，在 sed 命令中，我们要获取网卡 eth0 的 IP 地址信息，采用正则表达式将前后部分删掉来实现。但是我们发现 ifconfig 信息都是用空格进行分隔的，因此在 awk 中，可以利用其特点，直接取出对应行的对应列，从而直接取出 IP 地址。 12➜ ~/code/awk ifconfig eth0 | awk &#x27;NR==2&#123;print $2&#125;&#x27;192.168.202.82 awk 的分隔符有两种 一种是输入分隔符，默认是空格，叫 field separator，变量名为 FS 一种是输出分隔符，output field separator，简称 OFS 3.1 FS 输入分隔符awk 逐行处理文本的时候，以输入分割符为准，把文本切成多个片段，默认符号是空格。 例如下面的 passwd 文件，输出其第一列和最后一列： 12345678910root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinroot:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinroot:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin 1234567891011➜ ~/code/awk awk -F &#x27;:&#x27; &#x27;&#123;print $1,$NF&#125;&#x27; passwd root /bin/bashdaemon /usr/sbin/nologinbin /usr/sbin/nologinsys /usr/sbin/nologinsync /bin/syncgames /usr/sbin/nologinroot /usr/sbin/nologinlp /usr/sbin/nologinroot /usr/sbin/nologinnews /usr/sbin/nologin 这里使用了 -F 变量修改了默认分隔符，除了使用这种方法之外，还可以使用变量的形式，指定分隔符，使用 -v 选项搭配，修改 FS 变量： 1234567891011➜ ~/code/awk awk -v FS=&#x27;:&#x27; &#x27;&#123;print $1,$NF&#125;&#x27; passwd root /bin/bashdaemon /usr/sbin/nologinbin /usr/sbin/nologinsys /usr/sbin/nologinsync /bin/syncgames /usr/sbin/nologinroot /usr/sbin/nologinlp /usr/sbin/nologinroot /usr/sbin/nologinnews /usr/sbin/nologin 3.2 输出分隔符上面的例子我们发现，第一列和最后一列之间默认输出是用空格分隔，若我们想自定义该输出分隔符，可以更改 OFS 变量修改默认输出分隔符，如下： 1234567891011➜ ~/code/awk awk -v FS=&#x27;:&#x27; -v OFS=&#x27;==&gt;&#x27; &#x27;&#123;print $1,$NF&#125;&#x27; passwd root==&gt;/bin/bashdaemon==&gt;/usr/sbin/nologinbin==&gt;/usr/sbin/nologinsys==&gt;/usr/sbin/nologinsync==&gt;/bin/syncgames==&gt;/usr/sbin/nologinroot==&gt;/usr/sbin/nologinlp==&gt;/usr/sbin/nologinroot==&gt;/usr/sbin/nologinnews==&gt;/usr/sbin/nologin 这样就修改了默认的输出分隔符。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Linux/"}],"tags":[{"name":"sed","slug":"sed","permalink":"https://cherryyang05.github.io/hexo-blog/tags/sed/"},{"name":"awk","slug":"awk","permalink":"https://cherryyang05.github.io/hexo-blog/tags/awk/"},{"name":"grep","slug":"grep","permalink":"https://cherryyang05.github.io/hexo-blog/tags/grep/"},{"name":"Linux命令","slug":"Linux命令","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Git的使用","slug":"Git的使用","date":"2022-03-09T14:26:24.000Z","updated":"2023-08-08T12:35:27.377Z","comments":true,"path":"3645f6a9.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/3645f6a9.html","excerpt":"Git 的使用","text":"Git 的使用 1. 分支命令1234567git checkout -b &lt;new-branch-name&gt; //新建分支并切换到该分支git branch &lt;new branch name&gt; //新建分支git branch -D &lt;branch name&gt; //删除分支git branch -m oldName newName //修改分支名称git branch -vv //参数 `vv` 表示显示更多冗余信息git rebase 2. git config 配置12git config [--global] user.name &lt;&quot;Your-Name&quot;&gt; //设置git的用户名和邮箱密码等git config --global core.pager &quot;less -FRSX&quot; //设置不要将结果输出到新窗口，并且进行less分页显示 less 的功能比 more 更多，前者可以上下滚屏，后者不可以。core-pager 默认参数为 less，会在新的窗口中输出信息，按 q 键退出后终端将不显示刚刚的信息，这样有点不太方便。或者是添加参数 --no-pager. 1git log --all --graph --decorate --oneline 展示git的树形提交记录，oneline 表示展示的信息在一行中表示 1git diff &lt;commit1&gt; &lt;commit2&gt; &lt;file-name&gt; 显示指定的两次 commit 中的 file-name 文件的不同，默认 commit 为最新 commit 3. remote操作123456789101112131415161718192021222324git init --baregit remote add &lt;name&gt; &lt;url&gt; // url可以是本地地址，也可以是远程仓库地址(例如github)git remote add origin ../remotegit push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;git push origin master:mastergit clone &lt;url&gt; &lt;folder name&gt;git clone ./gitDemo demo2//创建本地和远端分支的关联关系git branch --set-upstream-to &lt;remote&gt;/&lt;remote branch&gt;git pull = git fetch; git mergegit pull --all // 拉取远程所有分支git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt; // 将远程指定分支拉取到本地指定分支上git pull origin &lt;远程分支名&gt; // 将远程指定分支拉取到本地当前分支上git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; // 将本地当前分支推送到远程指定分支上（注意：pull 是远程在前本地在后，push 相反）git push origin &lt;本地分支名&gt; // 将本地当前分支推送到与本地当前分支同名的远程分支上git push -u origin &lt;本地分支名&gt; // 将本地分支与远程同名分支相关联 注意远程仓库的初始化一定是“裸”的，即 git init --bare，因为远程仓库中不允许进行 git 操作，不包含工作区。 git fetch 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中，而 git pull 是直接合并。 4. 其他12345678git add -p &lt;filename&gt;git clone --shallow //浅克隆，不会保留仓库原有的提交记录git show &lt;commit id&gt; //展示某次提交的具体内容(通过diff展示)git stash //暂时移除工作目录下的修改内容git stash pop //移除隐藏 参数 -p 表示交互式暂存，可以自定义某些修改是否要提交 命令 功能 git init 在本地的当前目录里初始化git仓库 git status 查看当前仓库的状态 git add -A 增加目录中所有的文件到缓存区 git add file 增加相应文件到缓存区 git commit -m “msg” 将缓存区中更改提交到本地仓库 git log 查看当前版本之前的提交记录 git reflog 查看HEAD的变更记录，包括回退 git branch -b branch_name 建立一个新的分支 git diff 查看当前文件与缓存区文件的差异 git checkout –file 取消更改，将缓存区的文件提取覆盖当前文件 git reset –hard ver_num 回退到相应版本号，同样也可以回退到未来的版本号 git clean -xf 删除当前目录中所有未追踪的文件 git config –global core.quotepath false 处理中文文件名 5. git reset 命令及用 amend 提交合并当我们提交一版代码后，发现有一个小问题需要重新修改一下，但是又不想重新再提交一次，因为这样会多一次无用的提交记录，不方便整体的管理和日志的查看。我们首先使用 git reset 进行回退。 git reset 命令有几个参数 --soft 参数表示撤销到某次提交，保留暂存区（add 操作之后保存到的地方）里的内容，如果要再提交只要再执行 commit 即可 --mixed 会撤销某次提交，但是工作目录下修改的内容不会被存到暂存区中，需要重新执行 add 命令才能存入暂存区 --hard 会直接回退到某一提交，任何修改都不会被保存，这个参数要谨慎使用，很可能会造成本地文件丢失。 若是不小心使用 git reset --hard 误操作了可以先使用 git reflog 查看所有操作记录，找到要回退的版本号（ HEAD 指针或 commitId），然后指定具体的版本号进行回退即可。 另一种避免重复提交的方法就是 git --amend 命令，在第二次提交时，若我们想合并上一次提交，可以使用 git commit --amend -m &quot;xxx&quot;，这样新一次的提交会覆盖上一次的提交。 但是在使用 --amend 时候不能进行 push 提交，否则会提 123提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。提示：再次推送前，先与远程变更合并（如 &#x27;git pull ...&#x27;）。详见提示：&#x27;git push --help&#x27; 中的 &#x27;Note about fast-forwards&#x27; 小节` 若 push 了之后应该使用 --force-with-lease 参数。 6.12git ls-files // 查看暂存区中的文件git restore --staged // 撤销在暂存区提交的文件","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux/"}]},{"title":"计算机体系结构课程笔记（四）","slug":"计算机体系结构课程笔记（四）","date":"2022-01-31T14:18:17.000Z","updated":"2023-08-08T12:35:27.529Z","comments":true,"path":"767f71ea.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/767f71ea.html","excerpt":"第六章 输入输出系统 国防科大计算机体系结构课程第六-八章笔记","text":"第六章 输入输出系统 国防科大计算机体系结构课程第六-八章笔记 6.1 存储设备6.1.1 磁盘 磁盘始终占据着后备存储器的主宰地位。原因有二： 磁盘一直是虚拟存储器技术的物质基础，执行程序时，磁盘用作为交换缓冲区 关机时，磁盘作为操作系统和所有应用程序的非易失性的驻留介质 磁盘是最重要的 I&#x2F;O 设备，是存储层次中辅存的载体，发展比较平缓 磁盘由一组绕轴旋转的盘片组成，盘片的数量为 1~20 片 磁盘系统的转速一般在每分钟 3600 转到 15000 转之间，即 3600rpm~15000rpm 磁道（每一个盘片有 5000~30000 条磁道）。 扇区（每条磁道分为 100~500 个扇区）。所有磁道具有相同数目的扇区 磁盘访问时间计算1. 寻道时间 若要读写扇区，磁盘控制器发出命令首先将磁头移动到包含有所需数据的磁道上，这个过程称为“寻道”，所需要的时间叫做“寻道时间” 最小寻道时间、最大寻道时间和平均寻道时间。常见的平均寻道时间的公布值约为 6ms 到 20ms，实际应用当中的平均寻道时间约为公布值的 25% 到 33%2. 旋转时间 所需扇区转到磁头之下所需要的时间称为旋转时间。大部分磁盘的转速在3600rpm到10,000rpm，平均延迟是磁盘转半圈的时间，所以对大部分磁盘的平均旋转时间 $T_AR&#x3D;3ms~8.3ms$3. 传输时间 传输时间是指在磁头下传输一个数据块(通常是一个扇区)所需花的时间。它由块的大小、旋转速度、磁道记录密度和连接磁盘电子器件的速度确定 数据传输率有两个：一是从盘面到缓冲存储器的内部传输率；一是从缓冲存储器到主机的外部传输率 内部数据传输率：硬盘将数据从盘片上读取出，交给硬盘上的缓冲存储器的速度。也被称作硬盘的持续传输率（Sustained Transfer Rate），它取决于硬盘转速和盘片位密度。内部传输率等于磁头相对磁盘的线速度与磁盘位密度之积。外部传输率是以内部传输率为基础的，有效地提高硬盘的内部传输率才能对磁盘性能有最直接、最明显的提升 外部传输率：计算机通过磁盘接口从硬盘的缓存中将数据读出，交给相应的控制器的速度；被称为突发数据传输率（Burst Data Transfer Rate）。外部数据传输率和磁盘的接口有关，目前已有 IDE、EIDE、Ultra-EIDE、SCSI、Fast and Wide-SCSI、FC-AL 等接口。ATA-6 接口的速度已经达到 133MB&#x2F;s 内部传输率等于记录的位密度乘以盘面旋转的线速度。外部传输率则与接口有关4. 控制器时间 控制磁盘及磁盘与主存之间数据传输，需要一系列的控制器和通道来完成 控制器时间是控制器在执行I&#x2F;O访问时的额外开销 因此，磁盘访问时间&#x3D;寻道时间+旋转时间+传输时间+控制器时间 磁盘访问时间例题对于目前一般的磁盘而言，读或写一个 512 字节的扇区的平均时间是多少？假设此时磁盘空闲，这样没有排队延迟；公布的平均寻道时间是 9ms，传输速度是 4MB&#x2F;s，转速是 7200rpm，控制器的开销是 1ms [分析] 寻道时间 &#x3D; 9ms 旋转时间 &#x3D; 0.5 &#x2F; 7200rpm &#x3D; 4.2ms 传输时间 &#x3D; 0.5KB &#x2F; 4.0MB&#x2F;s &#x3D; 0.125ms 控制器时间 &#x3D; 1ms 因此访问时间 &#x3D; 9 + 4.2 + 0.125 + 1 &#x3D; 14.3ms 磁表面记录密度 磁盘记录数据的密度一般用“磁表面记录密度”来表示，也就是每平方英寸上的位数： 1988年前，每年增长约 29%，即 3 年翻一番； ~1996年后，每年增长 60%，即 3 年翻四番。 ~2001年，每年增长 100%，2001 年实验室中可达每平方英寸600亿位 提高转速可以提高数据传输速率。旋转速度越高，数据就可以越快到达驱动器读写头能够接触的位置。目前硬盘最大转速为 15000RPM。但转速提高也带来一些弊端，例如工作噪音和发热量变大，工作状态下的抗冲击能力也有所下降等。 提高记录密度。目前采用的技术主要有：提高单碟容量以及改进信号处理技术。由于单碟容量越大的硬盘数据密度越高，磁头的寻道频率与移动距离可以相应的减少，从而减少了平均寻道时间，内部传输速率也得到了提高 在传统的纵向记录技术中，为了提高面密度以增加总的存储容量，必须压缩数据位并使其更紧密地排列在一起。然而，如果数据位太小，为其定位的磁能也会相应减小，小到一定程度后热能就可能会使其退磁，存储的数据就会丢失，这一现象被称为超顺磁性。为了避免超顺磁性效应，磁盘介质制造商一直在努力提高介质的矫顽磁性(写一个数据位所需要的‘磁场’ ) 。不过，能施加的磁场大小会受到磁头材料的限制 而在垂直记录技术(Perpendicular Magnetic Recording)中，盘片的磁化不像目前水平记录技术那样发生在盘片所在的平面上，而是发生在与盘片相垂直的平面上。这样一来，数据位就是指向上或向下的定向磁化区域。(在水平记录技术中，数据位的磁化是在磁盘平面上，在与磁头运动方向相同和相反的点之间翻转。)介质淀积在软磁衬底上，衬底的作用是作为写磁场返回路径的一部分并有效地生成记录磁头的镜像，这将使记录磁场增强一倍，故能达到比水平记录技术更高的记录密度。值得一提的是，垂直记录并不会因这项强化而提高功率消耗或产生更高热能，这对于对耗电与热量敏感的笔记本领域非常关键。此外，垂直记录也因为能够强化数据对于热衰退的阻抗能力从而提升硬盘可靠性。对于生产厂商来说，垂直记录技术将可延长磁盘储存装置的发展年限，对消费者来说，则可提供更高容量的硬盘容量 磁盘在后备存储器上的地位曾受到过多次考验，主要原因就是所谓“访问时间差距”问题。磁盘与 DRAM 的性能价格比差异很大。虽然 DRAM 的数据传输率约为磁盘的 50 倍，但是其访问时间却是磁盘的十万分之一 6.1.2 Flash 存储器和固态硬盘 SSD SSD的优点是： 永久性； 速度快； 高传送速率和高可靠性。 SSD的最大缺点是： 有限擦写次数 磨损均衡（动态、静态） 成本太高，每 MB 的价格大约是磁盘价格的 50 倍 6.1.3 磁带 磁盘和磁带性能价格比的差异主要取决于它们的机械构成 磁盘盘片具有有限的存储面积，并且存储介质被封装在每个读部件内，提供 ms 级的随机访问 磁带绕在可转动轴上，一个读部件可以使用多盘磁带(没有长度限制)，但磁带需要顺序访问，每次访问都可能需要较长的反绕、退出和加载时间，等待时间较长(数秒) 对磁带而言，最大的优点是容量极大、技术成熟、单位价格低廉。最大的缺点是访问时间较长。这种差异恰好使得磁带成为磁盘的备份技术。 宽 0.38cm1.27cm;长 183m731.5m;(110G 以上） 磁带技术的主要受限因素是在其线速度不定，为解决该问题，提出了“螺旋扫描磁带(Helical Scan Tapes)”，使磁带保持同样的线速度，这种技术以 20 到 50 的倍数增加记录密度，螺旋扫描磁带目前已被普遍使用在视频录像设备中，大大降低了磁带和读部件的开销 磁带的另外一个缺点是易磨损，螺旋磁带只能使用几百遍，传统的高质量磁带则可以使用几百万遍。螺旋扫描磁头同样容易磨损，通常额定指标为连续使用 2000 小时 为了解除操作中的负担，同时也加速换带速度，便产生了自动磁带库。自动磁带库通过机械手自动地安装和更换磁带，相当于又提供了一个新的存储器层次，这种自动化的磁带库可在无人工干预的情况下，十几秒内访问几TB的信息 STC 的 PowderHorn 可以处理 6000 个磁带，提供的总容量达 60TB 6.1.4 光盘 只读类光盘的全称为光学紧密盘(Optical Compact Disk)，简称 CD-ROM。 特点是： 容量大(640M字节)、存储寿命长； 成本低、读出设备价格便宜； 便于保管、便于携带等。 最大问题是不能够写入。因此 CD-ROM 适于作为软件和资料的载体，基本已经替代了几年前广泛使用的软盘 可写类光盘包括两类： 一次性写：称为可记录光盘 CD-R(CD-Recordable)，又称为 WORM 盘，出厂时是空白的，用户通过写入设备，将数据写入 CD-R 中。特性与 CD-ROM 相当，可以通过普通的 CD-ROM 读设备读出，因此特别适合于作为数据备案的存储介质。 多次写：称为 WMRM(Write Many Read Many) 盘，主要采用磁光(MO)存储技术 MO光盘的容量更大(有 600MB、1.2GB、2.4GB 等规格)、保存和使用都很方便、便于携带，最大的问题是目前盘片和读写设备的价格昂贵，且各厂家的标准不统一，因此不够普及。这种 WMRM 盘作为大型软件编制、多媒体软件产品研制过程中的备案介质是非常合适的 多台光盘机组合在一起有三种结构： 光盘库(也叫自动换盘机，即Jukebox) 光盘库是一种能自动把机框中存放的许多片光盘选出并装入光盘机进行读写的设备 费用低； 可兼容性及低风险； 随机存取； 存储寿命长、保管容易、占用空间少； 具有多媒体功能 光盘塔(CD-ROM Tower) 优点： 安装简便；易于管理；使用便利； 资源共享；远程访问； 寿命长；结构简单；造价也低； 读取光盘速度快。 缺点： 容量较小；光盘塔中光盘机数量受到 SCSI 设备地址数的限制 光盘阵列(CD-ROM Array) 从阵列技术的基本原理来说，光盘阵列与磁盘阵列有一定的相似性。但光盘具有盘片可换、每道(柱面)只有一个读写头、寻道时间较长等特点，因此光盘阵列技术又有其特殊性 6.2 I&#x2F;O 系统分析与评价1. I&#x2F;O性能与系统响应时间 衡量I&#x2F;O系统性能的标准 I&#x2F;O系统的容量(能连几个 USB 等) 响应时间 吞吐率 响应时间和吞吐率之间存在矛盾 生产服务模型 2. Little 定律 I&#x2F;O系统的响应时间和吞吐率的计算 排队论 黑箱(Black Box) Little定律 系统中的平均任务数 &#x3D; 到达率×平均响应时间 3. M&#x2F;M&#x2F;1 排队系统 M&#x2F;M&#x2F;1排队系统一般假设为： 系统为一个平衡系统 连续两个到达请求的时间间隔服从指数分布，其均值为平均到达时间 请求的个数不受限制 如果排队中有任务，服务员服务完当前任务后立即服务下一个 队列无限长，FIFO 规则 系统只有一个服务员 相关结论 M&#x2F;M&#x2F;m 排队系统 基于 M&#x2F;M&#x2F;1 排队系统 服务员增加为 m 个 相关结论 4. I&#x2F;O 基准测试程序 使用 I&#x2F;O 基准测试程序来反映响应时间和吞吐率之间的平衡关系 TPC 事务处理委员会 发布 9 个事务处理基准测试程序 高端商业应用中，通常采用 TPC-C 测试程序进行测试 TPC具有一些独特的性质 测试结果中给出系统的价格因素 TPC模拟的是实际系统 测试结果经过TPC审核后才能发布 吞吐率指标受到响应时间的限制 通过独立的机构来维护 5. I&#x2F;O 系统的可靠性、可用性和可信性 术语 故障(fault)，可以恢复 错误(error)，不能恢复，不一定使得机器停掉 失效(failure) 故障产生原因 硬件 设计 操作 环境(温度等) 故障分类 暂时性 间歇性 永久性 存储外设可靠性参数 可靠性 可用性 可信性 提高系统可靠性的方法 故障避免技术：通过合理构建系统来避免故障 故障容忍技术：采取冗余措施 错误消除技术：通过验证，最大限度地减少潜在的错误 错误预报技术：通过分析，预报错误的出现，以便提前采取应对措施 6.3 RAID盘阵列(RAID，即 Redundant Array of Inexpensive Disks)，即廉价磁盘冗余阵列，简称盘阵列技术 1987年，由加州大学伯克利分校的Patterson、Gibson 和 Katz 提出 既可以提高存储系统的可靠性，又可以提高存储系统的性能。这种技术可以通过使用多个磁盘驱动器（包括多个磁臂）而不是使用一个大容量的磁盘（单个磁臂）来提高磁盘的吞吐率。使用磁盘阵列可以简单地将数据分布到多个磁盘上（称为数据分块技术），这样使得一个数据的访问将导致对多个磁盘的同时访问。 盘阵列容量大、速度快、可靠性高、造价低廉。它是目前解决计算机I&#x2F;O瓶颈的有效方法之一，有着广阔的发展前景 6.3.1 RAID 0 亦称数据分块（Striping），即把数据分布在多个盘上，实际上是非冗余阵列，无冗余信息。严格地说，它不属于 RAID 系列 优点：高性能，磁盘利用率高 缺点：系统可靠性差，没有冗余 6.3.2 RAID 1 亦称镜像盘，使用双备份磁盘 优点：I&#x2F;O速度快，可靠性高 缺点：代价高，可扩展性不好 一个读请求可由包含请求数据的两个物理磁盘中的某一个提供，只要它的寻道时间加旋转时间延迟较小。这样 RAID 1 的读性能由镜像盘中读性能最好的磁盘决定。故在 I&#x2F;O 处理中，如果是大批的读请求，RAID 1 的性能能够达到 RAID 0 性能的两倍 6.3.3 RAID 2 位交叉式海明编码阵列 优点： 高速误差校正 数据传输速率高 缺点： 校正空间较大，盘阵列利用率较低 RAID 2 的优点是使用海明编码来进行错误检测和纠正，数据传输率高。海明校验码可以检测磁盘的 2 位错误，并纠正 1 位数据错误。对于单个读，所有磁盘同时读取，请求的数据和相关的海明校验码被传送到阵列管理器。如果出现 1 位错误，则阵列管理器可以立即识别并加以纠正，因此读取时间很短，可以达到很高的数据传输率。对于单个写，所有的数据盘和校验盘都要参加写操作。RAID 2 阵列管理器的设计比后面的 RAID 级别要简单 RAID 2 的缺点是需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。这样，尽管 RAID 2 比 RAID 1 需要的磁盘少，RAID 2 存储容量的利用率仍然不高，尤其是在数据字长较短的情况下。另外，RAID 2 可以达到的数据传输率将受限于整个磁盘阵列中最慢的磁盘以及阵列管理器的校验速度 6.3.4 RAID 3 位交叉奇偶校验盘阵列，是单盘容错并行传输的阵列。即数据以位或字节交叉的方式存于各盘，冗余的奇偶校验信息存储在一台专用盘上 在RAID3中，将磁盘分组，读写要访问组中所有盘。当一个磁盘出故障时，可以通过奇偶校验磁盘中的校验和来恢复出错数据 优点：冗余代价低，传输速率高 应用领域：多媒体应用 先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。一旦某一个盘失效，只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是失效的盘上的数据。冗余盘中的奇偶校验和通常是模 2 和。这种方法的缺点是恢复时间较长，但由于磁盘失效的可能性很小，因此还是可以接受的 6.3.5 RAID 4 块交叉奇偶校验盘阵列，即数据以块(块大小可变)交叉的方式存于各盘，冗余的奇偶校验信息存在一台专用盘上 优点：读写速度快；冗余代价低缺点：阵列控制器复杂 由于磁盘扇区中存在错误检测信息，使得磁盘在读数据时就可以检测数据是否正确，因此只要访问的数据以扇区为单位，则每个磁盘都可以同时独立地进行这种操作。与 RAID 3 相比，RAID 4 中对一个数据的读操作是对两个磁盘的两次读操作 6.3.6 RAID 5 块交叉分布式奇偶校验盘阵列，即数据以块交叉的方式存于各盘，但无专用的校验盘，而是把冗余的奇偶校验信息均匀地分布在所有磁盘上 优点： 冗余代价较小； 读数据速率高； 写数据相对较快。 缺点： 控制器设计复杂 通过将校验信息分布到多个磁盘中，这样就不会出现 RAID 4 中冗余磁盘成为写操作的瓶颈这个问题 6.3.7 RAID 6 双维奇偶校验独立存取盘阵列，即数据以块(块大小可变)交叉的方式存于各盘，冗余的检、纠错信息均匀地分布在所有磁盘上。并且，每次写入数据都要访问一个数据盘和两个校验盘，可容忍双盘出错 目前的计算机实际上是将多种盘阵列技术综合使用 6.4 总线 1. 总线特点 优点： 低成本 多样性 缺点： 可能造成设备信息交换的瓶颈，从而限制了系统中总的I&#x2F;O吞吐量 总线设计存在很多技术难点，一个重要原因就是总线上信息传送的速度极大地受限于各种物理因素，如总线的长度、设备的数目、信号的强度等，这些物理因素限制了总线性能的提高。另外，对 I&#x2F;O 操作的低延迟要求以及对 I&#x2F;O 高吞吐量的要求也可能造成设计需求上的冲突 2. 总线设计时因考虑的因素 总线的分类 按设备定时方式分类： 同步总线；同步总线上所有设备通过统一的总线系统时钟进行同步 异步总线：设备之间没有统一的系统时钟，设备自己内部定时。设备之间的信息传送用总线发送器和接收器控制。但在传输时，异步总线需要额外的同步开销 采用独立的地址和数据线、更宽的数据总线的位数以及多字数据传输块将提高总线的性能，但同时也带来了高成本 3. 总线标准 只要计算机和 I&#x2F;O 设备的设计都满足相应的标准，那么 I&#x2F;O 设备和计算机可以任意连接 I&#x2F;O 总线标准就是定义设备连接的文件 4. 常用的 I&#x2F;O 总线 概况 常用的 I&#x2F;O 总线标准 ISA EISA PCI：扩展主机设备(PCIE) USB(含 USB 2.0)：连接各种外部设备到主机 IEEE 1394、…… RS-485&#x2F;RS-232 CAN(汽车，卫星) IIC(家电等) 主要影响因素： 系统中各部件的工作频率 传输数据和编址地址位数 5. I&#x2F;O 总线的发展历程 6. 设备的连接 I&#x2F;O 设备编址方式 存储器映射 I&#x2F;O 独立编址(有单独的访问 I&#x2F;O 指令，如 in, out) I&#x2F;O 设备控制方式 程序查询 中断 DMA(部分单片机内也开始使用这种方式) I&#x2F;O 处理机(包含功能较弱的通道) 在大型计算机系统中，采用程序控制、中断和 DMA 这三种基本的 I&#x2F;O 方式来管理外围设备，会引起如下两个问题： 所有外围设备的 I&#x2F;O 工作全部都要由CPU来承担，CPU 的 I&#x2F;O 负担很重，不能专心于用户程序的计算。低速外围设备每传送一个字符都要由 CPU 执行一段程序来完成，而高速外围设备虽然使用 DMA 方式减少了 CPU 的干预，但初始化工作仍然需要 CPU 用程序来完成 （四种设备控制方式为计组重点内容，略） 6.5 通道 接受 CPU 发来的 I&#x2F;O 指令，根据指令要求选择一台指定的外围设备与通道相连接 执行 CPU 为通道组织的通道程序，从主存中取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令 给出外围设备的有关地址，即进行读／写操作的数据所在的位置。如，磁盘存储器的柱面号、磁头号、扇区号等 给出主存缓冲区的首地址，这个缓冲区用来暂时存放从外围设备上输入的数据，或者暂时存放将要输出到外围设备中去的数据 控制外围设备与主存缓冲区之间数据交换的个数，对交换的数据个数进行计数，并判断数据传送工作是否结束 指定传送工作结束时要进行的操作。例如，将外围设备的中断请求及通道的中断请求送往 CPU 等 检查外围设备的工作状态，是正常或故障。根据需要将设备的状态信息送往主存指定单元保存 在数据传输过程中完成必要的格式变换，例如，把字拆卸为字节，或者把字节装配成字等 通道分为三种类型： 字节多路通道：简单的共享通道，为多台低速或中速的外围设备服务。采用分时方式工作 选择通道：为高速外围设备（如磁盘存储器等）服务。在传送数据期间，只能为一台高速外围设备服务，在不同的时间内可以选择不同的设备，可以在一段集中的时间内完成高速设备的传输任务，比较适合高速设备 数组多路通道：为高速设备服务。时间片轮转、分时复用的思想，各台高速设备重迭操作，但是传输的单位不是字节，而是一块 6.6 I&#x2F;O 与操作系统 能够使处理器性能发挥的软件是编译器，而发挥存储性能的软件是操作系统，采用哪种硬件进行 I&#x2F;O 处理由操作系统决定，所以在设计 I&#x2F;O 系统时还要注意操作系统的因素 数据不一致问题有两个方面 存储器中可能不是 CPU 产生的最新数据，所以 I&#x2F;O 系统从存储器中取出来使用的是陈旧数据 I&#x2F;O 与存储器交换数据之后，在 Cache 中被 CPU 使用的可能就是陈旧数据 由于 I&#x2F;O 会在两个方面导致数据不一致的问题，那么我们直接将 I&#x2F;O 总线挂接在 Cache 上，这样 I&#x2F;O 从 Cache 读取数据一定是最新的（无论 Cache 写策略是直写还是写回），CPU 访问数据时要先访问 Cache，因此 CPU 使用的数据也是最新的。但是这种方式需要考虑对性能的影响。 写直达 Cache 可以保证存储器和 Cache 有相同的数据 但是这种方式只能解决一个方面的数据不一致问题，即 CPU 读数据时仍然读取到的是 Cache 的旧数据 写回 Cache 则需操作系统帮助进行数据检查 根据 I&#x2F;O 使用的存储器地址来清除 Cache 相应的块，确保 I&#x2F;O 使用的数据不在 Cache 中 这种方式貌似可行，但是相对来说增加了一点开销 地址检查过程也可以使用硬件完成 DMA 与虚拟存储器 使用 DMA，I&#x2F;O 设备直接访问内存（物理地址），如果不使用虚拟存储器，则 DMA 使用物理地址来传输数据 若使用虚拟存储器，使用物理地址进行 DMA，存在以下两个问题： 对于超过一页的数据，由于缓冲区使用的页面在物理存储器中不一定是连续的，传输会发生问题 DMA 正在存储器和帧缓冲器之间传输数据时，操作系统从存储器中移出一些页面(或重新分配)，DMA 将会在存储器中错误的页面上传输数据 允许 DMA 设备直接使用虚拟地址，在 DMA 期间由硬件将虚拟地址映射到物理地址。这样，I&#x2F;O 使用的缓冲区页面在虚拟存储器中是连续的，但物理页面可以分散在物理存储器中，并且虚拟地址提供了对 I&#x2F;O 操作的保护。如果使用虚拟 DMA 的进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表 第七章 多处理机 一个问题:图书馆将一批新书上架，可以有多种方式。假定将书按类上架，而将书架依据在书库中的位置分成一些组解决办法若由一工人单独完成，不能在要求的时间内完成任务若由多个工人完成， 假定每次一人仅往书架上放一本书。可以采用两种不同的方式（1）将所有的书籍平均分配给每个人去完成。这种划分方法不是太有效，原因是每个工人为了将书上架必须走遍所有的书架。（2）将所有书架分成一些组，且平均分配给各个工人负责，同时将所有图书平均分配给每个工人去上架。如果工人发现一本书属于自己所负责的书架上，则将其放入书架。否则，将这本书传给所在书架对应的工人。这种分法对应的效率比较高结论将一个任务划分成一些子任务，并分配给多个工人去完成，工人们相互合作、并在需要时相互传递图书，这种协调的工作方式可较快地完成任务并行计算就是严格地按照上述原理来完成的 并行计算相关的两个概念 任务划分(task partitioning)将图书平均分配给所有工人为任务划分的一个例子。 通信(communication)工人之间传递图书为子任务通信的例子。什么是并行计算？ 并行计算是指同时对多个任务或多条指令、或对多个数据项进行处理。完成此项处理的计算机系统称为并行计算机系统，它是将多个处理器通过网络以一定的连接方式有序地组织起来 并行计算机的发展原因： 要获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起 体系结构改进能否持续下去？通过复杂度和硅技术的提高得到的性能提升正在减小； 并行计算机应用软件已有缓慢但稳定的发展。 重点：中小规模的机器(处理器的个数不超过128)的多处理机设计技术 并行计算的研究内容:(1) 并行计算机设计(2) 有效算法的设计(3) 评价并行算法的方法(4) 并行计算机语言(5) 并行编程环境与工具(6) 并行程序的可移植性(7) 并行计算机的自动编程 并行计算的应用领域：(1) 天气预报(2) 卫星数据处理(3) 石油数据处理（连续优化问题）(4) 调度问题(5) VLSI设计（离散优化问题）(6) …… 美国政府的HPCC计划公布的重大挑战性应用 磁记录技术：研究静磁和交互感应以降低高密度磁盘的噪音 新药设计：通过抑制人的免疫故障病毒蛋白酶的作用来研制治疗癌症与艾滋病的药物 高速民航：用计算流体动力学来研制超音速喷气发动机 催化作用：仿生催化剂计算机建模，分析合成过成中的酶作用 燃料燃烧：通过化学动力学计算，揭示流体力学的作用，设计新型发动机 海洋建模：对海洋活动与大气流的热交换进行整体海洋模拟 臭氧耗损：研究控制臭氧损耗过程中的化学与动力学机制 数字解析：实时临床成像、计算层析术、磁共振成像 大气污染：对大气质量模型进行模拟研究，控制污染的传播，揭示其物理与化学机理 蛋白质结构设计：对蛋白质组成的三维结构进行计算机模拟研究 图像理解：实时绘制图像或动态 密码破译：破译由长位数组成的密码，寻找该数的两个乘积因子 并行计算的应用分类 （1）计算密集型（Compute-Intensive）这一类型的应用问题主要集中在大型科学工程计算与数值模拟（气象预报、地球物理勘探等）（2）数据密集型 (Data-Intensive)Internet的发展，为我们提供了大量的数据资源，但有效地利用这些资源，需要进行大量地处理，且对计算机的要求也相当高，这些应用包括数字图书馆、数据仓库、数据挖掘、计算可视化。（3）网络密集型 (Network-Intensive)通过网络进行远距离信息交互，来完成用传统方法不同的一些应用问题。如协同工作、遥控与远程医疗诊断等 7.1 引言单处理机的发展正在走向尽头？并行计算机在未来将会发挥更大的作用。 获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起； 自1985年以来，体系结构的改进使性能迅速提高，这种改进的速度能否持续下去还不清楚，但通过复杂度和硅技术的提高而得到的性能的提高正在减小； 并行计算机应用软件已有缓慢但稳定的发展。 本章重点:中小规模的机器(处理器的个数＜100 多处理机设计的主流) 7.1.1 并行计算机体系结构的分类 按Flynn分类法，可把计算机分成 单指令流单数据流（SISD） 单指令流多数据流（SIMD） 多指令流单数据流（MISD） 多指令流多数据流（MIMD） MIMD已成为通用多处理机体系结构的选择，原因： MIMD具有灵活性 MIMD可以充分利用商品化微处理器在性能价格比方面的优势 MIMD的优点（灵活性&#x2F;COTS） MIMD机器分类:集中式共享存储器结构(Centralized Shared-Memory Architecture)。,也称为对称式共享存储器结构(SMP, Symmetric shared-memory MultiProcessor)机器或者UMA(Uniform Memory Access)机器。 分布式存储器结构的机器。支持较大数目的处理器，存储器必须分布到各个处理器上，而非采用集中式，否则存储器系统将不能满足处理器带宽的要求。系统中每个结点包含了处理器、存储器、I／O以及互连网络接口 MIMD机器分为两类（每一类代表了一种存储器的结构和互连策略） 集中式共享存储器结构 这类机器有时被称为 UMA(Uniform Memory Access)机器 分布式存储器结构 每个结点包含：处理器、存储器、I&#x2F;O 在许多情况下，分布式存储器结构优于采用集中式共享存储器结构。 分布式存储器结构需要高带宽的互连 分布式存储器结构的优点 如果大多数的访问是针对本结点的局部存储器，则可降低对存储器和互连网络的带宽要求； 对局部存储器的访问延迟低 主要缺点 处理器之间的通信较为复杂，且各处理器之间访问延迟较大 7.1.2 通信模型和存储器的结构模型 两种地址空间的组织方案 物理上分离的多个存储器可作为一个逻辑上共享的存储空间进行编址。 这类机器的结构被称为分布式共享存储器(DSM)或可缩放共享存储器体系结构。 DSM 机器被称为 NUMA(non-uniform memory access)机器。 整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址 每一个处理器-存储器模块实际上是一个单独的计算机，这种机器也称为多计算机 两种方案： DSM：一个处理器如果具有访问权，就可以访问任何一个其他的局部存储器，DSM机器被称为 NUMA(Non-Uniform Memory Access)机器，这是因为其访问时间依赖于数据在存储器中的存放位置。 整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址。在这种机器的不同处理器中，相同的物理地址指向不同存储器的不同单元 两种通信模型 共享地址空间的机器（共享存储器机器） 利用 Load 和 Store 指令中的地址隐含地进行数据通信 多个地址空间的机器 通过处理器间显式地传递消息完成 (消息传递机器) 消息传递机器根据简单的网络协议，通过传递消息来请求某些服务或传输数据，从而完成通信 区别： 对于共享地址空间的机器，用 load 和 store 指令中的地址隐含地进行数据通讯，因而可称为 共享存储器机器 对于多个地址空间的机器，数据通讯要通过处理器间显式地传递消息完成，因而这种机器常称为 消息传递机器 例如：一个处理器要对远程存储器上的数据进行访问或操作(1) 发送消息，请求传递数据或对数据进行操作；远程进程调用(RPC， remote process call)(2) 目的处理器接收到消息以后，执行相应的操 作或代替远程处理器进行访问，并发送一个 应答消息将结果返回 对于通信机制的性能，可以通过下面三个关键的性能指标来进行衡量： 通信带宽──理想状态下的通信带宽受限于处理器、存储器和互连网络的带宽。进行通信时，结点内与通信相关的资源被占用，这种占用限制了通信速度。 通信延迟──理想状态下通信延迟应尽可能地小。通信延迟的构成为：通信延迟＝发送开销＋跨越时间＋传输延迟＋接收开销（?） （老师讲 “跨越时间”是指第一位数据从发送端口到接收端口所需的时间，“传输延迟”是指最后一位通信数据从发送端口到接收端口之间的延迟，我没怎么听懂，这两个有什么区别吗？这和计网里的数据包传送有什么不一样吗？） 通讯延迟的隐藏──如何才能较好地将通信和计算或多次通信之间重叠起来，以实现通讯延迟的隐藏 每种通信机制各有优点，共享存储器通信主要有以下优点：(1) 与常用的对称式多处理机使用的通信机制兼容。(2) 当处理器通信方式复杂或程序执行动态变化时易于编程，同时在简化编译器设计方面也占有优势(都统一翻译成存储指令即可)。(3) 当通信数据较小时，通信开销较低，带宽利用较好。(4) 通过硬件控制的 Cache 减少了远程通信的频度，减少了通信延迟以及对共享数据的访问冲突。 消息传递通信机制的主要优点包括： 硬件较简单。 通信是显式的，从而引起编程者和编译程序的注意，着重处理开销大的通信。 当然，可在支持上面任何一种通信机制的硬件模型上建立所需的通信模式平台。 在共享存储器上支持消息传递相对简单，因为发送一条消息可通过将一部分地址空间的内容复制到另一部分地址空间来实现。 但在消息传递的硬件上支持共享存储器就困难得多 7.1.3 并行处理面临的挑战 程序中有限的并行性 有限的并行性使机器要达到好的加速比十分困难 通过所给的例子，100 个处理器达到 80 的加速比，并行比例要达到 99.75%，即 0.25% 的串行比例影响了 20 的加速比。因此我们得到结论：串行对于并行处理的加速比具有至关重要的影响 相对较高的通信开销（可通过 Amdahl 定律解释） 面临的第二个挑战主要是指多处理机中远程访问的较大延迟。在现有的机器中，处理器之间的数据通信大约需要 50～10000 个时钟周期 并行性不足： 通过采用并行性更好的算法来解决远程访问延迟的降低： 靠体系结构支持和编程技术 在并行处理中，负载平衡、同步和存储器访问延迟等影响性能的因素常依赖于高层应用特点，如应用程序中数据的分配，并行算法的结构以及数据在空间和时间上的访问模式等。 依据应用特点可把多机工作负载大致分成两类：单个程序在多处理机上的并行工作负载和多个程序在多处理机上的并行工作负载 7.2 对称式共享存储器体系结构反映并行程序性能的一个重要的度量是计算与通信的比率。如果比值较高，就意味着应用程序中相对于每次数据通信要进行较多的计算。 通信在并行计算中的开销是很大的，因而较高的计算／通信比率十分有益。在一个并行处理环境下，当要增加处理器的数目，或增大所求解问题的规模，或者两者同时都增大时，都要对计算／通信比率的变化加以分析。 例如，在增加处理器数目的同时知道这个比率的变化，会对应用能获得的加速比有清楚的了解。 通常状况下，计算／通信比率随着处理的数据规模增大而增加，随着处理器数目的增加而降低。 用更多的处理器来求解一个固定大小的问题会导致不利因素的增加，因为处理器之间通信量加大了。 增加处理器时应该调整数据的规模，从而使通信的时间保持不变。 7.2.1 多处理机 Cache 一致性 多个处理器共享一个存储器。 当处理器规模较小时，这种机器十分经济。 支持对共享数据和私有数据的Cache缓存。 私有数据供一个单独的处理器使用，而共享数据供多个处理器使用 共享数据进入Cache产生了一个新的问题：Cache 的一致性问题 对共享数据，不同处理器的 Cache 都保存有对应存储器单元的内容，因而在操作中就可能产生数据的不一致，称为 Cache一致性（Coherence）问题 1. 不一致产生的原因（Cache 一致性问题） I／O 操作 Cache中的内容可能与由 I／O 子系统输入输出形成的存储器对应部分的内容不同 共享数据 不同处理器的 Cache 都保存有对应存储器单元的内容 2. 存储器是一致的（非正式地定义）如果对某个数据项的任何读操作均可得到其最新写入的值，则认为这个存储系统是一致的 存储系统行为的两个不同方面 返回给读操作的是什么值 什么时候才能将已写入的值返回给读操作 满足条件 处理器 P 对 X 进行一次写之后又对 X 进行读，读和写之间没有其它处理器对 X 进行写，则读的返回值总是写进的值。（一个处理器） 一个处理器对 X 进行写之后，另一处理器对X进行读，读和写之间无其它写，则读 X 的返回值应为写进的值。（多个处理器） 对同一单元的写是顺序化的，即任意两个处理器对同一单元的两次写，从所有处理器看来顺序都应是相同的 假设:直到所有的处理器均看到了写的结果，一次写操作才算完成；允许处理器无序读，但必须以程序规定的顺序进行写 三条已充分地保证了一致性，什么时候才能获得写进去的值仍是一个重要的问题 7.2.2 实现一致性的基本方案在一致的多处理机中，Cache 提供两种功能 共享数据的迁移 降低了对远程共享数据的访问延迟 共享数据的复制 不仅降低了访存的延迟，也减少了访问共享数据所产生的冲突 小规模多处理机不是采用软件而是采用硬件技术实现 Cache 一致性 (1) Cache 一致性协议 对多个处理器维护一致性的协议(2) 关键：跟踪共享数据块的状态(3) 共享数据状态跟踪技术 目录 物理存储器中共享数据块的状态及相关信息均被保存在目录中。 监听 每个 Cache 除了包含物理存储器中块的数据拷贝之外，也保存着各个块的共享状态信息 监听：Cache 通常连在共享存储器的总线上，各个 Cache 控制器通过监听总线来判断它们是否有总线上请求的数据块 两种协议 写作废协议 在一个处理器写某个数据项之前保证它对该数据项有唯一的访问权，即在某个 CPU 往内存中写入数据时，将其他拥有该单元的拷贝全部作废，写完后其他处理器再从该内存单元中重新读取数据，此时便是新的数据 写更新协议 当一个处理器写某数据项时，通过广播使其它 Cache 中所有对应的该数据项拷贝进行更新 写作废和写更新协议性能上的差别 对同一数据的多个写而中间无读操作的情况，写更新协议需进行多次写广播操作，而在写作废协议下只需一次作废操作。 对同一块中多个字进行写，写更新协议对每个字的写均要进行一次广播，而在写作废协议下仅在对本块第一次写时进行作废操作。 从一个处理器写到另一个处理器读之间的延迟通常在写更新模式中较低。而在写作废协议中，需要读一个新的拷贝。 在基于总线的多处理机中，写作废协议成为绝大多数系统设计的选择 7.2.3 监听协议及其实现 小规模多处理机中实现写作废协议的关键利用总线进行作废操作,每个块的有效位使作废机制的实现较为容易。 写直达 Cache，因为所有写的数据同时被写回主存，则从主存中总可以取到最新的数据值。 对于写回 Cache，得到数据的最新值会困难一些，因为最新值可能在某个 Cache 中，也可能在主存中。 当某个处理器进行写数据时，必须先获得总线的控制权，然后将要作废的数据块的地址放在总线上。其它处理器一直监听总线，它们检测该地址所对应的数据是否在它们的 Cache 中。若在，则作废相应的数据块。获取总线控制权的顺序性保证了写的顺序性，因为当两个处理器要同时写一个单元时，其中一个处理器必然先获得总线控制权，之后它使另一处理器上对应的拷贝作废，从而保证了写的严格顺序性 在写回Cache条件下的实现技术 用Cache中块的标志位实现监听过程。 给每个Cache块加一个特殊的状态位说明它是否为共享。 因为每次总线任务均要检查Cache的地址位，这可能与CPU对Cache的访问冲突。可通过下列两种技术之一降低冲突： 复制标志位 采用多级包含 Cache 7.3 分布式共享存储器体系结构7.3.1 基于目录的 Cache 一致性存储器分布于各结点中，所有的结点通过网络互连。访 问可以是本地的，也可是远程的。 不支持Cache一致性： 规定共享数据不进入Cache，仅私有数据才能保存在Cache中。 优点： 所需的硬件支持很少(因为远程访问存取量仅是一个字(或双字)而不是一个Cache块) 缺点：(1) 实现透明的软件 Cache 一致性的编译机制能力有限(2) 没有 Cache 一致性，机器就不能利用取出同一块中的多个字的,开销接近于取一个字的开销这个优点，这是因为共享数据是以 Cache 块为单位进行管理的。当每次访问要从远程存储器取一个字时，不能有效利用共享数据的空间局部性(3) 诸如预取等延迟隐藏技术对于多个字的存取更为有效，比如针对一个 Cache 块的预取 对远程存储器访问的巨大延迟与对本地Cache访问的短延迟相比，突出地反映出了这些缺点。例如，Cray T3E本地访问延迟为两个时钟周期，并且可被流水化，而一次远程访问则需约400个时钟周期(T3E-900, 450MHz Alpha) 解决Cache一致性问题的关键： 目录协议 目录：用一种专用的存储器所记录的数据结构，它记录着可以进入Cache的每个数据块的访问状态、该块在各个处理器的共享状态以及是否修改过等信息。 对每个结点增加目录表后的分布式存储器的系统结构 而当系统的规模变大时，它又是致命的弱点。此外，监听的访问量与处理器个数的平方（N2）成正比，即使总线的带宽随系统规模线性增长（N），而实际的性能还是下降到1&#x2F;N 目录协议的基本点 在每个结点增加了目录存储器用于存放目录； 存储器的每一块在目录中对应有一项； 每一个目录项主要有状态和位向量两种成分。 状态描述该目录所对应存储块的当前情况； 位向量共有N位，其每一位对应于一个处理器的局部 Cache，用于指出该Cache中有无该存储块的拷贝 目录必须跟踪每个 Cache 块的状态 Cache 块状态有三种： 共享：在一个或多个处理器上具有这个块的拷贝，且主存中的值是最新值(所有 Cache 均相同)。 未缓冲：所有处理器的Cache都没有此块的拷贝。 专有：仅有一个处理器上有此块的拷贝，且已对此块进行了写操作，而主存的拷贝仍是旧的。这个处理器称为此块的拥有者。 由于写作废操作的需要，还必须记录共享此块的处理器信息。 方法：对每个主存块设置一个位向量。 当此块被共享时，每个位指出与之对应的处理器是否有此块的拷贝。 当此块为专有时，可根据位向量来寻找此块的拥有者。 宿主结点 存放有存储器块和对应地址目录项的结点 7.3.2. 目录协议及其实现基于目录的协议中，目录承担了一致性协议操作的主要功能。 (1) 发往一个目录的消息会产生两种不同类型的动作 更新目录状态 发送消息满足请求服务 (2) 目录项可能接收到三种不同的请求（注意请求的完备性） 读失效 写失效 数据写回 (3) 在各个状态下所接收到的请求和相应的操作 ①当一个块处于未缓冲状态时，对此块发出的请求及处理操作为: 读失效 将存储器数据送往请求方处理器，且本处理器成为此块的唯一共享结点，本块的状态转换为共享 写失效 将存储器数据送往请求方处理器，此块成为专有 ②当一个块是共享状态时，存储器中的数据是其当前最新值，对此块发出的请求及处理操作为: 读失效 将存储器数据送往请求方处理器，并将其加入共享集合 写失效 将数据送往请求方处理器，对共享集合中所有的处理器发送写作废消息，且将共享集合置为仅含有此处理器，本块的状态变为专有 ③当某块处于专有状态时，本块的最新值保存在共享集合指出的拥有者处理器中，从而有三种可能的目录请求 读失效 将“取数据”的消息发往拥有者处理器，使该块的状态转变为共享，并将数据送回目录结点写入存储器，进而把该数据返送请求方处理器，将请求方处理器加入共享集合 写失效 本块将有一个新的拥有者。 数据写回 拥有者处理器的 Cache 要替换此块时必须将其写回，从而使存储器中有最新拷贝(宿主结点实际上成为拥有者)，此块成为非共享，共享集合为空 对基于目录的Cache一致性的多种改进 有限映射目录 链式结构目录 基于目录的 Cache 一致性协议采取了“以空间换时间”的策略，减少了访问次数但增加了目录存储器，它的大小与系统规模 N 的平方成正比。基于目录的 Cache 一致性协议是完全由硬件实现的 7.4 互连网络","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"体系结构","slug":"课程笔记/体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"体系结构","slug":"体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"实现C语言编译器：三、输入及词法分析","slug":"实现C语言编译器：三、输入及词法分析","date":"2022-01-18T12:48:04.000Z","updated":"2023-08-08T12:35:27.416Z","comments":true,"path":"2a32925d.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/2a32925d.html","excerpt":"","text":"三、输入及词法分析输入系统 输入系统的作用是将源文件从磁盘或内存中读入，根据模块化设计原理，如果输入系统是一个独立模块，通过固定接口与词法解析器交互的话，那么它的修改和维护将会非常灵活。输入系统的效率，决定着整个编译系统的效率。我们用 C 语言的时候，经常会用到他提供的输入函数例如 scanf 等 C 语言的输入系统设计得不是很合理。当 C 语言的库函数将数据读入程序的过程中，有三次拷贝, 一是从磁盘上将数据拷贝到操作系统中，二是将数据从操作系统拷贝到一个 FILE 结构中，三是将数据从 FILE 结构拷贝到程序的内存中。这些拷贝都需要耗费时间和空间。另外，词法解析器在解析时需要预先读入一些字符(look ahead，在前面的简易编译器中使用过这种技巧), 以便对输入的字符串打上合适的标签(想象前面的 typedef 语句， 一旦读到typedef 那就需要将 typedef 后面的字符读进来才好解析), 预先读入的字符，使用完后，可能需要重新放回到缓冲区中，这一取一放，如果不加以良好的设计，那很可能会产生 I&#x2F;O 性能上的影响。","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"编译器","slug":"编译器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Java","slug":"Java","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Java/"}]},{"title":"计算机体系结构课程笔记（三）","slug":"计算机体系结构课程笔记（三）","date":"2022-01-16T06:17:16.000Z","updated":"2023-08-08T12:35:27.477Z","comments":true,"path":"c152688f.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/c152688f.html","excerpt":"第五章 存储层次 国防科大计算机体系结构课程第五章笔记","text":"第五章 存储层次 国防科大计算机体系结构课程第五章笔记 5.1 存储器的层次结构5.1.1 从单级存储器到多级存储器 主存储器与 CPU 速度差距越来越大，存储墙问题严重制约着计算机性能的提升 系统与应用的规模不断扩大，需要更大的存储器来支撑程序的运行 各类存储器的容量&#x2F;速度&#x2F;价格不可兼得，如SRAM（已经可以和 CPU 速度持平）、DRAM、磁盘等，凭现有单种存储器件，无法构建一个可行的存储系统 处理器性能与存储系统性能之间存在巨大差距，这叫做存储墙（Memory Wall）怎么办？ 利用多种存储器件，取长补短，构建层次式存储系统 快速但昂贵的存储器：容量少点，尽量让 CPU 多访问 慢速但容量大的存储器：容量大点， CPU 尽可能少访问 能否达到预期效果？ 访问速度方面：采用快速存储器，尽量让 CPU 多访问快速存储器中的内容（增加 Cache 层次） 程序局部性原理： 时间局部性：当前访问的数据存放 Cache 中 空间局部性：把与当前访问地址相邻的数据放入 Cache 中（以块为单位从内存调入） 容量方面：采用慢速但容量大的存储器，内存不够时数据可以放到外存中（增加辅存层次） 5.1.2 Cache——主存和主存——辅存层次 这是最主要的两种存储层次 从主存的角度来看 Cache——主存层次：弥补主存速度的不足 主存——辅存层次：弥补主存容量的不足 失效时 CPU 是否切换：Cache——主存层次不切换，主存——辅存层次需要切换到其他进程 5.1.3 存储层次的四个问题 当把一个块调入高一层(靠近CPU)存储器时，可以放在哪些位置上？ 映象规则：调入块可以放在哪些位置 当所要访问的块在高一层存储器中时，如何找到该块？ 查找算法：如何在映象规则规定的候选位置查找 当发生失效时，应替换哪一块？ 替换算法：规定的候选位置均被别的块占用 当进行写访问时，应进行哪些操作？ 写策略：如何处理写操作 5.1.4 存储层次的性能参数 $C$(平均每位价格), $H$(命中率), $T_A$(平均访问时间) 假设： $S$ ——容量 $T_A$——访问时间 $C$——每位价格 仅考虑 $M_1 M_2$构成的两级存储层次时： $M_1$的参数：$S_1$，$T_{A1}$，$C_1$ $M_2$的参数：$S_2$，$T_{A2}$，$C_2$ 每位价格 $C&#x3D;\\cfrac{C_1S_1+C_2S_2}{S_1+S_2}$ 命中率 $H$ 和失效率 $F$ $H&#x3D;\\cfrac{N_1}{N_1+N_2}$ $F&#x3D;1-H$ 平均访问时间 $T_A$ $T_A&#x3D;T_{A1}+(1-H)T_M ; 或 ; T_A&#x3D;T_{A1}+F·T_M$ $T_M&#x3D;T_{A2}+T_B$ $T_{A1}$——命中时间 $T_{A2}$——$M2$ 访问时间 $T_M$——失效开销 5.2 Cache 基本知识5.2.1 映像规则1. 全相联映象 全相联：主存中的任一块可以被放置到 Cache 中的任意一个位置。 对比： 阅览室位置──随便坐 特点： 空间利用率最高，冲突概率最低，实现最复杂。 2. 直接映象 直接映象：主存中的每一块只能被放置到 Cache 中唯一的一个位置。(循环分配) 对比：阅览室位置 ── 只有一个位置可以坐 特点：空间利用率最低，冲突概率最高，实现最简单。 3. 组相联映像 组相联：主存中的每一块可以放到Cache中唯一的一个组中的任何一个位置 组的选择常采用位选择算法 n 路组相联，每个组中有 n 个块，n 称为相联度，相联度越高，Cache 空间利用率就越高，块冲突概率就越低，失效率也就越低 绝大多数计算机的 Cache&lt;&#x3D;4 相联度不是越大越好 5.2.2 查找方法 如何确定 Cache 中是否有所要访问的块？若有的话如何确定其位置？ Cache 块调入时记录存放的位置到 目录表（标识存储器） 表项中只需要放入标识（tag）和有效位即可，因 index 都一样，是冗余信息，所以无需放入表项 只需查找候选位置所对应的目录表项 并行查找与顺序查找（减少硬件开销） 相联存储器（代价高） 单体多字存储器＋比较器 只有一套访存机制，一次可读多个字 ４路组相联 Cache 的查找过程 首先根据给定的物理地址的组号找到对应的表项，再将该组中的 4 个 cache 块的标记读出，分别与物理地址的 tag 标记字段进行比较，若没有匹配，则 Cache 缺失 若有匹配，则从数据存储体中读取该组中所有的数据（四路），然后再通过 4：1 MUX 选择是哪一路命中了数据，再根据块内偏移确定具体的数据送给 CPU 对于比较器的个数，应等于组相联中的相联度（2022年408真题中考察了该知识点） - 直接映象 Cache 的查找过程 - 先根据 index 选择到对应的 Cache 块，然后将给定的物理地址的 tag 和标识存储体中的标识通过一个标识检查器（比较器）进行比较，若不命中，则 Cache 缺失 - 若命中，直接访问数据存储体，将数据读出送至 CPU 提高性能的重要思想：主候选位置(MRU块) 5.2.3 替换算法所要解决的问题：当新调入一块，而该块能够占用的 Cache 位置已被占满时，替换哪一块？ 随机法 FIFO: 实现简单 LRU（最近最久未使用）：失效率低，但是硬件实现较为复杂 LFU：最不常使用法 5.2.4 写策略 “写”操作所占的比例 Load 指令：26% Store 指令：9% “写”在所有访存操作中所占的比例：9%&#x2F;(100%＋26%＋9%)≈7% “写”在访问数据 Cache 操作中所占的比例：9%&#x2F;(26%+9%)≈25% “写”操作必须在确认是否命中后才能进行 “写”访问可能导致 Cache 和主存内容不一致 两种写策略 写直达法：执行“写”操作时，不仅写入 Cache ，而且也写入下一级存储器 写回法：执行“写”操作时，只写入Cache，仅当 Cache 中相应的块被替换时，才写回主存（设置“脏位”） 两种写策略比较 写回法优点：速度快，占用存储器频带低 写直达法易于实现，一致性好 写缓冲器 将数据写入写缓冲器便完成了一次写操作，无需再写入存储器中 写缓冲器若满，只能等待 写合并 当把数据写入写缓冲器时，判断本次所写入单元的块地址是否与写缓冲器中某个有效块的地址相同，若是，则把新数据与该块合并 写回法——按写分配 写直达法——不按写分配 5.2.3 Cache 结构DEC 的 Alpha AXP21064 中的内部数据 Cache 简介 容量： 8KB 块大小： 32B 块数： 256 映象方法：直接映象 “写”策略：写直达——不按写分配 写缓冲器大小： 4 个块 混合 Cache 与分离 Cache 优缺点 两种 Cache 可以采用不同策略，方便进行读写 分离 Cache 平均失效率的计算： 访问指令 Cache 的百分比 × 指令 Cache 的失效率＋访问数据 Cache 的百分比 × 数据 Cache 的失效率 5.2.6 性能分析 平均访问时间 平均访问时间＝命中时间＋失效率 × 失效开销 CPU 时间 CPU 时间＝(CPU 执行周期数＋存储器停顿周期数)×时钟周期时间 存储器停顿周期数&#x3D;访存次数×失效率×失效开销 CPU 时间＝IC×(CPIexe＋访存次数&#x2F;指令数×失效率×失效开销)×时钟周期时间 CPU 时间＝IC×(CPIexe + 每条指令平均存储器停顿周期数)×时钟周期时间 注：$CPI_{exe}$ 表示理想情况下的 CPI 例 5.1 假设 Cache 的命中时间为 1 个时钟周期，失效开销为 50 个时钟周期，在混合 Cache 中一次 load 或 store 操作访问 Cache 的命中时间都要增加一个时钟周期(因为混合 Cache 只有一个端口，无法同时满足两个请求。按照前一章中有关流水线的术语，混合 Cache 会导致结构冲突)，根据表 5-4 所列的失效率，试问：(1) 指令 Cache 和数据 Cache 容量均为 16KB 的分离 Cache 和容量为 32KB 的混合 Cache 相比，哪种 Cache 的失效率更低？(2) 又假设采用写直达策略，且有一个写缓冲器，并且忽略写缓冲器引起的等待。请问上述两种情况下平均访存时间各是多少？ [解析](1) 75% 的访存为取指令，因此分离 Cache 总体失效率为 (75%×0.64%)+(25%×6.47%)&#x3D;2.10%根据表 5-4 ，容量为 32KB 的混合 Cache 的失效率略低一些，只有 1.99%(2) 平均访存时间公式可以分为指令访问和数据访问两部分平均访存时间＝指令所占的百分比 ×(指令命中时间＋指令失效率 × 失效开销) ＋ 数据所占的百分比 × (数据命中时间＋数据失效率 × 失效开销)所以，两种结构的平均访存时间分别为平均访存时间分离 ＝ 75%×(1＋0.64%×50)＋25%×(1＋6.47%×50)＝(75%×1.32)＋(25%×4.325)＝0.990＋1.059＝2.05平均访存时间混合＝ 75%×(1＋1.99%×50)＋25%×(1＋1＋1.99%×50)＝(75%×1.995)＋(25%×2.995)＝1.496＋0.749＝2.24 这里混合 Cache 平均访存时间较长的主要原因是，混合 Cache 共用指令 Cache 和数据 Cache，节约了硬件，但是可能会造成结构冲突 [注意] 在访问数据段时候同时也在访问指令，因此要多增加一个时钟周期 例 5.2 我们用一个和 Alpha AXP 类似的机器作为第一个例子。当不考虑存储器停顿时，所有指令的执行时间都是 2.0 个时钟周期。假设 Cache 失效开销为 50 个时钟周期， Cache 的失效率为 2% ，平均每条指令访存 1.33 次。试分析 Cache 对性能的影响。 [分析]CPU 时间＝IC×(CPIexe+存储器停顿周期数&#x2F;指令数)×时钟周期时间考虑 Cache 失效后，性能为 CPU 时间有Cache＝IC×(2.0+(1.33×2%×50))×时钟周期时间＝IC×3.33×时钟周期时间 实际 CPI＝3.33，3.33&#x2F;2.0＝1.67倍 CPU 时间增加了 1.67 倍 若不采用 Cache，则：CPI＝2.0+50×1.33＝68.5 差距显而易见 5.2.7 改进 Cache 性能 平均访存时间＝命中时间＋失效率 × 失效开销 可以从三个方面改进 Cache 的性能：(1) 降低失效率(2) 减少失效开销(3) 减少 Cache 命中时间 15 种 Cache 优化技术 1. 降低失效率 增加块大小 提高相联度 Victim Cache 伪相联 Cache 硬件预取 编译器控制的预取 用编译器技术减少 Cache 失效 2. 减少失效开销 使读失效优于写 子块放置技术 尽早重启动和关键字优先 非阻塞 Cache 第二级 Cache 3. 减少命中时间 容量小且结构简单的 Cache 对 Cache 索引时，不必进行地址转换 流水化写 值得注意的是，要想提高平均访存时间，不是从单一的某一方面去进行优化，而是要从全局进行考虑，这是体系结构的核心观点。比如仅仅减少失效开销，不一定会降低平均访存时间，因为降低失开销率可能需要更改整个体系结构，从而带来失效率的增加，最终反而会增加平均访存时间。 5.3 降低 Cache 失效率的方法5.3.1 三种失效（3C）1. 强制性失效（Compulsory miss）当第一次访问一个块时，该块不在 Cache 中，需要从下一级存储器中调入 Cache，这就是强制性失效。也叫冷启动失效，首次访问失效 2. 容量失效（Capacity miss）如果程序执行时所需的块不能全部调入 Cache 中，则当某些块被替换后，若又被重新访问，就会发生失效。这种失效成为容量失效。（全相联映射完全是因为容量失效造成的，因为没有替换算法） 3. 冲突失效（Conflict miss）在组相联或直接映像 Cache 中，若太多的块映像到同一组或同一块中，则会出现该组中某个块被别的块替换（即使其他组有空闲块），然后又被重新访问的情况，这就是冲突失效，也叫碰撞失效或干扰失效。若同一个块不断被换进换出，便产生了颠簸，要尽量避免颠簸造成的系统损耗。 三种失效所占的比例 通过上图可以看出：(1) 相联度越高，冲突失效就越少；(2) 强制性失效不受 Cache 容量的影响，但容量失效却随着容量的增加而减少；强制性失效和容量失效不受相联度的影响（容量失效一般是在全相联映像下测试出来的）(3) 表中的数据符合 2:1 的 Cache 经验规则，即大小为 N 的直接映象 Cache 的失效率约等于大小为 N&#x2F;2 的两路组相联 Cache 的失效率 减少三种失效的方法 强制性失效：增加块大小，预取 增加块大小后，每个块包含的内容就更多了，程序局部性更好了，需要读取的块就少了，于是便减少了强制性失效的次数 容量失效：增加容量，防止出现颠簸现象 冲突失效：增加相联度，理想情况是全相联 但是许多降低失效率的方法会增加命中时间 5.3.2 增加 Cache 块大小 失效率与块大小的关系 对于给定的 Cache 容量，当块大小增加失效率开始时下降，后来反而上升 Cache 容量越大，失效率达到最低的块大小就越大 那么这是为什么呢？ 导致 Cache 失效率先下降后上升的原因在于增加块大小会产生双重作用。一方面它减少了强制性失效。因为局部性原理有两方面的含义，即时间局部性和空间局部性，增加块大小便利用了程序的局部性。另一方面由于增加块大小会减少 Cache 中块的数目，所以有可能会增加冲突失效。在 Cache 容量较小时甚至还会增加容量失效。刚开始增加块大小时，由于块大小还不是很大，上述的第一种作用超过第二种作用从而使失效率下降。但等到块大小较大时，第二种作用超过第一种作用使失效率上升。 例 5.4假定存储系统在延迟 40 个时钟周期后，每 2 个时钟周期能送出 16 个字节。即 : 经过 42 个时钟周期，它可提供 16 个字节；经过 44 个时钟周期，可提供 32 个字节；依此类推。试问：对于表 5-6 中列出的各种容量的 Cache ，在块大小分别为多少时，平均访存时间最小？假设命中时间为一个时钟周期。 5.3.3 提高相联度 采用相联度超过 8 的方法实际意义不大（一般 n 为 4 或 2） 2:1 Cache 经验规则：容量为 N 的直接映象 Cache ≈ 容量为 N&#x2F;2 的两路组相联 提高相联度是以增加命中时间为代价 Cache TTL 或 ECL 板级 Cache ，两路组相联：增加 10 ％ 定制的 CMOS Cache, 两路组相联：增加 2 ％ 例 5.5假定提高相联度会按下列比例增大处理器时钟周期：时钟周期2路 ＝ 1.10 × 时钟周期1路时钟周期4路 ＝ 1.12 × 时钟周期1路时钟周期8路 ＝ 1.14 × 时钟周期1路假定命中时间为 1 个时钟，直接映象情况下失效开销为 50 个时钟周期，而且假设不必将失效开销取整。使用表 5-5 中的失效率，试问当 Cache 为多大时，以下不等式成立？平均访存时间8路 &lt; 平均访存时间4路平均访存时间4路 &lt; 平均访存时间2路平均访存时间2路 &lt; 平均访存时间1路解：在各种相联度的情况下，平均访存时间分别为：平均访存时间8路＝命中时间8路 + 失效率8路 × 失效开销8路＝ 1.14＋失效率8路 × 50平均访存时间4路 &#x3D; 1.12 ＋失效率4路 × 50平均访存时间2路 &#x3D; 1.10 ＋失效率2路 × 50平均访存时间1路 &#x3D; 1.00 ＋失效率1路 × 50 例如， 1KB 的直接映象 Cache 的平均访存时间为：平均访存时间1路 ＝ 1.00 ＋ (0.133×50) ＝ 7.65容量为 128KB 的 8 路组相联 Cache 的平均访存时间为：平均访存时间8路 ＝ 1.14 ＋ (0.006×50) ＝ 1.44 提高相联度可以减少失效率，但是总体性能可能下降 5.3.4 Victim Cache 基本思想 在 Cache 和它从下一级存储器调数据的通路之间设置一个全相联的小 Cache ，用于存放被替换出去的块 (称为 Victim)，以备重新使用。 当颠簸发生时，被调出去的块很快就要被重新调入，那么从外存中重新写回到内存很浪费时间，于是就增加了一个小 Cache，减少颠簸对系统性能的影响 作用 对于减小冲突失效很有效，特别是对于小容量的直接映象数据 Cache ，作用尤其明显。例如，项数为 4 的 Victim Cache: 使 4KB Cache 的冲突失效减少 20% ～ 90% 开销大。不仅需要 Cache 所需的一切硬件和布线，并且如果在 Victim Cache 中找到数据，而在数据 Cache 中没有找到，还要进行交换，因为此时 Victim Cache 中的数据局部性更好 5.3.5 伪相联 Cache取直接映象及组相联两者的优点：命中时间小，失效率低缺点 :多种命中时间会使 CPU 流水线的设计复杂化，时钟周期要按照较慢的过程执行时间为标准，降低了计算机整体的性能 这里并不是真的是两路组相联，只是每次查找有两次选择，用指针相连，这样就不用经过多路选择器了。 (1) 基本思想及工作原理 在逻辑上把直接映象 Cache 的空间上下平分为两个区。对于任何一次访问，伪相联 Cache 先按直接映象 Cache 的方式去处理。若命中，则其访问过程与直接映象 Cache 的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器。 (2) 快速命中与慢速命中 要保证绝大多数命中都是快速命中，将命中概率较高的块交换到主位上 5.3.6 硬件预取技术 指令和数据都可以预取 预取内容既可放入 Cache ，也可放在外缓冲器中，例如：指令流缓冲器 预取效果 (1) Joppi 的研究结果 指令预取： (4KB ，直接映象 Cache, 块大小＝16 字节) 1 个块的指令流缓冲器： 捕获 15%～25%的失效 4 个块的指令流缓冲器： 捕获 50% 16 个块的指令流缓冲器：捕获 72% 数据预取： (4KB, 直接映象 Cache) 1 个数据流缓冲器：捕获 25% 的失效，还可以采用多个数据流缓冲器(2) Palacharla 和 Kessler 的研究结果 流缓冲器：既能预取指令又能预取数据 对于两个 64KB 四路组相联 Cache 来说：8 个流缓冲器能捕获 50%～70%的失效 5.3.7 由编译器控制的预取由编译器加入预取指令，在数据被用到之前发出预取请求。 预取的类型 寄存器预取：把数据取到寄存器中 Cache 预取： 只将数据取到 Cache 中 故障性预取：预取时，若出现虚地址故障或违反访问权限，就会发生异常 非故障性预取：预取时，若出现虚地址故障或违反访问权限，并不会导致异常，只是转变为“不预取” 在预取数据的同时，处理器应能继续执行，只有这样，预取才有意义。 非阻塞 Cache (非锁定 Cache) Cache 可以接受多个读写请求，当 CPU 在访问 Cache 时，同时还能对 Cache 进行预取 循环是预取优化的主要对象 失效开销小时：循环体展开 1～2 次 失效开销大时：循环体展开许多次 例 5.7 对于下面的程序，判断哪些访问可能会导致数据 Cache 失效。然后，加入预取指令以减少失效。最后，计算所执行的预取指令的条数以及通过预取避免的失效次数。假定：(1) 我们用的是一个容量为 8KB、块大小为 16B 的直接映象 Cache，它采用写回法并且按写分配。(2) a、b 分别为 3×100(3 行 100 列)和 101×3 的双精度浮点数组，每个元素都是 8 个字节。当程序开始执行时，这些数据都不在 Cache 内。 123for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 100; j++) a[i][j] = b[j][0] * b[j + 1][0]; [分析] 首先可以得到数组 a 有 3*100&#x3D;300 个元素，每个块为 16B，一个元素为 8B，因此一个块能放 2 个元素。所以数组 a 的 300 个元素要失效 300&#x2F;2&#x3D;150 次 数组 b 没有空间局部性，因为他是按照列访问的。但是却具有较好的时间局部性： 对于 i 的循环，每次 b 都访问同一个元素 对于 j 的循环，b 的每次访问都会有一个和上一次访问重复的元素 因此数组 b 失效 101 次，如下图 综上，在没有指令预取时，这个循环引起的数据 Cache 失效次数为 150+101&#x3D;251 次 指令预取123456789101112//先展开 i = 0 这一层循环for (j = 0; j &lt; 100; j++) &#123; prefetch(b[j + 7][0]); //预取7次循环后所需的b(j,0) prefetch(a[0][j + 7]); //预取7次循环后所需的a(0,j) a[0][j] = b[j][0] * b[j + 1][0];&#125;for (int i = 1; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; prefetch(a[i][j + 7]); //预取7次循环后所需的a(i,j) a[i][j] = b[j][0] * b[j + 1][0]; &#125;&#125; 将 i &#x3D; 0 展开是为了预取 b 数组，因为 b 数组只用到了第一列。然后在七次循环之后（七次循环是一个比较合适的次数）预取数组 a 的元素，这样一共失效 12 + 7 &#x3D; 19 次，远远小于没有指令预取时的 251 次。 例 5.8 在以下条件下，计算例 5.7 中所节约的时间：(1) 假设预取可以被重叠或与 Cache 失效重叠执行，从而能以最大的存储带宽传送数据。(2) 不考虑 Cache 失效时，修改前的循环每 7 个时钟周期循环一次。修改后的程序中，第一个预取循环每 9 个时钟周期循环一次，而第二个预取循环每 8 个时钟周期循环一次(包括外层 for 循环的开销) 。(3) 1 次失效需 100 个时钟周期[分析] 修改前 循环时间：300 * 7 &#x3D; 2100 失效开销：251 * 100 &#x3D; 25100 总时间：2100 + 25100 &#x3D; 27200 修改后 循环时间：100 * 9 + 200 * 8 &#x3D; 2500 失效时间：(4 + 7) * 100 + 8 * 100 &#x3D; 1900（一共失效 19 次） 总时间：2500 + 1900 &#x3D; 4400 加速比：27200 &#x2F; 4400 &#x3D; 6.2 5.3.8 编译器优化 基本思想在编译时，对程序中的指令和数据进行重新组织，以降低 Cache 失效率 McFaring 发现：通过对指令进行重新排序，可有效地降低指令 Cache 的失效率 数据对存储位置的限制比指令的少，因此更便于优化通过把数据重新组织，使一块数据被从 Cache 替换出去之前，能最大限度利用其中的数据(访问次数最多) 1. 数组合并12345678//修改前int val [SIZE];int key [SIZE];struct merge &#123; int val ; int key ;&#125;;struct merge merged_array[size]; 在没有优化之前，val 和 key 单独定义，这样在内存中就不是连续存放，这样空间局部性就差了。优化之后两个数组在内存中实现连续存放，提高了空间局部性。 2. 内外循环交换12345678//修改前for (j = 0; j &lt; 100; j++) for (i = 0; i &lt; 5000; i++) x[i][j] = 2 * x[i][j];//修改后for (i = 0; i &lt; 100; i++) for (j = 0; j &lt; 5000; j++) x[i][j] = 2 * x[i][j]; 这个例子不用过多解释了，计组里面计算 Cache 失效率经常用的例子，就是数组按行存放，但是按列读取，增加了 Cache 的失效率 3. 循环融合123456789101112131415//修改前for (i = 0; i &lt; N; i++) for (j = 0; j &lt; N; j++) a[i][j] = 1 / b[i][j] * c[i][j];for (i = 0; i &lt; N; i++) for (j = 0; j &lt; N; j++) d[i][j] = a[i][j] + c[i][j];//修改后for (i = 0; i &lt; N; i++) for (j = 0; j &lt; N; j++) &#123; a[i][j] = 1 / b[i][j] * c[i][j]; d[i][j] = a[i][j] + c[i][j]; &#125;&#125; 我们看修改前的两次循环，第一次循环中用到了 a，c 数组，满足了空间局部性，但是第二次循环中仍然用到了 a，c 两个数组，并且都是读取，于是就要把刚刚的循环再来一遍，没有利用好时间局部性，降低了整体效率，也增加了 Cache 失效率。解决方法就是将两次循环合并起来。 4. 分块把对数组的整行或整列访问改为按块进行 123456789//修改前for (i = 0; i &lt; N; i++) for (j = 0; j &lt; N; j++) &#123; r = 0; for (k = 0; k &lt; N; k++) &#123; r = r + y[i][k] * z[k][j]; &#125; x[i][j] = r; &#125; 失效次数：$2N^3+N^2$ 1234567891011//修改后for (jj = 0; jj &lt; N; jj += B) for (kk = 0; kk &lt; N; kk += B) for (i = 0; i &lt; N; i++) for (j = jj; j &lt; min(jj + B - 1, N); j++) &#123; r = 0; for (k = kk; k &lt; min(kk + B - 1, N); k++) &#123; r = r + y[i][k] * z[k][j]; &#125; x[i][j] = r; &#125; 失效次数：$(N&#x2F;B)×(N&#x2F;B)×N×2B+N^2&#x3D; 2N^3&#x2F;B+N^2$ （问号脸？？上面这些略过吧，我觉得现在没人这样写代码了） 5.4 减少 Cache 失效开销5.4.1 写缓冲及写合并 写直达 Cache 中，因为所有的写请求都必须发送到下级存储层次中，所以经常使用一个写缓冲来降低失效开销 如何提高写缓冲的效率和利用率——写合并 在写回法 Cache 中，也可采用写缓冲器 5.4.2 让读失效优先于写 Cache 中的写缓冲器导致对存储器访问的复杂化 解决问题的方法（读失效的处理） 推迟对读失效的处理直到写缓冲排空（缺点：读失效的开销增加） 检查写缓冲器的中的内容：增加硬件 5.4.3 子块放置技术 当一个块比较大的时候，可能需要多次访存，如果失效的话，失效开销会很大。如果当失效的时候，将 Cache 块划分成更小的块（子块），并给每个子块赋予一位有效位，用于指明该子块中的数据是否有效 但是块变小了，程序局部性可能没有以前好，失效率可能会增加 Cache 与下一级存储器之间以子块为单位传送数据，但标识仍以块为单位 5.4.4 请求字处理技术 请求字 从下一级存储器调入 Cache 的块中，只有一个字是立即需要的，这个字称为请求字 实际上 CPU 请求的数据并不是整个 Cache 块，而是块内的某个字或字节 应尽早把请求字发送给 CPU 尽早重启动：调块时，从块的起始地址开始读，一旦请求字到达，就立即发送给 CPU，让 CPU 继续执行 请求字优先：调块时，从请求字所在的位置读起，这样第一个读出的字便是请求字，将其立即发送个 CPU 这种技术在以下情况下效果不大： Cache 块较小 下一条指令正好访问同一 Cache 块的另一部分 5.4.5 多级 Cache 应把 Cache 做得更快？还是更大？ 二者兼顾：再增加一级 Cache： 第一级 Cache(L1)小而快 第二级 Cache(L2)容量大 性能分析 平均访问时间&#x3D;L1命中开销+L1失效率*L1失效开销 其中L1失效开销&#x3D;L2命中时间+L2失效率*L2失效开销 局部失效率和全局失效率 局部失效率&#x3D;该级 Cache 的失效次数&#x2F;到达该级 Cache 的访问次数，如上述式子中的失效率L2 全局失效率&#x3D;该级 Cache 的失效次数&#x2F;CPU 发出的访存次数 全局失效率为各级 Cache 局部失效率的乘积 评价多级 Cache 时，应使用全局失效率这个指标 当第二级 Cache 比第一级 Cache 大得多时，两级 Cache 的全局失效率与容量和第二级 Cache 相同的单级 Cache 的失效率非常接近 第二级 Cache 的参数 第二级 Cache 不会影响 CPU 的时钟频率，因此其设计有更大的考虑空间 两个问题： 能否降低 CPI 中的平均访存时间部分？ 成本是多少？ (1) 容量：第二级 Cache 的容量一般比第一级的大许多，如 512KB (2) 相联度：第二级 Cache 可采用较高的相联度或伪相联 例 5.12给出有关第二级 Cache 的以下数据：⑴ 对于直接映象，命中时间 L2&#x3D;10 个时钟周期⑵ 对于两路组相联，命中时间增加 10%×CPU 时钟周期⑶ 对于直接映象，局部失效率 L2&#x3D;25%⑷ 对于两路组相联，局部失效率 L2&#x3D;20%⑸ 失效开销 L2&#x3D;50 个时钟周期试问第二级 Cache 的相联度对失效开销的影响如何？ [分析] 对于直接映像的第二级 Cache 来说，第一级 Cache 失效开销为：10 + 25% * 50 &#x3D; 22.5 个时钟周期 对于两路组相联来说，命中时间增加了 10% 个时钟周期，因此第一级 Cache 失效开销为：10 + 10 * 10% + 20% * 50 &#x3D; 20.1 个时钟周期，将命中时间取整（10或11），得到失效开销为 20 或 21 个时钟周期 (3) 块大小：第二级 Cache 可采用 大的块，如64、128、256 字节。为减少平均访问时间，可以让容量较小的第一级 Cache 采用较小的块，而让容量较大的第二级 Cache 采用较大的块 5.4.6 非阻塞 Cache 技术 非阻塞 Cache ： Cache 失效时仍允许 CPU 进行其它的命中访问。即允许“失效下命中” 进一步提高性能：多重失效下命中存储器必须能够处理多个失效 重叠失效个数对平均访问时间的影响 5.5 减少命中时间5.5.1 采用容量小、结构简单的 Cache 命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是 Cache 的访问时间限制了处理器的时钟频率 硬件越简单，速度就越快 应该使 Cache 足够小，以便可以与 CPU 放在同一块芯片上，如果放在 CPU 外面，内部总线的延迟会增加 5.5.2 虚拟 Cache 虚拟 Cache 背景：现代计算机几乎都使用虚拟存储技术，程序运行时都是将虚拟地址转化成物理地址再执行 检查 Cache 是否命中首先要将虚拟地址转化成物理地址，然后在 Cache 中找到组号，比较 tag，看是否命中 虚拟 Cache 希望能够仅通过虚拟地址访问 Cache 索引，其中 Cache 的索引以及 Cache 中的标识都是虚拟地址(一部分) 并非都采用虚拟 Cache 的原因 因为许多进程运行时，有大量虚拟地址可能重叠，若当前进程的数据按照虚拟地址写入虚拟 Cache，当下一个进程运行时，要清空虚拟 Cache，否则取到的就是上一个进程的数据，而清空虚拟 Cache 很耗时 虚拟 Cache 的清空问题 解决办法：在地址标识字段中增加 PID 字段（进程 ID） PIDs 与单进程相比：时间开销增加 0.3%~0.6% PIDs 与清空相比：时间开销减少 0.6%~4.3% 同义&#x2F;别名问题 多个虚拟地址对应同一个物理地址 若两个进程共享同一块物理地址，两个程序中对应的虚拟地址是不同的 解决方法：反别名法，页着色 具体略 虚拟索引+物理标识 利用虚拟地址找到索引读 Cache，同时进行虚实地址转换：前提是虚拟索引&#x3D;物理索引 而页内位移在虚实地址变换时不变，可以将索引 index 放在页内偏移中 优点：兼得虚拟 Cache 和物理 Cache 的好处 局限性：Cache 容量受限于页大小*相联度 举例：IBM3033 的 Cache，页大小＝ 4KB，相联度＝16 另一种方法：硬件散列变换（不展开） 5.5.3 写操作流水化设置延迟写缓冲器 5.5.4 Cache优化技术总结 [注]：+ 表示对某方面产生有利影响，- 表示不利影响 5.6 主存 存储层次的性价比特征 速度越快，每位价格就越高 容量越大，每位价格就越低 容量越大，速度越慢 寄存器访问（M1），Cache访问（M2），存储器访问（M3），磁盘存储器访问（M4） 名称 寄存器 Cache 主存 磁盘 典型大小 &lt;1KB &lt;16MB &lt;512G &gt;1TB 实现技术 定制多端口存储器，CMOS 片上或片外CMOS SRAM CMOS DRAM 磁介质盘 访问时间（ns） 0.25-0.5 0.5-25 50-250 5,000,000 带宽（MB&#x2F;s） 50,000-500,000 5000-20,000 2500-10,000 50-500 管理 编译器 硬件 操作系统 操作系统和用户 后备 Cache 主存 磁盘 CD或磁带 主存的主要性能指标：延迟和带宽 以往：Cache 主要关心延迟，I&#x2F;O 主要关心带宽 现在：Cache 关心两者 本节讨论几种提高主存性能的存储器组织技术在下面的讨论中，以处理 Cache 失效为开销例来说明各种存储器组织结构的好处。 为了减少失效开销 $T_M$，应该： 减少主存延迟 提高主存带宽 增加 Cache 块大小能利用主存带宽增加所来的好处 &#x3D;&#x3D;假设基本存储器结构性能为：&#x3D;&#x3D; 送地址需要 4 个时钟周期 每个字的访问时间为 24 个时钟周期 传送一个字的数据需要 4 个时钟周期 如果 Cache 大小为 4 个字，则：失效开销为4*(4+24+4)&#x3D;128 时钟周期 带宽 &#x3D; 16 &#x2F; 128 &#x3D; 0.0125(字节&#x2F;时钟周期) 5.6.1 存储器组织技术1. 增加存储器的宽度 性能分析（按照之前的假设） 当宽度为 4 个字时，失效开销为 1 * 32 &#x3D; 32 时钟周期，带宽 &#x3D; 0.5 (字节&#x2F;时钟周期) 缺点 增加 CPU 和存储器之间的连接通路宽度 CPU 和 Cache 之间有一个多路选择器，增加了硬件开销，使得在关键路径上的时间开销增加 扩充主存的最小增量增加了相应的倍数 写入有可能变得复杂 实例： DEC 的 Alpha Axp21064 ：256 位宽 2. 采用简单的多体交叉存储器 在多体交叉存储器中，存储系统采用多个 DRAM，利用他们潜在的并行性，他们可以同时工作，但是向 Cache 传送数据的通路不变，是比较窄的，只有一个送地址部件 高位交叉与低位交叉编址 低位交叉编址 能够很好的利用其并行性 高位交叉编址 无法利用其并行性 那么如何充分发挥多体交叉的并行性呢？ 1. 同时启动 前提：要取的存储体内的字必须是同一个偏移地址 2. 分时启动 性能分析（参照之前的假设） 失效开销 &#x3D; 4 + 24 + 4 * 4 &#x3D; 44 时钟周期（低位交叉编址 4 个字可同时取出，但是写进 Cache 还是要按字节写入，因为存储体和 Cache 之间的总线宽度仍然是一个字） 带宽 &#x3D; 0.4 （字节&#x2F;时钟周期） 存储器的各个体一般是按照字交叉，低位字交叉存储器非常适合处理 Cache 读失效，写回法 Cache 中的写回 例 5.14假设某台机器的特性及其 Cache 的性能为：· 块大小为 1 个字· 存储器总线宽度为 1 个字（32 位）· Cache 失效率为 3 %· 平均每条指令访存 1.2 次· Cache 失效开销为 32 个时钟周期 (和上面相同)· 平均 CPI(忽略 Cache 失效) 为 2试问多体交叉和增加存储器宽度对提高性能各有何作用？ 如果当把 Cache 块大小变为 2 个字时，失效率降为 2%；块大小变为 4 个字时，失效率降为 1%。根据 5.6.2 小节中给出的访问时间，求在采用 2 路、4 路多体交叉存取以及将存储器和总线宽度增加一倍时，性能分别提高多少？ [分析] 在改变前的机器中，Cache 块大小为一个字，其 CPI 为：2 + (1.2 * 3% * 32) &#x3D; 3.15 将块大小增加为 2 个字时，在下面三种情况下的 CPI 分别为 32 位总线和存储器，不采用多体交叉 CPI &#x3D; 2 + (1.2 * 2% * 2 * 32) &#x3D; 3.54 （公式里的 *2 是因为 32 位总线和存储器传送 2 个字失效时需要传送两次） 32 位总线和存储器，采用多体交叉 CPI &#x3D; 2 + (1.2 * 2% * (4 + 24 + 8)) &#x3D; 2.86（多体交叉传送地址需要 4 个周期，数据取出来要 24 个周期，总线宽度只有一个字，传送一个字要 4 个时钟周期，传送两个字则是 8 个时钟周期） 性能提高了 10% 64 位总线和存储器，不采用多体交叉 CPI &#x3D; 2 + (1.2 * 2% * 1 * (4 + 24 + 4)) &#x3D; 2.77（64 字节为两个字，读一次即可，故失效开销为 32 个时钟周期）性能提高了14% 如果将块大小增加到 4 个字，则： 32 位总线和存储器，不采用多体交叉 CPI &#x3D; 2 + (1.2 * 1% * 4 * 32) &#x3D; 3.54 （传送四次） 32 位总线和存储器，采用多体交叉 CPI &#x3D; 2 + (1.2 * 1% * (4 + 24 + 16)) &#x3D; 2.53（多体交叉传送地址需要 4 个周期，数据取出来要 24 个周期，总线宽度只有一个字，传送一个字要 4 个时钟周期，传送四个字则是 16 个时钟周期） 性能提高了 25% 64 位总线和存储器，不采用多体交叉 CPI &#x3D; 2 + (1.2 * 1% * 2 * (4 + 24 + 4)) &#x3D; 2.77（64 字节为两个字，读两次，每次失效开销为 32 个时钟周期）性能提高了14% 在采用简单的多体交叉存储器时，体的数目 ≥ 访问体中一个字所需的时钟周期 3. 独立存储体设置多个存储控制器，使多个体能独立操作，以便能同时进行多个独立的访存 每个体有独立的地址线 非阻塞 Cache 与多体结构 Cache 失效时仍允许 CPU 进行其它的访存。这样的设计对于独立多体结构才有意义 IO 访存 体和超体 5.6.2 存储器芯片技术1. DRAM 与 SRAM 容量： 4～8:1 存储周期： 8～16:1 价格： 1：8～16 一般来说：主存一般是DRAM，Cache一般是SRAM Amdahl 经验规则： 为了保持系统平衡，存储容量应随 CPU 速度的提高而线性增加。（每 3 年增加 4 倍） 各代 DRAM 的典型参数 DIMM(dual inline memory modules) 多个 DRAM 芯片经常被组装在称为条的小型板上，构成“双列直插式存储模块”。 一个 DIMM 通常包含 4~16 片 DRAM 芯片，这些芯片常被组织成 8 字节宽的主存(带 ECC 校验) 2. DRAM 芯片优化技术 芯片内部优化技术是提高主存系统性能的一个重要方面 快页模式：内部缓冲一行的数据以便进行列访问 SDRAM : Synchronous DRAM，DRAM 接口增加一个时钟信号可使 DRAM 能针对一个请求连续同步地传输多个数据而不需同步开销 DDR(Double Data Rate，双数据率)：在 DRAM 时钟的上沿和下沿都进行数据传输，可把数据传输率提高一倍。现代 DRAM 的名称和性能 总结： DDR 技术规定的标准电压为 2.5V ， DDR2 技术的电压将为 1.8V ，工作频率范围为 266MHz~400MHz，DDR3 的电压将为 1.5V，最大工作频率为 800MHz 存储器优化技术都是通过增加少量逻辑来开发 DRAM 内部潜在的高带宽，这种优化代价很小，却能使带宽显著提高 5.7 虚拟存储器……系统被设计成将主存储器和后备存储器组合在一起，在程序员看来好像只有一级存储，必须进行的地址变换是自动完成的。——Kilburn et al.(1962) 5.7.1 虚拟存储器基本原理虚存系统： 由价格较贵、速度较快、容量较小的主存储器 M1 和一个价格低廉、速度较慢、容量很大的辅助存储器 M2(通常是硬盘)组成 在系统软件和辅助硬件的管理下，就象一个单一的、可直接访问的大容量主存储器 程序员可以用机器指令的地址码对整个程序统一编址，就如同应用程序员具有对应于这个地址码宽度的存储空间(称为程序空间)一样，而不必考虑实际主存空间的大小 1. 虚拟存储器的特点 程序员可以利用巨大的逻辑空间，而不必做存储管理工作 多个进程可以共享主存空间 采用动态重定位，简化了程序的装入 2. 虚存管理方式分两类：页式和段式 页式虚存把空间划分为大小相同的块，称为页面。常用页大小为 4KB～64KB。 段式虚存把空间划分为可变长的块，称为段。段最小长度为 1 个字节，最大因机器而异，常为 $2^{16}B～2^{32}B$。 页面是对空间的机械划分，而段则往往是按程序的逻辑意义进行划分 采用页式虚存还是段式虚存对 CPU 有不同的影响 页式虚存：地址是单一、固定长度的地址字，由页号和页内位移两部分组成 段式虚存：地址需要用两个字表示，一个为段号，另一个为段内位移。因为段的长度是可变的 段页式：每段被划分成若干个页面。既保持了段作为逻辑单位的优点，又简化了替换的实现，而且段不必作为整体全部一次调入主存，而是可以以页面为单位部分调入 3. 存储层次中 Cache 和虚存的对比 虚存处于“主存—辅存”层次 与“ cache——主存”层次的相似点 都是分块方式： Cache 块、页、段 都有失效问题： Cache 块失效、页故障、地址故障 与“cache——主存”层次的不同点 失效替换：Cache 由硬件完成，虚存主要由 OS 处理器地址大小决定虚存大小，但与 Cache 大小无关 辅存除用做主存的后备存储器外，还用于文件系统 4. 存储层次中 Cache 和虚存的典型指标 5. 有关虚拟存储器的四个问题 映像规则 全相联。以降低失效率为主要目标，不在关键路径上，因此降低命中时间没那么重要了 查找算法 页表，段表，TLB 页表和段表：索引页号或段号的数据结构，含有所要查找的块的物理地址。 段式系统：段内位移加上段的物理地址就是最终的物理地址。 页式系统：只需简单地将页内位移拼接在相应页面的物理地址之后 替换算法 LRU。尽可能减少页故障，OS 为每个页面设置“使用位” 写策略 写回法 （具体例子和相关图片就不放了，计组和 OS 里面重点中的重点） 5.7.2 快表 TLB TLB （ Table Look-aside buffer ） TLB 是一个专用的高速缓冲器，用于存放近期经常使用的页表项 TLB 中的内容是页表部分内容的一个副本 TLB 也利用了局部性原理 Alpha Axp 21064 的地址转换过程 TLB 一般比 Cache 的标识存储器更小、更快 5.8 进程保护和虚存实例进程：程序呼吸所需的空气和生存的空间 5.8.1 进程保护1. 界地址寄存器基地址，上界地址检测条件：（基地址 + 地址）≤上界地址2. 虚拟存储器给每个页面增加访问权限标识3. 环形保护4. 加锁和解锁 5.8.2 页式虚存举例Alpha Axp 的存储管理和 21064 的 TLBAlpha Axp 体系结构采用段页相结合的方式 1. Alpha 的地址空间分为 3 段kseg(地址最高两位：10) (内核)sego(最高位：0) (用户)seg1(最高两位：11) (用户) 2. Alpha 采用三级页表 3. Alpha 的页表项（PTE，8 字节） 4. Alpha Axp21064 TLB 的参数 块大小：1 PTE（8字节） 命中时间：1 个时钟周期 平均失效开销：20 个时钟周期 TLB 容量 指令 TLB：8 个 PTE 用于大小为 8K 字节的页，4 个 PTE 用于大小为 4MB 的页（共 96 字节） 数据 TLB：32 个 PTE 用于大小为 8KB ，512KB 和 4MB 的页（共 256 字节） 块替换策略：随机 写策略：不适用 块映像策略：全相联","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"体系结构","slug":"课程笔记/体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"体系结构","slug":"体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"计算机体系结构课程笔记（二)","slug":"计算机体系结构课程笔记（二）","date":"2022-01-11T00:53:38.000Z","updated":"2023-08-08T12:35:27.493Z","comments":true,"path":"1f2e7710.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/1f2e7710.html","excerpt":"第四章 指令集并行 国防科大计算机体系结构课程第四章笔记","text":"第四章 指令集并行 国防科大计算机体系结构课程第四章笔记 4.1 指令集并行的概念 当指令之间不存在相关时，它们在流水线中是可以重叠起来并行执行的。这种指令序列中存在的潜在并行性称为指令级并行 Instruction-Level Parallelism 简记为 ILP 如何知道指令之间可以并行？硬、软件如何支持指令级并行？如何研究这些问题？ 硬件技术或者软件技术都可以提高指令级并行性 必须要硬件技术和软件技术互相配合，才能够最大限度地挖掘出程序中存在的指令级并行性能评价：CPI计算 流水线处理器的实际CPI（平均每条指令使用的周期数）等于理想流水线的CPI加上各类停顿引起的周期数的总和CPI流水线 &#x3D; CPI理想 + 停顿结构相关 + 停顿先写后读 + 停顿先读后写 + 停顿写后写 + 停顿控制相关 减少其中的任何一种停顿，都可以有效地减少CPI，从而提高流水线的性能 软件和硬件的支持 上述技术中有些技术主要是硬件支持 循环展开 寄存器换名的动态调度（基本的Tomasulo’s） 动态分支指令预测 每个周期多发射 前瞻技术 所有的技术都必须和软件，特别是编译器合作完成 几个基本概念 基本（程序）块：一段除了入口和出口以外不包含其它分支的线性代码段 程序平均每6~7条指令就会有一个分支 必须在多个基本块之间开发指令级的并行性 循环级并行：循环体中指令之间的并行性 开发循环级并行的基本技术方法 指令调度（scheduling） 循环展开（loop unrolling） 换名（renaming） 4.1.1 循环展开调度的基本方法 循环展开是展开循环体若干次，将循环级并行转化为指令级并行的技术 这个过程既可以通过编译器静态完成，也可以通过硬件动态进行 开发循环级并行性的另外一个重要技术是向量处理技术 具有向量处理指令的典型机器是向量计算机，有关向量处理和向量计算机的内容本章不作讨论 本章中的分支指令就是指条件转移指令 本章通用浮点流水线延迟表 编译器在完成这种指令调度时，受限于以下两个特性 一是程序固有的指令级并行性 二是流水线功能部件的执行延迟 本章中使用的浮点流水线的延迟如下表 流水线其他特性说明 整数流水线采用改进的 MIPS 整数流水线 由于数据的取操作的结果可以毫无停顿的通过相关通路机制传送到数据存部件，所以延迟为 0 定向通道或旁路机制 分支指令，由整数流水线执行 分支条件检测调整到 ID 段 如果分支指令使用上一条指令的结果作为分支条件，将要延迟 1 节拍 分支指令有 1 个节拍的延迟槽 浮点运算一般为 64 位 无结构冒险 循环展开实例 对于下面的源代码，在不进行指令调度和进行指令调度两种情况下，分析代码一次循环的执行时间12for (i = 1; i &lt;= 1000; i++) x[i] = x[i] + s; 编译过程 每一遍循环之间是不存在相关的 多遍循环可以同时执行而不会导致结果的错误 变量分配寄存器 整数寄存器 R1 用作循环计数器，初值为向量中最高端地址元素的地址 浮点寄存器 F2 用于保存常数 S 为简单起见，假定最低端元素的地址为8 否则需要另外的指令来将它和R1做比较 MIPS汇编语言程序程序转换成MIPS汇编语言程序 12345Loop: LD F0, 0(R1) ;F0为向量元素 ADDD F4, F0, F2 ;加常数F2 SD 0(R1), F4 ;保存结果 SUBI R1, R1, #8 ;修改指针 BNEZ R1, Loop ;循环控制 硬件给编译器更大的空间和支持。编译器用寄存器来进行表达式计算、传递参数、存放变量。 循环无调度执行结果分析- 每遍循环需要10个时钟节拍- 只有3个时钟节拍(L.D, ADD.D, S.D)是有效的关键指令 - 有效比率为 30% - 空转5个时钟节拍 (50%) - 循环控制2个时钟节拍 (20%)- 调度代码，减少空转 经过调度后，一次循环仅需 6 个时钟周期便可以完成。 如何进行调度 通过一个好的编译器来调度可以 调换 SUBI 和 SD 的位置 将 SD 指令移到 BNEZ 的延迟槽内 改变 SD 存取指令访问内存地址的偏移量 调度代码结果分析 每遍循环 6 个时钟节拍 和未调度代码比较，加速比 $10&#x2F;6&#x3D;1.7$ 3个有效时钟节拍 (L.D, ADD.D, S.D) 节拍有效比率 50% 1拍空转 (占17%) 2拍循环控制 (占33%) 如何进一步减少空转和循环控制占用的比率? 循环展开如果将循环展开3次得到4个循环体(假设向量包含了4的倍数的元素) 1234567891011121314Loop: L.D F0,0(R1) ADD.D F4,F0,F2 S.D 0(R1),F4 L.D F6,-8(R1) ADD.D F8,F6,F2 S.D -8(R1), F8 L.D F10,-16(R1) ADD.D F12,F10,F2 S.D -16(R1), F12 L.D F14,-24(R1) ADD.D F16,F14,F2 S.D -24(R1), F16 DADDUI R1,R1,#-32 BNE R1,R2,Loop 执行时间分析 123456789101112131415Loop: L.D F0,0(R1) 1 ADD.D F4,F0,F2 2,3 S.D 0(R1),F4 4,5,6 L.D F6,-8(R1) 7 ADD.D F8,F6,F2 8,9 S.D -8(R1), F8 10,11,12 L.D F10,-16(R1) 13 ADD.D F12,F10,F2 14,15 S.D -16(R1), F12 16,17,18 L.D F14,-24(R1) 19 ADD.D F16,F14,F2 20,21 S.D -24(R1), F16 22,23,24 DADDUI R1,R1,#-32 25 BNE R1,R2,Loop 26,27 stall 28 结果分析 循环使用 28 个时钟节拍 14 个空转节拍 每个 L.D 有 1 个空转节拍 – 共 4 拍 每个 ADD.D 有 2 个空转节拍 - 共 8 拍 DADDUI 有 1 个空转节拍 - 共1拍 BRANCH 有 1 个空转节拍 - 共1拍 有 14 个指令流出节拍 每遍循环 7 个时钟节拍 共计使用 9 个寄存器 代码量增大 循环展开+指令调度1234567891011121314Loop: L.D F0, 0(R1) L.D F6, -8(R1) L.D F10, -16(R1) L.D F14, -24(R1) ADD.D F4, F0, F2 ADD.D F8, F6, F2 ADD.D F12, F10, F2 ADD.D F16, F14, F2 S.D 0(R1), F4 S.D -8(R1), F8 DADDUI R1,R1, #-32 S.D 16(R1), F12 BNE R1, R2, Loop S.D 8(R1), F16 “循环展开+指令调度”结果分析 每遍循环时间下降为14个时钟节拍 每个元素平均使用3.5个时钟节拍 比较 循环展开，没有指令调度 每个元素7拍 没有循环展开，有指令调度 每个元素6拍 循环展开总结 对指令进行移动是有效的 展开是有用的 用不同的寄存器 换名 更多的寄存器 消除额外的测试开销 在循环展开时分析 LOAD&#x2F;STORE 指令进行内存地址换名（动态地址具有不确定性，必须完全算出地址才能继续执行下面的代码，无法像静态地址那样可以预测） 保留真相关 不规整？ 4.2 指令的动态调度 编译器本质上通过对每个循环迭代中寄存器重命名来展开循环 硬件也可通过寄存器重命名和乱序执行来获得同样的效果 动态调度 记分牌 Tomasulo’s 算法 4.2.1 冒险的检测和调度 如果存在数据相关，硬件检测机制会做如下的事情直到相关消除动态调度 暂停指令 停止取指令和发射指令 静态调度（开始于60s，流行于80s）消除动态调度 软件来负责调度指令减少空转 动态调度 硬件对指令的执行重新排序来减少空转 动态调度 动态调度的目的 在程序执行的时候，解决WAW,WAR和RAW带来的冒险 优点： 处理在编译的时候未知的相关，简化编译器 在不同的流水线上都能有效的运行 缺点： 很大地增加了硬件的复杂性 两个动态调度技术 记分牌 Tomasulo 算法 4.2.2 记分牌算法 记分牌 1964 被 Cray 用于 CDC 6600 记分牌允许指令乱序执行，前提： 充足的资源，无数据相关 记分牌动态解决了写后读（RAW）相关 指令可以乱序执行 基本原理 每条指令均经过记分牌，记录各指令间数据相关的信息 如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从而决定何时能够执行 记分牌处理 流水线 ID 段被分为两级 流出——解析指令，检查结构相关 读操作数——直到不存在数据相关时，才读取操作数 如果存在 WAR 或者 WAW 相关，记分牌会暂停这条指令的执行，直到相关消除后才继续执行 记分牌执行过程 流出（Issue） 本指令所需的功能部件有空闲 正在执行指令使用的目的寄存器与本指令不同 保证 WAW 相关 读操作数（Read operands） 前面已流出的还在运行的指令不对本指令的源操作数寄存器进行写操作 一个正在工作的功能部件已经完成了对这个寄存器的写操作 动态解决 RAW 相关 前面两步完成了原来ID段的功能 执行（Execution） 开始于取到操作数后 当结果产生后，修改记分牌 FP 流水部件会占用多个周期 写结果（Write result）：检查 WAR 相关 出现以下情况时，不允许指令写结果： 前面的某条指令还没有读取操作数 其中某个源操作数寄存器与本指令的目的寄存器相同 记分牌结构 功能部件状态表 记录每条指令的功能状态，包括指令类型，使用的功能部件、寄存器，结束时间以及谁将使用该条指令的数据等 用9个域来记录每个功能部件的状态 Busy：指示功能部件是否工作 Op：功能部件当前执行的操作 Fi：目的寄存器编号 Fj，Fk：源寄存器编号 Qj，Qk：向Rj，Rk中写结果的功能部件 Rj，Rk：标示Fj，Fk是否就绪，是否已经被使用 程序实例 指令序列如下：123456LD F6, 34(R2)LD F2, 45(R3)MULTD F0, F2, F4SUBD F8, F6, F2DIVD F10, F0, F6ADDD F6, F8, F2 浮点部件执行时间延迟 加（减）法2拍 乘法 10 拍 除法 40 拍 [Cycle 1] 第一条指令 LD 是访存指令，使用整型功能部件，目的寄存器为 R2，Fk 标记为准备好 [Cycle 2] 第二条指令也是 LD，也是使用整型功能部件，因此无法流出 [Cycle 3] 因为第二条 LD 指令不能流出，因此第三条指令 MULTD 也无法流出 [Cycle 4] 第四个时钟周期后，我们可以得到第一条指令的结果，于是要将第一条指令的整数部件释放掉，将结果写回到 F6 中 [Cycle 5] 第五拍时流出第二条 LD 指令，他使用整数部件，因此 F2 是整数部件作为目标寄存器在使用，查询 R3 有效，并且这条指令占用了目标寄存器 F2。 [Cycle 6] 第六个时钟周期时，乘法功能部件空闲，因此第三条乘法指令 MULTD 可以流出。 然后标记 F2 和 F4 为两个源操作数，但是第一个操作数为立即数，因此标记 F2 为整数功能部件。因为整数功能部件目前正在被使用，因此 F2 的数据没有就绪。 [Cycle 7] 该节拍中，目标地址生成，R3 不再使用，因此把 R3 的标识符设置为空闲（No）。 同时第三条指令 MULTD 的 F2 整数部分还未拿到（整数功能部件还未就绪），因此无法继续执行。 减法使用加法部件（空闲），因此将 Add 标志送给 F8，表示 F8 作为 Add 功能部件的目的寄存器使用，查询 F6，F2 可得，F6 已就绪，F2 使用整数部件，未就绪。 [Cycle 8a（前半拍）] 前半拍时，第二条 LD 指令的结果被读出，即将要写入 F2，但是不能立即就被等待整数功能部件的两个寄存器使用，只有到后半拍的时候才能被供给使用 [Cycle 8b（后半拍）] 前半拍实际上是读 LD 的结果，后半拍将结果写进去 这样第三条和第四条指令的四个源操作数便都就绪了，整数部件使用的目的操作数 F2 也就绪了 第五条除法指令 DIVD 经检查也可以流出：除法部件空闲，目的寄存器为 F10，因此将 F10 打上 Divide 功能部件的标志 使用的两个源操作数 F0被乘法功能部件使用，未就绪，F6 就绪 [Cycle 9] 第三条乘法指令和第四条减法指令的四个操作数都就绪，根据之前的约定，这两条指令可以同时启动 前面约定，乘法指令将使用 10 拍完成，加减法指令使用 2 拍完成，将这两个设置计数器倒计时 第六条加法指令使用加法部件，而加法部件此时正在被减法指令（SUBD）使用 [Cycle 10] 第六条加法指令仍然不能流出，乘法和减法指令执行一拍 [Cycle 11] 在第 11 个时钟周期，乘法和减法指令会被执行两拍，减法指令执行完毕 无其他需要使用 F8 寄存器的指令 [Cycle 12] 减法指令将结果写回 F8 寄存器 [Cycle 13] 流出第六条加法（ADDD）指令，使用 F6 作为目标寄存器，因此将 F6 打上加法（Add）功能部件的标志 F8，F2 都可以就绪 [Cycle 14] 启动加法指令执行，需要两个时钟周期 [Cycle 15] 加法指令还剩一拍，乘法指令计数器还剩 4 拍 [Cycle 16] 求得加法指令结果 [Cycle 17] 这时能否将 F6 写回？需要判断是否有读后写相关 需要扫描所有源寄存器（源记录）阵列，扫描发现在除法指令中 F6 寄存器已就绪，说明还没有被读走，因此该加法指令不能写入 F6，需等待除法指令读取完 F6 后才能写入 该指令存在读后写相关，被阻塞在原地 [Cycle 18] 乘法指令还剩一拍 [Cycle 19] 乘法指令执行完 [Cycle 20] 释放掉 F0，除法指令的源操作数使用的 F0 寄存器就绪 除法指令继续启动 [Cycle 21] 除法指令计数器从 40 开始计数 [Cycle 22] 源寄存器 F6 读完，取消就绪态，加法指令可以写 F6 寄存器 [Cycle 61] 经过 40 个节拍，除法指令执行完毕 [Cycle 62] 将结果写入 F10 寄存器 记分牌最终状态 观察最后的结果，我们发现指令流出是顺序的，读操作数和执行是乱序的，结果写回也是乱序的 指令乱序执行，指令乱序写回 开销和性能提升 CDC6600 |性能提升|编码方式||——-|——| |1.7|FORTRAN||2.5|手工汇编| Condition（CDC6600记分牌） 无软件流水调度 无主存储器 无 Cache CDC6600 上的记分牌的逻辑电路相当于一个功能部件，器件的耗费是非常低的 但是记分牌需要和每个功能部件进行连线，有了记分牌之后的连线是原来的 4 倍 4.2.3 Tomasulo 算法 IBM 360&#x2F;91比 CDC6600 晚三年推出 商业计算机使用 Cache 技术之前 整个 360 系列仅一个指令系统和一个编译器 要求具有很高的浮点性能，但不是通过高端机器的专用的编译器实现 只有四个双精度浮点寄存器，编译器调度的有效性受到很大限制 访存时间和浮点计算时间都很长 可支持循环的多次迭代重叠执行 Tomasulo 算法与记分牌 采用了许多记分牌中的理念 两个较大的差异 Tomasulo 算法中，冲突检测和执行控制是分布的，利用保留站实现 Tomasulo 算法不检查 WAR 和 WAW 相关，他们通过算法本身消除掉了 在MIPS上实现算法 360&#x2F;91 浮点功能单元 3个加法单元 2个乘法单元 6个读单元 3个写单元 MIPS和360&#x2F;91浮点单元的区别 360&#x2F;91: 支持寄存器-存储器指令 360&#x2F;91: 采用流水化功能单元，不采用多个功能单元 每个功能单元都有保留站：缓冲 可以看到，结构中有一个指令队列，指令从队列中流出到各个功能部件，有四个浮点寄存器，三个加法部件，两个乘法部件，三个 store 部件，六个 load 部件 但是只有一个加法器和三个缓冲器，一个乘法器和两个缓冲器，这三个加法缓冲器和两个乘法缓冲器加起来叫保留站（Reservation Station），对于指令队列来说，流出队列并且进入加法器的指令可以有三条，这就相当于有三个加法器，同理，相当于有两个乘法器，三个 store 部件和六个 load 部件 这些缓冲器又称为虚拟功能部件，这样做是为了有更多的部件供请求队列使用 Tomasulo 浮点单元具体执行流程 一条指令流出后，可能是加法或其他类型的指令，该指令将被分配到相应的功能部件，指令开始进入执行阶段 在每一个保留站中，便会记录该指令的操作类型（加法还是减法等）以及两个源操作数，这两个源操作数将从浮点寄存器中读取，如果就绪则成功读取，若没有就绪，则记录谁将产生这个操作数 一旦获得了操作数或者知道了将从哪儿产生这个操作数后，该寄存器对于该部件便没有意义了，相当于将其释放了 操作数从其他部件或从自己部件的保留站中产生，实际上完成了一个指针的调整，记录了一个指针等待这个数据从什么地方过来 当两个操作数都成功得到后，该指令便会被流入到功能部件进行运算，运算完成后将结果送入一条总线上，这个总线叫公共数据总线，该总线是 Tomasulo 算法的枢纽 将数据放入公共数据总线后，所有需要该数据的地方将同时获得该数据，包括保留站和寄存器，供下一条指令使用 获得两个操作数的指令便可以接着执行，相关的检测是在保留站中执行的，没有一个统一的控制电路 数据指针的调整使得寄存器完成了一次换名操作，&#x3D;&#x3D;由原来的寄存器读数，变成从产生数据的源部件取数&#x3D;&#x3D; MIPS五阶段的流水线的改造 ID和EX阶段被以下三个阶段代替1、流出（Issue）2、执行（Execute）3、结果写回（Write result） 流出（Issue） 从浮点指令队列中取出一条指令 如果存在一个空的保留站，就流出这条指令 如果操作数在寄存器中，就送到该指令对应的保留站 存储器取&#x2F;存指令只要有空闲的缓存就可以流出 如果没有空闲的保留站或者缓存，就存在结构相关，指令暂停，直到有空闲的保留站或者缓存 执行 如果缺少一个或者多个操作数，就监听 CDB这个阶段实际是检测和自动维护 RAW 相关 如果两个操作数都就绪，这条指令就可以执行 结果写回（Write result） 如果结果已经产生，将其写到 CDB 上 通过 CDB，把这个结果写到目标寄存器和等待这个结果的所有功能单元的保留站 保留站的六个域 Op：对源操作数 S1 和 S2 进行的操作 Qj, Qk：产生本条指令所需要的源操作数的保留站 如果值为 0，意味着源操作已经就绪 Vj, Vk：源操作数的值 V 域和 Q 域不同时有效，表示一旦获得源操作数的值或者获得源操作数的来源，则寄存器便失效 Busy：这个保留站被占用了 寄存器文件和存缓冲都有 Qi 域 Qi：保留站的编号 编号所对应产生结果的保留站 如果 Qi 为空，就是当前没有指令的结果要写到这个寄存器或者缓冲 Load 缓冲和 Store 缓冲都有 busy 位 地址域 Store缓冲还有 V 域 $\\sum$ 程序实例用以下指令序列来说明 Tomasulo 算法原理同记分牌算法的指令系列 123456LD F6, 34(R2)LD F2, 45(R3)MULTD F0, F2, F4SUBD F8, F6, F2DIVD F10, F0, F6ADDD F6, F8, F2 假设： 加法指令需要 2 个时钟周期 乘法指令需要 10 个时钟周期 除法指令需要 40 个时钟周期 数据相关 三个 RAW 相关（真数据相关） 第二个 LD 与 MULTD 和 SUBD 从 MULTD 到 DIVD 从 SUBD 到 ADDD 名相关 DIVD 和 ADDD 之间的 WAR 相关（反相关） Tomasulo 中通过硬件遍历搜索当前指令的目的寄存器是否和之前指令的源操作数寄存器相同，从而避免读后写相关 第一条 LD 和 ADDD 之间的 WAW 相关（输出相关） 举例 有三个 Add 保留站，两个 Multi 保留站 三个 Load 缓冲 [Cycle 1] 第一条 LD 指令可以流出，使用一个 Load 功能部件 [Cycle 2] Load 功能部件还有剩余，并且使用 F2 作为目标寄存器，因此可以流出，并在 F2 上打上 Load2 标志 第一条 LD 指令进行地址相加计算，进行访存（？） [Cycle 3] 第三条指令 MULTD 使用一个乘法保留站，目的寄存器为 F0，将 F0 打上 Mult1 标志 检查两个源寄存器 F2 和 F4，F2 未就绪，记录 F2 被 Load1 使用 F4 就绪 MULTD 进入等待状态 第一条 LD 指令进入地址计算阶段 [Cycle 4] 第一条 LD 指令结果写回，释放 Load1 第二条 LD 指令也进入地址计算阶段 第四条指令 SUBD 是减法指令，使用加法保留站，有空闲单元，可以流出，目的寄存器为 F8，将 F8 打上 Add1 的标志（先判断是否能流出，在将寄存器打上标志） 在第一个加法保留站中记录操作类型为 SUBD 检查目的操作数 F6 和 F2，发现 F2 正在被 Load2 使用，进行标记 F6 来自 LD 指令写回的值，通过 CDB 进行传送，写到所有等待该数据的保留站中，于是 F6 就绪 [Cycle 5] 第二条 LD 指令写回 F2， 通过 CDB 传送给 Mult1 中的 F2，第三条指令 MULTD 的两个操作数就绪，开始执行 第四条 SUBD 指令的 F2 也在等待数据，因此 F2 也要传送给 Add1 保留站，于是该指令两个操作数准备就绪，开始执行 第五条指令 DIVD 使用乘法功能部件，Multi2 空闲，可以流出，目的寄存器 F10 空闲，打上 Mult2 标志 检查源操作数 F0 和 F6，检查 F0，记录正在被 Mult1 使用 F6 准备就绪 对于加法和乘法指令，需要使用局部计数器完成对整个运算的计数，Add1 设置计数器为 2，Mult1 设置计数器为 10 [Cycle 6] Add1 和 Mult1 分别完成一拍的计算，还剩 1 和 9 第六条指令 ADDD 是加法指令，加法保留站有空闲，可以流出 ADDD 目标操作数是 F6，F6 空闲，将 F6 打上 Add2 标签 检查源操作数 F8 和 F2，检查发现 F8 由 Add1 产生结果，未就绪，F2 已就绪 [Cycle 7] 加法保留站 Add1 的计数器为0，表示第四条指令 SUBD 已经完成运算 [Cycle 8] 第八拍时，SUBD 将结果写回 F8，同时写到 CDB 上 检查到 Add2 的一个目的寄存器使用 Add1 输出的结果，因此 Add1 同时将数据通过 CDB 输出到 Add2，ADDD 两个源操作数准备就绪，开始执行，设置计数器为 2 [Cycle 9] Add2 计数器还剩 1，Mult1 计数器还剩 6 [Cycle 10] Add2 计数器为 0，计算完成 [Cycle 11] ADDD 的结果写回 F6，同时送入公共数据总线，除了 Add2，没有其他保留站等待该数据 Mult1 还剩四拍计算完成 [Cycle 12-14]图略，等待 MULTD 计算完成 [Cycle 15] MULTD 计算完成 [Cycle 16] 使用第一个乘法器（Mult1）结果的有两个地方：一个是第二个乘法部件 Mult2，第二个是 F0 寄存器 Mult2 获得 F0 结果后，DIVD 两个寄存器都准备就绪 DIVD 指令开始计算，设置计数器为 40 [Cycle 55] 除法还剩一个节拍 [Cycle 56] 除法执行完成 [Cycle 57] 将结果写回 F10 算法分析 指令流出是顺序的，但是执行结束的顺序是乱序的，写结果的顺序也是乱序的 Tomasulo 算法特点：有序流出，乱序执行，乱序结束 可以将优先获得资源并且可以执行的指令优先结束 Tomasulo算法的优点 分布式硬件冲突检测 利用保留站和缓冲完成寄存器换名，彻底消除 WAW 和 WAR 这两种名相关 如果多个保留站等待同一个操作数，当操作数在 CDB 上广播时，他们可以同时所需的数据 动态调度方法评价 动态方法能够达到很高的性能 主要缺陷 高复杂性：需要大量硬件 存在瓶颈：单个公共数据总线（CDB）引发竞争 额外的 CDB：在每个保留站上需要为每条 CDB 设置重复的硬件接口 现代计算机一般有 3 条 CDB，1 条全局，2 条局部（单独连浮点寄存器和保留站） 4.3 控制相关的动态解决技术 动态分支预测的两个理由 n流出的处理器加速上限为n倍 Amdahl定律提示：在较低CPI机器上，控制相关导致的空转对机器性能影响大 前面解决控制相关的静态策略 需要编译器将一条或多条指令移动到流水线产生的分支延迟槽中 关于分支预测策略的两部分工作 预测的分支是否成功 执行分支目标指令 4.3.1 分支预测缓冲 预测的准确率 分支的开销 预测正确的开销 预测错误的开销 分支预测缓冲(BPB) 最简单的分支预测策略 分支预测缓冲是一个小的存储器阵列 每个单元只有 1 位，记录最近一次分支是否成功的信息 预测位为1则预测分支成功，并从目标位置开始取指令 单元由分支指令地址的低位索引进行寻址 BPB 的预测位会被具有相同低位地址的分支设置 BPB也被称为 BHP（branch history buffer 分支历史缓冲） 1 位 BPB1 位 BPB 状态图 这种单位预测策略有大约 80% 左右的准确率 当分支不成功时，单位预测会连续失败两次 2 位预测策略能够改善这种情况 2 位 BPB2 位 BPB 状态图 在 2 位预测策略中，一个预测必须错误两次才会改变 对于一个 4096 条记录的 BPB，利用 2 位预测策略，用 SPEC89 测试，命中率为 82% 到 99% 准确率最高的测试程序一般包含大量循环 线性代码一般准确率最差 另一种转换图： 4096 单元 2 位 BPB 的预测准确率 测试程序为 SPEC89 整数测试程序: 平均 11% gcc, espresso, eqntott, li 浮点测试程序: 平均 4% nasa7, matrix300, tomcatv 为什么? 因为整数程序线性代码较多 浮点主要用于计算，循环程序更多 n 位 BPB 1 位或 2 位 BPB 是 n 位 BPB 的特殊情况 n 位策略使用计数器，表示 0~2^n^-1 的值 与 2 位策略类似，对于 n 位 BPB，每次分支成功，计数器 +1，反之则 -1 如果计数器值大于其最大值的一半，则做成功预测，反之则做失败预测 4K 个单元的 BPB 和无穷单元的 BPB 最后结果相差无几 BPB 实现 BPB的实现方案 实现一个小而特殊的“cache”，利用指令地址进行索引，在 IF 流水段访问。 或者，为指令 cache 中每一块增加附加位，与指令一起取出 若一个指令在 ID 段被译码为分支指令，且对应的BPB标志位预测其成功，则 一旦 PC 已知，立刻从分支目标位置开始取指 或者，继续顺序取指 4.3.2 分支目标缓冲(BTB) 另一个动态分支预测方法：分支目标缓冲 Branch Target Buffer, BTB 为了减小或消除流水线的分支开销，我们需要在 IF 段结束前知道从哪个地址开始取下一条指令 换句话说，我们在 IF 段就需要知道这条未译码的指令是否为分支指令，并且如果它是分支指令，要尽快知道 NPC 值应当为多少 这个缓冲机制中保存以前分支成功的分支指令的地址，等到下一次在遇到这条指令的时候，当前指令的地址将会和缓冲中保存的分支指令地址进行比较，若相同，则认为当前指令就是曾经执行过的分支成功的指令，因此预测下一次该指令仍然分支成功 BTB 实现 分支目标缓存 BTB 每个单元应该包括 分支指令的地址 分支目标的地址 分支预测标识 取指阶段，所有指令地址都与 BTB 中保存的分支指令的地址做比较，一旦相同，就认为本指令是分支指令，并且分支成功 它的目标地址就是保存在缓冲区中的分支目标地址 取出后直接送入 NPC 执行过程 当前指令的 PC 将和 BTB 中的 PC 值进行遍历比较，如果有相同的项，那么就认为该指令是曾经成功的分支指令，他的分支目标地址放在列&#x3D;&#x3D;分支目标PC&#x3D;&#x3D;中 然后将分支目标PC取出直接放入 PC 寄存器，从该地址取出下一条指令执行 BTB 可以进一步优化，将分支目标指令也存放在缓冲中，加快指令的读取 如果没有命中，则认为他是普通指令，正常执行 若分支预测成功、不是分支指令或者不在 BTB 中且分支不成功，则流水线无延迟 BPB VS. BTB 分支预测技术（BPB）受限于预测精度，以及预测失效后产生的开销，预测精度为 80% 左右 根据不同程序特点以及缓冲区的大小，典型的BTB可以实现 80% 到 95% 的预测精度 降低失效开销技术：在一个时钟周期内同时取出不同分支路径的指令，即把分支成功和失败的指令都取出来 会引入其他开销，比如存储系统的端口加倍 降低失效开销的唯一方法，比如 AS&#x2F;400 PowerPC 处理器，多分支预测技术 分支预测局限性 预测准确性：80%-90% 预测性能依赖于 程序类型 缓冲区大小 预测失效开销的优化 预取不同分支路径指令 存储端口数目加倍,交叉存取缓冲 在目标缓冲中缓冲多个路径的指令 4.4 多指令流出技术 多指令流出处理器 实现一个时钟周期内流出多条指令时 达到 CPI 小于1 多流出处理器 2 种基本结构 超标量（Superscalar） 超标量每个时钟周期流出的指令数不定 可以编译器静态调度，也可以硬件动态调度 超长指令字（VLIW，Very long Instruction Word） 每个时钟周期流出的指令数是固定的，只能通过编译静态调度 4.4.1 超标量处理机 超标量处理机的原型来自于 IBM 实验室的 “America”处理器 RS&#x2F;6000 第一个采用超标量技术 现在，几乎所有高性能处理器都是用该技术 超标量处理机的硬件支持每个时钟周期发出 1-8 条不存在相关的指令 如果指令流中的指令相关或不满足限制条件，则只能流出这条指令前面的指令，因此超标量处理器流出的指令数是不定的 超标量处理器 假设有这样一个简单的超标量处理器，每个时钟周期它可以流出两条指令 一条指令可以是取指令、存指令、分支指令或整数运算操作 另一条指令可以是任意的浮点操作 第一条指令排在第二条指令的前面 这种配置与 HP 7100 结构类似 超标量处理机的理想执行情况 超标量处理机的技术问题 每个时钟周期流出两条指令意味着取指令和解码部件都是64位 假设：指令按要求组合成对，且与 64 位边界对其，整数指令顺序在前 需要使得浮点部件流水化或增加相关部件来减少结构相关 另一个限制超标量流水线性能发挥的障碍是取操作和分支操作的延迟 分支指令肯定是指令组合的第一条指令，影响配对指令和后续两条指令，分支延迟也变为 3 条指令 超标量处理器举例 为了能有效利用超标量处理器的可获得的并行度，需要采用更有效的编译技术、硬件调度技术和更复杂的指令译码技术 循环展开成5个副本 使用先前我们用到的代码作为例子12345LOOP LD F0, 0(R1) ;取出一个向量单元. ADDD F4, F0, F2 ;与F2寄存器中的标量相加 SD 0(R1), F4 ;保存相加后的向量单元 SUBI R1, R1, #8 ;R1寄存器值减8 BNEZ R1, LOOP ;如果R1值不为0，则跳转 超标量：例子执行情况 在超标量流水线上对上述代码进行调度，以获取更多地指令机并行度 超标量：例子结果分析 每次循环需 12 个时钟周期 每个迭代为 2.4 个时钟周期 前面在普通的流水线上，通过循环展开和调度，可以达到每个迭代为 3.5 个时钟周期 超标量可以获得更好地性能，代价是硬件复杂性大幅度增加 4.4.2 超长指令字技术 一台超标量机器每周期能够流出4-8条指令 由于必须要用硬件分析指令间的相关，为其实现带来了困难 另一种选择：长指令字（LIW，Long Instruction Word）或称为超长指令字（VLIW，Very Long Instruction Word）体系结构 第一种商用 LIW 机器是 AP-120B，由 Floating Point Systems 开发 FPS-164 是较新的机器，它的每个指令字含有对应于 10 个不同功能单元的 10 条指令 VLIW基本机构 VLIW 采用多个独立的功能单元，多个不同的操作封装在一条长指令字中，每个功能单元在 VLIW 指令中都有一定的对应区域 一般每个功能单元占用 16-24 位 例如：2个整数、2个浮点、2个访存、1个分支，则该指令的长度为 112-168位 VLIW 硬件只是简单地将指令字中对应的部分送给各个功能单元，功能单元在哪一个时钟周期执行什么操作由编译器来确定 如果某个功能单元在某个周期没有任务，则执行 NOP（空操作）指令 VLIW例子 再次使用先前在解释循环展开及超标量机器时使用过的那段循环代码，来解释VLIW如何工作这一次，我们将循环展开n个副本 VLIW机器每条指令字包含 两个访存操作 两个浮点操作 一个整数或分支操作 得到如下指令序列 5 条结果在 8 个时钟周期中完成计算 每条结果花费 1.3 时钟周期，比超标量性能更高 有 17&#x2F;40 的指令槽被放入了有效的操作，利用率很低 当循环展开为 7 次时： 9 拍产生 7 个结果 每个结果 1.29 拍 比前面的超标量，每个结果 2.4 拍，快接近2倍 9 拍里面执行了 23 个操作 2.5 操作&#x2F;拍 指令槽利用率不高， 只有 51% (23&#x2F;45) 使用大量寄存器 7 个循环，共计使用 2×7+1&#x3D;15 个 64 位浮点寄存器 如果我们想减少循环展开的次数，则至少展开三次才能保证流水线中没有空周期： 8 拍 3 个结果，每个结果 2.66 拍 指令槽利用率: 11&#x2F;40 &#x3D; 27.5% 寄存器：3×2+1&#x3D;7 个 64 位浮点寄存器 如果我们想尽可能充满指令槽，可以展开 10 次： 10 拍 10 个结果，每个结果使用 1 拍 指令槽利用率：36&#x2F;50 &#x3D; 72% 寄存器需求：10×2+1&#x3D;23 个 64 位浮点寄存器 当前 MIPS 只有 16 个 64 位浮点寄存器或 32 个 32 位寄存器，已经超过了要求 VLIW的技术难题 第一，从线性代码片段中产生足够的操作需要进行激进的循环展开，这增大了代码大小 第二，无论指令是否被充满，没有被使用的功能单元也在指令字编码过程中占据了相应的位，也就是说将近一半的指令槽是被浪费掉的，这不仅浪费运算资源，还占用了大量存储空间 解决方式：在主存中压缩指令，在 cache 中解压缩指令 第三，VLIW 带来了二进制代码兼容性问题 若采用 2 个浮点部件和 3 个浮点部件，将带来二进制指令代码不兼容 采用模拟的方法解决 4.5 第四章指令级并行总结 4.1 指令级并行的概念 循环展开调度的基本方法 解决跨基本块的指令调度 通过寄存器换名技术解决名相关 4.2 指令的动态调度 记分牌 通过硬件解决数据相关 Tomasulo算法 还可以解决控制相关引发的问题 可以很好解决循环展开的问题，由硬件完成寄存器换名，减少空周期 4.3 控制相关的动态解决技术 分支预测缓冲 以较小的存储代价和 1 拍的时间延迟进行分支指令的历史预测，提高机器执行效率 分支目标缓冲 通过保存分支指令和分支目标的地址，实现没有空转周期的分支预测 这两者都是基于历史信息来进行预测的，分支目标缓冲需要更大的存储空间 现在的机器上一般将两者结合使用：使用几十上百个分支目标缓冲和若干 K 个分支预测缓冲 这样可以很好的实现控制相关的动态预测，将失效率降低到 10% 左右 4.4 多指令流出技术 超标量技术 CPI &lt; 1 指令流出一般在 3-6 条 超长指令字技术 依赖编译器的静态多指令流出技术 通用领域技术不够成熟","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"体系结构","slug":"课程笔记/体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"体系结构","slug":"体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"markdown简明语法","slug":"markdown简明语法","date":"2022-01-10T11:52:01.000Z","updated":"2023-08-08T12:35:27.415Z","comments":true,"path":"e1ac91e3.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/e1ac91e3.html","excerpt":"Cmd Markdown 简明语法手册 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。","text":"Cmd Markdown 简明语法手册 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 &#x3D;&#x3D;&#x3D; 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码&#96; 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E&#x3D;mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i&#x3D;1}^n a_i&#x3D;0$$ $$f(x_1,x_x,\\ldots,x_n) &#x3D; x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k&#x3D;0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 13. 定义型列表名词 1定义 1（左侧有一个可见的冒号和四个不可见的空格）代码块 2这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Markdown/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://cherryyang05.github.io/hexo-blog/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"markdown箭头汇总","slug":"markdown箭头汇总","date":"2022-01-06T08:32:31.000Z","updated":"2023-08-08T12:35:27.415Z","comments":true,"path":"be1bf65e.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/be1bf65e.html","excerpt":"Markdown箭头的输入方法汇总普通箭头 箭头形状 MarkDown $\\uparrow$ $\\uparrow$ $\\Uparrow$ $\\Uparrow$ $\\downarrow$ $\\downarrow$ $\\Downarrow$ $\\Downarrow$ $\\leftarrow$ $\\leftarrow$ $\\Leftarrow$ $\\Leftarrow$ $\\rightarrow$ $\\rightarrow$ $\\Rightarrow$ $\\Rightarrow$ $\\updownarrow$ $\\updownarrow$ $\\Updownarrow$ $\\Updownarrow$ $\\leftrightarrow$ $\\leftrightarrow$ $\\Leftrightarrow$ $\\Leftrightarrow$","text":"Markdown箭头的输入方法汇总普通箭头 箭头形状 MarkDown $\\uparrow$ $\\uparrow$ $\\Uparrow$ $\\Uparrow$ $\\downarrow$ $\\downarrow$ $\\Downarrow$ $\\Downarrow$ $\\leftarrow$ $\\leftarrow$ $\\Leftarrow$ $\\Leftarrow$ $\\rightarrow$ $\\rightarrow$ $\\Rightarrow$ $\\Rightarrow$ $\\updownarrow$ $\\updownarrow$ $\\Updownarrow$ $\\Updownarrow$ $\\leftrightarrow$ $\\leftrightarrow$ $\\Leftrightarrow$ $\\Leftrightarrow$ 长箭头 箭头形状 MarkDown $\\longleftarrow$ $\\longleftarrow$ $\\Longleftarrow$ $\\Longleftarrow$ $\\longrightarrow$ $\\longrightarrow$ $\\Longrightarrow$ $\\Longrightarrow$ $\\longleftrightarrow$ $\\longleftrightarrow$ $\\Longleftrightarrow$ $\\Longleftrightarrow$ 其他箭头 箭头形状 MarkDown $\\twoheadrightarrow$ $\\twoheadrightarrow$ $\\rightarrowtail$ $\\rightarrowtail$ $\\looparrowright$ $\\looparrowright$ $\\curvearrowright$ $\\curvearrowright$ $\\circlearrowright$ $\\circlearrowright$ $\\Rsh$ $\\Rsh$ $\\multimap$ $\\multimap$ $\\leftrightsquigarrow$ $\\leftrightsquigarrow$ $\\rightsquigarrow$ $\\rightsquigarrow$ $\\leadsto$ $\\leadsto$ $\\nearrow$ $\\nearrow$ $\\searrow$ $\\searrow$ $\\swarrow$ $\\swarrow$ $\\nwarrow$ $\\nwarrow$ $\\nleftarrow$ $\\nleftarrow$ $\\nLeftarrow$ $\\nLeftarrow$ $\\nrightarrow$ $\\nrightarrow$ $\\nRightarrow$ $\\nRightarrow$ $\\nleftrightarrow$ $\\nleftrightarrow$ $\\nLeftrightarrow$ $\\nLeftrightarrow$ $\\dashrightarrow$ $\\dashrightarrow$ $\\dashleftarrow$ $\\dashleftarrow$ $\\leftleftarrows$ $\\leftleftarrows$ $\\leftrightarrows$ $\\leftrightarrows$ $\\Lleftarrow$ $\\Lleftarrow$ $\\twoheadleftarrow$ $\\twoheadleftarrow$ $\\leftarrowtail$ $\\leftarrowtail$ $\\looparrowleft$ $\\looparrowleft$ $\\curvearrowleft$ $\\curvearrowleft$ 箭头形状 MarkDown $\\circlearrowleft$ $\\circlearrowleft$ $\\Lsh$ $\\Lsh$ $\\mapsto$ $\\mapsto$ $\\hookleftarrow$ $\\hookleftarrow$ $\\hookrightarrow$ $\\hookrightarrow$ $\\upharpoonright$ $\\upharpoonright$ $\\upharpoonleft$ $\\upharpoonleft$ $\\downharpoonright$ $\\downharpoonright$ $\\downharpoonleft$ $\\downharpoonleft$ $\\leftharpoonup$ $\\leftharpoonup$ $\\rightharpoonup$ $\\rightharpoonup$ $\\rightharpoondown$ $\\rightharpoondown$ $\\leftharpoondown$ $\\leftharpoondown$ $\\upuparrows$ $\\upuparrows$ $\\downdownarrows$ $\\downdownarrows$ $\\rightrightarrows$ $\\rightrightarrows$ $\\rightleftarrows$ $\\rightleftarrows$ $\\leftleftarrows$ $\\leftleftarrows$ $\\leftrightarrows$ $\\leftrightarrows$ $\\rightleftharpoons$ $\\rightleftharpoons$ $\\leftrightharpoons$ $\\leftrightharpoons$","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Markdown/"}],"tags":[{"name":"markdown语法","slug":"markdown语法","permalink":"https://cherryyang05.github.io/hexo-blog/tags/markdown%E8%AF%AD%E6%B3%95/"}]},{"title":"实现C语言编译器：二、简单数学表达式的语法分析","slug":"实现C语言编译器：二、简单数学表达式的语法分析","date":"2022-01-06T08:14:27.000Z","updated":"2023-08-08T12:35:27.417Z","comments":true,"path":"f73c25d7.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/f73c25d7.html","excerpt":"二、简单数学表达式的语法分析当前所实现的简易编译器是将一条或一组数学表达式编译成类似汇编语言的代码，因此就要给算术表达式设立一组语法规则，判断是否是合法的算数表达式，那么程序才能对输入的表达式进行分析，我们将一组带有分号的算数表达式称为 statements，例如 1+2*3+4; 41*2;1+2+3+4;，这三个表达式的集合称为 statements，同时将一组表达式中的某一条带有分号的表达式称为 expression，也就是说 statements 是由多个 expression 组成的。 statements 的语法规则可以写成： $statements\\rightarrow expression;|expression;statements$","text":"二、简单数学表达式的语法分析当前所实现的简易编译器是将一条或一组数学表达式编译成类似汇编语言的代码，因此就要给算术表达式设立一组语法规则，判断是否是合法的算数表达式，那么程序才能对输入的表达式进行分析，我们将一组带有分号的算数表达式称为 statements，例如 1+2*3+4; 41*2;1+2+3+4;，这三个表达式的集合称为 statements，同时将一组表达式中的某一条带有分号的表达式称为 expression，也就是说 statements 是由多个 expression 组成的。 statements 的语法规则可以写成： $statements\\rightarrow expression;|expression;statements$ 观察上述表达式，我们发现箭头左边的被解析的对象在右边也出现了，这样便构成了一种循环，在编译原理中称为左循环(LR，Left recursive) 1234statements(buffer) &#123; expression(buffer); statements(buffer); //此处导致循环调用&#125; 其他的语法规则： $$expression \\rightarrow expression + term | term \\term \\rightarrow term * factor | factor\\factor \\rightarrow NUMBER | (expression)$$ 现在我们先记住这些，根据代码先整体理解，在后面的内容中再详细介绍。 回到语法规则上，箭头右边有两种替换规则，那么我们应该选取哪一种进行替换呢？在编译原理中，有一种方法叫做 lookahead，举个例子，对于语法：$statements\\rightarrow expression;|expression;statements$我们按照顺序读取到第一个分号，若下一个字符有意义，那么就选取后者进行解析；如果下一个字符是 EOI，那么说明该表达式已经读完，那么选取前者进行解析。 那么如何解决语法规则中的循环调用呢？我们更改语法规则如下：$1. \\quad statements \\rightarrow 空|expression;statements$$2. \\quad expression \\rightarrow term ,, expression’$$3. \\quad expression \\rightarrow +term ,, expression’ | 空$$4. \\quad term \\rightarrow factor ,, term’$$5. \\quad term’ \\rightarrow *factor ,, term’ | 空$$6. \\quad factor \\rightarrow number | (expression)$ 语法解析树如下：","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"编译器","slug":"编译器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Java","slug":"Java","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Java/"}]},{"title":"实现C语言编译器：一、简单数学表达式的词法分析","slug":"实现C语言编译器：一、简单数学表达式的词法分析","date":"2022-01-06T08:14:06.000Z","updated":"2023-08-08T12:35:27.416Z","comments":true,"path":"19cdc324.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/19cdc324.html","excerpt":"一、简单数学表达式的词法分析","text":"一、简单数学表达式的词法分析","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"编译器","slug":"编译器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Java","slug":"Java","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Java/"}]},{"title":"PTA Basic 部分题解","slug":"PTA-Basic-部分题解","date":"2022-01-01T07:31:48.000Z","updated":"2023-08-08T12:35:27.392Z","comments":true,"path":"a74ee18.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/a74ee18.html","excerpt":"","text":"1025. 反转链表题目链接 这个题目第一眼看上去不知道怎么处理链表结点的地址，以及不知道如何用简便的方法将链表反转过来，如果用常规的设置链表的结构体来逆置链表，会比较麻烦。而且输入的结点并不是按照链表顺序给出的，并且地址是人为设定的，因此用结构体的方法会非常麻烦，因此考虑用数组来存储链表相关地址信息和顺序关系。 并且，翻转链表可以使用algorithm头文件中的reverse函数，会非常简便。 要注意输入的结点可能是一个完整的链表，他可以从中间断开，此时我们只要找到以头结点开始的那个链表就可以了。 完整代码参考了柳婼的代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int first, n, k, temp; int data[100005], next[100005], list[100005]; memset(data, 0, sizeof(data)); memset(list, 0, sizeof(list)); memset(next, 0, sizeof(next)); cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; temp; cin &gt;&gt; data[temp]; cin &gt;&gt; next[temp]; &#125; int sum = 0; //除去断开的链表，获得完整的链表长度 while (first != -1) &#123; list[sum++] = first; first = next[first]; &#125; for (int i = 0; i + k &lt;= sum; i += k) &#123; reverse(begin(list) + i, begin(list) + i + k); &#125; for (int i = 0; i &lt; sum - 1; i++) printf(&quot;%05d %d %05d\\n&quot;, list[i], data[list[i]], list[i + 1]); //注意这里是list[i + 1],一开始写成了next[list[i]] printf(&quot;%05d %d -1\\n&quot;, list[sum - 1], data[list[sum - 1]]); return 0;&#125; 1035. 插入与归并题目链接 分析：先将 i 指向中间序列列中满⾜足从左到右是从⼩小到⼤大顺序的最后⼀一个下标，再将 j 指向从 i+1 开始，第一个不不满⾜足 a[j] == b[j] 的下标，如果 j 顺利利到达了了下标n，说明是插⼊入排序，再下⼀一次的序列列是 sort(a, a+i+2);否则说明是归并排序。归并排序就别考虑中间序列列了了，直接对原来的序列列进⾏行行模拟归并时候的归并过程，i 从0 到 n/k，每次一段段得 sort(a + i * k, a + (i + 1) * k); 最后别忘记还有最后剩余部分的 sort(a + n / k * k, a + n); 这样是一次归并的过程。直到有一次发现a的顺序和b的顺序相同，则再归并一次，然后退出循环 AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int a[105], b[105], n; cin &gt;&gt; n; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); int i = 0, j = 0; for (j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; a[j]; &#125; for (j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; b[j]; &#125; for (i = 0; i &lt; n - 1 &amp;&amp; b[i] &lt;= b[i + 1]; i++); for (j = i + 1; j &lt; n &amp;&amp; a[j] == b[j]; j++); int pow = 2, flag = 0; //标记当前趟是否为目标趟 if (j == n) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(a, a + i + 2); &#125; else &#123; cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl; while (!flag) &#123; flag = 1; //归并 for (i = 0; i &lt; n / pow; i++) &#123; sort(a + i * pow, a + (i + 1) * pow); &#125; sort(a + (n / pow) * pow, a + n); //比较当前趟是否为目标趟 for (i = 0; i &lt; n; i++) &#123; if (a[i] != b[i]) &#123; flag = 0; break; &#125; &#125; pow *= 2; &#125; for (i = 0; i &lt; n / pow; i++) &#123; sort(a + i * pow, a + (i + 1) * pow); &#125; sort(a + (n / pow) * pow, a + n); &#125; cout &lt;&lt; a[0]; for (i = 1; i &lt; n; i++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; a[i]; &#125; return 0;&#125; 1040. 有几个PAT（25) [逻辑题]题目链接 这是一道思维题，要想知道构成多少个PAT，那么遍历字符串串后对于每一A，它前⾯面的P的个数和它后⾯面的T的个数的乘积就是能构成的PAT的个数。然后把对于每一个A的结果相加即可。只需要先遍历字符串串数一数有多少个T，然后每遇到一个T，便countT–-;每遇到一个P呢， countP++;然后一遇到字⺟母A呢就countT * countP，把这个结果累加到result中～～最后输出结果就好啦~~对了了别忘记要对10000000007取余哦～～ 穷举遍历显然会超时～～ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#define M 1000000007using namespace std;int main() &#123; string str; cin &gt;&gt; str; int countP = 0, countA = 0, countT = 0; int res = 0; for (char c : str) &#123; if (c == &#x27;T&#x27;) countT++; &#125; for (char c : str) &#123; if (c == &#x27;T&#x27;) countT--; if (c == &#x27;P&#x27;) countP++; if (c == &#x27;A&#x27;) &#123; res += countP * countT % M; res %= M; &#125; &#125; cout &lt;&lt; res % M &lt;&lt; endl; return 0;&#125;//033510010 1045. 快速排序（25）题目链接 分析：先看数据规模，1e5，如果用穷举，平方之后就是1e10，肯定超时，于是要想其他方法。对原序列sort排序，逐个比较，当当前元素没有变化并且它左边的所有值的最大值都比它小的时候就可以认为它一定是主元（证明正确性：因为无论如何当前这个数要满足左边都比他大右边都比他小，那它的排名【当前数在序列中处在第几个，也就是相对位置】一定不会变） 一开始测试点 2 段错误，后来才想到如果没有主元存在的话，v[0]非法访问，改正后发现格式错误，然后加了句换行才正确。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, cnt = 0, max = 0; vector&lt;int&gt; v; int a[100005], b[100005]; cin &gt;&gt; n; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; memcpy(b, a, sizeof(a)); sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i] &amp;&amp; b[i] &gt; max) &#123; cnt++; v.push_back(b[i]); &#125; if (b[i] &gt; max) &#123; max = b[i]; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; if (v.size() != 0) &#123; sort(v.begin(), v.end()); for (int i = 0; i &lt; v.size() - 1; i++) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; v[v.size() - 1] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; endl; &#125; return 0;&#125; 1049 数列的片段和 (20)题目链接 总结 printf() 和 scanf() 函数：如果输入的是 float 型数据,那么用 %f 来接收；如果输入的是 double 型数据，那么用 %lf 来接收；如果输入的是 long double 型数据，那么用 %llf 来接收。但后来这道题的测试点 2 数据进行了更精细地改动，大概是将 N 改为 10 的 5 次方，此时会用 double 类型数据进行大量的计算，而由于数组中的每个数都小于 1.0，因此很有可能出现 double 小数精度不够用的情况而导致精度丢失，这时候计算出来的结果有可能会有偏差了。 查阅资料后得出以下两种方法： 对每个输入的数据都先乘1000（只能乘以1000，可能乘多了就会导致整数部分精度丢失了，可以把这个结果想象成 63 位的队列，队接近队头部分是整数，接近队尾部分是小数，那么小数位数多了就会从队尾“丢出”丢失了的精度，整数位数多了就会从队头“丢出”丢失了的精度），这样就降低了小数位数，最后再对累加的结果除以之前乘的数字即可。 这个方法就更简单了，每当我们用 int 型发现范围不够的时候会怎么办？难道会先去把这个数除以 1000，再把最后的结果乘以之前除掉的数字吗？当然不会，一般都是把 int 类型改成 long long 类型（为啥不是 long 类型，而是 long long 类型呢，这就涉及到另一个需要记忆的内容了：因为 long int、long、int 这三者都是 4 字节的，一样长，想不到吧？）说了那么多没有用。。。正解就是把 total 的类型改成 long double 就行了，这时候 total 的小数精度范围更大，就能完美解决测试点 2 出现的精度丢失问题。 double 类型占8字节，用 %lf 或 %f 控制输出，long double 一般占 12 字节用 %Le %Lf %Lg 控制输出 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main() &#123; double a[100005]; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; long long c[100005]; memset(c, 0, sizeof(c)); long long cnt = 1; for (int i = 1; i &lt;= n; i++) &#123; c[i] = (long long)i * (n - i + 1); &#125; long double sum = 0.0f; for (int i = 1; i &lt;= n; i++) &#123; sum += a[i] * 1000 * c[i]; &#125; printf(&quot;%.2Lf&quot;, sum / 1000); return 0;&#125; 1095 解码PAT准考证 (25)纯模拟题，细心即可[注]：ios::sync_with_stdio(0);可以加速 cin 和 cout 的输入输出速度，还有 cin.tie(0);。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;int N, M;struct PAT &#123; string NUM, room, date, stuNum; char level; int score; PAT(string _NUM, int _score) : NUM(_NUM), score(_score) &#123; level = _NUM[0]; room = _NUM.substr(1, 3); date = _NUM.substr(4, 6); stuNum = _NUM.substr(10, 3); &#125;&#125;;vector&lt;PAT&gt; p;int cmp(PAT a, PAT b) &#123; if (a.score == b.score) return a.NUM &lt; b.NUM; else return a.score &gt; b.score;&#125;void print_score(int cases, int type, char level) &#123; printf(&quot;Case %d: %d %c\\n&quot;, cases, type, level); int flag = 0; for (int i = 0; i &lt; N; ++i) &#123; if (p[i].level == level) &#123; printf(&quot;%s %d\\n&quot;, p[i].NUM.c_str(), p[i].score); flag = 1; &#125; &#125; if (!flag) printf(&quot;NA\\n&quot;);&#125;void print_room(int cases, int type, string room) &#123; printf(&quot;Case %d: %d %s\\n&quot;, cases, type, room.c_str()); int cnt = 0, sum = 0; for (int i = 0; i &lt; N; ++i) &#123; if (p[i].room == room) &#123; cnt++; sum += p[i].score; &#125; &#125; if (cnt == 0) printf(&quot;NA\\n&quot;); else printf(&quot;%d %d\\n&quot;, cnt, sum);&#125;void print_date(int cases, int type, string date) &#123; printf(&quot;Case %d: %d %s\\n&quot;, cases, type, date.c_str()); unordered_map&lt;string, int&gt; m; for (int i = 0; i &lt; N; ++i) &#123; if (p[i].date == date) &#123; m[p[i].room]++; &#125; &#125; vector&lt;pair&lt;string, int&gt;&gt; room_order(m.begin(), m.end()); sort(room_order.begin(), room_order.end(), [=](pair&lt;string, int&gt; p1, pair&lt;string, int&gt; p2) -&gt; bool &#123; if (p1.second == p2.second) return p1.first &lt; p2.first; else return p1.second &gt; p2.second; &#125;); if (room_order.size() == 0) printf(&quot;NA\\n&quot;); else &#123; for (int i = 0; i &lt; room_order.size(); ++i) &#123; printf(&quot;%s %d\\n&quot;, room_order[i].first.c_str(), room_order[i].second); &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(0); freopen(&quot;in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; N &gt;&gt; M; string s; int score; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; s &gt;&gt; score; p.push_back(PAT(s, score)); &#125; sort(p.begin(), p.end(), cmp); int type; char c; string room, date; for (int i = 0; i &lt; M; ++i) &#123; cin &gt;&gt; type; switch (type) &#123; case 1: cin &gt;&gt; c; print_score(i + 1, type, c); break; case 2: cin &gt;&gt; room; print_room(i + 1, type, room); break; case 3: cin &gt;&gt; date; print_date(i + 1, type, date); break; default: break; &#125; &#125; return 0;&#125; 1099 性感素数 (20)题目链接 这题的主要问题是当给定的数不是 Sexy Prime 时，要找比他大的最小符合条件的数，可以与比他小 6 的组成一对，并不一定是比他大 6 的数组成一对。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int n) &#123; if (n &lt;= 1) return false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;void Judge(int n) &#123; if (isPrime(n)) &#123; if (isPrime(n - 6)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; cout &lt;&lt; n - 6 &lt;&lt; endl; return; &#125; if (isPrime(n + 6)) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; cout &lt;&lt; n + 6 &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; for (int i = n + 1; i &lt;= 1000000000; i++) &#123; if (isPrime(i) &amp;&amp; isPrime(i + 6) || isPrime(i) &amp;&amp; isPrime(i - 6)) &#123; cout &lt;&lt; i &lt;&lt; endl; return; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; Judge(n); return 0;&#125; 1100 校庆 (20)这题问题还是超时，用 map 进行查找可以将数量级压缩在 O(n). 1104 天长地久 (20)这题主要就是要注意超时问题，可以推出来末尾一定是 99（我感觉题目“天长地久”已经有暗示了），然后在末尾 99 的基础上每次加 100 就行了，这样循环数量级变成 1e7，就不会超时了。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://cherryyang05.github.io/hexo-blog/tags/PTA/"},{"name":"上机","slug":"上机","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%B8%8A%E6%9C%BA/"},{"name":"算法","slug":"算法","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"计算机体系结构课程笔记（一）","slug":"计算机体系结构课程笔记（一）","date":"2021-12-31T04:10:32.000Z","updated":"2023-08-08T12:35:27.421Z","comments":true,"path":"bc5a2705.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/bc5a2705.html","excerpt":"本系列笔记来自于国防科技大学的计算机体系结构课程作者：Cherry时间：2022.1","text":"本系列笔记来自于国防科技大学的计算机体系结构课程作者：Cherry时间：2022.1 第一章 国防科大计算机体系结构课程第一至三章笔记 1.1 计算机体系结构的概念与发展冯诺依曼结构：运算器（核心）、存储器、输入&#x2F;输出设备、控制器 程序执行的过程 分解程序指令，形成控制四个部分工作的控制流 对数据进行加工（运算），形成数据流 周而复始地产生指令流 &#x2F; 数据流 并最终得到结果 一个机器周期里面安排的操作序列 计算机从存储器中取出一条指令 对这条指令进行译码 分解并确定这条指令所指示的操作 确定操作对象（操作数）所在的位置 某个寄存器单元、存储器单元或者输入设备 取操作数并送到运算器 运算器按照译码确定的操作进行运算 运算结束后，将结果送到指定的位置 计算机准备执行下一条指令 阿姆道尔（C. M. Amdahl）首次明确 计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性 1964 年 4 月， Architecture of the IBM System&#x2F;360 ，发表在 IBM Journal of Research and Development 上 计算机体系结构概念的经典定义 程序员所看到的计算机的属性 对于通用寄存器型机器，这些属性主要是指（1）数据表示：硬件能直接辨认和处理的数据类型（2）寻址规则：最小寻址单元、寻址方式及其表示（3）寄存器定义：寄存器的定义、数量和使用方式（4）指令系统：机器指令的操作类型和格式、指令间的排序和控制机构等（5）中断系统：中断的类型和中断响应硬件的功能等（6）机器工作状态的定义和切换：如管态和目态等（7）存储系统：程序员可用的最大存储容量（8）信息保护：信息保护方式和硬件的支持（9）I&#x2F;O 结构：I&#x2F;O 寻址方式、数据传送的方式等 计算机组成关注的问题： 指令集结构的逻辑实现 数据通路宽度 各种操作对功能部件的共享程度 专用功能部件的设置 功能部件的并行性 缓冲和排队技术 预测技术 可靠性技术 控制机构的组成，等等 计算机的实现 处理器、主存的物理结构 器件的集成度和速度 信号传输 器件、模块、插件、底板的划分与连接 涉及的专用器件 电源、冷却 微组装技术 整机装配技术，等等 不同年代计算机体系结构研究内容的变化： 年代 研究内容 典型计算机 1940s 程序控制计算机、存储程序计算机 ENIAC、EDVAC 1950s 指令系统 IBM 360 系列机 1960s 阵列机和并行处理 ILLIAC IV 1970s 流水线、向量处理、微处理器 Cray-1、Intel 4004 1980s RISC、cache、流水线 MIPS R1000、Power 1990s SMP、CMP、指令级并行 MIPS R100000、PowerPC 604 2000 年以来 SMT、功耗、Multi-core，Stream Intel i7、Power 6、ARM、GPU 同一个功能用硬件和软件实现是等效的，但是效率不同。 计算机系统中的多语言层次结构： 第一级：微程序机器级 微程序机器级的机器语言是微指令集 程序员用微指令编写的微程序一般是直接由硬件解释实现的 第二级：传统机器级 传统机器级的语言是该机的指令集 机器指令程序可以由微程序进行解释(仿真)，可有多个解释程序通过仿真，实现多种指令集 可以没有微程序机器级 第三级：操作系统虚拟机 直接管理传统机器中的软硬件资源 是传统机器的引伸 提供了传统机器所没有的某些基本操作和数据结构 文件系统 虚拟存储系统 多道程序系统 多线程管理等 第四级：汇编语言虚拟机 用汇编语言编写的程序，首先翻译或解释成第 3 级和第 2 级语言，然后再由相应的机器执行 完成汇编语言翻译的程序就叫做汇编程序，又叫汇编器 第五级：高级语言虚拟机 机器语言就是各种高级语言 用这些语言所编写的程序一般是由称为编译程序翻译到第４级或第 3 级上 也有用解释的方法实现转化 第六级：应用语言虚拟机 为使计算机满足某种用途而专门设计的（人工智能、教育、行政管理、计算机设计） 应用语言编写的程序一般是由应用程序包翻译到第 5 级上 翻译和解释： 翻译（Translation）：先把 N+1 级程序全部变换成 N 级程序后，再去执行新产生的 N 级程序，在执行过程中 N+1 级程序不再被访问 解释（Interpretation）：每当一条 N+1 级指令被译码后，就直接去执行一串等效的 N 级指令，然后再去取下一条 N+1 级的指令，依此重复进行 一般来说，解释执行比翻译花的时间多，但存储空间较少。 1.1.4 系列机和兼容 系列机（family machine）是具有相同体系结构，但组成和实现不同的一系列不同型号的计算机系统 IBM 公司在推出 IBM S360 时首次提出的系列机的概念，被认为是计算机发展史上一个重要里程碑 各计算机厂家仍按系列机研发产品 现代计算机不但系统系列化，其构成部件和软件也系列化 如微处理器（ CPU ）、硬盘、操作系统、高级语言等 兼容性 向上 (下) 兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器 向前(后)兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前 (后) 投入市场的机器 兼容对体系结构的影响 计算机系统及软件设计者的“障碍”： 系统软件的开发难度大 需要保护巨大的应用软件宝库 向后兼容是才是软件兼容的根本特征，也是系列机的根本特征 为了保证软件的兼容，要求指令集不改变，这无疑又妨碍计算机体系结构的发展 向后兼容虽然削弱了系列机对体系结构发展的约束，但仍然是体系结发展的沉重包袱 20 世纪 80 年代具有 RISC 体系结构的微处理器在新结构、新技术应用等方面领先传统的 CISC 微处理器的主要原因之一 1.2 计算机体系结构的发展 并行技术的发展：概念： 指令集并行 线程级并行 任务级&#x2F;过程级并行 提高并行性的技术途径： 时间重叠 资源重复 资源共享（提高资源的使用效率，如打印机） 并行计算的应用需求 计算机的成本构成： 处理器板：37% I&#x2F;O 设备：37% 附件：6% 软件：20% 目前，设计者需要取得性能与成本之间的平衡 摩尔定律1965 年，时任仙童公司研发实验室主任的摩尔（Gordon Mooer）在《Electronics》上撰文，认为集成电路密度大约每两年翻一番，大约成指数级增长。40 年来，摩尔定律不但印证了集成电路技术的发展，也印证了计算机技术的发展。 1.3 计算机系统设计和分析装机部件的成本的 50% 左右在显示部件上，即显示器和显卡。成本——时间因素：学习曲线 产品价格随着时间下降的趋势 1.3.2 基准测试程序五类测试程序 真实程序 修正的（或者脚本化）应用程序 核心程序 小测试程序 合成测试程序(将多个程序的核心部分提取出来) 测试程序包：选择一组各个方面有代表性的测试程序组成如：www.SPEC.org 基于 NUIX ，诞生于 20 世纪 80 年代 由真实程序和核心程序构成 采用 C 和 Fortran 两种语言，后增加 C++ 包括整数部分 SPECint 和浮点部分 SPECfp 主要版本包括 SPEC89 、 SPEC92 、 SPEC95 、 SPEC2000 和 SPEC2006 等 SECP2006 功能进一步细化 台式计测试： SPEC CPU2000 图像测试： SPECviewperf, SPECapc NFS 性能测试： SPECSFS Web 服务测试： SPECWeb 1.3.3 量化设计的基本原则 大概率事件优先原则 追求全局的最优结果 Amdahl 定律 系统性能加速比，受限于该部件在系统中所占的重要性 可以定量计算 程序的局部性原理 程序执行时所访问存储器在时-空上是相对地簇聚 这种簇聚包括指令和数据两部分 大概率事件优先原则 对于大概率事件（常见的事件）赋予优先的处理权和资源使用权，以获得全局的最优结果 要能确定什么是大概率事件，同时要说明针对该事件进行的改进将如何提高机器的性能 “好钢用在刀刃上”，事半功倍 Amdahl 定律 $$系统加速比&#x3D;\\dfrac{系统性能_{改进后}}{系统性能_{改进前}}&#x3D;\\frac{总执行时间_{改进前}}{总执行时间_{改进后}}$$ 核心概念：时间 系统加速比依赖于两个因素 “可改进比例”：可改进部分在原系统计算时间中所占的比例 ，它总是小于等于 1 的 “部件加速比”：可改进部分改进以后的性能提高，一般情况下它是大于 1 的 Amdahl的系统执行时间：$$&#x3D;(1-可改进比例)×总执行时间_{改进前}+\\dfrac{可改进比例}{部件加速比}×总执行时间_{改进前}$$$$&#x3D;总执行时间_{改进前}×(1-可改进比例+\\dfrac{可改进比例}{部件加速比})$$ 则Amdahl的系统加速比$$&#x3D;\\dfrac{总执行时间_{改进前}}{总执行时间_{改进后}}$$$$&#x3D;\\dfrac{1}{(1-可改进比例)+\\dfrac{可改进比例}{部件加速比}}$$ Amdahl定律的观点 性能增加的递减规则 仅仅对计算机中的一部分做性能改进，则改进的越多，系统获得的效果越小 Amdahl 定律的一个重要推论 针对整个任务的一部分进行优化，则最大加速比不大于$$\\frac{1}{1-可改进比例}$$ 通俗的说，系统的性能是由他不可加速的部分的性能决定 Amdahl 定律衡量一个“好”的计算机系统 具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能 程序局部性 程序访问地址的分布不是随机的，而是相对地簇聚 包括时间局部性和程序的空间局部性 程序的时间局部性 程序即将用到的信息很可能就是目前正在使用的信息 程序的空间局部性 程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近 其他局部性 生产 - 消费局部性 1.3.5 CPU 性能 程序执行过程中所处理的指令数，记为 IC 每条指令执行所需要的时钟周期数 CPI(Cycles Per Instruction) 每条指令执行所需要的平均时钟周期数 CPI &#x3D; CLK &#x2F; IC CPU 性能公式例子见 PPT 第二章 指令系统大纲- 指令集结构概述- 指令集结构的分类 - 寻址方式- 指令系统的设计和优化- 指令系统的发展和改进 - 操作数的类型和大小- MIPS指令系统结构 - 指令集结构概述- 指令集结构的分类2.1 指令集结构和设计技术1. 指令集结构概述2. 指令集结构的分类 一般来说，可以从如下五个因素考虑对计算机指令集结构进行分类，即： 在CPU中操作数的存储方法； 指令中显式表示的操作数个数； 操作数的寻址方式； 指令集所提供的操作类型； 操作数的类型和大小。 CPU中用来存储操作数的存储单元主要有： 堆栈； 累加器； 一组寄存器。  指令中的操作数可以被明确地显式给出，也可以按照某种约定隐式地给出。 通用寄存器型指令集结构的分类 通用寄存器型指令集结构的主要优点: 在表达式求值方面，比其它类型指令集结构都具有更大的灵活性； 寄存器可以用来存放变量； 减少存储器的通信量，加快程序的执行速度（因为寄存器比存储器快） 可以用更少的地址位来寻址寄存器，从而可以有效改进程序的目标代码大小。 两种主要的指令特性能够将通用寄存器型指令集结构（GPR）进一步细分。 ALU指令到底有两个或是三个操作数？ 在ALU指令中，有多少个操作数可以用存储器来寻址，也即有多少个存储器操作数？ 可以将当前大多数通用寄存器型指令集结构进一步细分为三种类型： 寄存器－寄存器型(R－R：register-register) 寄存器－存储器型(R－M：register-memory) 存储器－存储器型(M－M：memory-memory) 三种通用寄存器型指令集结构的优缺点 寄存器－寄存器型（0,3） 优点： 指令字长固定，指令结构简洁，是一种简单的代码生成模型，各种指令的执行时钟周期数相近。 缺点： 与指令中含存储器操作数的指令系统结构相比，指令条数多，目标代码不够紧凑，因而程序占用的空间比较大。 寄存器－存储器型（1,2） 优点： 可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。 缺点： 由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能限制指令所能够表示的寄存器个数。指令的执行时钟周期因操作数的来源（寄存器或存储器）的不同而差别比较大。 存储器－存储器型（3,3） 优点： 目标代码最紧凑，不需要设置存储器来保存变量。 缺点： 指令字长变换很大，特别是3个操作数指令。而且每条指令完成的工作也差别很大。对存储器的频率访问会使存储器成为瓶颈。这种类型的指令系统现在已经不用了。 2.2 指令集结构和MIPS指令集3. 寻址技术 在通用寄存器型指令集结构中，一般是利用寻址方式指明指令中的操作数是一个常数、一个寄存器操作数，抑或是一个存储器操作数。 寻址实际上是从形式地址到实际地址的转换。形式地址由指令描述，实际地址也称为有效地址。 有效地址指明的是存储器单元的地址或寄存器地址。 必须加速有效地址生成。 常用的一些操作数寻址方式： 寄存器寻址 立即值寻址 偏移寻址 寄存器间接寻址 索引寻址 直接寻址或绝对寻址 存储器间接寻址 自增寻址（串操作，先寻址再加） 自减寻址（先减再寻址） 缩放寻址 指令实例： Add R1, 100(R2)[R3] 含义：Regs[R1]←Regs[R1]+Mem[100+Regs[R2]+Regs[R3]*d] 4. 指令系统的设计和优化一种指令集结构中的指令到底要支持哪些类型的操作呢？这就是所谓的指令集结构功能设计问题。 分类 功能 算术和逻辑运算 整数的算术和逻辑操作：加、减、与、或等 数据传输 Load&#x2F;Store 控制 分支、跳转、过程调用和返回、自陷等 系统 操作系统调用、虚拟存储器管理等 浮点 浮点操作：加、乘等 十进制 十进制加、十进制乘、十进制到字符的转换 字符串 字符串移动、字符串比较、字符串搜索等 图形 像素操作、压缩&#x2F;解压操作等 控制指令 跳转” （Jump）：当控制指令为无条件改变控制流时，我们称之为“跳转” 。 “分支” （Branch）：而当控制指令是有条件改变控制流时，我们称之为“分支” 。 控制流程的改变情况： 条件分支（conditional branch）； 跳转（jump）； 过程调用（call）； 过程返回（return）。 控制指令主要使用在条件分支上 条件分支指令的表示 分支条件表示 优点 缺点 条件码（CC）在程序的控制下，由ALU操作设置特殊的位 可以自由设置分支条件 必须从一条指令将分支条件信息传送到分支指令，所以CC是额外状态，条件码限制了指令执行顺序 条件寄存器：根据比较结果测试条件寄存器 简单 占用了一个寄存器 比较分支：比较操作是分支指令的一部分，比较受限制 一条指令完成了两条指令的功能 分支指令的操作增多(串行) 过程调用和返回的状态保存 调用者保存” （caller saving）方法：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器，以备调用结束返回后，能够再次访问调用者。 “被调用者保存” （callee saving）方法：如果采用被调用者保存策略，那么被调用的过程必须保存它要用的寄存器，保证不会破坏过程调用者的程序执行环境，并在过程调用结束返回时，恢复这些寄存器的内容。 5. 指令系统的发展和改进 一个方向是强化指令功能，实现软件功能向硬件功能转移，基于这种指令集结构而设计实现的计算机系统称为复杂指令集计算机（CISC）。 八十年代发展起来的精简指令集计算机（RISC），其目的是尽可能地降低指令集结构的复杂性，以达到简化实现，提高性能的目的。 CISC指令集功能设计 面向目标程序增强指令功能 提高运算型指令功能； 提高传送指令功能； 增加程序控制指令功能。 面向高级语言和编译程序改进指令系统 增加对高级语言和编译系统支持的指令功能； 高级语言计算机指令系统。 面向操作系统的优化实现改进指令系统 主要表现在对中断处理、进程管理、存储管理和保护、系统工作状态的建立与切换等的支持。 可以设置支持系统工作状态和访问方式转移的指令、支持进程转移的指令、支持进程同步和互斥的指令等措施，达到优化实现操作系统的目的。 RISC指令集功能设计 CISC结构存在着如下缺点： 在CISC结构的指令系统中，各种指令的使用频率相差悬殊。据统计，有20％的指令使用频率最大，占运行时间的80％。也就是说，有80％的指令在20％的运行时间内才会用到。 CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误。 CISC结构指令系统的复杂性给VLSI设计增加了很大负担，不利于单片集成。 CISC结构的指令系统中，许多复杂指令需要很复杂的操作，因而运行速度慢。 在CISC结构的指令系统中，由于各条指令的功能不均衡性，不利于采用先进的计算机体系结构技术（如流水技术）来提高系统的性能。 注：x86 从奔腾4开始，内部已经实现 RISC 化 RISC指令集功能设计原则 选取使用频率最高的指令，并补充一些最有用的指令； 每条指令的功能应尽可能简单，并在一个机器周期内完成； 所有指令长度均相同； 只有load和store操作指令才访问存储器，其它指令操作均在寄存器之间进行； 以简单有效的方式支持高级语言。 6. 操作数的类型和大小 操作数类型和操作数表示也是软硬件主要界面之一。 操作数类型是面向应用、面向软件系统所处理的各种数据结构。 操作数表示是硬件结构能够识别、指令系统可以直接调用的那些结构。 操作数表示所表征的那些操作数类型，是应用软件和系统软件所处理的操作数类型的子集。 确定操作数表示实际上也是软硬件取舍折衷的问题 计算机即使只具有最简单的操作数表示，如只有整数（定点）表示法，也可以通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率。 如果各种复杂的操作数类型均包含在操作数表示之中，无疑会大大提高系统的效率，但是所花费的硬件代价也很高。 7. MIPS指令系统结构 Load&#x2F;Store型指令集结构； MIPS是一种多元指令集结构； 具有一个简单的Load&#x2F;Store指令集； 注重指令流水效率； 简化指令的译码； 高效支持编译器。 MIPS指令集结构：寄存器 32个32位通用寄存器（GRPs） 寄存器R0的内容恒为0 32个32位浮点寄存器（FPRs） 单精度浮点数表示和双精度浮点表示 MIPS指令集结构：数据类型 整型数据： 8位、 16位、 32位。 浮点数据： 32位单精度浮点； 64位双精度浮点； IEEE 754标准。 MIPS指令集结构：寻址方式 寄存器寻址；如ADD R1,R2,R3 立即值寻址；如ADD R1,R2,#42 偏移寻址； 如ADD R1,R2,40(R3) 寄存器间接寻址。存储器地址宽度为32位。如ADD R1,R2,0(R3) MIPS指令集结构：指令格式 I类型指令 R类型指令 J类型指令 MPIS指令集结构：操作类型 Load和Store操作； ALU操作； 分支和跳转操作； 浮点操作； 符号&lt;- 表示数据传送操作，其后附带一个下标n，也即 &lt;-n 表示传送一个n位数据。 符号 ## 用来表示两个域的串联操作，它可以出现在数据传送操作的任何一边。 域的下标用来表明从该域中选择某一位。域中位的标记是从最高位开始标记，并且起始标记为0。下标可以是一个单独的数字，也可以是一个范围； 上标表示复制一个域，如$0^{24}$可以得到一个24位全为0的一个域。 变量Mem用来表示存储器中的一个数组，存储器按照字节寻址，它可以传送任何数目的字节。 Load和Store操作：可以对MIPS的所有通用寄存器和浮点寄存器进行Load（载入）和Store（储存）操作， 但是对通用寄存器R0的Load操作没有任何效果。 ALU操作：在MIPS中，所有的ALU指令都是寄存器－寄存器型指令，其运算包含了简单的算术和逻辑运算，如加、减、AND、OR、XOR和移位。 “设置相等”、“设置不等”“设置小于”:寄存器比较指令 描述目标地址的方法： 其中两种类型的跳转指令用带符号位的26位偏移量加上程序计数器的值来确定跳转的目标地址； 另外两种类型的跳转指令则指定一个寄存器，由寄存器中的内容决定跳转的目标地址。 两种跳转类型： 一种是简单跳转； 另一种是跳转并链接（用于过程调用），它将下一条顺序指令地址（返回地址）保存在寄存器R31中。 浮点操作：浮点指令的操作数来源于浮点寄存器，同时它还指明了相应的操作是单精度浮点操作还是双精度浮点操作。 后缀D代表双精度浮点操作； 而后缀F代表单精度浮点操作（如： ADDD、ADDF、 SUBD、 SUBF、 MULTD、 MULTF、DIVD、 DIVF）。 MIPS的浮点操作有：加、减、乘、除。 MIPS的效能分析 问题的提出： MIPS指令集结构的指令格式、寻址方式和操作都非常简单。也许有人会担心，这些特性会使得目标代码中指令条数增多，导致程序运行时间加长，从而使这种指令集结构的机器性能并不会太高。 第三章 流水线技术3.1 流水线基本概念流水技术将一重复的时序过程分解为若干子过程，每个子过程都可以有效地在其专用功能段上与其它子过程同时执行，这种技术成为流水技术。 时空图从时间和空间两个方面描述流水线的工作过程，横坐标表示时间，纵坐标表示各流水段。 流水线的特点 流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线的“深度”。 每个子过程由专用的功能段实现 各功能段的时间应基本相等，通常为1个时钟周期（1拍） 流水线需要经过一定的通过时间才能稳定。 流水技术适合于大量重复的时序过程。（流水也是一种并行，但和“并发”不一样，是处于“不同阶段”任务的并行） 3.1.2 流水线的分类1. 单功能流水线和多功能流水线 按流水线所完成的功能分类 单功能流水线，是指只能完成一种固定功能的流水线。 例如：功能单元流水线 多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能。 例如：TI ASC的多功能流水线 2. 静态流水线和动态流水线 按同一时间内流水段的连接方式划分 静态流水线，是指在同一时间内，流水线的各段只能按同一种功能的连接方式工作 例如：TI ASC的流水线 适合于处理一串相同的运算操作 动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算 会使流水线的控制变得很复杂 多功能流水线才有这样的划分。 3. 部件级、处理机级及处理机间流水线 按流水的级别划分 部件级流水线，又叫 运算操作流水线，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水。 处理机级流水线，又叫 指令流水线，是把解释指令的过程按照流水方式处理。 处理机间流水线，又叫 宏流水线，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。 4. 标量流水处理机和向量流水处理机 按照数据表示来进行分类 标量流水处理机，是指处理机不具有向量数据表示，仅对标量数据进行流水处理。 例如IBM360&#x2F;91，Amdahl 470V&#x2F;6等 向量流水处理机，是指处理机具有向量数据表示，并通过向量指令对向量的各元素进行处理。 例如TI ASC、STAR-100、CYBER-205、CRAY-1、YH-1等 5. 线性流水线和非线性流水线 按照是否有反馈回路来进行分类 线性流水线是指流水线的各段串行连接，没有反馈回路。 非线性流水线是指流水线中除有串行连接的通路外，还有 反馈回路。 存在流水线调度问题。 确定什么时候向流水线引进新的输入，从而使新输入的数据和先前操作的反馈数据在流水线中不产生冲突，此即所谓 流水线调度 问题。 一般不采用该方式 3.2 MIPS基本流水线3.2.1 MIPS的一种简单实现下图给出了实现MIPS指令的一种简单数据通路 这是非流水方式 指令执行划分为5个阶段 取指（IF） 根据PC值从存储器中取出指令，并将指令送入指令寄存器IR；PC值增加4，指向顺序的下一条指令，并将下一条指令的地址放入临时寄存器NPC中。 IR←Mem[PC]，NPC←PC+4 译码，读寄存器（ID） 进行指令译码，读IR寄存器（指令寄存器），按照相应寄存器号读寄存器文件，并将读出结果放入两个临时寄存器A和B中。同时对IR寄存器中内容的低16位进行符号扩展，然后将符号扩展之后的32位立即值保存在临时寄存器Imm中。 A←Regs[IR6..10] B←Regs[IR11..15] Imm←((IR16)16##IR16..31) 执行，有效地址计算（EX） 存储器访问： ALUoutput←A+Imm 寄存器-寄存器ALU： ALUoutput←A op B 寄存器-立即值ALU: ALUoutput←A op Imm 分支操作： ALUoutput←NPC+Imm Cond←(A op 0) 问题：为什么执行和有效地址计算可以合并？ 访存（MEM） 访存操作： Load： LMD←LMDMEM[ALUoutput] Store： Mem[ALUoutput]←B 分支操作： if (Cond) PC←ALUoutput else PC←NPC 写回（WB） 寄存器-寄存器型ALU指令： Reg[IR16..20]←ALUoutput 寄存器-立即值型ALU指令： Reg[IR11..15]←ALUoutput Load指令：Reg[IR11..15]←LMD 性能分析 在该数据通路上，分支指令需要4个时钟周期，其它指令需要5个时钟周期。假设分支指令占总指令数的12%，问CPI&#x3D;? CPI&#x3D;4×12%+5×(1-12%)&#x3D;4.88 结论：就性能和硬件开销而言，上述实现不是一种优化实现！ 改进方法 在Mem周期完成ALU指令 假设ALU指令数占指令总数的44%，则在时钟周期时间不变的同时，CPI可以降低至4.4 如要进一步降低CPI，可能会增加时钟周期时间 采用单周期实现，可以将CPI降低为1，但时钟周期时间却会增加为原来的5倍。一般不采用这种方法，为什么？（因为实际上并没有提高效率） 流水技术 3.2.2 基本MIPS流水线1. 一种简单的MIPS流水线 将3.2.1中的数据通路流水化，使得数据通路中的每一个周期就成为流水线的一段 每个时钟周期启动一条指令——得到了一条简单的MIPS流水线。 简单MIPS流水线的流水过程： 时-空图 按时间错开的数据通路注意：纵坐标不是流水段，而是指令 2. 实现流水技术应解决的一些问题 应保证流水线各段不会在同一时钟周期内使用相同的寄存器通路资源。 例如，不能要求一个ALU既做有效地址计算，又做减法操作 IF与Mem两个阶段都要访问存储器，怎样避免访存冲突？ 使用 哈佛结构，将指令存储器和数据存储器分离 ID和WB两个阶段都要访问寄存器，是否存在冲突？怎样避免？ 将寄存器隔离，各自使用各自的资源（？） PC计算问题 为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获得下一条指令的地址，并将其保存在PC中。 但是，分支指令会改变PC的值，而且只有在Mem段结束时，这个新值才会被写入PC，出现矛盾。 解决方法： 改变数据通路，在IF段完成PC计算。但分支指令如何处理？ 处理分支指令可以在流水线中加入暂停周期，或设置延迟槽 合理划分流水段，每段内的操作都必须在一个时钟周期内完成。 流水线寄存器设计 为防止寄存器中的值在为流水线中某条指令所用时被流水线中其它的指令所重写，可在流水线各段之间设置流水线寄存器文件，也称锁存器。（分站后站间寄存器算哪站的？都可以，但不要不一致） 流水线寄存器文件的命名 段A与B之间的流水线寄存器文件称为A&#x2F;B 流水线寄存器的作用当指令在流水线中流动时，其数据和控制信息也在同步地向前流动 流水线寄存器文件的构成 3. MIPS流水线的操作 在任一时刻，流水中的指令仅在流水线中的某一段内执行操作。 因此，只要知道每一流水段在各指令下进行何种操作，就知道了整个流水线的操作。 4. MIPS流水线中多路选择器的控制 主要是确定如何控制那四个多路选择器： ALU输入端的两个MUX由ID&#x2F;EX.IR所指出的指令类型控制 IF段的MUX由EX&#x2F;MEM.Cond域的值控制 WB段的MUX由当前指令类型(Load&#x2F;ALU)控制 3.2.3 流水线性能分析三项性能指标：吞吐率、加速比和效率 1. 吞吐率 是衡量流水线速度的重要指标 吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量。 最大吞吐率TPmax是指流水线在达到 稳定状态后所得到的吞吐率。 设流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率，记作TP。 (1) 最大吞吐率 假设流水线各段时间相等，均为 $\\Delta t_{0}$，则：$TP_{max} &#x3D; \\frac{1}{\\Delta t_{0}}$ 假设流水线各段时间不等，第 i 段时间为$\\Delta t_{i}$，则：$TP_{max} &#x3D; \\frac{1}{max{\\Delta t_{0}}}$ 最大吞吐率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈（不均匀的流水线才能反映出流水线瓶颈问题） 消除瓶颈的方法 细分瓶颈段 重复设置瓶颈段 (2) 实际吞吐率 若各段时间相等（假设均为$\\Delta t_{0}$），则完成时间$T_{流水} &#x3D; m\\Delta t_{0}+(n-1)\\Delta t_{0}$ 实际吞吐率 $TP&#x3D;\\cfrac{1}{T_{流水}}&#x3D;\\cfrac{n}{m\\Delta t_{0}+(n-1)\\Delta t_{0}}&#x3D;\\cfrac{1}{(1+\\frac{m-1}{n})\\Delta t_{0}} &#x3D; \\cfrac{TP_{max}}{1+\\frac{m-1}{n}}$ 若各段时间不等（假设第i段为$\\Delta t_{i}$），则完成时间为：$T&#x3D;\\sum\\limits_{i&#x3D;1}^{m}\\Delta t_{i}+(n-1)\\Delta t_{j}$这里$\\Delta t_{j}&#x3D;max{\\Delta t_{i}}$实际吞吐率 $TP&#x3D;\\cfrac{n}{\\sum\\limits_{i&#x3D;1}^{m}\\Delta t_{i}+(n-1)\\Delta t_{j}}$ 不均匀流水线吞吐率的影响因素：深度、任务数、瓶颈段时间。 2. 加速比 加速比是指流水线速度与等功能的非流水线速度之比，加速比一定大于1。 根据定义可知，加速比 $S &#x3D; T_{非流水}&#x2F;T_{流水}$ 若流水线为m段，每段时间均为 $\\Delta t_{0}$，则 $T_{非流水}&#x3D;nm\\Delta t_{0}$$T_{流水}&#x3D;m\\Delta t_{0}+(n-1)\\Delta t_{0}$加速比 $S&#x3D;\\cfrac{mn}{m+n-1}&#x3D;\\cfrac{m}{1+\\frac{m-1}{n}}$ 3. 效率 效率指流水线的设备利用率。 由于流水线有 通过时间和排空时间，所以流水线的各段并非一直满负荷工作，$E&lt;1$ 若各段时间相等，则各段效率也相等，即 $e1 &#x3D; e2 &#x3D; e3 &#x3D;…&#x3D; n\\Delta t_{0}&#x2F;T_{流水}$ 整个流水线效率 $E&#x3D;\\cfrac{n}{m+n-1}&#x3D;\\cfrac{1}{1+\\frac{m-1}{n}}$当 $n\\ll m$ 时，$E\\approx 1$ 从时-空图上看，效率就是n个任务所占的时空区与m个段总的时空区之比 根据这个定义，可以计算流水线各段时间不等时的流水线效率 $E&#x3D;\\cfrac{n个任务占用的时空区}{m个段总的时空区}$ 时空图上的对应关系：忙的时间和总时间的比。算出来的是所有设备的平均效率。 4. 吞吐率、加速比和效率的关系 根据加速比 $S&#x3D;\\dfrac{mn}{m+n-1}&#x3D;\\dfrac{m}{1+\\frac{m-1}{n}}$和效率 $E&#x3D;\\dfrac{n}{m+n-1}&#x3D;\\dfrac{1}{1+\\frac{m-1}{n}}$可得，效率实际上是加速比 S 和最大加速比 m 的比值，即 $E&#x3D;\\dfrac{S}{m}$ $E&#x3D;n\\Delta t_{0}&#x2F;T_{流水}&#x3D;(n&#x2F;T_{流水})\\Delta t_{0}&#x3D;TP\\Delta t_{0}$当 $\\Delta t_{0}$ 不变时，流水线的效率与吞吐率呈正比。为提高效率而采取的措施，也有助于提高吞吐率 例题 3.1 在静态流水线上计算 $\\sum\\limits_{i&#x3D;1}^{4}A_{i}B_{i}$，问吞吐率、加速比、效率各是多少？ 上述方案性能不高，效率仅为 0.21 静态多功能流水线在对某种功能进行处理时，总有某些段处于空闲状态 功能切换增加了前一种功能的排空时间和后一种功能的通过时间 需要把输出回传到输入（相关） 能否通过动态流水线改进其性能？ 设置多功能流水线，在加法未进行完时，便进行乘法流水（可以缩短进入时间和排空时间） 当需要的乘法结果出来后立即执行加法流水，也可缩短一定的进入时间和排空时间 实际上这样设置流水线是有问题的，只有当前两个乘法完全执行完，才能执行加法，即在t&#x3D;5 时才能执行第一个加法，在 t&#x3D;7 时才能执行第二个加法，最后总时间为 19$\\Delta t_{0}$。 例 3.3 在 MIPS 的非流水实现和基本流水线中，5个功能单元的执行时间：10&#x2F;8&#x2F;10&#x2F;10&#x2F;7ns。流水线额外开销为 1ns，求相对于非流水指令实现而言，基本 MIPS 流水线的加速比是多少？ 注：流水线额外开销包括：流水寄存器的延迟（建立时间和传输延迟）以及时钟扭曲 6. 有关流水线性能的若干问题 流水线并不能减少（而且一般是增加）单条指令的执行时间，但能够提高吞吐率 增加流水线的深度可以提高流水线性能 流水线深度受限于流水线的延迟和额外开销 需要用高速锁存器作为流水线寄存器——Earle 锁存器 指令之间存在的相关，限制了流水线的性能 Earle锁存器 1965 年由 J.G.Earle 发明 优点 对时钟扭曲不敏感（相对而言），一般是两级门延迟，避免了数据通过锁存器时可能产生的时钟扭曲 在锁存器中可以执行两级逻辑运算，而不会增加锁存器的延迟时间，可以隐藏锁存器产生的额外开销 锁存器是流水线技术存在的基本保证 3.3 流水线中的相关1. 什么是相关？ 流水线中的相关是指相邻或相近的两条指令因存在某种关联，后一条指令不能在原先指定的时钟周期开始执行。 消除相关的基本方法——暂停（stall） 暂停流水线中某条指令及其后面所有指令的执行，该指令之前的所有指令继续执行。 2. 三种不同类型的相关 结构相关：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突时将产生“结构相关”。 数据相关：因一条指令需要用到前面指令的结果，而无法与产生结果的指令重叠执行时，就发生了数据相关。 控制相关：当流水线遇到分支指令和其它会改变 PC 值的指令时就发生控制相关。 3.3.1 流水线的结构相关 导致结构相关的常见原因： 功能部件不是全流水 重复设置的资源数量不足 实例：当数据和指令存在同一存储器中时，访存指令会引起存储器访问冲突。 解决方法： I. 插入暂停周期 II. 将指令存储器和数据存储器分离 避免结构相关的方法： 所有功能单元完全流水化 设置足够多的硬件资源 但是，硬件代价很大！ 有些设计方案允许结构相关存在 降低成本 减少功能单元的延迟 例 3.4 当前许多机器都没有将浮点功能单元完全流水， 比如在MIPS实现中，浮点乘需要5个时钟周期，但对该指令不流水。请分析由此引起的结构相关对 mdljdp2 基准程序在MIPS上运行的性能有何影响？为简单起见，假设浮点乘法服从均匀分布。 解：mdljdp2中浮点乘法出现的频率约为14%。最坏情况：每个浮点乘都无法与其它操作重叠执行，都需要5个周期，此时CPI为1.56最好情况：可以完全重叠执行，仅需要1个周期，此时没有性能损失 3.3.2 流水线的数据相关1. 数据相关简介 实例： 12345ADD R1, R2, R3SUB R4, R1, R5AND R6, R1, R7OR R8, R1, R9XOR R10, R1, R11 产生原因：当指令在流水线中重叠执行时，流水线有可能改变指令读&#x2F;写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据相关。 消除方法：向流水线中插入暂停周期（stall） 2. 通过定向技术（Forwarding）减少数据相关带来的暂停 定向（Forwarding），也称为旁路技术（bypassing），转发技术 主要思路：将计算结果从其产生的地方直接送到真正需要它的地方，就可以避免暂停。 寄存器文件 EX&#x2F;MEM 中的 ALU 运算结果总是回送到 ALU 的输入寄存器 从定向通路得到输入数据的 ALU 操作不必从源寄存器中读取操作数 进一步推广：一个结果不仅可以从某一功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。 在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。 两条指令访问同一存储单元，也可能引起数据相关，例如访问数据 Cache 失效时。 本章只讨论寄存器数据相关！ 3. 数据相关的分类 两条指令 i 和 j，都会访问同一寄存器R，假设i 先进入流水线，则它们对R有四种不同的访问顺序： (1) 写后读(RAW) —— i 写 j 读 如果 j 在 i 完成写之前从 R 中读出数据，将得到错误的结果！ 最常见的数据相关，严重制约了 CPU 的性能，是程序最重要的特征之一！ (2) 写后写(WAW) —— i 写 j 写 如果 j 在 i 之前完成写操作，R 中将保存错误的结果！ MIPS 流水线不会出现这种相关！ 当流水线中有多个段可以写回，而且当流水线暂停某条指令的执行时，其后的指令可以继续前进时，可能引起这种类型的相关。 (3) 读后写(WAR) —— i 读 j 写 如果 j 先将数据写入 R，i 将读出错误的结果！ MIPS流水线不会出现这种类型的相关！ 当有些指令在流水段后半部分读源操作数，另一些指令在流水线前半部分写结果，可能引起这种类型的相关。 (4) 读后读(RAR) —— i 读 j 读 不引起数据相关！ 4. 需要暂停的数据相关 并非所有数据相关都可以通过定向技术解决。 例： LW R1，0（R2） SUB R4，R1，R5 AND R6，R1，R7 OR R8，R1，R9 增加流水线“流水线互锁”部件，当互锁硬件发现这种相关后，就暂停流水线，直到相关消除。 这种情况下，暂停的时钟周期数称为载入延迟。 5. 对数据相关的编译调度方法 流水线中常常会遇到多种类型的暂停 例如，计算表达式 $A&#x3D;B+C$ 时会出现暂停 编译器可以通过重新排列代码的顺序来消除这种暂停，这种技术就是流水线调度或指令调度 软件上的方法有时会使事情变得轻而易举，但这取决于编译器的智能。 例 3.6请为下列表达式生成没有暂停的MIPS指令序列 $a &#x3D; b – c$，$d &#x3D; e – f$，假设载入延迟为1个时钟周期。分析：为了避免数据相关，需要调整指令的顺序，并合理利用 Forwarding 技术。 6. 对 MIPS 流水线控制的实现 指令发射：指令从流水线的译码段进入执行段的过程称为指令发射。 检测数据相关 ID 段可以检测所有数据相关 在使用一个操作数的时钟周期的开始(EX 和 MEM 段的开始)检测相关，并确定必需的定向 流水线相关硬件可以检测到的各种相关情况 例：Load 互锁的检测与实现 在 ID 段检测是否需要启动 Load 互锁，必须进行三种比较 一旦检测到相关，控制部件必须在流水线中插入暂停周期，并使 IF 和 ID 段中的指令停止前进 将 ID&#x2F;EX 中控制部分清 0 保持 IF&#x2F;ID 的内容不变 定向逻辑的实现 所有的定向都是从 ALU&#x2F;DM 的输出到 ALU、DM 或 0 检测单元的输入 形成了一个旁路网络 需要比较哪些信息？ ALU输入端应采用多少个输入的 MUX？ 3.3.3 流水线的控制相关1. 分支指令的实现 一旦分支转移成功，正确的地址要在 Mem 段的末尾才会被写入 PC 一旦 ID 段检测到分支指令，就暂停执行其后的指令，直到分支指令达到 Mem 段，确定新的 PC 为止 分支转移成功将导致 MIPS 流水线暂停 3 个周期 这是引起更大暂停的另一类相关 没有控制流指令的指令集机器是很不好用的 在事务处理应用中，分支跳转等指令占有相当大的比重。 2. 减少分支开销的途径 两个基本途径：同时采用，缺一不可！ 在流水线中尽早判断分支转移是否成功 转移成功时，尽早计算出转移目标地址 经改进，MIPS流水线可以将分支开销减少1拍 将 $&#x3D;0?$ 测试提前到 ID 段 在 ID 段增加一个加法器，计算分支目标地址 表 3.6 列出了改进后流水线的分支操作 第一种改进，注意分支结果在 EX 段有效。 再改进，MIPS 流水线可以将分支开销再减少 1 拍 将分支判断结果和目标地址提前到 ID&#x2F;EX 站前 第二步改进，这次分支结果在 ID 段有效！！！ 3. 程序中分支指令的行为特点(1) 各种能改变PC值的指令的执行频度 条件分支： 整数程序：14-15% 浮点程序：3-12% 其中，向前分支与向后分支的比：3:1 无条件分支：≤4%（绝大多数） (2) 条件分支转移成功的概率 向前转移成功：60%；向后转移成功：85% 4. 减少流水线分支损失的方法(1) 冻结或排空流水线 思路：在流水线中暂停或删除分支后的指令，直到得到转移目标地址 优点：简单 (2) 预测分支转移失败 思路：流水线继续照常流动，如果分支转移成功，将分支指令后的指令转换为空操作，并从分支目标处开始取指令执行；否则照常执行 实际发生的成功分支多，就应该在硬件上预测成功，反之则预测失 所谓预测，就是在硬件执行时把分支当作全部成功或全部失败 MIPS流水线的处理过程 (3) 预测分支转移成功 思路：始终假设分支成功，直接从分支目标处取指令执行 对 MIPS 流水线没有任何好处！ (4) 延迟分支（delayed branch） 思路：分支开销为 n 的分支指令后紧跟有 n 个延迟槽，流水线遇到分支指令时，按正常方式处理，顺带执行延迟槽中的指令，从而减少分支开销。 延迟槽指令不影响后续指令执行，编译器动态调度 延迟分支及指令的执行顺序 具有一个分支延迟槽的MIPS流水线的执行过程 什么样的指令能否放入分支延迟槽？ 三种调度方法：从前调度；从目标处调度；从失败处调度 三种方法的要求与效果，存在限制因素 编译器预测分支是否成功的能力 放入延迟槽中的指令 取消分支 思路：分支指令中包含预测方向，若预测正确，正常执行延迟槽中的指令，否则将其转换为空操作 5. 各种分支处理方法的性能 假设理想CPI&#x3D;1，则加速比$S&#x3D;D&#x2F;(1+C)&#x3D;D&#x2F;(1+f×p_{分支})$ 这里，D 为流水线的深度，p 分支为分支开销，C 为分支引起的流水线暂停时钟周期数(每条指令的平均值)，f 为分支的出现频度。 表 3.7 列出了流水线中各种处理方法的开销 [补充] 流水线数据相关与冒险（冲突）在组成原理中，流水线相关包含数据相关，结构相关，控制相关，这里的相关在体系结构中应该称作为冲突（或冒险），实际上相关和冲突在含义上有一些不同 在体系结构中有 3 种不同类型的相关：数据相关（也叫真数据相关）、名相关和控制相关 数据相关若： 指令 i 生成的结果可能会被指令 j 用到 指令 j 数据相关于指令 k，指令 k 相关于指令 i 那么指令 j 数据相关于指令 i 要说明的是，数据相关可能会导致数据冒险 名相关（名称相关）当两条指令使用相同的寄存器或存储器位置（称为名称），但与该名称相关的指令之间没有数据流动时，就会发生名相关 当指令 j 对指令 i 读取的寄存器或存储器位置执行写操作时，会发生反相关 当指令 i 和指令 j 对同一个寄存器或存储器位置执行写操作时，会发生输出相关 由于没有在指令之间传递值，所以反相关和输出相关都是名称相关，与真数据相关相对。因为名称相关不是真正的相关，因此如果改变这些指令中使用的名称，使这些指令不再冲突，这些指令便可以同时执行，或者重新排序。 数据冒险（数据冲突） 写后读（RAW），与真数据相关对应 写后写（WAW），与输出相关对应 读后写（WAR），源于反相关，或名称相关 读后读（RAR），不是冒险 3.4 实例分析：MIPS R40003.4.1 MIPS R4000的整型流水线1. 指令集：64位MIPS-3指令集 2. MIPS R4000流水线结构 超流水结构（superpipeling） 访存操作流水化 3. 流水线各段的功能 4. 指令序列在流水线中的重叠执行过程 定向+插入暂停周期 定向不一定是相邻指令 结构不同，定向和暂停机制所对应的硬件结构也不同 5. 载入延迟为两个时钟周期 实际上在 DS 阶段数据已经计算出来，后一个阶段 TC 是将数据写入存储器（WB 阶段写入寄存器），而进行旁路时，无需将其写入存储器便可以得到数据，因此载入延迟为两个时钟周期 6. 指令序列在流水线中的执行时空图 7. R4000流水线的定向路径远多于MIPS流水线 - ALU输入端的定向源有4个：EX&#x2F;DF，DF&#x2F;DS，DS&#x2F;TC，TC&#x2F;WB 8. 分支处理 在 EX 段完成分支条件的计算，基本分支延迟为3个时钟周期 分支处理策略 单周期延迟分支 从失败处调度 3.4.2 MIPS R4000的浮点流水线 包括浮点除法器、浮点乘法器和浮点加法器各1个 分为8段（表3.9） 多功能非线性流水线 双精度浮点操作指令延迟、初始化间隔和流水段的使用情况（表3.10） 3.4.3 MIPS R4000流水线性能分析1. 引起流水线暂停的四个主要原因 载入暂停 分支暂停 浮点结果暂停 浮点结构性暂停 2. 暂停对MIPS R4000流水线CPI的影响 3.5 向量处理机1. 什么是向量机？ 具有向量数据表示和相应向量指令的流水线处理机称为向量流水线处理机，也称向量处理机。 与之对应的是标量处理机，不支持向量数据表示，没有提供向量指令。 2. 实例：一个简单的FORTRAN循环程序$$ DO \\quad 10 \\quad i&#x3D;1, N \\ 10 \\quad d[i] &#x3D; a[i]*(b[i]+c[i])$$ 3.5.1 向量处理方式和向量处理机 水平（横向）处理方式 垂直（纵向）处理方式 分组（纵横）处理方式 将长度为N的向量分为m组，每组有n个元素，组内按纵向方式处理，依次处理各组。 需要m次迭代；每次迭代执行两条向量指令，有1次数据相关，需要2次功能切换 需要寄存器-寄存器型操作的运算流水线 这种技术称为向量循环或分段开采 例3.8 设 A 和 B 是长度为N的向量，考虑在一个向量长度为 64 的向量处理机上实现如下的循环操作：DO 10 I&#x3D;1, N10 A(I) &#x3D; 5.0 * B(I) + 1.0 (1) 当N≤64时(2) 当N&gt;64时，需要进行分段开采 4. 向量处理机的速度评价方法 由于一条指令最多得到一个结果，标量处理机通常用每秒执行多少条指令(MIPS)来衡量机器的运算速度 向量处理机用每秒取得多少浮点运算结果来衡量机器速度，以 MFLOPS 作为测量单位 采用 MFLOPS 可以忽视 Load、Store、分支、测试等类型指令的影响 一般认为，在标量计算机中执行一次浮点运算，平均需 3 条指令。因此，如果要把这两种速度指标放在一起比较，就应该把 MFLOPS 乘以一个系数，以得到相应的 MIPS 比较法：选择一台速度指标得到公认的机器作为标准机，给定一些典型的基准程序，分别在标准机和被测机上求解。 3.5.2 向量处理机实例分析实例：Cray-I 1. 性能指标1GFLOPS、主频80M、向量长度64 2. 基本结构 向量运算部件 向量寄存器组（V0-V7） 向量长度寄存器 向量屏蔽寄存器 3. 向量指令类型 $V_k ← V_i ,op ,V_j$（两个向量操作） $V_k ← S_i ,op ,V_j$（一个向量一个标量操作） $V_k ← Mem$（取数据） $Mem ← V_k$（存数据） 功能部件冲突：同一功能部件被一条以上的并行工作向量指令所使用 $V_i$ 冲突：并行工作的各向量指令具有相同的源向量或结果向量 4. CRAY-I 体系结构特点 向量寄存器与功能单元的连接通路 每个 $V_i$ 块都有单独总线可连到所有向量功能部件，而每个向量功能部件也各自都有把运算结果送回向量寄存器组的总线（寄存器组和功能部件全相连） 向量链接技术 一个向量功能部件得到的结果直接送入另一个向量功能部件的操作数寄存器时所发生的连接过程称为链接。 上图中，当完成 $V_1+V_2$ 时，将值送入 $V_3$ 的同时送入下一个乘法流水线作为其中的被乘数（其实我感觉有点像处理数据相关时的 Forwarding 技术）。 当两条指令出现“写后读”相关时，若它们不存在功能部件冲突和向量寄存器(源或目的) 冲突，就有可能把它们所用的功能部件头尾相接，形成一个链接流水线，进行流水处理。 链接特性实质上是把流水线“定向”的思想引入到向量执行过程的结果 5. 向量链接技术实例分析例3.7 对向量运算 D&#x3D;A*(B+C)，若向量长度 N≤64，向量元素为浮点数，则在B、C取到V0、V1后，就可用以下三条向量指令求解：V3←存储器 (访存，载入A)V2←V0＋V1 (浮点加)V4←V2*V3 (浮点乘，将D存入V4) 假设：向量处理机将元素从 $V_i$ 送往功能部件及把结果存入 $V_i$ 都需要1拍；浮点加法和访存操作都需要 6 拍；浮点乘操作需要 7 拍。这样，第一个结果被存入 $V_4$ 需要经过： 1(送)+ 6(浮加) +1(入)+1(送)+7(浮乘)+1(入)&#x3D;17(拍) 此后，每拍将得到一个结果送入 $V_4$。总的完成时间为：17+（N-1）拍 6. 向量链接技术应考虑的问题 设定合适的向量功能部件和操作数寄存器 链接时机问题 只有在前一条向量指令的第一个结果元素送入结果向量寄存器的那一个时钟周期才可以进行链接 只有当前一条向量指令全部执行完毕，释放相应的向量寄存器资源后才能执行后面的向量指令 所有可以链接执行的向量指令的向量长度应相等 总结链接的时机：普适的原则","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"体系结构","slug":"课程笔记/体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"体系结构","slug":"体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"LeetCode题解（一）","slug":"LeetCode题解（一）","date":"2021-03-27T03:55:04.000Z","updated":"2023-08-08T12:35:27.384Z","comments":true,"path":"33fe21e.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/33fe21e.html","excerpt":"LeetCode 热题 Hot 100","text":"LeetCode 热题 Hot 100 1. 两数相加 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; map; vector&lt;int&gt; v(2,-1); for (int i = 0; i &lt; nums.size(); i++) &#123; if (map.count(target - nums[i]) &gt; 0) &#123; v[1] = map[target - nums[i]]; v[0] = i; break; &#125; map[nums[i]] = i; &#125; return v;&#125; 这里要注意，若 map 中没有元素，用 if 条件判断时会自动调用构造函数添加该元素。判断是否有该元素课用map.count()或map.find().map.count()找到返回1，否则返回0。map.find()找到返回元素位置，找不到返回map.end()迭代器指针。 2. 两数相加(链表) 给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 1234567891011121314151617ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p = new ListNode(0); ListNode *temp = p; int carry = 0; while (l1 != nullptr || l2 != nullptr || carry != 0) &#123; int val1 = l1 != nullptr ? l1-&gt;val : 0; int val2 = l2 != nullptr ? l2-&gt;val : 0; int sum = val1 + val2 + carry; carry = sum / 10; ListNode *sumNode = new ListNode(sum % 10); temp-&gt;next = sumNode; temp = temp-&gt;next; if (l1 != nullptr) l1 = l1-&gt;next; if (l2 != nullptr) l2 = l2-&gt;next; &#125; return p-&gt;next;&#125; 3. 无重复字符的最长子串(滑动窗口) 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度 不重复最长子串 思路： 定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复我们定义不重复子串的开始位置为 start，结束位置为 end 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符 无论是否更新 start，都会更新其 map 数据结构和结果 ans。 时间复杂度：O(n) 12345678910111213141516171819int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; map; int left = 0, right = 0, len = 0; while (right &lt; s.length()) &#123; if (map.count(s[right]) == 0) &#123; map[s[right]] = right; &#125; else &#123; if (left &gt; map[s[right]]) &#123; //若出现的字符不在当前窗口内 map[s[right]] = right; &#125; else &#123; left = map[s[right]] + 1; map[s[right]] = right; &#125; &#125; right++; len = ((right - left) &gt; len) ? (right - left) : len; &#125; return len;&#125; 4. 搜索旋转排序数组 整数数组 nums 按升序排列，数组中的值互不相同。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1要求时间复杂度为 O(log(n)) 可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。 这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分： 如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。 12345678910111213141516171819202122232425int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (!n) return -1; if (n == 1) return target == nums[0] ? 0 : -1; int l = 0, r = n - 1; int mid = 0; while (l &lt;= r) &#123; mid = (l + r) / 2; if (target == nums[mid]) return mid; if (nums[mid] &gt; nums[r]) &#123; //前面有序，后面无序 if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) &#123; //target在前半部分 r = mid - 1; &#125; else &#123; //target在后半部分 l = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; &#125; return -1;&#125; 5. 最大数 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数. 题目 题解 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;string largestNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), [](int x, int y)&#123; int sx = 10, sy = 10; while (sx &lt;= x) &#123; sx *= 10; &#125; while (sy &lt;= y) &#123; sy *= 10; &#125; return x * sy + y &gt; y * sx + x; &#125;); if (nums[0] == 0) return &quot;0&quot;; string str = &quot;&quot;; for (int i : nums) &#123; str += to_string(i); &#125; return str;&#125;int main() &#123; vector&lt;int&gt; v = &#123;78, 7&#125;; cout &lt;&lt; largestNumber(v) &lt;&lt; endl; return 0;&#125; 6. 盛最多水的容器 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 思路：双指针，从两端往中间遍历，每次将两端较小的指针向中间移动，直到相遇。 证明如下：双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。 为什么对应的数字较小的那个指针不可能再作为容器的边界了？ 在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。 考虑第一步，假设当前左指针和右指针指向的数分别为 $x$ 和 $y$，不失一般性，我们假设 $x \\leq y$。同时，两个指针之间的距离为 $t$。那么，它们组成的容器的容量为： $$min(x, y)t &#x3D;xt$$ 我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x*t$ 了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。 我们任意向左移动右指针，指向的数为 $y_1$，两个指针之间的距离为 $t_1$，那么显然有 $t_1 &lt; t$，并且 $min(x, y_1) \\leq \\min(x, y)$ 如果 $y_1 \\leq y$，那么 $min(x, y_1) \\leq \\min(x, y)$ 如果 $y_1 &gt; y$，那么 $min(x, y_1) &#x3D; x &#x3D; min(x, y)$ 因此有： $$min(x, y_t) * t_1 &lt; min(x, y) * t$$ 即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。 这样一来，我们将问题的规模减小了 1，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界。便按照上述思路继续解决这个问题。 1234567891011121314151617181920212223242526//11.盛水最多的容器#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int maxArea(vector&lt;int&gt;&amp; height) &#123; int MAX = 0; int res = 0; int l = 0, r = height.size() - 1; while (l &lt; r) &#123; res = (height[l] &lt; height[r] ? height[l] : height[r]) * (r - l); if (height[l] &lt; height[r]) l++; else r--; if (res &gt; MAX) MAX = res; &#125; return MAX;&#125;int main() &#123; vector&lt;int&gt; v = &#123;1,8,6,2,5,4,8,3,7&#125;; cout &lt;&lt; maxArea(v) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/"},{"name":"LeetCode","slug":"刷题/LeetCode","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/LeetCode/"}],"tags":[{"name":"Hot 100","slug":"Hot-100","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Hot-100/"}]},{"title":"C语言中的可变参数详解(va_list, va_start...)","slug":"C语言中的可变参数详解-va-list-va-start","date":"2021-03-16T13:27:13.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"9c76e862.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/9c76e862.html","excerpt":"详解C语言中的可变参数(头文件stdarg.h)1. 获取函数的变长参数(va_list, va_start, va_arg, va_end)详细介绍 例：求若干个数的和 12345678910111213141516int func(int num, ...) &#123; //省略号前面有无逗号都可以 int sum; //在stdarg.h 头文件中 va_list list; //为 num 个参数初始化 valist va_start(list, num); for (int i = 0; i &lt; num; ++i) &#123; sum += va_arg(list, int); &#125; return sum;&#125;int main() &#123; cout &lt;&lt; func(5, 1, 2, 3, 4, 5) &lt;&lt; endl; return 0;&#125;","text":"详解C语言中的可变参数(头文件stdarg.h)1. 获取函数的变长参数(va_list, va_start, va_arg, va_end)详细介绍 例：求若干个数的和 12345678910111213141516int func(int num, ...) &#123; //省略号前面有无逗号都可以 int sum; //在stdarg.h 头文件中 va_list list; //为 num 个参数初始化 valist va_start(list, num); for (int i = 0; i &lt; num; ++i) &#123; sum += va_arg(list, int); &#125; return sum;&#125;int main() &#123; cout &lt;&lt; func(5, 1, 2, 3, 4, 5) &lt;&lt; endl; return 0;&#125; 步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 va_start 宏，获取可变参数列表的第一个参数的地址（list 是类型为 va_list 的指针，param1 是最后一个显式声明的参数）： 1#define va_start(list, param1) (list = (va_list)&amp;param1 + sizeof(param1)) va_arg 宏，返回变长参数的值，第二个参数是该变长参数的类型，返回指定类型并将指针指向下一参数（mode 参数描述了当前参数的类型）： 1#define va_arg(list, mode) ((mode *) (list += sizeof(mode)))[-1] va_end宏，清空va_list可变参数列表： 1#define va_end(list) (list = (va_list)0) 注：以上 sizeof() 只是为了说明工作原理，实际实现中，增加的字节数需保证为为 int 的整数倍 注意事项： a）他们都是宏，因此不能做运算和求地址等操作； b）变长参数的类型和数目不能通过宏来获取，只能通过自己写程序控制； c）编译器对变长参数函数的原型检查不够严格，会影响代码质量。 C中的 printf 函数实际上就使用了变长参数，实现原理如下所示(参考前文博客链接中代码)： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;stdarg.h&gt;using namespace std;void myprintf(const char *format...)&#123; va_list argptr; va_start(argptr, format); //va_start char ch; while (ch = *(format++)) &#123; //逐个遍历format字符串 if (ch == &#x27;%&#x27;) &#123; ch = *(format++); if (ch == &#x27;s&#x27;) &#123; char *name = va_arg(argptr, char *); //va_arg cout&lt;&lt;name; &#125; else if (ch == &#x27;d&#x27;) &#123; int age = va_arg(argptr, int); //va_arg cout&lt;&lt;age; &#125; &#125; else &#123; cout&lt;&lt;ch; &#125; &#125; cout &lt;&lt; endl; va_end(argptr); //va_end&#125;int main() &#123; myprintf(&quot;My name is %s, age %d.&quot;, &quot;AnnieKim&quot;, 24); return 0;&#125; 2. va_list 的用法C语言的 printf, scanf 函数不同于我们写的那种只能接受固定参数个数的函数，他们可以接受任意多个参数。C 语言允许定义这样的接受变参的函数, 它的机制就是 va_list , 使用它 , 我们也可以定义自己的变参个数的函数. 首先, 看下 printf 函数的声明: 1int printf(char * format, ... ); 变参处的定义或声明, 用 ... 代替参数类型. 变参 ... 只能放在参数列表最末尾. 这里我们写一个小程序, 来演示 va_list 的用法, 定义一个 barycentre 函数, 计算 n 个点的重心并返回, 声明如下: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdarg.h&gt;using namespace std;struct Point &#123; Point() &#123;&#125; Point(double _x, double _y) : x(_x), y(_y) &#123;&#125; double x, y;&#125;;struct Point barycentre(int n...) &#123; struct Point p; struct Point sum = &#123;0, 0&#125;; va_list list; va_start(list, n); for (int i = 0; i &lt; n; ++i) &#123; p = va_arg(list, Point); sum.x += p.x; sum.y += p.y; &#125; sum.x /= n; sum.y /= n; va_end(list); return sum;&#125;int main() &#123; Point P1 = Point(1.25, 3.0); Point P2 = Point(3.0, 5.2); cout &lt;&lt; barycentre(2, P1, P2).x; return 0;&#125; 从 va 的实现可以看出，指针的合理运用，把C语言简洁、灵活的特性表现得淋漓尽致，叫人不得不佩服 C 的强大和高效。不可否认的是，给编程人员太多自由空间必然使程序的安全性降低。va 中，为了得到所有传递给函数的参数，需要用va_arg依次遍历。其中存在两个隐患： 1）如何确定参数的类型。 va_arg 在类型检查方面与其说非常灵活，不如说是很不负责，因为是强制类型转换，va_arg 都把当前指针所指向的内容强制转换到指定类型； 2） 结束标志。如果没有结束标志的判断，va将按默认类型依次返回内存中的内容，直到访问到非法内存而出错退出。例2中 SqSum() 求的是自然数的平方和，所以我把负数和0作为它的结束标志。例如 scanf 把接收到的回车符作为结束标志，大家熟知的 printf() 对字符串的处理用 &#39;\\0&#39; 作为结束标志，无法想象C中的字符串如果没有&#39;\\0&#39;，代码将会是怎样一番情景，估计那时最流行的可能是字符数组，或者是 malloc&#x2F;free。 允许对内存的随意访问，会留给不怀好意者留下攻击的可能。当处理 cracker 精心设计好的一串字符串后，程序将跳转到一些恶意代码区域执行，以使 cracker 达到其攻击目的。(常见的 exploit 攻击)所以，必需禁止对内存的随意访问和严格控制内存访问边界。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"可变参数","slug":"可变参数","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2021-03-14T09:12:19.000Z","updated":"2023-08-08T12:35:27.384Z","comments":true,"path":"d0edc1ed.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/d0edc1ed.html","excerpt":"","text":"Linux常用的命令总结1. du查看文件大小 1du -sh du 是 disk usage 磁盘使用的缩写，-s 是查看总用量，-h 是以 M 为单位 2. tail输出文件的最后若干行内容 1ls -l / | tail -n2 表示查看根目录列表的最后两行信息 3. 管道1stdin | stdout 管道的表示是一条竖杠 |，将竖杠的左边的输出作为右边的输入，他们是两个程序。 例如 1curl --head www.baidu.com | grep -i content-length 就是将请求百度的 HTTP 报头，传送到 grep 程序中，计算字符个数，最终显示： 1Content-Length: 277 再例如 1curl --head www.baidu.com | grep -i content-length | cut --delimiter=&#x27; &#x27; -f2 表示将上述结果以空格进行切分，输出第二个参数，显然最终应该输出 1277 4. tee1echo &quot;welcome ysyx&quot; | tee ysyx.txt 从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。上述命令将字符串 welcome ysyx 输入到 ysyx.txt 文件中，并在命令行中输出该字符串 参数：-a： append，not overwrite 5. xdg-open1xdg-open &#123;file | URL&#125; 用用户默认的程序打开对应的文件和链接，比如链接就用网页打开，txt文件就用文本编辑器打开等。 6. find1sudo find /sys -name capacity -exec cat &#123;&#125; \\; \\表转义，在不同的脚本中 ; 有不同的含义，因此要转义 7. shell脚本创建自定义的命令：1vim mcd.sh 1234mcd() &#123; mkdir -p &quot;$1&quot; cd $1&#125; 12source mcd.shmcd a/b/c $0 - 脚本名 $1 到 $9 - 脚本的参数。$1 是第一个参数，依此类推 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 !! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 命令通常使用 STDOUT来返回输出值，使用STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本&#x2F;命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生 使用 !! 表明复用上一个执行的命令12mkdir /sys/newsudo !! &lt;(CMD)进程替换（process substitution）， &lt;(CMD) 会执行 CMD 并将结果输出到一个临时文件中，并将 &lt;(CMD) 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。 bash脚本编写123456789101112131415#!/bin/bashecho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null # 如果模式没有找到，则grep退出状态为1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone shellcheckshell脚本分析工具 htop能够可视化查看 CPU 占用和内存占用情况，并显示所有进程信息 8. alias1alias ll=&quot;ls -alh&quot; 该命令将 ll 映射为 ls -alh 注意后面的命令 = 前后没有空格，因为它只接收一个参数，加上空格便会解析成多个参数 但是，但是这样的映射在 shell 关闭之后将失效，要想让他们每次都生效，将命令写入 ~/.bashrc 中。 例 .bashrc: 123alias ll=&quot;ls -alh&quot; //列表显示所有文件，大小以单位显示alias mv=&quot;mv -i&quot; //让 mv 操作有提示信息PS1=&quot;&gt; &quot; //让 bash 命令行以 &quot;&gt; &quot;开头 9. rsync1rsync -avP . name@ip:folder rsync 支持断点下载，并保留原文件的权限，是一种比 scp 更有效的拷贝文件的方式","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"笔试题总结","slug":"笔试题总结","date":"2021-03-13T10:53:25.000Z","updated":"2023-08-08T12:35:27.418Z","comments":true,"path":"200b33f8.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/200b33f8.html","excerpt":"刷笔试题错误和易混点总结1. 下面哪些机制可以用于进程间通信？ Socket Named pipe Named event Critical Section Shared memory Virtual memory Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)Linux线程间通信：互斥量（mutex），信号量，条件变量Windows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）","text":"刷笔试题错误和易混点总结1. 下面哪些机制可以用于进程间通信？ Socket Named pipe Named event Critical Section Shared memory Virtual memory Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket)Linux线程间通信：互斥量（mutex），信号量，条件变量Windows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 2. Linux系统中的wc (Word Count) 命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出1．命令格式： wc [选项]文件… 2．命令功能： 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的***计数。 3．命令参数： -c 统计字节数。 -l 统计行数。 -m 统计字符数。这个标志不能与 -c 标志一起使用。 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L 打印最长行的长度。 -help 显示帮助信息 –version 显示版本信息 4．使用实例： 实例1：查看文件的字节数、字数、行数 命令： 1wc test.txt 输出： 1234567891011121314151617181920[root@localhost test] # cat test.txt hnlinuxpeida.cnblogs.comubuntuubuntu linuxredhatRedhatlinuxmint[root @localhost test] # wc test.txt7 8 70 test.txt[root @localhost test] # wc -l test.txt 7 test.txt[root @localhost test] # wc -c test.txt 70 test.txt[root @localhost test] # wc -w test.txt 8 test.txt[root @localhost test] # wc -m test.txt 70 test.txt[root @localhost test] # wc -L test.txt 17 test.txt 说明： 127 8 70 test.txt行数 单词数 字节数 文件名 3. Cookie可以用于验证用户，并且可以在无状态的HTTP上建立一个用户会话层正确 当浏览器访问服务器时，服务器会创建一个session对象（该对象有一个唯一的id号，称之为sessionId）服务器在默认的情况下，会将sessionId以cookie的方式，发送给浏览器，浏览器会将sessionId保存到内存中。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可以找到之间创建的session对象 4. 定义字符串 String str &#x3D; “用户1|用户2|用户3|用户4”，现在想要对字符串根据字符“|”进行分割解析，下面哪种分割方式是正确的？1str.split(&amp;ldquo;\\\\|&amp;rdquo;) |属于正则表达式中的字符，转义字符前面加\\\\ 5. ATM 既可以用于广域网，又可以用于局域网，这是因为它的工作原理与 Ethernet 基本上是相同的错误 ATM可以用于广域网，也可以用于广域网，一般用于广域网比较多。ATM的原理是采用面向连接的传输方式，将数据分割成固定长度的信元，通过虚连接进行交换。ATM的原理和以太网的原理是不一样的。 ATM是一种为了多种业务设计的通用的面向连接的传输模式。它适用于局域网和广域网，它具有高速数据传输率和支持许多种类型如声音、数据、传真、实时视频、CD质量音频和图像的通信。ATM采用面向连接的传输方式，将数据分割成固定长度的信元，通过虚连接进行交换。ATM集交换、复用、传输为一体，在复用上采用的是异步时分复用方式，通过信息的首部或标头来区分不同信道。 6. 如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是 protected void setColor() {…} void setColor() {…} public void setColor() {…} 以上语句都可以用在类BlueGlass中 JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。接口中属性为public static final，方法为public abstract. 7. 以下哪些命令可以查看当前系统的启动时间 w top ps uptime w: 查看当前登录到系统中的用户，并查看该用户正在运行的进程top: 查看Linux中的资源信息，第一行开始部分显示了系统当前时间，并显示已经运行了多长时间，两者相减就是系统启动时间uptime: 查看系统启动时间who -b: 查看登录到系统中的用户什么时候登录的 8. 关于Nginx的安全加固，以下说法正确的是 nginx的master进程不能以root权限启动 nginx的Worker进程不能以root权限启动 图片等静态资源目录不能给脚本执行权限 禁止访问.git、.svn和.sql目录，可以防止因运维操作不当造成的代码或数据泄漏","categories":[{"name":"工作","slug":"工作","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"笔试题","slug":"笔试题","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"}]},{"title":"自动化的实现（包括makefile脚本的使用）","slug":"自动化的实现（包括makefile脚本的使用）","date":"2021-03-12T13:26:06.000Z","updated":"2023-08-08T12:35:27.418Z","comments":true,"path":"ec9e8461.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/ec9e8461.html","excerpt":"makefile脚本的实现在此之前，我们编译内核都是通过手动输入一条一条命令实现的，但是随着我们的模块越来越多，每次编译内核再手动链接成一个二进制文件，最后再手动反汇编是很麻烦的。作为一名合格的计算机专业的大学生，这种手动模式是很不专业的，一是手输代码很容易出错，倘若我们更新了某个模块，却忘了重新编译链接的话，那么最后的内核就会出现一些难以排除的诡异 bug；二是，作为计算机专业的大学生，将工作自动化是理所应当的，这也是和其他专业的毕业生的一个区别。因此，要想真正的提升自己的技术水平，就必须懂得将业务逻辑进行自动化实现。 那么从现在开始，我们将把以前手动处理的编译链接反编译等一系列工作，全面自动化。 我们之前在 Windows 上也有一个简单的 bat 脚本，如下所示：","text":"makefile脚本的实现在此之前，我们编译内核都是通过手动输入一条一条命令实现的，但是随着我们的模块越来越多，每次编译内核再手动链接成一个二进制文件，最后再手动反汇编是很麻烦的。作为一名合格的计算机专业的大学生，这种手动模式是很不专业的，一是手输代码很容易出错，倘若我们更新了某个模块，却忘了重新编译链接的话，那么最后的内核就会出现一些难以排除的诡异 bug；二是，作为计算机专业的大学生，将工作自动化是理所应当的，这也是和其他专业的毕业生的一个区别。因此，要想真正的提升自己的技术水平，就必须懂得将业务逻辑进行自动化实现。 那么从现在开始，我们将把以前手动处理的编译链接反编译等一系列工作，全面自动化。 我们之前在 Windows 上也有一个简单的 bat 脚本，如下所示： 123456789101112131415161718192021222324252627@echo off::clsf:cd F:\\Code\\Java\\Java4LinuxOSnasm boot.asm -o boot::copy boot \\srcnasm kernel.asm -o kernel::copy kernel \\srccd srcjavac OS.javajava OSdel OS.classdel Floppy.classdel Floppy$MAGNETIC_HEAD.class::del boot::del kernelmove system.img ../cd F:\\Code\\Java\\Java4LinuxOSe:cd E:\\Virtual\\SimpleOSdel system.imgecho 原映像文件已删除copy F:\\Code\\Java\\Java4LinuxOS\\system.img E:\\Virtual\\SimpleOSecho 新映像已移动至虚拟机根目录下f:move F:\\Code\\Java\\Java4LinuxOS\\system.img F:\\bochs\\Bochs-2.6.11echo 新映像已移动至bochs根目录下 该脚本的作用是用 nasm 编译内核，运行 Java 类生成镜像文件，再将镜像文件传到虚拟机和 bochs 根目录下，这样一来，也能节省不少时间，而且不用启动 Java 编辑器了，也不用再一次次的点击复制粘贴了。但是这样的话还是需要在 Linux 中手动输入很多冗长的编译指令，下面的 makefile 脚本文件能够实现这些编译，链接，反汇编，以及传输等操作。首先，是内核 C 语言模块部分的编译，反汇编，以及从虚拟机传输到实体机。现在我们 C 内核有以下模块：write_vga_desktop.c,mem_util.c, mem_util.h, win_sheet.c, win_sheet.h。makefile内容如下： 12345678910111213141516171819202122ckernel.asm : ckernel.o ./objconv -fnasm ckernel.o -o ckernel.asmckernel.o : write_vga_desktop_win.o win_sheet.o mem_util.o ld -m elf_i386 -r write_vga_desktop_win.o mem_util.o win_sheet.o -o ckernel.owrite_vga_desktop_win.o : write_vga_desktop_win.c win_sheet.c win_sheet.h mem_util.c mem_util.h gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c write_vga_desktop_win.c -o write_vga_desktop_win.owin_sheet.o : win_sheet.c win_sheet.h gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c win_sheet.c -o win_sheet.omem_util.o : mem_util.c mem_util.h gcc -m32 -fno-pic -fno-asynchronous-unwind-tables -s -c mem_util.c -o mem_util.oall : ckernel.asm @cd src/ &amp;&amp; javac -encoding gbk OS.java @cd src/ &amp;&amp; mv OS.class ../ &amp;&amp; mv Floppy.class ../ &amp;&amp; mv Floppy\\$$MAGNETIC_HEAD.class ../ &amp;&amp; mv ProcessASMFile.class ../ @rm *.class java OS ckernel.asm @cp system.img /home/cherry/Virtual @echo &quot;镜像已移动到虚拟机根目下&quot; @mv system.img /home/cherry/Bochs @echo &quot;镜像已移动到Bochs根目下&quot; @rm ckernel.o write_vga_desktop_win.o win_sheet.o mem_util.oclean: rm ckernel.o write_vga_desktop_win.o win_sheet.o mem_util.o 其中，我将OS.java和ProcessASMFile.java结合起来，并且增加了通过Java来执行命令行的功能，使用Runtime.getRuntime().exec()函数实现。 makefile脚本中转义字符为\\$，在要转义字符的前面加上这个符号表示转义单个字符。 我们将不想显示的命令前面加@来隐藏，然后再将我们需要操作的文件夹在虚拟机上共享。 最终运行效果如下： 感觉makefile脚本中all指令执行有点繁琐，总是将字节码移来移去，最好的方式是在src源代码目录下运行Java，处理asm文件，运行nasm命令，然后在根目录下生成boot, kernel二进制文件并生成system.img镜像","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"脚本","slug":"生产力工具/脚本","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%84%9A%E6%9C%AC/"},{"name":"makefile","slug":"makefile","permalink":"https://cherryyang05.github.io/hexo-blog/tags/makefile/"}]},{"title":"C/C++常用函数整理","slug":"C++常用函数整理","date":"2021-03-08T11:29:56.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"37079a34.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/37079a34.html","excerpt":"C&#x2F;C++ 中常用函数","text":"C&#x2F;C++ 中常用函数 1. time1clock_t clock(void); 简单而言，就是该程序从启动到函数调用占用 CPU 的时间。这个函数返回从“开启这个程序进程”到“程序中调用 clock()函数”时之间的 CPU 时钟计时单元(clock tick)数，在 MSDN 中称之为挂钟时间(wal-clock)；若挂钟时间不可取，则返回-1。其中 clock_t 是用来保存时间的数据类型。在 time.h 文件中，我们可以找到对 clock_t()的定义： 1234#ifndef _CLOCK_T_DEFINEDtypedef long clock_t;#define _CLOCK_T_DEFINED#endif 例： 1234int time_begin = clock();func();int time_end = clock();cout &lt;&lt; (time_end - time_begin) / CLOCKS_PER_SEC &lt;&lt; endl; 2. fill1fill(v.begin(), v.end(), val); //将容器中每个元素被重置为val fill 函数作用是将一个区间的元素赋值为 val，该 val 可以非零，包含在 algorithm 头文件里。 和 memset 函数区别：我们定义数组时通常喜欢用 memset 函数赋初值 0，但是实际上 memset 也只能赋值为 0。函数原型如下： void *memset(void *s, int ch, size_t n); 函数功能是：将 s 所指向的某一块内存中的前 n 个字节的内容全部设置为 ch 指定的 ASCII 值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为指向 s 的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。 但是要注意的是， memset 是按照一个一个字节进行初始化的，如果初始化的值为 0，则结果是对的，但是如果将一个 int 型变量初始化为 1，则不能使用 memset，因为初始化后该变量会变成 00000001 00000001 00000001 00000001，这样的值便是错误的。 这是和 fill 最根本的区别。 参考博客 3. next_permutation1bool next_permutation(iterator start,iterator end) 该函数是获得容器内序列的下一个排列组合，包含在头文件 algorithm 中。 示例： 12345string str;sort(str.begin(), str.end());do &#123; cout &lt;&lt; str &lt;&lt; endl;&#125; while(next_permutation(str.begin(), str.end())); 此外，next_permutation(v, v + n, cmp)可以对结构体 num 按照自定义的排序方式 cmp 进行排序 若要求的字典序是 &#39;A&#39;&lt;&#39;a&#39;&lt;&#39;B&#39;&lt;&#39;b&#39;&lt;...&lt;&#39;Z&#39;&lt;&#39;z&#39;，则可以自定义 cmp 函数： 12345678910111213141516171819202122232425#include &lt;iostream&gt; //poj 1256 Anagram#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int cmp(char a, char b) &#123; if(tolower(a) != tolower(b)) //tolower 是将大写字母转化为小写字母. return tolower(a) &lt; tolower(b); else return a &lt; b;&#125;int main() &#123; char ch[20]; int n; cin &gt;&gt; n; while(n--) &#123; scanf(&quot;%s&quot;, ch); sort(ch, ch + strlen(ch), cmp); do &#123; printf(&quot;%s\\n&quot;, ch); &#125; while(next_permutation(ch, ch + strlen(ch), cmp)); &#125; return 0;&#125; 参考博客 4. stoi1stoi(string, pos, n进制) stoi(string to int)，表示将 n 进制的字符串转化为十进制 和 atoi 的比较： 相同点： ① 都是 C++的字符处理函数，把数字字符串转换成 int 输出② 头文件都是 #include&lt;cstring&gt; 不同点： ① atoi()的参数是 const char，因此对于一个字符串 str 我们必须调用 c_str() 的方法把这个 string 转换成 const char 类型的,而 stoi()的参数是 const string，不需要转化为 const char； ② stoi()会做范围检查，默认范围是在 int 的范围内的，如果超出范围的话则会 runtime error.而 atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界。 5. GetTickCountGetTickCount 是一种函数。GetTickCount 返回(retrieve)从操作系统启动所经过(elapsed)的毫秒数，它的返回值是 DWORD。函数原型： 1DWORD GetTickCount(void); 头文件：C&#x2F;C++头文件：winbase.hwindows 程序设计中可以使用头文件 windows.h 例： 12345678910111213#include&lt;iostream&gt;#include&lt;Windows.h&gt;using namespace std;int main() &#123; DWORD startTime = GetTickCount();//计时开始 for (int i = 0; i &lt; 2147483640; i++) &#123; i++; &#125; DWORD endTime = GetTickCount();//计时结束 cout &lt;&lt; &quot;The run time is:&quot; &lt;&lt; endTime - startTime &lt;&lt; &quot;ms&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; GetTickcount 函数：它返回从操作系统启动到当前所经过的毫秒数，常常用来判断某个方法执行的时间，其函数原型是 DWORD GetTickCount(void)，返回值以 32 位的双字类型 DWORD 存储，因此可以存储的最大值是(2^32-1) ms 约为 49.71 天，因此若系统运行时间超过 49.71 天时，这个数就会归 0，MSDN 中也明确的提到了:”Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.”。因此，如果是编写服务器端程序，此处一定要万分注意，避免引起意外的状况。 特别注意：这个函数并非实时发送，而是由系统每 18ms 发送一次，因此其最小精度为 18ms。当需要有小于 18ms 的精度计算时，应使用 StopWatch 方法进行。用 clock()函数计算运行时间，表示范围一定大于 GetTickCount()函数，所以，建议使用 clock()函数。 参考网站 6. C 中的可变参数包含在头文件 stdarg.h 中 例：求若干个数的和 1234567891011121314151617int func(int num, ...) &#123; //省略号前面有无逗号都可以 int sum; //在stdarg.h 头文件中 va_list list; //为 num 个参数初始化 valist va_start(list, num); for (int i = 0; i &lt; num; ++i) &#123; sum += va_arg(list, int); &#125; return sum;&#125;int main() &#123; cout &lt;&lt; func(5, 1, 2, 3, 4, 5) &lt;&lt; endl; cout &lt;&lt; func(4, 1, 2, 3, 4) &lt;&lt; endl; return 0;&#125; 步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 详细介绍 7. sprintf1int sprintf(char *buffer, const char *format, ...) 1. 把整数 123 打印成一个字符串保存在 s 中 1sprintf(s, &quot;%d&quot;, 123); //产生&quot;123&quot; 2. 格式对齐 123sprintf(s, &quot;%08X&quot;, 4567);//产生：000011D7sprintf(s, &quot;%-8x&quot;, 4567);//产生：11D7，小写16进制，左对齐sprintf(s, &quot;%8X&quot;, 4567);//产生：11D7，大写十六进制，右对齐 3. 取对应个数的字符 1234char a1[] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;&#125;;char a2[] = &#123;&#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;&#125;;sprintf(s, &quot;%.7s%.7s&quot;, a1, a2);//产生：&quot;ABCDEFGHIJKLMN&quot; 这可以类比打印浮点数的 &quot;%m.nf&quot;，在 &quot;%m.ns&quot; 中，m 表示占用宽度（字符串长度不足时补空格，超出了则按照实际宽度打印），n 才表示从相应的字符串中最多取用的字符数。通常在打印字符串时 m 没什么大用，还是点号后面的 n 用的多。自然，也可以前后都只取部分字符： 1234sprintf(s, &quot;%.6s%.5s&quot;, a1, a2);//产生：&quot;ABCDEFHIJKL&quot;sprintf(s, &quot;%.*s%.*s&quot;, 7, a1, 7, a2);//或者sprintf(s, &quot;%.*s%.*s&quot;, sizeof(a1), a1, sizeof(a2), a2); 4. 实际上，前面介绍的打印字符、整数、浮点数等都可以动态指定那些常量值比如： 1234sprintf(s, &quot;%-*d&quot;, 4, &#x27;A&#x27;); //产生&quot;65 &quot;sprintf(s, &quot;%#0*X&quot;, 8, 128); //产生&quot;0X000080&quot;，&quot;#&quot;产生0Xsprintf(s, &quot;%*.*f&quot;, 10, 2, 3.1415926); //产生&quot; 3.14&quot;//这里 (%*.*f) 相当于 (%10.2f), 表示该浮点数保留 2 位小数，并且向右靠齐占位 10 个字符 5. sprintf(s, “%p”, &amp;i); 6. strlen 便已经知道了结果字符串的长度 1int len = sprintf(s, &quot;%d&quot;, i); 对于正整数来说，len 便等于整数 i 的 10 进制位数。 sprintf 函数属于 C 库函数，功能是将标准输出到字符串 buffer 中(C 语言的中的字符数组)，若写入成功则返回写入的字符数量，否则返回负值，除了第一个参数外，其他参数同 printf 8. sscanf1int sscanf(const char *s, const char *format, ...); sscanf 与 scanf 等价，所不同的是，前者的输入字符来源于字符串 s，而 scanf 以 stdin 作为输入源 **1. %d, %s: * 号表示此数据不读入，忽略掉 比如: 1234ch = &quot;MemTotal:2028248 kB&quot;sscanf(ch, &quot;%*s%d&quot;, &amp;total);printf(&quot;%d\\n&quot;, total);输出结果：2028248 [注意] sprintf 中的 * 号表示占位符，类似于 JDBC 中的 ?，而 sscanf 中的 * 号表示跳过对应格式的数据不读入 2. 取指定长度的字符串 123sscanf(&quot;123456 &quot;, &quot;%4s&quot;, buf);printf(&quot;%s\\n&quot;, buf);结果为：1234 3. 取到指定字符为止的字符串在下例中，取遇到空格为止的字符串 123sscanf(&quot;123456 abcdedf&quot;, &quot;%[^ ]&quot;, buf);printf(&quot;%s\\n&quot;, buf);结果为：123456 4. sscanf(ch, “%*[^e]%[^2]”, ch1)寻找e到2之间的数，包括e但不包括2如果中间有空格，包括空格。 5. 给定一个字符串”hello, world”，仅保留world（注意：”，”之后有一空格） 123sscanf(“hello, world”, &quot;%*s%s&quot;, buf);printf(&quot;%s\\n&quot;, buf);结果为：world %*s 表示第一个匹配到的 %s 被过滤掉，即 hello 被过滤了如果没有空格则结果为NULL 6. 分割字符串 12sscanf(&quot;2006:03:18&quot;, &quot;%d:%d:%d&quot;, a, b, c);sscanf(&quot;2006:03:18 - 2006:04:18&quot;, &quot;%s - %s&quot;, sztime1, sztime2); 如果 2006:03:18 - 2006:04:18 间没有空格 1sscanf(&quot;2006:03:18 - 2006:04:18&quot;, &quot;%[0-9,:] - %[0-9,:]&quot;, sztime1, sztime2); 9. c_str1const char *c_str(); c_str() 函数返回一个指向正规 C 字符串的指针常量，内容与本 string 串相同。这是为了与 c 语言兼容，在 c 语言中没有 string 类型，故必须通过 string 类对象的成员函数 c_str()把 string 对象转换成 c 中的字符串样式。 c_str 是一个内容为字符串指向字符数组的临时指针； c_str 返回的是一个可读不可改的常指针； 注意：一定要使用 strcpy() 函数等来操作方法 c_str() 返回的指针 。 比如：最好不要这样： 123char* c;string s = &quot;1234&quot;;c = s.c_str(); c 最后指向的内容是垃圾，因为 s 对象被析构，其内容被处理，同时，编译器也将报错——将一个 const char 赋与一个 char 。 应该这样用： 123char c[20];string s = &quot;1234&quot;;strcpy(c, s.c_str()); 这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作。 10. 用 scanf 读入 string12345string a;a.resize(100); //需要预先分配空间scanf(&quot;%s&quot;, &amp;a[0]);puts(a.c_str());return 0; 11. 5 种读入整行字符串的操作1. scanf()读入 char[] 123char str[1024];scanf(&quot;%[^\\n]&quot;, &amp;str);getchar(); 说明：在 scanf 函数中，可以使用 %c来读取一个字符，使用 %s 读取一个字符串，但是读取字符串时不忽略空格，读字符串时忽略开始的空格，并且读到空格为止，因此只能读取一个单词，而不是整行字符串。 其实 scanf 函数也可完成这样的功能，而且还更强大。这里主要介绍一个参数:%[]，这个参数的意义是读入一个字符集合。[] 是个集合的标志，因此 %[] 特指读入此集合所限定的那些字符，比如 %[A-Z] 是输入大写字母，一旦遇到不在此集合的字符便停止。如果集合的第一个字符是 &quot;^&quot;，这说明读取不在 &quot;^&quot; 后面集合的字符，即遇到 &quot;^&quot; 后面集合的字符便停止。注意此时读入的字符串是可以含有空格的，而且会把开头的空格也读进来。 注意：如果要循环的多次从屏幕上读取一行的话，就要在读取一行后，在用 %c 读取一个字符，将输入缓冲区中的换行符给读出来。否则的话，在下一次读取一行的时候，第一个就遇到&#39;\\n&#39;，匹配不成功就直接返回了。这里可以用 scanf() 或者 getchar() 函数读取换行符。 2. getchar() 读入 char[] 12345char str[1024];int i = 0;while((str[i] = getchar()) != &#x27;\\n&#x27;) i++;getchar(); 说明：这样一个一个读也可以，也会把开头的空格读进来。最后也需要考虑换行符，使用 getchar() 读出来。 3. gets()读入 char[] 12char str[1024];gets(str); 说明：感觉这个就是多个 getchar 的集合函数，很好用。功能是从标准输入键盘上读入一个完整的行（从标准输入读，一直读到遇到换行符），把读到的内容存入括号中指定的字符数组里，并用空字符 &#39;\\0&#39; 取代行尾的换行符 &#39;\\n&#39;。读入时不需要考虑换行符。 4. getline() 读入 string 或 char[] 12345string str;getline(cin, str); //读入stringchar str2[1024];cin.getline(str2, 1024); //读入char数组 说明：这是比较常用的方法，cin.getline 第三个参数表示间隔符，默认为换行符&#39;\\n&#39;。读入不需要考虑最后的换行符。 5. get() 读入 char[] 12char str3[1024];cin.get(str3, 1024); //读入char数组 说明：get 函数读入时需要考虑最后的换行符，也就是说，如果用 get 读入多行数据，要把 &#39;\\n&#39; 另外读出来，一般使用 cin.get(str, 1024).get(); 来读入多组数据。 12. reversereverse 这个函数功能非常强大，作用是将序列[first,last)的元素在原容器中翻转，包含在algorithm库中 reverse()函数无返回值，时间复杂度O(n) 注意区间是 [begin, end)，左闭右开 可以作用于 vector，string，普通数组 123456789vector&lt;int&gt; v = &#123;1, 2, 3&#125;;reverse(begin(v), end(v));reverse(v.begin(), v.end());int a[] = &#123;4, 5, 6, 7&#125;;reverse(begin(a), end(a));string str = &quot;My name is Cherry.&quot;;reverse(str.begin(), str.end()); 13. sort(lamda表达式)这个函数应该很熟悉了，这里我们主要介绍他的lamda 表达式的用法。 1234567891011121314151617struct stu &#123; string name; int id; stu() &#123;&#125; stu(string _name, int _id) : name(_name), id(_id) &#123;&#125;&#125;stu s[10];sort(s, s + 10, [](stu s1, stu s2) &#123; if (s1.name == s2.name) return s1.id &lt; s2.id; else return s1.name &lt; s2.name;&#125;);//也可以写成下面这样，因为根据return可清楚的知道返回类型为bool，便不用显式声明了sort(s, s + 10, [](stu s1, stu s2) -&gt; bool &#123; if (s1.name == s2.name) return s1.id &lt; s2.id; else return s1.name &lt; s2.name;&#125;); 这里 sort 函数的第三个参数，[]叫做捕获说明符，表示一个 lamda 表达式的开始，接下来是参数列表，即这个 lamda 函数的参数。 [] 表示该 lambda 表达式是不能访问任何外部变量的，即表达式的函数体内无法访问当前作用域下的变量。[=] 表示按值访问， [&amp;] 表示按引用访问变量之间用逗号分隔，比如 [=factor, &amp;total] 表示按值访问变量 factor，而按引用访问 total。 示例： 1234int test = 100;auto fl = [test](int x, int y) &#123; //这里要传入test才能在lamda表达式中访问 return test + x + y;&#125;;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"}],"tags":[{"name":"STL函数","slug":"STL函数","permalink":"https://cherryyang05.github.io/hexo-blog/tags/STL%E5%87%BD%E6%95%B0/"},{"name":"C/C++","slug":"C-C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C-C/"}]},{"title":"博弈论 第2节 学会换位思考","slug":"博弈论-第2节-学会换位思考","date":"2021-03-03T13:47:12.000Z","updated":"2023-08-08T12:35:27.416Z","comments":true,"path":"ccda0dbe.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/ccda0dbe.html","excerpt":"耶鲁博弈论 第2节 学会换位思考","text":"耶鲁博弈论 第2节 学会换位思考 一些定义形成博弈的要素 参与人（players），用 $i$, $j$ 表示 参与人的策略（strategies），用 $s_{i}$，$s_{j}$ 表示；所有可能的策略集合 $S_{i}$，区别于参与人的策略小写 $s$；某一次博弈 $s$，用不带下标的 $s$ 表示，称为策略组合（a strategy profile），也称为策略向量 博弈的收益（payoffs），用大写的 $U$ 表示，$U_{i}$ 取决于参与博弈的 $N$ 个人的博弈策略，记做 $(s_{1},…,s_{i},…,s_{i})$，简写为 $U_{i}(s)$，由策略组合决定（即所有参与博弈的人） 我们用 $s_{-i}$ 表示除了 $i$ 之外的其他参与者的决策，因为考虑在和对手在不同选择下的收益是很有必要的，填数游戏中以标准形式描述博弈： $$U_{i}(s)&#x3D;\\begin{cases} 5美元 - 误差 \\ 0\\end{cases}$$ 再用一个例子熟悉使用符号语言来描述博弈： 左 中 右 上 5, -1 11, 3 0, 0 下 6, 4 0, 2 2, 0 这里参与人是 $A$ 和 $B$策略集合是 $S_{1}&#x3D;{上，下}$，$S_{2}&#x3D;{左，中，右}$收益：例如 $U_{1}(上，中)&#x3D;11$，$U_{2}(下，右)&#x3D;0$显然对于参与者 $B$，右是严格劣势策略。因此我们给出 严格优势策略的定义： $$\\begin{aligned}参与人 i 的策略 s_{i}^{‘} 严格劣于参与人 i 的另一个策略 s_{i}，在其他参与者\\ 选择 s_{-i} 时，选择 s_{i} 的收益 U_{i}(s_{i}) 严格优于此情况下 s_{i}^{‘} 的收益 U_{i}(s_{i}^{‘})\\end{aligned}$$ 再来一个例子： 汉尼拔将军将要攻打一个国家，他有两个营的兵力，他可以选择从崎岖道路（翻过阿尔卑斯山）进军（但是行军途中要损失一个营的兵力），也可以选择从平坦的道路（平原）进军（途中没有损失）。防守者只能在崎岖道路和平坦道路其中之一设防，当进攻者遇到防守者时，进攻者将损失一个营的兵力。若你是防守者，你该选择何处设防？ 双方收益如下：（行是防守者，列是进攻者） easy hard easy 1, 1 1, 1 hard 0, 2 2, 0 在这个例子中，防守者似乎没有严格优势策略，但是对于汉尼拔将军（进攻方）来说，选择平坦道路进攻似乎优于从崎岖道路进攻，这只是一个优势策略，并非严格优势，只是一个弱优势。我们引出 弱优势 的定义： $$\\begin{aligned}\\begin{array}{c}参与人 i 的策略 s_{i}^{‘} 弱于参与人 i 的另一个策略 s_{i}，在其他参与者\\选择 s_{-i} 时，选择 s_{i} 的收益 U_{i}(s_{i}) 大于等于此情况下 s_{i}^{‘} 的收益 U_{i}(s_{i}^{‘})，即\\U_{i}(s_{i},s_{-i}) \\geq U_{i}(s_{i}^{‘},s_{-i})\\ for\\ all\\ s_{-i} \\U_{i}(s_{i},s_{-i}) &gt; U_{i}(s_{i}^{‘},s_{-i})\\ for\\ some\\ s_{-i}\\end{array}\\end{aligned}$$ 回到填数游戏好，那么我们现在回到第一节课的填数游戏，在 $1-100$ 之间任选一个数，最接近平均数的 $\\frac{2}{3}$ 的人获胜。 老师询问了填 $33-35$ 之间的数的同学，他们回答：大家在 $1-100$ 之间随机选择一个数，最后平均值会在 $50$ 左右，而 $50$ 的三分之二就是 $33$ 左右。 这个说法看似正确，但是却忽略了一个重要前提：教室里的人并不会随机选择一个数，他们都想赢得这5美元。若人人都这样想，最终平均值会趋近于 $33$，而 $33$ 的三分之二是 $22$。然而，这还是太大了。 再次重申这个游戏的重点：每个人都有自己的策略，每个人都想赢。 那么我们来分析一下这个游戏，哪些选择是（弱）劣势策略？ 设想最坏的情况，每个人都选了 $100$ 那么这样最终的结果也只是 $66\\frac{2}{3}$ 最接近的是 $67$，那么选择大于 $67$ 的数相对于 $67$ 来说就是弱劣势策略。这样对于理智的人来说，游戏简化成了在 $1-67$ 之间选择一个数，因为他们知道没人会选择 $67$ 以上的数。同样，相似的策略也会被排除，这样，$45$ 以上的数也不会有人选。但是 $45-67$ 之间的数在原博弈中并不是弱劣势策略，可是我们排除掉 $67-100$ 的时候，$45-67$ 便成为了弱劣势策略。同理，$30-45$ 也被排除，$20-30$，$14-20$……直至 $1$. 尽管 $1$ 就是这个游戏的最优策略，但是这一切都是建立在参与人都是理性的情况下，并且理性的参与者知道其他人也都是理性的。我们用术语共同知识来描述类似：我知道，我知道你知道，我知道你知道我知道…这样的循环。但是实际上，每个区间的数都有人选择，这就要考虑分布的问题了。最终老师公布结果，平均数在 $13$ 左右，最终选择 $9$ 的人获得了胜利，巧的是，这也是所有人选择的中位数。 按照之前的最优策略，为什么 $1$ 不是最终结果呢？尽管有相当一部分人选择了 $1$，","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"博弈论","slug":"课程笔记/博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"博弈论 第1节 导论——五个入门结论","slug":"博弈论-第1节-导论——五个入门结论","date":"2021-03-01T15:49:00.000Z","updated":"2023-08-08T12:35:27.416Z","comments":true,"path":"2558636.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/2558636.html","excerpt":"耶鲁博弈论 第1节 导论——五个入门结论 本系列笔记来自耶鲁博弈论，课程视频来自b站耶鲁大学：博弈论，笔记不定期更新。","text":"耶鲁博弈论 第1节 导论——五个入门结论 本系列笔记来自耶鲁博弈论，课程视频来自b站耶鲁大学：博弈论，笔记不定期更新。 一、开胃菜——成绩博弈 开场游戏：你和你的同桌在完全不知情的情况下，填写自己的成绩 $α$ 和 $β$，然后老师将所有同学随机分成两两一组，你的成绩将按照以下情况给出：(1)若你填写 $α$ 你的对手填写 $β$，你将得到 $A$ 等级，你的对手将得到 $C$ 等级(2)若你填写 $α$ 你的对手填写 $α$，你将得到 $B-$ 等级，你的对手将得到 $B-$ 等级(3)若你填写 $β$ 你的对手填写 $β$，你将得到 $B+$ 等级，你的对手将得到 $B+$ 等级(4)若你填写 $β$ 你的对手填写 $α$，你将得到 $C$ 等级，你的对手将得到 $A$ 等级 课堂上老师询问了几个选 $α$ 的同学的理由，第一个人觉得对方也会填 $α$，所以我要填 $α$；第二个人的理由是，填 $α$ 的结果总要优于填 $β$.而选择 $β$ 的同学觉得选择 $β$ 成绩波动较小，（会从B+波动到C）（实际上选择 $α$ 波动和 $β$ 一样，从A到B-）；另一个觉得一开始大家可以合作，都填 $β$ 获得最大利益。 目前我们涉及到博弈的行为、策略、参与人，但是忽略了一个博弈的必备要素：动机(objectives). 下面我们用效用矩阵表示收益（Possible Payoffs）： 可能情况 Pair Me α,α α,β β,α β,β 效用 Pair Me 0, 0 3,-1 -1,3 1, 1 前提是所有人只在乎自己的成绩，并且努力想取得更高的成绩。这里显然能够看出，不管对手选择什么，选择 $α$ 的效益始终大于 $β$ $（0 &gt; -1, 3 &gt; 1）$ 我们称这种始终不会取得劣势的选择称作严格优势策略 因此得到第一个结论：1.不要选择严格劣势策略，原因很简单，the payoffs are lower.但似乎这样的结论有些过于简单而不值得讨论。 但是如若别人也是这样想，选择了 $β$，那么你们都将获得 1 的效用，而 1 是 大于 0 的，因此选择 $β$ 是更好的选择，这似乎与第一个结论有些矛盾。 实际上这种说法有两个问题，其一，我的想法实际上是无法影响到你的想法，也就是我的选择无法左右你的选择，其二，建立在第一个假设上，若我的想法能够左右你的想法，那么为了争取最大的效用，我应该选择 $α$ 而不是 $β$ 由此得到第二个结论：2.理性的选择（严格优势策略）往往使得结果变得糟糕协商难以达成的原因不是缺少沟通，而是没有强制力 （囚徒困境，三个和尚没水吃，企业价格战） 换种情况，若效用矩阵变成下面这样： 效用 Pair Me 0, 0 -1,-1 -3, 3 1, 1 若我选择 $α$，而对手选择了 $β$，但是我感到愧疚，良心受到谴责，减去我的负罪感的负效用后只得到了 -1（把他称作负罪感）。相反我选择 $β$，而对手选择了 $α$，觉得不服气只得到了 C，因此下次要好好学习，表现出了雄心壮志，并且这个成绩是因为对手选了 $α$ 所致，在道义上的谴责又减去了一些效用，最终变成了 -3. 选 $α$ 的人觉得这样可以最小化损失，而选 $β$ 的人觉得这样有机会获得最大效用 1. 当对方选择 $α$ 时，我应该选择 $α$ 才能获得最大效用，相反，当对方选择 $β$ 时，我也应该选择 $β$ 才能得到最大效用。因此，这种情况下没有严格优势策略，而这也仅仅是改变了博弈的收益，并没有改变博弈的结构和结果，但是我们的目的被改变了。第一种情况我们显然应该选择 $α$，而第二种情况我们却不知道该选什么，这种博弈叫 协和谬误 由此得出第三个结论：3.汝欲得之，必先知之永远选择优势策略，损失小，如果对手有优势策略应以此作为选择策略的指导 第三种情况，我们更改对手每种情况的效用，如下： 效用 Pair Me 0, 0 3,-3 -1, -1 1, 1 显然，$α$ 是严格优势策略，选择 $α$ 更好。 第四种情况，仅仅修改我自己不同情况下的效用，如下： 效用 Pair Me 0, 0 -1,-1 -3, 3 1, 1 这种情况下，对我自己而言，没有了所谓的严格优势策略，但是对于对手而言，$α$ 是严格优势策略，他必定会选择 $α$，因此我只能选择 $α$ 来获得最大效用。 因此得到第四个结论：4.站在对方的立场上去分析对方会怎么做 综上可以得到第五个结论： 5.人都是自私的 填数游戏 每个人写下 $1-100$ 中随机一个数，最终离平均数的 $\\frac{2}{3}$ 最接近的人获得奖励 解析请看下节… 【老师每节课开奖是为了不让学生逃课吗？（笑）】","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"博弈论","slug":"课程笔记/博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"TFTP简单文本传输协议的基本原理","slug":"TFTP简单文本传输协议的基本原理","date":"2020-06-10T11:32:31.000Z","updated":"2023-08-08T12:35:27.404Z","comments":true,"path":"2c942dc5.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/2c942dc5.html","excerpt":"TFTP简单文本传输协议的介绍随着互联网发展，文件传输效率越来越快，相应的传输协议也越来越复杂。早年有很多文件传输协议如今已经很少再用，所谓老兵不死，只是慢慢凋零。这些协议尽管现在使用不多，但它们的设计思想依然值得我们好好研究和掌握。 例如 FTP 以及它的 UDP 版本 TFTP，它们实现文件传输的协议设计思想依然非常值得研究，它对我们设计新协议依然很有启发性。本节开始，我们研究 TFTP 协议的原理以及相关代码实现。 TFTP 原名叫Trivial File Transport Protocol.对互联网早期存有记忆的同学对 FTP 协议一定非常了解，当时局域网乃至整个网络上很多大文件，例如电影的传输依靠的就是该协议。FTP 协议运行在 TCP 协议之上，它的内容很复杂，除了文件传输外，它还支持很多文件相关操作，例如远程实现文件建立，删除等。TFTP 是 FTP 协议的简化版，它运行在 UDP 协议上，同时简化了很多 FTP 操作，只支持文件的传输功能。","text":"TFTP简单文本传输协议的介绍随着互联网发展，文件传输效率越来越快，相应的传输协议也越来越复杂。早年有很多文件传输协议如今已经很少再用，所谓老兵不死，只是慢慢凋零。这些协议尽管现在使用不多，但它们的设计思想依然值得我们好好研究和掌握。 例如 FTP 以及它的 UDP 版本 TFTP，它们实现文件传输的协议设计思想依然非常值得研究，它对我们设计新协议依然很有启发性。本节开始，我们研究 TFTP 协议的原理以及相关代码实现。 TFTP 原名叫Trivial File Transport Protocol.对互联网早期存有记忆的同学对 FTP 协议一定非常了解，当时局域网乃至整个网络上很多大文件，例如电影的传输依靠的就是该协议。FTP 协议运行在 TCP 协议之上，它的内容很复杂，除了文件传输外，它还支持很多文件相关操作，例如远程实现文件建立，删除等。TFTP 是 FTP 协议的简化版，它运行在 UDP 协议上，同时简化了很多 FTP 操作，只支持文件的传输功能。 TFTP协议是基于服务器和客户端之间的传输协议。一开始客户端向服务器发出连接请求，服务器应答后两者连接建立。然后客户端向服务器发出文件传输请求，服务器将客户端需要的文件分割成多个小块，依次传递给客户端，客户端每收到一个小块后向服务器发出应答，收到应答后服务器再发送下一个小块。当所有文件块传输完毕后，两者连接断开。 TFTP 服务器程序通常在端口 69 监听客户端请求。值得注意的是，当服务器与客户端进行数据块传输时，服务器会使用一个随机端口而不是用于监听请求的 69 端口，这是为了服务器能同时相应多个客户端的连接。服务器与不同客户端使用不同端口进行数据通信，这样就保证不同客户端所需要的数据块不会发生混淆。 服务器与客户端在发送文件数据时，会按照一种名为”锁定步骤”的方式进行数据传输。也就是服务器向客户端发送一个数据块，再接收到客户端发回的应答数据包前什么都不做，直到收到客户端确定数据块已经收到的应答后，它才发送下一个数据块，这种方式使得数据传输效率不高，但确保数据传输流程足够简单，同时能保证传输出错时，数据重传很方便，同时客户端也不用考虑数据块不按次序抵达时，如何将数据块进行正确组装。 TFTP 协议的简单附带的代价是效率不高。由于它走的是 UDP 协议，因此一次发送数据块不能超过 512 字节，这也是服务器必须把文件切成小块反复传输的原因。还有一点值得注意的是 TFTP 协议没有任何安全措施，它不需要注册或登录，任何客户端都可以连接然后下载文件。 我们首先在网络上下载一个 TFTP 的服务器客户端：Tftpd64 具体界面如下： 然后在 Windows 中的设置的程序与功能中打开 TFTP Client: TFTP抓包演示我们在 TFTP 服务器客户端上选择我们的 IP 地址：192.168.1.101，然后这台电脑就可以作为我们的 TFTP 服务器了，然后我们在命令行中输入：tftp 192.168.1.101 get test.txt(test.txt 是我特地新建的用来测试的文件，该文件必须存放在 tftp 服务器客户端软件中 Current Directory 所显示的目录中)： 然后就可以在当前磁盘（G盘）中看到我们传送的文件了 需要注意的几个问题: 文件传送成功与否，你朋友也可以在 Tftpd32 的 “Tftp Server” 和 “Current Action”这两项中看到。 如果想把文件传给你朋友，那么只要把命令换成 “Tftp -i朋友IP put pictures.rar” 即可。关于Tftp命令的更多参数，你可以在 CMD 下输入 Tftp 进行查看。不过此时你朋友不能进行上传和下载工作，因为他此时是 Tftp 的服务端，只有客户端才能进行这些操作。如果他想把西传给你，那就需要你做服务端了。 用 Tftp 传送文件时，服务端需有确定的公网 IP，如果你朋友在局域网中通过网关上网的话，那就无法传送了。当然，如果两个人在同一局域网中，内网的 IP 也可以传送文件,只是有些多此一举。 Windows 98 系统可以当服务端，但客户端一定要是 Windows 2000 或是 Windows XP 等有 Tftp 命令的系统。以后如果你遇到因为防火墙等原因不能通过QQ传送文件时，不妨试试 Tftp. 我们再通过 Wireshark 抓包来观察 TFTP 协议(由于在 Windows上自己传给自己抓不到包，因此我在 Linux虚拟机上进行测试)，但是出现了 Destination unreachable (Host administratively prohibited)，查询资料得知，是 Linux 的防火墙没有设置，我们设置一下 iptables: 1234iptables -P OUTPUT ACCEPT #允许所有本机向外的访问iptables -P FORWARD ACCEPT #允许所有转发iptables -P INPUT ACCEPT #允许所有本机向外的访问iptables -F #清除所有规则 【注】:我的电脑不知道为何只能抓到单向的数据包，无法抓到主机向虚拟机传送的数据包，查了很多资料之后未果，先接着学习吧。 抓包显示两种数据包，分别是 Acknowledgement 和 Data block，其中前者是客户端收到数据块后对服务器的应答，后者是服务器向客户端发送的数据块。数据包的具体格式我们会在后面进行详细分析。 TFTP交互细节及数据包解读tftp 主要分为三步，首先是连接，然后是数据传输，最后是连接中断。所有这些步骤都通过发送相关数据包完成。最开始由客户端发送一个数据读取或写入请求，这个请求发出的同时连接自动建立，在这个过程中双方会协议要传输什么格式的文件。TFTP协议支持两个格式文件的传输，分别是 ASCII 文本，另一种是二进制数据，FTP 协议支持的文本格式比 TFTP 要复杂得多。 如果客户端请求的文件存在，服务器会直接将第一个数据块发送给客户端。如果是客户端想上传文件，服务器会发送一个 ACK 数据包表示确认。在这个过程中如果出现错误，其中一方就向另一方发送错误信息数据包，然后文件传输终止。由于使用 UDP 作为底层协议，因此一次数据发送最大不超过 512 字节。因此为了保证数据顺序正确性，每个数据包必须对应相应编号，编号根据数据块的顺序从1开始。 由于每次数据块最大是 512 字节，只要文件传输没有结束，那么一次数据块就是 512 字节，如果有数据包中数据少于 512 字节，那意味着这是文件最后一个数据包，最后一个数据块发送完后，连接自动中断。我们通过一个具体实例来掌握数据发送流程，假设客户端想从服务器读取一个 1200 字节的文件，以下是相关步骤： 客户端发送一个数据包给服务器，其中包含了要读取的文件名。 服务器发回第一个 512 字节数据块，并对其标号为 1. 客户端返回服务器一个标号为 1 的确认数据包 服务器发送标号为 2 包含 512 字节的数据块 客户端收到 2 号数据块后发生确认数据包 服务器发送标号为 3 的包含 176 字节的数据块 客户端收到后回发标号为 3 的确认数据包 服务器收到确认数据包后，确认文件发送完毕 我们再看看客户端上传文件的流程： 客户端发送一个写请求数据包，里面包含了要写的文件名称 服务器发送确认数据包，在数据包中它使用编号 0 客户端发送一个含有 512 字节，编号为1的数据包 服务器返回编号为 1 的确认数据包 客户端发送编号为 2，包含 512 字节的数据包 服务器返回编号为 2 的确认数据包 客户端发送编号为 3，包含 176 字节的数据包，等待服务器返回确认数据包。 服务器接受 3 号数据包后，返回确认数据包，由于该数据包数据少于 512 字节，服务器知道是最后一个数据包。 客户端收到 3 号确认数据包后，知道文件传输完毕，中断连接。 TFTP 协议后来又经过一次扩展，增加一些控制命令。如果客户端或服务器想使用扩展命令时，它必须向对方确认是否也能支持相应命令。它会发送一个数据包，里面包含扩展命令对应的数值列表，对方也会返回一个列表，把它支持的扩展命令对应的数值放在列表中，不支持的则不在列表里。TFTP 协议一个特点是，它不允许任何一方连续发送 2 个数据包，必须是一来一回。具体的扩展功能在协议实现时我们再详细研究。 探究数据包具体格式我们看看 TFTP 数据包的组装方式，为我们代码实现该协议奠定基础。TFTP 协议总共有5种不同数据包，分别对应读请求，写请求，数据块，接收回应(ACK)，以及错误。前两种数据包格式一样，只不过某些值域设置有差别，剩下的三种数据包格式各不相同。但无论哪一种数据包，他们都包含一个值域叫操作码，用来定义该数据包属于那种类型。 我们先看读请求和写请求数据包的格式，首先是2字节表示操作码，它用来表示当前数据包的类型，取值 1 表示该数据包是个读请求，2 表示该数据包是；接下来是可变长字段，它用来表示要读取或上传的文件名，它使用 ASCII 码并以 0 表示结尾；第三个字段叫 Mode，也是可变长字段，用来表示传输文件的数据类型，如果传输的是字符串文件，那么它填写字符串 “netascii”，如果传输的是二进制文件，那么它填写字符串 “octet”，这些字符串都以 0 结尾，其结构用下图表示： 接着我们看看传输数据块的数据包，它的前 2 字节也是操作码，取值 3 用于表示数据包用于数据块传输，接下来是 2 字节，用于表示数据块编号，最后是可变长字段 Data，用于装载数据块，该数据包的格式如下： 然后是应答数据包，它开始 2 字节也是操作码，取值 4，接下来2字节表示接收到的数据块编号，相应结构如下图： 最后一个是错误数据报，它前 2 字节表示操作码，取值 5；接下来 2 字节表示错误码，0 表示未知错误，1 表示文件不存在，2 表示权限不足，3 表示磁盘已满，具体的错误码我们在实践时再具体分析；接下来是可变长字段，它用字符串的形式描述具体错误，该数据包的结构如下图： 具体代码实现","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"计算机网络/TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TFTP协议","slug":"TFTP协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/TFTP%E5%8D%8F%E8%AE%AE/"}]},{"title":"DNS协议原理实现","slug":"DNS协议原理实现","date":"2020-05-27T07:21:23.000Z","updated":"2023-08-08T12:35:27.372Z","comments":true,"path":"47ec812d.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/47ec812d.html","excerpt":"DNS(域名解析协议)基本原理介绍我们这章开始研究和实现一个体系较为复杂的协议，也就是域名解析协议，简写为DNS。该协议几乎也是我们”日用而不知”的幕后英雄，没有它肯定就没有现在的互联网繁荣。 当我们在浏览器上输入网址，例如www.baidu.com时，浏览器先通过DNS协议找到与该网址对应的IP地址，然后再使用IP去向服务器获取网页信息。也就是说互联网上的设备其实有两种辨认方法，一种是IP，一种是域名。就如同人的身份证，人有名字，同时也有几十位数字组成的身份证号。 人与人相互识别时，使用的都是名字，几乎没有人使用身份证号来识别他人的，即使身份证号相对于名字而言更加唯一和准确。说到底是因为人对数字识别很费劲，而记住名字很容易。","text":"DNS(域名解析协议)基本原理介绍我们这章开始研究和实现一个体系较为复杂的协议，也就是域名解析协议，简写为DNS。该协议几乎也是我们”日用而不知”的幕后英雄，没有它肯定就没有现在的互联网繁荣。 当我们在浏览器上输入网址，例如www.baidu.com时，浏览器先通过DNS协议找到与该网址对应的IP地址，然后再使用IP去向服务器获取网页信息。也就是说互联网上的设备其实有两种辨认方法，一种是IP，一种是域名。就如同人的身份证，人有名字，同时也有几十位数字组成的身份证号。 人与人相互识别时，使用的都是名字，几乎没有人使用身份证号来识别他人的，即使身份证号相对于名字而言更加唯一和准确。说到底是因为人对数字识别很费劲，而记住名字很容易。 对计算机的访问也是如此。在互联网发展早期，计算机只是在局域网内互联，并且联网的机器非常有限，因此当时使用IP直接定位不同的机器。但是随着网络的发展，联网的机器越来越多，使用数字辨别每一台计算机变得越来越困难，于是人们开始想用更方便的记忆方式，于是自然就想到用字符串来替代难以记忆的数字。 然而对程序而言，它只能识别数字，于是字符串仅仅用作于方便记忆，在运行机制上，程序就得把字符串与IP数字进行转换。最早使用的转换机制很简单，甚至到现在还在使用，那就是hosts文件，它使用文本的方式将IP与字符串名字对应起来，如下图： 程序在运行时，先将该文件内容读入内存，当用户输入网址时，它先从里面的对应关系中，将网址直接转换成对应的IP地址。这种方法在主机数量少时适用，但现在网络上的主机数量数以千万计，如此我们得在文件中维护几万个对应关系，这显然不合情理，随着联网的设备越来越多，适用这种静态配置的方式越来越不合时宜，因此全网使用一种统一的IP字符串映射方式是势在必行。 如今能满足这种域名转换成IP需要机制，就是我们要研究和实现的DNS协议，它是极佳的分布式系统设计案例，互联网发展几十年来，接入网络的设备呈指数级增长，需要进行域名解析的请求自然也指数级增长，DNS自设计完成以来就具备了极佳的扩展性，因此它在没有大变动的情况下，满足日益增长的需求，可见其设计思路之巧妙。 DNS协议系统相比于其他网络协议，DNS协议本身更像是一个系统。它主要包含以下三种系统功能： 显然我们不可能实现全部功能，但我们会选择一些重要模块进行研究和实现，事实上抓住局部原理，对整体功能的把握也就能做到心中有数。DNS分为三大块，紫色部分是名字空间，它规定了域名的层级构造标准，第二部分是名字注册，它负责添加新设备的名称并防止名字冲突，第三部分是名字解析，它负责将域名转换为对应IP。 在了解DNS协议时，我们需要掌握一个很重要的概念叫域名。”域名”其实是对一个特定领域的统一称呼。例如我的大学名叫”北京化工大学”，于是对于我母校而言，它是一级域名，在下面又分很多个学院，例如理学院，化工学院，文法学院等，这些学院名称就是二级”域名”，学院内又有很多个系，像我所在的理学院有：数学系，物理系，化工系，这些系的名称就是三级域名，系下面又分班，比如我所在的数学系分为1，2，3，4班，这四个班名称对应的是四级域名，每个班内的人都有自己的名字，于是就对应五级域名。 DNS域名结构DNS中的域名以拓扑树的方式存在，如下图： 它以一个根节点开始，派生出一级域名，一级域名下面是二级域名，二级域名之后全都叫子域名。每一级域名可以使用数字和字符组合成的字符串来表示，其中字符串不区分大小写，同时一个域名下面的子域名不能相同，假设有一个一级域名叫Black,那么它下层的子域名可以是white，但必须只有一个，如果有另一个子域名叫WHITE，由于域名不区分大小写，因此两个域名被认为相同，这是不允许的。 由此域名设定时可以从根到叶子节点，中间以符号.隔开。上图中的Root始终对应空字符串，所以www.baidu.com对应于上图而言，第一级域名就是com，第二级域名就是baidu，第三级域名就是www，在解析的时候，该字符串域名就要倒转变成www.baidu.com。如果是百度知道，那么域名就是zhidao.baidu.com. 一级域名由特定机构控制例如IANA这类互联网管理机构，而二级域名往往对应一个特定组织或团体，例如baidu对应百度公司，三级域名则由组织自己控制。域名对公司而言是非常重要的信息资产，早期有很多聪明人通过域名碰瓷，也就曾大公司或机构不注意，用他们的名字注册域名，结果这些公司想用时只能从他们手中高价购买，很多人就靠这种手段发了大财。 域名解析流程接下来我们看看域名解析的基本流程。首先要解析域名，我们先找到含有相关域名信息的服务器，然后向该服务器发送信息请求。问题在于，域名信息不是存储在固定服务器中，为了系统鲁棒性和扩展性，域名信息以分布式的形式存储在不同服务器里，因此第一步要查询哪个服务器包含了域名对应的信息。 假设我们要解析域名C.B.A，首先我们将请求发送给所谓的根域名服务器，该服务器会把拥有域名A的服务器地址返回给我们，返回的服务器可能知道域名B.A的信息或者它把关于A的信息返回后，再给我们一个知道域名B的服务器地址，返回的服务器可能知道域名C的信息，或者返回域名B的信息后，再告诉我们哪个服务器知道域名C的信息，因此我们在解析过程中要根据服务器返回信息进行选择。 DNS协议系统运行流程及数据包解析域名信息存储DNS协议的运转需要客户端和服务器进行交互。由于服务器端需要存储大量的域名信息，同时每天需要应答海量的解析请求，因此它的设计必须遵循分布式系统。客户端向一台服务器请求解析服务时，对方可能没有相应的域名信息，于是它会向上一层查询，获得拥有给定域名信息的服务器，然后把对应服务器的信息归还给客户端，然后客户端再重新发起请求。 我们还需要关注域名信息如何在服务器上存储。在域名服务器上，信息存储有两种方式，一种是域名信息以二进制格式存储，这种格式对应的名称叫Resource Record Filed Format，同时为了方便管理员管理，这些信息又通过文本形式展现出来，对应的格式称为Master File Representation,管理员通过修改后者就能使得对应的二进制信息进行相应变换： Resource Record 是一种特定数据结构，专门用于存储域名解析相关信息，例如域名对应的服务器IP，域名解析服务器地址等，在后面我们解析数据包时再深入探讨。 域名解析域名解析其实有三种形式： 第一种是我们熟悉的，将域名发给服务器然后获得域名对应IP； 第二种叫反向解析，将IP发给服务器然后获得对应域名； 第三种叫电子邮件解析，将邮件地址发给服务器然后获得邮件的接收对象IP. 我们将主要关注第一种形式的原理和实现。 当我们执行第一种域名解析时，首先要做的是获得域名服务器地址。这个过程并非一撮而就，有可能我们查询第一个服务器时，它给我们返回另一个服务器的地址，然后我们继续查询；第二步是确定服务器后，我们要解析它返回来的数据内容。在这个过程中，第二步相对容易，而第一步则比较棘手。 在查询对应域名服务器时有两种方式，一种是循环式，第一个域名没有对应信息，但返回另一个它认为有对应信息的服务器，接着客户端向第二个服务器请求，第二个服务器又返回另一个服务器信息，该过程依次循环直到找到对应服务器为止： 第二种叫递归式，它与一种的区别在于，服务器承担起客户端查找对应服务器的职责，服务器会反复向其他服务器查询，直到拿到对应域名信息后，直接返回给客户端： 一般担任root服务器的角色的是路由器 数据包格式接下来我们看看DNS数据包的基本格式，首先第一部分叫Header，用于描述消息类型，以及后续数据结构的相关信息；第二部分叫Question，它用来包含客户端想向服务器查询的信息；第三部分叫Answer，是服务器用于回复客户端查询；第四部分叫Authority，如果请求没有得到全部答复，这部分内容告诉客户端向哪个服务器进行查询；第五部分叫Additional，这部分包含客户端查询信息的附加说明，它并非必须，所以数据包的基本结构如下： 我们用wireshark抓取DNS有关的消息包后，对照上面描述的条目进行解析。启动wireshark，然后使用关键词DNS过滤，然后在浏览器里输入一个你以前没有访问过的网址，如果输入已经访问过的，浏览器会有缓存，因此不会走dns协议。以下是我抓取到的一个DNS解析请求包： 首先是头部，它包含12字节，从Transaction ID 到 Additional RRs，每个字段2字节。ID用来标志一次会话，一个会话内的数据包拥有相同ID。Flags分为两部分，第一部分一字节叫做QR(query &amp; response)，用来表示该数据包是查询还是回答，如果是查询就设置为0，如果是回答就设置为1.如果是查询，那么第二个字节就是OpCode，进一步表明具体查询，它分为若干部分，前四个比特位用于表明查询类型，0表示查询域名对应IP，1不再使用；2表示查询域名服务器状态；3目前不使用，4用于服务器之间的交互；5也是用于服务器之间的交互。 第五个比特位叫AA(Authoritative),它只在回复包中设置，用于表明回复的权威性，只有在最后能够获得完整的IP的服务器上，才会返回1，其他中间的服务器只是起到代理作用，返回0.第六个比特位叫TC(Truncated)，它用于表明数据是否被截断，用于DNS支持UDP和TCP，但使用UDP时数据包不能超过512字节，如果超过数据包就得截断成多个小数据包，如果该位设置成1，它表明双方需要通过TCP来建立连接。第八位叫RD(Recursion desired)，如果设置成1，它意味着客户端请求递归式查询，也就是让服务器帮忙向其他服务器询问，得到最终消息后再返还给客户端。根据此比特位可以判断下面的信息是不是最终信息，如果该比特位为0，那么还需要根据下面的信息解析其他服务器传递过来的内容。 接下来字节的比特位是RA，如果设置为1表示服务器支持递归式查询，也就是服务器把所有累活都承担了，0则是不支持。接下来三个比特位必须设置为0，接着4个比特位表示返回码，如果值为0表示返回数据正常，非0表示出现错误，其中取值1表示查询数据包格式错误；2表示服务器自身故障；3表示解析错误；4表示不支持所要求的查询；5表示拒绝查询请求；其他值我们暂时忽略。 接下来用于表示相应条目的数量，Questions表示有几个查询条目，Answer RRs表示有几个回复条目，Authority RRs表示有几个权威信息条目，所谓”权威”是指真正能够解析域名的服务器，如果当前服务器不能解析域名请求，它需要把请求转发给其他服务器时，它自己就不是Authoritive，我们家用路由器其实承担域名解析服务器的职责，但是它本身不可能包含所需要的域名信息，它会把请求转发给上一层服务器，因此路由器就不是”权威”域名解析服务器。由此一个DNS域名解析数据包的轮廓如下： 返回的问题段的数据结构： 数据包： 首先是答案名字，这个字段长度可变，存储的是要查询的域名，以00作为结尾。第二个是问题类型(Type)，它是2字节，用于表明查询的类型，取值1表示查询域名对应IP，取值2查询服务器名称，具体类型在后面我们用到时再详细讨论。最后是问题类别，一般而言写死为1(IN,表明查询媒介类型为因特网)。 这里我们讲解一下查询的域名(Queries Name)对应的字符串结构，例如对于字符串：www.baidu.com，它的对应格式为``[3]www[5]baidu[3]com``,其中[]内表示接下来字符个数，例如[3]表示后面跟着3个字符www,[5]表示接下来跟着5个字符，**注意到这些数字所在位置正好对应字符串中符号点所在位置。** 最后以00结尾。 接下来我们看Answer Resource Records的结构，服务器收到客户端请求，完成解析工作后，把解析信息存储在该结构里发回给客户端。它的结构如下，第一个是名字字符串，可变长，它对应要解析的域名或服务器名称。接着是资源类型，2字节，表明资源的类型，如果取值是5，那么接下来对应着域名服务器对应的字符串名称，接着是资源类别，2字节，一般设置成1；接着是TTL(Time To Live)，4字节，表明这些信息能在缓存中存储多久；接着是RDLength，2字节，用于表明接下来内容的长度；最后是相应内容，如果资源类型是5，那么内容就是字符串，如果是1，那么内容就是4字节的IP地址，该数据类型对应的格式轮廓如下： 这里值得提到的是，如果资源类型5，那么对应的字符串才是”真正”域名，例如下面显示内容： 它显示的是，一开始我们使用域名pan.baidu.com去进行域名解析，此时解析服务器没有直接返回该域名对应的IP，而是返回另一个域名yiyun.n.shifen.com，前面pan.baidu.com其实是一个别名，打个比方，一个人可以使用假名和真名，假名可以随时变，真名则要跟身份证绑定。同样的道理，pan.baidu.com这个域名可以根据需要随时变化，例如以后它可以变成pen.baidu.com，但是第二个域名就唯一绑定一台服务器，我们只有拿这个域名去查询才能找到对应的IP。 为了简单起见，其他两种资源的数据格式我们暂时放一放，以后需要的时候才研究，在下一节我们将使用代码实现本节描述的DNS域名解析流程。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381package Application;import protocol.IProtocol;import protocol.ProtocolManager;import protocol.UDPProtocolLayer;import java.net.InetAddress;import java.nio.ByteBuffer;import java.util.HashMap;import java.util.Random;/** * @Author Cherry * @Date 2020/5/29 * @Time 16:53 * @Brief DNS 域名解析协议 */public class DNSApplication extends Application &#123; private byte[] resolve_server_ip = null; private String domainName = &quot;&quot;; private byte[] dnsHeader = null; private byte[] dnsQuestion = null; private short transition_id = 0; private static int QUESTION_TYPE_LENGTH = 2; private static int QUESTION_CLASS_LENGTH = 2; private static short QUESTION_TYPE_A = 1; private static short QUESTION_CLASS = 1; private static char DNS_SERVER_PORT = 53; //该类型表示服务器返回域名的类型号 private static short DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS = 5; private static short DNS_ANSWER_HOST_ADDRESS = 1; /** * 初始化，一般将域名交给路由器让其查询IP * * @param destIP 要查询域名的服务器IP，一般为该局域网的路由器 * @param domainName 域名 */ public DNSApplication(byte[] destIP, String domainName) &#123; resolve_server_ip = destIP; this.domainName = domainName; Random random = new Random(); transition_id = (short) random.nextInt(); //随机选择一个发送端口，这个没有具体要求 this.port = (short) random.nextInt(); constructDNSPacketHeader(); constructDNSPacketQuestion(); &#125; /** * 组装 DNS 首部，12B */ private void constructDNSPacketHeader() &#123; byte[] header = new byte[12]; ByteBuffer buffer = ByteBuffer.wrap(header); //会话Id,2B buffer.putShort(transition_id); //2字节操作码 short opCode = 0; /* * 如果是查询数据包，第16个比特位要将最低位设置为0,接下来的4个比特位表示查询类型，如果是查询ip则设置为0， * 第11个比特位由服务器在回复数据包中设置，用于表明信息是它拥有的还是从其他服务器查询而来， * 第10个比特位表示消息是否有分割，有的话设置为1，由于我们使用UDP，因此消息不会有分割。 * 第9个比特位表示是否使用递归式查询请求，我们设置成1表示使用递归式查询, * 第8个比特位由服务器返回时设置，表示它是否接受递归式查询 * 第7,6,5，3个比特位必须保留为0， * 最后四个比特由服务器回复数据包设置，0表示正常返回数据，1表示请求数据格式错误，2表示服务器出问题，3表示不存在给定域名等等 * 我们发送数据包时只要将第9个比特位设置成1即可(从1开始向左数第9位) */ opCode = (short) (opCode | (1 &lt;&lt; 8)); buffer.putShort(opCode); //接下来是2字节的question count,由于我们只有1个请求，因此它设置成1 short questionCount = 1; buffer.putShort(questionCount); //剩下的默认设置成0 short answerRRCount = 0; buffer.putShort(answerRRCount); short authorityRRCount = 0; buffer.putShort(authorityRRCount); short additionalRRCount = 0; buffer.putShort(additionalRRCount); this.dnsHeader = buffer.array(); &#125; /** * 构造DNS数据包中包含域名的查询数据结构 * 首先是要查询的域名，它的结构是是：字符个数+是对应字符， * 例如域名字符串pan.baidu.com对应的内容为 * [3]pan[5]baidu[3]com也就是把 &#x27;.&#x27;换成它后面跟着的字母个数 */ private void constructDNSPacketQuestion() &#123; //解析域名结构，按照 &#x27;.&#x27; 进行分解,第一个1用于记录&quot;pan&quot;的长度，第二个1用0表示字符串结束 dnsQuestion = new byte[1 + 1 + domainName.length() + QUESTION_TYPE_LENGTH + QUESTION_CLASS_LENGTH]; String[] domain = domainName.split(&quot;\\\\.&quot;); ByteBuffer buffer = ByteBuffer.wrap(dnsQuestion); for (String str : domain) &#123; //先填写字符个数 buffer.put((byte) str.length()); //填写字符 for (int i = 0; i &lt; str.length(); ++i) &#123; buffer.put((byte) str.charAt(i)); &#125; &#125; //用0表示域名表示结束 byte end = 0; buffer.put(end); //填写查询问题的类型和级别 buffer.putShort(QUESTION_TYPE_A); buffer.putShort(QUESTION_CLASS); &#125; /** * 向服务器发送查询请求 */ public void queryDomain() &#123; byte[] dnsPacketBuffer = new byte[dnsHeader.length + dnsQuestion.length]; ByteBuffer buffer = ByteBuffer.wrap(dnsPacketBuffer); buffer.put(dnsHeader); buffer.put(dnsQuestion); byte[] udpHeader = createUDPHeader(dnsPacketBuffer); byte[] ipHeader = createIP4Header(udpHeader.length); byte[] dnsPacket = new byte[ipHeader.length + udpHeader.length]; buffer.clear(); buffer = ByteBuffer.wrap(dnsPacket); buffer.put(ipHeader); buffer.put(udpHeader); //将消息发给路由器 try &#123; ProtocolManager.getInstance().sendData(dnsPacket, resolve_server_ip); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 组装 UDP 包头 * * @param data * @return */ private byte[] createUDPHeader(byte[] data) &#123; IProtocol udpProtocol = ProtocolManager.getInstance().getProtocol(&quot;udp&quot;); if (udpProtocol == null) &#123; return null; &#125; HashMap&lt;String, Object&gt; headerInfo = new HashMap&lt;&gt;(); char udpPort = (char) this.port; headerInfo.put(&quot;source_port&quot;, udpPort); headerInfo.put(&quot;dest_port&quot;, DNS_SERVER_PORT); headerInfo.put(&quot;data&quot;, data); return udpProtocol.createHeader(headerInfo); &#125; /** * 组装 IP 包头 * * @param length * @return */ private byte[] createIP4Header(int length) &#123; IProtocol ipPrtocol = ProtocolManager.getInstance().getProtocol(&quot;ip&quot;); if (ipPrtocol == null || length &lt;= 0) &#123; return null; &#125; HashMap&lt;String, Object&gt; headerInfo = new HashMap&lt;&gt;(); headerInfo.put(&quot;data_length&quot;, length); ByteBuffer destIP = ByteBuffer.wrap(resolve_server_ip); headerInfo.put(&quot;destination_ip&quot;, destIP.getInt()); byte protocol = UDPProtocolLayer.PROTOCOL_UDP; headerInfo.put(&quot;protocol&quot;, protocol); headerInfo.put(&quot;identification&quot;, transition_id); return ipPrtocol.createHeader(headerInfo); &#125; /** * 解析服务器回发的数据包，首先读取头2字节判断 transition_id 是否与我们发送时使用的一致 * * @param headerInfo data */ @Override public void handleData(HashMap&lt;String, Object&gt; headerInfo) &#123; System.out.println(&quot;\\n==================== DNS START ====================&quot;); byte[] data = (byte[]) headerInfo.get(&quot;data&quot;); if (data == null) &#123; System.out.println(&quot;Empty data...&quot;); return; &#125; ByteBuffer buffer = ByteBuffer.wrap(data); short transitionID = buffer.getShort(); if (transitionID != transition_id) &#123; System.out.println(&quot;TransitionID is different!!!&quot;); return; &#125; //读取2字节flag各个比特位的含义 short flag = buffer.getShort(); readFlags(flag); //下面两个字节表示请求数量(Questions) short questionCount = buffer.getShort(); System.out.println(&quot;Client send &quot; + questionCount + &quot; requests.&quot;); //两字节表示服务器回复信息的数量 short answerCount = buffer.getShort(); System.out.println(&quot;Server return &quot; + answerCount + &quot; answers.&quot;); //两字节表示数据拥有属性信息的数量 short authorityCount = buffer.getShort(); System.out.println(&quot;Server return &quot; + authorityCount + &quot; authority resources.&quot;); //两字节表示附加信息的数量 short additionalInfoCount = buffer.getShort(); System.out.println(&quot;Server return &quot; + additionalInfoCount + &quot; additional info.&quot;); //处理回复包中的Question部分，这部分湖人查询包中的内容一模一样 readQuestions(questionCount, buffer); //处理服务器返回的信息 readAnswers(answerCount, buffer); &#125; /** * 分析 flag 字段各个比特位的含义 * * @param flag */ private void readFlags(short flag) &#123; //最高字节为1表示该数据包为回复数据包 if ((flag &amp; (1 &lt;&lt; 15)) != 0) &#123; System.out.println(&quot;This is packet returned from server...&quot;); &#125; //如果第9个比特位为1表示客户端请求递归式查询 if ((flag &amp; (1 &lt;&lt; 8)) != 0) &#123; System.out.println(&quot;Client requests recursive query!(客户端请求递归查询)&quot;); &#125; //第8个比特位为1表示服务器接受递归式查询请求 if ((flag &amp; (1 &lt;&lt; 7)) != 0) &#123; System.out.println(&quot;Server accept recursive query request!(服务器接受递归查询)&quot;); &#125; //第6个比特位表示服务器是否拥有解析信息 if ((flag &amp; (1 &lt;&lt; 5)) != 0) &#123; System.out.println(&quot;Sever own the domain info!(拥有解析信息)&quot;); &#125; else &#123; System.out.println(&quot;Server query domain info from other servers!(无解析信息)&quot;); &#125; &#125; /** * 处理 Question 部分 * * @param questionCount question 部分的数量 * @param data buffer */ private void readQuestions(int questionCount, ByteBuffer data) &#123; System.out.println(&quot;\\n=============== Queries ===============&quot;); for (int i = 0; i &lt; questionCount; i++) &#123; readStringContent(data); System.out.println(); //查询问题的类型 short type = data.getShort(); if (type == QUESTION_TYPE_A) &#123; System.out.println(&quot;Request IP for given domain name&quot;); &#125; //查询问题的级别 short clasz = data.getShort(); System.out.println(&quot;The class of the request is &quot; + clasz); &#125; &#125; /** * 处理 Answer 部分 * 回复信息的格式如下： * 第一个字段是 name，它的格式如同请求数据中的域名字符串 * 第二个字段是类型，2字节 * 第三字段是级别，2字节 * 第4个字段是 Time to live, 4字节，表示该信息可以缓存多久 * 第5个字段是数据内容长度，2字节 * 第6个字段是内如数组，长度如同第5个字段所示 * * @param answerCount 服务器返回的 answer 部分的数量 * @param data buffer */ private void readAnswers(int answerCount, ByteBuffer data) &#123; System.out.println(&quot;\\n=============== Answers ===============&quot;); /* * 在读取name字段时，要注意它是否使用了压缩方式，如果是那么该字段的第一个字节就一定大于等于192， * 也就是它会把第一个字节的最高2比特设置成11，接下来的1字节表示数据在dns数据段中的偏移， * 即从DNS报文段开头开始偏移。 * 因为规定字符串长度不能超过63，即6位，因此若发现字符串的长度超过(或等于)192，就是采用了压缩 */ for (int i = 0; i &lt; answerCount; i++) &#123; System.out.println(i + 1 + &quot;: Name content in answer filed is:&quot;); if (isNameCompression(data.get())) &#123; int offset = (int) data.get(); byte[] array = data.array(); ByteBuffer dup_buffer = ByteBuffer.wrap(array); //从指定偏移处读取 dup_buffer.position(offset); readStringContent(dup_buffer); System.out.println(); &#125; else &#123; readStringContent(data); System.out.println(); &#125; //类型 short type = data.getShort(); System.out.println(&quot;Answer type is : &quot; + type); if (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123; System.out.println(&quot;This answer contains server string name...&quot; + &quot;(该答复中包含了服务器的字符串名称)&quot;); &#125; //级别 short clasz = data.getShort(); System.out.println(&quot;Answer class: &quot; + clasz); //接下来4个字节是TTL存活时间 int ttl = data.getInt(); System.out.println(&quot;This content can cache (该域名生存时间为):&quot; + ttl + &quot; seconds(秒)...&quot;); //接下来2字节表示数据长度，长度为4表示IP，其他长度为服务器字符串名称 short length = data.getShort(); if (type == DNS_ANSWER_CANONICAL_NAME_FOR_ALIAS) &#123; readStringContent(data); System.out.println(); &#125; else if (type == DNS_ANSWER_HOST_ADDRESS) &#123; //打印服务器的IP byte[] ip = new byte[4]; for (int j = 0; j &lt; 4; ++j) &#123; ip[j] = data.get(); &#125; try &#123; InetAddress inetAddress = InetAddress.getByAddress(ip); System.out.println(&quot;IP for domain name is(域名解析得到的IP为): &quot; + inetAddress.getHostAddress()); System.out.println(&quot;==================== DNS END ====================&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(); &#125; &#125; /** * 解析域名字符串 * * @param buffer buffer */ private void readStringContent(ByteBuffer buffer) &#123; byte charCount = buffer.get(); //如果字符第一个数正确或者使用压缩方式，输出字符串内容 while (charCount != 0 || isNameCompression(charCount)) &#123; if (isNameCompression(charCount)) &#123; int offset = buffer.get(); byte[] array = buffer.array(); ByteBuffer dup_buffer = ByteBuffer.wrap(array); dup_buffer.position(offset); readStringContent(dup_buffer); break; &#125; //输出字符 for (int i = 0; i &lt; charCount; ++i) &#123; System.out.print((char) buffer.get()); &#125; charCount = buffer.get(); if (charCount != 0) &#123; System.out.print(&quot;.&quot;); &#125; &#125; &#125; /** * 判断字符串是否使用压缩 * 若 7.8位 为 1，则采用压缩，因为允许的字符串长度最长为 64，即 6位 * * @param b 字符串本串 * @return */ private boolean isNameCompression(byte b) &#123; return (b &amp; (1 &lt;&lt; 7)) != 0 &amp;&amp; (b &amp; (1 &lt;&lt; 6)) != 0; &#125;&#125; 稍后进行代码讲解…","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"计算机网络/TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"DNS协议","slug":"DNS协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/DNS%E5%8D%8F%E8%AE%AE/"}]},{"title":"Linux服务器配置","slug":"Linux服务器配置","date":"2020-05-26T14:10:55.000Z","updated":"2023-08-08T12:35:27.384Z","comments":true,"path":"3472be8b.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/3472be8b.html","excerpt":"实验内容介绍Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 WAMP(Windows+Apache+MySQL+PHP) 和 LAMP(Linux+Apache+MySQL+PHP)架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。","text":"实验内容介绍Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 WAMP(Windows+Apache+MySQL+PHP) 和 LAMP(Linux+Apache+MySQL+PHP)架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本实验中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。本实验演示以 kali 64 位操作系统为例。因 kali 系统已经自带 Apache、MySQL 和 PHP，为了解安装流程，请先卸载系统自带软件。 卸载系统原有Apache、MySQL、PHPsudo apt-get remove apache2sudo apt-get remove mysql-*sudo apt-get remove php 在线安装Apache 服务器输入命令：sudo apt-get install apache2 输入命令：sudo /etc/init.d/apache2 start 手动启动服务 以上页面详细介绍了 Debian 发行版 Linux 中 Apache 基本信息，其中： Apache 根目录：/var/www/html Apache 配置目录和文件：/etc/apache2: Apache 主配置目录， Apache 所有配置文件均在此目录下；/etc/apache2/apache2.conf: 主配置文件，可配置 Apache 全局配置；/etc/apache2/ports.conf: 端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。其它文件略。 Apache 日志文件：/var/log/apache2/access.log: 服务请求日志/var/log/apache2/error.log: 服务错误日志 Apache 基本操作：服务启动：/etc/init.d/apache2 start服务停止：/etc/init.d/apache2 stop服务重启：/etc/init.d/apache2 restart部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。在浏览器找那个输入虚拟机的IP，看到： 说明服务器配置成功！ 安装 MySQL&#x2F;MariaDB本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。 安装 MariaDB 服务：sudo apt-get install mariadb-serversudo apt-get install mariadb-client 遇到的问题：首先就是提示没有mariadb-server软件包，类似于这样 这个可能是apt版本不够，需要执行sudo apt-get update 进行更新，但是更新实在太慢，我更新了33分钟才更新好，这时候已经快下课了。 然后就是出现域名无法解析的错误这个错误困扰了我好久，按照网上的方法试了很多，但是还是不行。最后发现是/etc/network/interfaces文件中网关写错了，写成了192.168.1.0，正确的应该是192.168.1.1然后修改/etc/resolv.conf文件，增加字段：nameserver 8.8.8.8（好像是谷歌的DNS服务器），然后执行ifdown -a关闭网卡，ifup -a启动网卡，然后就可以了。 至于为什么会出现DNS解析错误，一开始我的虚拟机的网络是用的NAT（虚拟地址转换），在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。在NAT模式下，宿主计算机相当于一台开启了DHCP功能的路由器，而虚拟机则是内网中的一台真实主机，通过路由器(宿主计算机)DHCP动态获得网络参数。因此在NAT模式下，虚拟机可以访问外部网络，反之则不行，因为虚拟机属于内网。 而改成了桥接模式后，虚拟机和宿主计算机处于同等地位（同处一个局域网），虚拟机就像是一台真实主机一样存在于局域网中。因此在桥接模式下，我们就要像对待其他真实计算机一样为其配置IP、网关、子网掩码等等。但是修改/etc/resolv.conf，重启过后就没有了，我们需要安装resolvconfig应用组件：sudo apt-get install resolvconf，在/etc/resolvconf/resolv.conf.d/base文件中添加DNS信息（nameserver 8.8.8.8），就可以了。 然后再次重新启动，刚刚的问题解决！ 配置 Mariadb 的安全选项:sudo mysql_secure_installation 此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo &#x2F;etc&#x2F;init.d&#x2F;mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认： Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)； Set root password? [Y&#x2F;n] 回车，默认为输入 Y； New password: 输入新密码； Re-enter new password 确认密码； Remove anonymous users? [Y&#x2F;n] 移除匿名用户； Disallow root login remotely? [Y&#x2F;n] 禁止 root 远程登录； Remove test database and access to it? [Y&#x2F;n] 移除测试数据库； Reload privilege tables now? [Y&#x2F;n] 重新加载权限表。 测试数据库:如图所示，若进入数据库则表示数据库安装成功，sudo mysql -u root -p 安装PHP安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL&#x2F;MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.2 版本，对应扩展包可通过以下命令模糊查询：sudo apt-cache search php7从查询结果可知，php7.3对应Apache、MySQL扩展包分别为 ：libapahe2-mod-php7.2，php7.2-mysql.如下图所示为安装 PHP 相关软件包。sudo apt-get install php7.2 libapahe2-mod-php7.2 php7.2-mysql PHP 安装完毕后需重启 Apache 测试PHP页面编辑测试文件，如下图所示，在 /var/www/html 目录下新建 test.php 文件，并输入如下所示的测试代码。 1&lt;?php echo phpinfo();?&gt; 在浏览器中访问如下： 注意：我修改了Apache的端口为8080，因此访问时要在URL后面加上8080端口。 创建文件上传页面文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在根目录下创建upload.html文件，编辑表单 在根目录下创建 upload.php 脚本文件，编写文件上传功能代码： 在根目录下创建“upload”目录，用于保存上传的图片然后访问192.168.1.120:8080/upload.html 选择一个不超过200K的图片文件： 先修改upload文件夹的权限，上传之后查看服务器中upload文件夹： 或者查看Apache的属主：ps -ef | grep apache，发现是www-data 然后更改修改目录的所有者： 结果和上述一样，大功告成！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Linux/"}],"tags":[{"name":"Linux服务器","slug":"Linux服务器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Java虚拟机知识总结（二）","slug":"Java虚拟机知识总结（二）","date":"2020-05-24T09:28:44.000Z","updated":"2023-08-08T12:35:27.384Z","comments":true,"path":"7a3f40e8.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/7a3f40e8.html","excerpt":"","text":"三、GC算法和收集器本文参考：Oracle Java JVM Standard Options：https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.htmlHotSpot Glossary of Terms：http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html周志明《深入理解Java虚拟机》第二版 如何判断对象可以被回收堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象） 引用计数法给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决对象之前相互循环引用的问题。所谓对象之间的相互引用问题，通过下面代码所示：除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://cherryyang05.github.io/hexo-blog/tags/JVM/"}]},{"title":"Java虚拟机知识总结(一)","slug":"Java虚拟机知识总结（一）","date":"2020-05-24T06:42:02.000Z","updated":"2023-08-08T12:35:27.377Z","comments":true,"path":"bc4fb6eb.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/bc4fb6eb.html","excerpt":"Java虚拟机介绍Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。","text":"Java虚拟机介绍Java虚拟机(Java Virtual Machine，JVM)，一种能够运行Java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 JVM基本结构 JVM由三个主要的子系统构成 类加载子系统 运行时数据区（内存结构） 执行引擎 类加载机制 加载将.class文件从磁盘读到内存 链接 验证验证字节码文件的正确性 准备给类的静态变量分配内存 解析类加载器装入类所引用的其他所有类(静态链接)静态链接：解析阶段，由符号引用转化为直接引用动态链接：程序运行期间，由符号引用转化为直接引用 初始化为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块 使用 卸载 类加载器的种类 启动类加载器(Bootstrap ClassLoader)负责加载JRE的核心类库，如JRE目标下的rt.jar,charsets.jar等 扩展类加载器(Extension ClassLoader)负责加载JRE扩展目录ext中jar类包 系统类加载器(Application ClassLoader)负责加载ClassPath路径下的类包 用户自定义加载器(User ClassLoader)负责加载用户自定义路径下的类包 双亲委派机制全盘负责委托机制当一个ClassLoader加载一个类的时候，除非显式的使用另一个ClassLoader,该类所依赖和引用的类也由这个ClassLoader载入 双亲委派机制指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类。实际上双亲委派机制实则父类委派机制。 双亲委派模式的优势 沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改 避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次 要确定一个类的唯一性，要获得该类的类加载器实例以及类的全限定名。 不同的类加载器加载同一个class文件是不同的类模板信息 为什么要打破双亲委派机制？Tomcat为了做wap包隔离 运行时数据区 堆：用来放类的实例对象栈：栈帧，用来存放方法，线程 方法区（Method Area）(永久代&#x2F;持久代jdk1.8以前，元空间)类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法&#x2F;接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间) 堆（Heap） YoungGC&#x2F;MinorGC CMS OldGC MajorGC&#x2F;FullGC 虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出OutOfMemoryError(OOM)异常。同时也是垃圾收集器管理的主要区域。 当年龄到15时，转入老年代 新生代（Young Generation）类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生代分为两部分：伊甸区（Eden space）和幸存者区（Survivor space），所有的类都是在伊甸区被new出来的。幸存区又分为From和To区。当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收（Minor GC），将Eden区中的不再被其它对象应用的对象进行销毁。然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区。 老年代（Old Generation）新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生Major GC（也可以叫Full GC），进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出OOM（OutOfMemoryError）异常 元空间（Meta Space）在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。 为什么移除了永久代？参考官方解释 http://openjdk.java.net/jeps/122 大概意思是移除永久代是为融合HotSpot与JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。 栈(Stack)Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致. 本地方法栈(Native Method Stack)和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库 程序计数器(Program Counter Register)就是一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计 将下面代码编译生成Class字节码并反汇编：123456789101112131415public class JVM &#123; public int math() &#123; int a = 1; int b = 5; int c = (a + b) * 10; System.out.println(a); return c; &#125; public static void main(String args[]) &#123; JVM jvm = new JVM(); System.out.println(jvm.math()); &#125;&#125; 反汇编后：(javap -c JVM.class &gt; JVM.txt) 1234567891011121314151617181920212223242526272829303132333435363738Compiled from &quot;JVM.java&quot;public class JVM &#123; public JVM(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public int math(); Code: 0: iconst_1 1: istore_1 2: iconst_5 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: bipush 10 9: imul 10: istore_3 11: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 14: iload_1 15: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 18: iload_3 19: ireturn public static void main(java.lang.String[]); Code: 0: new #4 // class JVM 3: dup 4: invokespecial #5 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_1 12: invokevirtual #6 // Method math:()I 15: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 18: return&#125; 很多其实都是编译原理的知识，下面是数据区： 反汇编之后前面的数字序号便是程序计数器PC 目前市面上大部分虚拟机都是用C/C++实现的，实际上最后启动线程都是通过C/C++库来调用操作系统内核函数实现。 利用javap -v JVM.class &lt; dynamicLink.txt查看动态链接详细信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Classfile /G:/JVM.class Last modified 2020-5-24; size 493 bytes MD5 checksum 5cdaa7b4d5fb74c45c86c10186ae5c8c Compiled from &quot;JVM.java&quot;public class JVM minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #19.#20 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #21.#22 // java/io/PrintStream.println:(I)V #4 = Class #23 // JVM #5 = Methodref #4.#18 // JVM.&quot;&lt;init&gt;&quot;:()V #6 = Methodref #4.#24 // JVM.math:()I #7 = Class #25 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 math #13 = Utf8 ()I #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 SourceFile #17 = Utf8 JVM.java #18 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V #19 = Class #26 // java/lang/System #20 = NameAndType #27:#28 // out:Ljava/io/PrintStream; #21 = Class #29 // java/io/PrintStream #22 = NameAndType #30:#31 // println:(I)V #23 = Utf8 JVM #24 = NameAndType #12:#13 // math:()I #25 = Utf8 java/lang/Object #26 = Utf8 java/lang/System #27 = Utf8 out #28 = Utf8 Ljava/io/PrintStream; #29 = Utf8 java/io/PrintStream #30 = Utf8 println #31 = Utf8 (I)V&#123; public JVM(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public int math(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: istore_1 2: iconst_5 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: bipush 10 9: imul 10: istore_3 11: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 14: iload_1 15: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 18: iload_3 19: ireturn LineNumberTable: line 4: 0 line 5: 2 line 6: 4 line 7: 11 line 8: 18 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: new #4 // class JVM 3: dup 4: invokespecial #5 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_1 12: invokevirtual #6 // Method math:()I 15: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 18: return LineNumberTable: line 12: 0 line 13: 8 line 14: 18&#125;SourceFile: &quot;JVM.java&quot; 第一段的Constant pool是符号引用","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://cherryyang05.github.io/hexo-blog/tags/JVM/"}]},{"title":"DHCP 主机动态配置协议详解","slug":"DHCP主机动态配置协议详解","date":"2020-05-15T10:20:18.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"2a5bb25d.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/2a5bb25d.html","excerpt":"一、DHCP介绍1. 简要介绍DHCP 协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了 WiFi，当你离开了屋子，又自动断开了 WiFi…… 这一系列的幕后都是DHCP协议在默默工作。 DHCP 协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。 该协议的最大作用是动态的为加入网络的设备分配 IP 地址，在该协议出现前，IP 地址的分配基于静态模式，你把设备的 mac 地址手动在路由器设置，然后路由器自动生成一个 IP 与你的 mac 地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配 IP 的做法不再适合。 DHCP 协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配 IP 地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。 DHCP 最重要功能显然是动态分配 IP 地址，当我们的设备连接上网络之后里面获得一个可用的 IP 地址，就得感谢该协议的执行，现在我们大多数设备都依靠 DHCP 来从路由器动态获得 IP","text":"一、DHCP介绍1. 简要介绍DHCP 协议在我们日常生活中应该是最常见而又经常被忽略的一种协议了。当你走进一间屋子，手机自动连上了 WiFi，当你离开了屋子，又自动断开了 WiFi…… 这一系列的幕后都是DHCP协议在默默工作。 DHCP 协议(Dynamic Host Configuration Protocol)是一个基于UDP协议的局域网的网络协议。指的是由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。 该协议的最大作用是动态的为加入网络的设备分配 IP 地址，在该协议出现前，IP 地址的分配基于静态模式，你把设备的 mac 地址手动在路由器设置，然后路由器自动生成一个 IP 与你的 mac 地址绑定起来。这种应用在有线网络时代可以适用，但在无线时代，每时每刻可能有不同的设备加入或离开网络，因此原有静态匹配 IP 的做法不再适合。 DHCP 协议的诞生就是为了迎合在无线情况下，网络内部连接设备不断变化的情况。它包含两部分，一是分配 IP 地址，二是支持客户端请求，服务器应答，使得两者之间有效交换配置信息。 DHCP 最重要功能显然是动态分配 IP 地址，当我们的设备连接上网络之后里面获得一个可用的 IP 地址，就得感谢该协议的执行，现在我们大多数设备都依靠 DHCP 来从路由器动态获得 IP 2. DHCP 的 IP 租借DHCP 协议能够维护一个动态的 IP 池，根据设备加入和离开网络回收或分发可用 IP，它甚至能实现多个设备共享相同 IP。DHCP 协议的实现基于 UDP，需要 IP 的设备和具备分配 IP 能力的设备根据 DHCP 协议的方式封装数据包，然后通过 UDP 协议发送给对方。有了该协议后，我们上网时不再麻烦的去配置各种信息，设备和路由器之间相互通信后，自动配置好相应信息，我们只要等着配置完毕然后上网就行。 DHCP 支持三种地址分配方式，一种是手动分配，由管理员手动将指定 IP 地址分发给特定设备；第二种是自动分配，它从当前可用的 IP 地址池中选出一个，永久的分发给某一台特定设备；第三种是动态分配，它从 IP 地址池中选出一个分发给某台设备一段时间，时间到了后收回，或者设备离开网络后通知路由器主动收回，由此可见，第二种和第三种区别不大 使用动态分配方式时，管理员指定一系列可以分配的 IP，然后 DHCP 服务器会自动维护哪些 IP 已经分配，哪些 IP 可以使用。同时服务器指定分配的 IP 使用时长，一旦超时后，客户必须主动向服务器请求续租，例如上图就有对应按钮，或者请求重新从服务器获得一个新的 IP 地址，这个请求应答过程将是我们研究和实现的重点。 DHCP 协议动态分配 IP 的好处显而易见，首先是自动化，省却了管理员耗时耗力的维护，其次是集中管理，从服务器就可以得知IP的使用情况，由此有效防止 IP 冲突。而且还能实现地址的共享和重用，如果一台设备不活跃，例如关机或离开网络，协议可以及时收回 IP，分发给在网络中的其他设备。 在 DHCP 协议管理下，所有设备只能“租借” IP 而不能“拥有” IP。有租借就必须有管理，DHCP 协议的主要内容就在这里。租借时常根据设备的使用情况而定，作为服务器的设备租借时间必须很长，而对于手持设备而言，租借时间可以很短。在很多情况下，管理员为了防止 IP 被长时间无效占用，例如某台设备计划租借一个月，但它运行一天就关机了，那么这个 IP 就会在余下 29 天浪费掉，因此管理员会强制设备租借短时期，时期到了后再跟服务器请求延长租借期。 管理员一般把 IP 池划分为若干类别，不同类别对应不同租期，然后根据接入设备的类型赋予不同类别的IP。一旦租期抵达一半时，设备就开始于服务器协商以便延长租期。 下面是IP租借的流程图： 上图描述了设备向 DHCP 服务器租借 IP 8 天流程，其中在第 4 天要与服务器协商续租。租借 IP 的设备需要保持两个时钟，时钟 T1 在租借期过了一半时触发，此时设备向服务器请求续租；如果续租不成功，第二个时钟在租期 87.5% 时触发，设备向另一个 DHCP 服务器发起租借 IP 的请求。我们后面用代码实现协议时，主要通过构造数据包完成上面所述流程。 DHCP 协议时典型的服务器客户端应用模式。需要 IP 的设备是客户端，分发 IP 的设备是服务器，两者通过互发消息完成一项任务。他们之间的交互可以由下图表达： 类似于 TCP 的握手，但是又比 TCP 简单不少。 二、DHCP主机动态配置协议解析和数据包格式说明1. 查看DHCP数据包打开网络封包分析软件 WireShack，输入过滤条件 bootp.option.type == 53 (或者 dhcp.option.type == 53 也可)，在命令行中输入 ipconfig/renew，表示续租 DHCP 服务器，我们获取这样的数据包： 点开一个数据包，看到： 我们看到 DHCP 协议数据包的组成格式为 IP数据包-&gt;UDP数据包-&gt;Boostrap Protocoal数据包(也就是DHCP数据包) 【注】Boostrap 是DHCP协议的前身，它叫主机静态配置协议。DHCP其实是它的扩展，将原来静态配置的过程动态化，于是配置起来更加灵活方便，只不过DHCP数据包的依然以Boostrap协议数据包为基础。 我们点开 DHCP 看看具体内容： 通过观察，我们大概可以知道 DHCP 数据包大概有哪些字段，要了解这些字段的作用，我们还得充分了解协议的具体交互流程。DHCP 协议以客户端&lt;-&gt;服务器的方式进行交互，整个过程由客户端主导，服务器被动回应，因此掌握客户端的运行状态，我们就可以掌握 DHCP 的协议交互流程。 2. DHCP流程DHCP 在执行时维护了一个状态机，该状态机由八个状态组成。 客户端在运行时维护一个内部状态机，其运行过程如下： INIT 状态。客户端创建一个DHCPDISCOVER消息在局域网内广播，查询可用的 DHCP 服务器，然后进入SELECTING状态。 SELECTING 状态。局域网内的DHCP收到广播消息后，发送DHCPOFFER消息，客户端会收到一个或多个 DHCP 服务器的回应，然后它从众多回应中选取一个服务器，向它发送DHCPREQUEST消息，然后进入REQUESTING状态。 REQUESTING 状态。客户端向服务器发送 DHCPREQUEST 消息中包含了它对服务器的数据请求，例如可用IP地址以及各类配置参数，请求发送出去后它等待服务器回应。服务器会返回DHCPACK 消息，里面包含了客户端想要的可用IP以及配置参数等信息。收到消息后，客户端检测服务器返回的 IP 地址是否可用，可用的话进入使用状态并像上一节描述的那样设置两个超时时钟。如果客户端发现 IP 地址不可用，它向服务器发送 DHCPDECLINE消息，然后转入状态1。如果客户端从服务器收到的是DHCPNAK消息，它表示服务器拒绝向客户端提供服务，因此客户端重新进入状态1. INIT-REBOOT 状态。如果客户端已经租借到IP，它重启后进入该状态。此时它会向服务器发送 DHCPREQUEST 消息，重新确定它对IP的使用权，然后客户端进入 REBOOTING 状态，等待服务器反应。 REBOOTING 状态。此时客户正在等待服务器返回确认消息，此时会有 3 种情况。一是客户端收到服务器发来的 DHCPACK 消息，表明可以继续使用它当前 IP,于是客户端进入 BOUND 状态；二是，客户端得到 DHCPACK 回应，然后发现它原来使用的 IP 在自己关机或重启时，被其他设备抢夺了，于是他想服务器发送 DHCPDECLINE 消息，然后进入状态 1；三是收到服务器发来的 DHCPNAK 消息，这表明服务器告诉客户端 IP 不能再继续使用，于是客户端进入状态 1. BOUND 状态。此时客户端得到可用IP地址，并进入使用状态。此时它启动两个时钟，T1 和 T2。当 T1 超时时，它进入状态 RENEWING。如果客户端主动要放弃使用当前 IP，它会向服务器发送 DHCPRELEASE 消息，然后进入状态 1. RENEWING 状态。此时客户端希望续租当前 IP，于是他想客户端发送 DHCPREQUEST 消息，然后等待服务器确认。此时客户端要面临三种情况，一是服务器返回 DHCPACK 消息，它可以继续使用当前 IP；二是收到 DHCPNAK 消息，服务器拒绝客户端继续租用当前 IP；三是客户端的 T2 时钟超时，客户端进入 REBINGDING 状态。 REBIDING 状态。此时客户端无法继续续租原有 IP，于是它持续向局域网广播 DHCPREQUEST 消息，直到有服务器响应它为止。此时客户端又面临三种情况。一是有服务器向客户端返回 DHCPACK 消息，于是客户端可以使用新分配的 IP；二是服务器返回 DHCPNAK 消息，这表明服务器希望客户端重新启动租借流程，于是客户端进入 INIT 状态；第三是，在收到回应前，客户端当前租用的 IP 到期，它重新进入 INIT 状态。 为了简单起见，我们将以客户端的方式编写代码，上面的流程状态可以使用下图统一描述： 3. 字段详解首先完成第一步，客户端向局域网广播消息，然后收到服务器应答。下面是 DHCP 消息的具体格式： 上面的是前面抓包时对应的 DHCP 部分，依次解析各个字段： op 字段 1 字节，它表明消息类型，请求消息使用数值1，回应消息使用数值2 HType 1 字节，它表明消息发送所使用的网络类型，由于我们默认使用互联网，因此它的值固定为 1 HLen 字段 1 字节，它表明设备硬件地址的长度，由于我们默认使用 mac 地址，因此该字段固定为 6 Hops 字段 1 字节，它表明数据包可以跨越几个不同网络，该字段的作用我们在前面 traceroute 程序中了解过，由于我们希望限制消息在当前局域网内流通，因此设置为 0 XID 字段 4 字节。它与 ICMP 消息中的 session 作用一样，用来标志一次对话过程 Secs 字段 2 字节。它用来表明客户端发出请求后等待的时间，一般该字段不常使用，我们将它固定为 0 Flags 字段 2 字节，取值 0 或 1，如果设置为 1，客户端要求服务器以广播的方式发送回应消息，因为此时客户端可能还没有 IP 地址 CIAddr 字段 4 字节，它存放客户端当前 IP 地址，如果客户端当前有 IP，而且进入状态 BOUND,RENEWING 状态，其他情况下统一设置为 0 YIAddr 字段 4 字节，这是服务器返回给客户端使用的IP SIAddr 字段 4 字节，服务器 IP 地址，它有点特殊，这个 IP 是不一定是当前交互的服务器 IP，而是设备下次启动时去获取IP地址的服务器IP GIAddr 字段 4 字节，网关 IP，当 DHCP 服务器不在本地局域网时，设备将通过该 IP 将数据包转发给处于另一个局域网的服务器，通常情况下使用不到 CHAddr 字段 16 字节，设备的硬件地址。由于我们默认设备使用 mac 地址，因此只使用到 6 个字节，其余 10 个字节用 0 填充 SName 字段 64 个字节，该字段用做 DHCP 服务器的字符串名称 File 字段 128 字节，该字段用于在设备和服务器间交换特定信息 Options 字段，可变长。该字段用于设备和服务器间交换多种配置信息 接下来我们看看 Options 字段，由于所有信息的交互都存储在该字段，因此我们需搞清楚它的结构。在该字段开始前是4个字节的 魔术字，固定为 99.130.83.99(十六进制：63 82 53 63)，然后才是一系列 Option 数据结构，Option 数据结构组成如下。 每个 Option 由三字段组成，第一字段是 Code,用来表明当前 Option 类型，它有两个特殊值，一个是 0，它表示当前 Option 只有这一个字节，另一个特殊值是 255，它表示后续不再含有 Option结构体；第二字段是 len，用来标志数据段的长度；第三字段是 Data，用来存储数据。 由于 Option 结构体用于客户端与服务器进行数据交换，因此它的种类相当繁杂。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"计算机网络/TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"DHCP","slug":"DHCP","permalink":"https://cherryyang05.github.io/hexo-blog/tags/DHCP/"}]},{"title":"BAT批处理文件的使用（二）","slug":"BAT批处理文件的使用（二）","date":"2020-05-09T10:44:22.000Z","updated":"2023-08-08T12:35:27.364Z","comments":true,"path":"58ced44c.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/58ced44c.html","excerpt":"BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 bat 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。","text":"BAT批处理（二）：批量删除指定文件以及相关简单的语法结构(if,for)，系统变量errorlevel，变量延迟等前两天在使用 VSCode 的时候，看到之前那么多 cpp 编译产生的 exe 可执行文件，于是心生一个念头，我要把它们全部删掉，但是又不想一个个地删，便想到了利用 bat 脚本批量删除 exe 文件。于是在搜集了大量资料后，开始了编写。 首先就是一条简单的 del： 1del F:\\Code\\C++\\*.exe 但是发现只能删除掉 C++ 那个文件夹根目录下的 exe 文件，然后发现，在后面加上 /s，表示在当前目录递归删除指定文件，就是还要进入子目录寻找文件。 &#x2F;a 根据百属性选择要删除的文件&#x2F;f 强制删除只读度文件&#x2F;s 从所有子目录删除指定文件&#x2F;q 安静模式。删除全局通配符时，不要求确知 1del F:\\Code\\C++\\*.exe /s 运行之后，哗啦啦，全删掉了(在其他盘里测试一下)：本来其实这样就可以了，把这个批处理脚本放到 C++ 文件夹根目录就行了，但是如果多次执行的时候，本来已经没有 exe 文件了，还要执行，就会提示 找不到 G:\\test\\*.exe，对于强迫症的我当然不能忍受起码提示一个 exe文件已经删完啦 之类的。要这样写势必要进行条件判断，然后，又去找了很多资料。一开始搜到一个 errorlevel 的系统变量，会判断你当前这条语句是否执行，如果成功执行该变量的值为 0， 否则是 1-255 之间的某一个值，这里的值主要是根据语句未能成功执行的原因（其实就是跟中断类型差不多）来决定的，一般是 1 123456789101112@echo off if ERRORLEVEL 1 goto failif ERRORLEVEL 0 goto successgoto done:failecho exe文件已经没有啦，别删啦~goto done:successecho 正在删除所有烦人的exe文件...del F:\\Code\\C++\\*.exe /s:doneecho 执行完成 运行后发现了中文乱码，于是改一下编码为 ANSI然后再次执行，发现不管 exe 文件是否被删掉，都会执行 success 标号的语句，说明 del 语句都被执行了，只是找不到文件而已。这种方法不行那就试试其他方法，用 if exist 条件判断应该可以吧 12345678910111213@echo off ::if ERRORLEVEL 1 goto fail::if ERRORLEVEL 0 goto successif exist F:\\Code\\C++\\*.exe (goto success) else (goto fail)goto done:failecho exe文件已经没有啦，别删啦~goto done:successecho 正在删除所有烦人的exe文件...del F:\\Code\\C++\\*.exe /s:doneecho 执行完成 这里的 ::是注释，当然注释还有其他写法 1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符） 2、rem 注释内容（不能出现重定向符号和管道符号） 3、echo 注释内容（不能出现重定向符号和管道符号）〉nul 4、if not exist nul 注释内容（不能出现重定向符号和管道符号） 5、:注释内容（注释文本不能与已有标签重名） 6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号） 7、goto 标签 注释内容（可以用作说明goto的条件和执行内容） 8、:标签 注释内容（可以用作标签下方段的执行内容 完美执行。然后在之后的其他测试中，若 C++ 根目录下没有 exe 文件，而在其子文件夹下有 exe 文件的话，就出问题了，因为 if exist 那行语句只是判断当前文件夹根目录下是否存在 exe 文件。那该怎么办呢？应该要对 C++ 根目录进行递归查找，便是 for 语句： 12345678910111213141516171819202122@echo offclsset PATH=F:\\Code\\C++\\set FILE=*.exe set cnt=0for /R %PATH% %%s in (%FILE%) do ( ::echo %%s set /a cnt=%cnt%+1)echo 删除了%cnt%个文件！if %cnt% EQU 0 (goto fail) else (goto success)goto done:failecho exe文件已经没有啦，别删啦~goto done:successecho 正在删除所有烦人的exe文件...del *.exe /secho 删除了%cnt%个文件！goto done:doneecho 执行完成 for 循环后面的 /R 便是对当前文件夹进行递归查找，若存在后缀名为 .exe 文件，便把计数值+1.然后运行，又出错了。。。cnt的值始终为1，这又是为什么呢？又查了许多资料，发现 批处理语法中还有叫什么 变量延迟 的语法，具体就是 当我们准备执行一条命令的时候，命令解释器会先将命令读取，如果命令中有环境变量，那么就会将变量的值先读取来出，然后在运行这条命令，如：echo %cnt%，当我们执行这条命令的时候，命令解释器会先读出 %cnt% 的值，然后执行echo，得到的结果是屏幕上显示出 cnt的值。但是，有的时候，我们在执行一条命令的时候，命令解释器将环境变量的值读出来以后，我们的环境变量的值发生了改变，这时个再执行命令就是使用的变量改变前的值，这就不是我们想要的结果了。也就是，当 for 语句执行时，命令解释器首先把它变成 1for /R %s in (*.exe) do (set /a cnt=0+1 ) 因此在这个循环里面 cnt 就全是0了，这里我们就需要用到 变量延迟 了，设置 setlocal enabledelayedexpansion，然后将需要使用变量延迟的变量两边用 ! 表示，即 set /a cnt=!cnt!+1.关闭变量延迟的话就是 setlocal disabledelayedexpansion.全部修改完了 bat 程序如下： 1234567891011121314151617181920212223@echo offclssetlocal enabledelayedexpansionset PATH=F:\\Code\\C++\\set FILE=*.exe set cnt=0for /R %PATH% %%s in (%FILE%) do ( ::echo %%s set /a cnt=!cnt!+1)if %cnt% EQU 0 (goto fail) else (goto success)goto done:failecho exe文件已经没有啦，别删啦~goto done:successecho 正在删除所有烦人的exe文件...del %PATH%%FILE% /secho 删除了%cnt%个文件！goto done:doneecho 执行完成endlocal 大功告成！！","categories":[{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"脚本","slug":"生产力工具/脚本","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"BAT","slug":"BAT","permalink":"https://cherryyang05.github.io/hexo-blog/tags/BAT/"},{"name":"批处理","slug":"批处理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"脚本","slug":"脚本","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"密码学（二）：古典密码之维吉尼亚密码的破解","slug":"密码学（二）：古典密码之维吉尼亚密码的破解","date":"2020-05-06T09:08:39.000Z","updated":"2023-08-08T12:35:27.417Z","comments":true,"path":"a1c2e50d.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/a1c2e50d.html","excerpt":"维吉尼亚密码的破解一、引言&amp;emsp;&amp;emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 e 是出现频率最高的，占12.7%；其次是t，9.1%；然后是a，o，i，n等，最少的是z，只占**0.1%**。","text":"维吉尼亚密码的破解一、引言&amp;emsp;&amp;emsp;上一章我们介绍了维吉尼亚密码的原理，是通过移位替换的加密方法进行加密，但是因为概率论的出现这种简单的移位或替换就容易破解了，其原理很简单，英文中字母出现的频率是不一样的。比如字母 e 是出现频率最高的，占12.7%；其次是t，9.1%；然后是a，o，i，n等，最少的是z，只占**0.1%**。 具体概率表 除了英语，其他语言也有相关统计（图片来源） 二、一般破解的方法1. 穷举密钥搜索&amp;emsp;&amp;emsp;只适用于与小的密钥空间，而像维吉尼亚密码的 $Z^n_{26}$ 是 26 的 n 次方的空间，当 n 很大时，计算量是相当大的。 2. 频率统计单表代换移位密码： 相同的明文字母总是对应相同的密文字母，因此，尽管字母的外形改变了，他出现的概率还是不变的，只要根据足够多的样例来进行统计，最终密文字母的出现概率总是近似于明文字母的出现概率，并且与之一一对应。 多表代换维吉尼亚密码： 相同的明文字母可能对应不同的密文字母，这里讲的维吉尼亚密码的破解也是根据字母出现的频率的蛛丝马迹进行破解。 三、维吉尼亚密码的破解1. 确定密钥长度方法一：Kasiski测试法原理：密文中出现两个相同字母组，它们所对应的明文字母相同的可能性很大，这样的两个密文字母组之间的距离可能为密钥长度的整数倍。&amp;emsp;&amp;emsp;尽管在维吉尼亚密码中相同的明文可能对应不同的密文，但是若连续出现相同的密文，那么用同样的密钥加密的概率会大大增加。这里密文 $ZB$ 都是用 $HI$ 加密，计算两者之间的距离为 $5$，因此可推断出来密钥长度为 $5.$ 方法二：重合指数法原理：自然语言（以英语为例）的重合指数约为 0.065，而且单标代换不会改变该值。重合指数定义： 设 $$x&#x3D;x_1x_2…x_n$$ 是含有 $n$ 个字母的串，则在 $x$ 中随机选择两个元素且这两个元素相同的概率为： 定义：$f_i$ 为 26 个字母中第 $i$ 个字母在 $x$ 中出现的次数 [例如：$x&#x3D;AAZZZ,n&#x3D;5,f_0&#x3D;2,f_{25}&#x3D;3$，第一次取出 A 的概率为 $\\frac {f_0} {n}$，第二次再取出 A 的概率为 $\\frac {f_0} {n} * \\frac {f_0-1} {n-1}$] 当我们把 26 个字母的概率全部相加，得到的总的概率就是重合指数：$$I_c(x)&#x3D;{\\frac {\\displaystyle\\sum_{i&#x3D;0}^{25}f_i(f_i-1)} {n(n-1)} }$$当计算的数量很大时，我们将 $n(n-1)$ 近似为 $n^2$，将 $f_i(f_i-1)$ 近似为 $f_i^2$ 因此$$I_c(x) \\approx \\displaystyle\\sum_{i&#x3D;0}^{25} {p_i^2} \\approx0.065$$这里的 $p_i$ 表示第 $i$ 个字母在英语语言中出现的概率，就是在引言中列出的数值。这个数值非常重要。 注意：在单表代换中，不会改变该值，也就是用相同密钥字加密应服从相同的重合指数。 猜测密钥长度&amp;emsp;&amp;emsp;假设密钥长度为 $d$，提取相同密钥字加密的密文，测试其重合指数。&amp;emsp;&amp;emsp;如果猜测正确，则重合指数接近 $0.065$，否则字符串表现得更加随机一般在 $0.038(1&#x2F;26) \\thicksim 0.065$ 之间。&amp;emsp;&amp;emsp;在这里，我们先猜测密钥长度为 5，然后将密文按照 5 进行分组，分别提取出用密钥 $k_1,k_2,k_3,k_4,k_5$ 加密的密文，组成集合 $C_1,C_2,C_3,C_4,C_5$，这样就把多表代换转化成了单表代换。这里 $C_1&#x3D;{Z,P,L,W,Z},C_2&#x3D;{P,A,Z,Z,N},C_3&#x3D;{D,Z,B,B,M},C_4&#x3D;{X,H,H,K},C_5&#x3D;{V,S,I,M}$ 以一个例子为例：&amp;emsp;&amp;emsp;$CHR$ 这三个字符出现频率较高，因此我们将其位置记录下来，测算他们之间的距离，并取最大公因数 5，猜测 5 便是密钥长度。这很有可能是相同的明文被相同的密文加密了。其实很容易猜到，这很可能是英语当中的定冠词 the. 我们在用重合指数法进行测试，分别测试 $d&#x3D;1,2,3,4,5$ （过程略） $d$ 重合指数 $1$ $[0.045]$ $2$ $[0.046,0.041]$ $3$ $[0.043,0050,0.047]$ $4$ $[0.042,0.039,0.046,0.040]$ $5$ $[0.063,0.068,0.069,0.061,0.072]$ &amp;emsp;&amp;emsp;观察发现，只有当 $d&#x3D;5$ 的时候，重合指数接近 $0.065$，因此刚刚的猜测 $d&#x3D;5$ 是正确的，这时通过穷举密钥的复杂度为 $26^5$，但是仍然比较大。 2. 确定密钥字相对位移密钥字的相对位移实际上就是确定密钥之间的相互关系。这里引入一个定义： 重合互指数:&amp;emsp;&amp;emsp;设 $x&#x3D;x_1,x_2,…,x_n,y&#x3D;y_1,y_2,…,y_{n’}$，分别为长度为 $n$ 和 $n’$ 的串，其重合互指数为从 $x$ 和 $y$ 中分别随机选出一个元素且两个元素相同的概率。 计算方法和刚刚的计算方法类似：$$MI_c(x,y)&#x3D;\\frac{\\displaystyle\\sum_{i&#x3D;0}^{25}f_if’_i}{nn’}$$具体不再阐述。 &amp;emsp;&amp;emsp;考虑不同密钥字加密后密文串的重合互指数，设密钥字为 $k&#x3D;k_1k_2…k_d$，$C_i$ 中的一个字母与 $C_j$ 中的一个字母都是 $A$ 的概率为 $p_{0-k_i}p_{0-k_j}$. 其中 $p_{0-k_i}$ 为密文 $A$ 所对应明文字母的出现概率。同理可以计算 $B,C,D,…,Z$，因此：$$MI_c(C_i,C_j) \\approx \\displaystyle\\sum_{l&#x3D;0}^{25}p_{l-k_i}p_{l-k_j}&#x3D;\\displaystyle\\sum_{l&#x3D;0}^{25}p_lp_{l+k_i-k_j}&#x3D;\\displaystyle\\sum_{l&#x3D;0}^{25}p_{l-k_i+k_j}p_l$$这里的下标是需要对 26 取模的，可以观察到：$Mi_c$ 取决于相对位移 $k_i-k_j$. 移位表如下：观察这里当相对距离为0时，重合互指数为 $0.065$，在之前提到的自然语言的重合互指数也是 $0.065$，这并不是巧合。当相对位移位 0 时，其实就是 $C_1,C_2$ 的集合是用同一种密文加密得到，这也就是单表代换这样，并不会改变重合指数。 这里其实并不需要列举从 0 到 25 的所有值。 猜测不同密钥字的相对位移s（猜测范围0~25）$$MI_c(C_i,C_j)&#x3D;\\frac{\\displaystyle\\sum_{t&#x3D;0}^{25}f_{i,t}f_{j,t-s} } {n_in_j}$$&amp;emsp;&amp;emsp;这里 $n_i$ 是指集合 $C_i$ 中字符个数，这里 $n_j$ 是指集合 $C_j$ 中字符个数，$f_{i,t}$ 表示在集合 $C_i$ 中，$t$ 这个密文字符出现的次数，$f_{j,t-s}$ 表示在集合 $C_j$ 中，$t-s$ 这个密文字符出现的次数。 &amp;emsp;&amp;emsp;如果猜对 $s$，那么 $MI_c$ 应该接近 $0.065$，这意味着找到了不同密钥字加密的相同的明文字母，这也就找到了密钥字之间的相对位移，也就转化成了单表代换。这里用 $m$ 表示明文字母，$c,c’$ 分别表示 $C_i,C_j$ 中 $m$ 对应的密文字母，那么：$$m&#x3D;c-k_i \\pmod{26} \\ m&#x3D;c’-k_j \\pmod{26}$$&amp;emsp;&amp;emsp;实际上，在维吉尼亚密码中，并没有很好的隐藏密钥和密文之间的相互关系，密钥之间的相互差距会体现在密文之间的相互关系。 &amp;emsp;&amp;emsp;我们计算上面例子中的集合 $C_1,C_2,C_3,C_4,C_5$ 两两之间的重合互指数： &amp;emsp;&amp;emsp;这里的 $i,j$ 表示当取到不同集合的时候，后面的值表示当猜测的相对位移 $s$ 取不同值的时候重合互指数的结果。 &amp;emsp;&amp;emsp;我们观察结果，当 $i&#x3D;1,j&#x3D;2,s&#x3D;9$ 时，重合互指数达到了 $0.068$，因此可以得到 $k_1-k_2&#x3D;9$.&amp;emsp;&amp;emsp;但是当 $i&#x3D;1,j&#x3D;3;i&#x3D;1,j&#x3D;4$ 时，没有合适的相对位移，那么我们先暂时跳过，观察其他结果，发现当 $i&#x3D;1,j&#x3D;5,s&#x3D;16$ 时，重合互指数达到 $0.070$，$i&#x3D;2,j&#x3D;3,s&#x3D;13$ 的时候，重合互指数达到了 $0.067$.我们列举完剩下的结果，得到：$$k_1-k_2&#x3D;9 \\ k_1-k_5&#x3D;16 \\ k_2-k_3&#x3D;13 \\ k_2-k_5&#x3D;7 \\ k_3-k_5&#x3D;20 \\ k_4-k_5&#x3D;11$$ 3. 穷举搜索密钥字&amp;emsp;&amp;emsp;根据上述的结果，在确定密钥字之间关系式的基础上，只要穷举 $26$ 中可能性就可以了。因为当猜测 $k_1$ 的时候， $k_2$ 也就确定下来了，以此类推，剩下的几个密钥也就确定下来了，只要从 $A-Z$ 进行穷举即可。 四、总结&amp;emsp;&amp;emsp;一个好的密码加密方案（或者说是算法），应该要很好的隐藏密钥和密文之间的联系，通过更复杂的算法或者在更大的密钥空间中，可以有效避免穷举搜索破解。如何设计加密算法以及如何选择合适的密钥空间，将在今后继续学习。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"密码学","slug":"课程笔记/密码学","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"古典密码","slug":"古典密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"维吉尼亚密码","slug":"维吉尼亚密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"}]},{"title":"密码学（一）：古典密码之维吉尼亚密码介绍","slug":"密码学（一）：古典密码之维吉尼亚密码介绍","date":"2020-05-06T08:55:26.000Z","updated":"2023-08-08T12:35:27.417Z","comments":true,"path":"73f9281.html","link":"","permalink":"https://cherryyang05.github.io/hexo-blog/73f9281.html","excerpt":"维吉尼亚（Vigenère Cipher）密码原理介绍一、介绍 &amp;emsp;&amp;emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。&amp;emsp;&amp;emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。&amp;emsp;&amp;emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。来源：百度百科","text":"维吉尼亚（Vigenère Cipher）密码原理介绍一、介绍 &amp;emsp;&amp;emsp;维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。&amp;emsp;&amp;emsp;维吉尼亚密码曾多次被发明。该方法最早记录在吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。然而，后来在19世纪时被误传为是法国外交官布莱斯·德·维吉尼亚（Blaise De Vigenère）所创造，因此现在被称为“维吉尼亚密码”。&amp;emsp;&amp;emsp;维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。这也让很多人使用维吉尼亚密码来加密的目的就是为了将其破解。来源：百度百科 二、古典密码1. 移位密码我们首先引入符号表示： $P$：明文空间，所有可能的明文组成的有限集$C$：密文空间，所有可能的密文组成的有限集$K$：密钥空间，所有可能的密钥 $k$ 组成的有限集$Enc$：加密算法&amp;emsp;&amp;emsp;$Enc_k(m)&#x3D;c$ 加密算法$Enc$以密钥$k$、明文$m$为输入，输出密文$c$$Dec$：加密算法&amp;emsp;&amp;emsp;$Dec_k(c)&#x3D;m$ 解密算法$Dec$以密钥$k$、密文$c$为输入，输出明文$m$算法正确性：对每个明文 $m\\in P$ 以及秘钥 $k\\in K$ 都有 $Dec_k(Enc_k(m))&#x3D;m$ 其中最典型的移位密码就是凯撒密码，凯撒密码是通过移位替换的方法，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。$$令P&#x3D;C&#x3D;K&#x3D;Z_{26}&#x3D;{ 0,1,2,3,…,25 } \\随机选择 K \\in Z_{26} 作为密钥 \\Enc_k(m)&#x3D;m+k \\pmod {26} \\Dec_k(c)&#x3D;c-k\\pmod{26}$$其中 $Z_{26}$ 是26个英文字母组成的集合空间。例如，当偏移量$k$是3的时候，所有的字母A将被替换成D，B变成E … Z变成C，以此类推。 2.维吉尼亚密码维吉尼亚密码便是移位密码的推广$$P&#x3D;C&#x3D;K&#x3D;Z_{26}^n\\随机选择密钥k&#x3D;(k_1,k_2,..,k_n) \\in Z_{26}^n \\Enc_k(m_1,m_2,…,m_n)&#x3D;(m_1+k_1,m_2+k_2,…,m_n+k_n) \\Dec_k(c_1,c_2,…,c_n)&#x3D;(c_1-k_1,c_2-k_2,…,c_n-k_n)$$实际上就是每个明文加上对应的密钥字。举例如下：若密钥为 $CIPHER$，即 $k&#x3D;(2,8,15,7,4,17)$明文是以下字符串： $THISCRYPTOSYSTEMISNOTSECURE$ 我们根据字母表将字符串翻译成数字： $(19,7,8,18,2,17,24,15,19,14,18,24,18,19,4,12,8,18,13,14,19,18,4,2,20,17,4)$ 然后将其按照密钥个数进行分组，分别与集合 $K$ 相加，得到密钥： $(21,15,23,25,6,8,0,23,8,21,22,15,20,1,19,19,12,9,15,22,8,25,8,19,22,25,19)$ 因此密文为： $VPXZGIAXIVWPUBTTMJPWIZITWZT$ 3. 二维表形式我们观察到，若密钥为1的话，A将会变成B，若密钥为2的话，A将会变成C，实际上就是字母表整体往左边移动了一个字母和两个字母的距离，我们把移动的26种情况整理下来，变成了一张二维表。其中棕色的行表示明文，橙色的列表示密钥。若密钥为3，实际上对应的字母为C，那么就到C的那一行，可以观察到，A对应的是C，以此类推。因此若想找明文A对应密钥为C的密文，只要找他们的交点即可。以上述例子为例，$THIS$ 的密钥为$(2,8,5,17)$，对应的字母为 $CIPH$，找到 $T$ 和 $C$的交点 $V$，$H$ 和 $I$ 的交点 $P$，$I$ 和 $P$ 的焦点 $X$，$S$ 和 $H$ 的交点 $Z$.因此其密文为 $VPXZ.$普通的移位密码是通过相同的移位来加密，若明文中有两个相同的字母，例如 $HAPPY$ 的$P$，加密过后仍然会有两个相同的字母，若样本多了之后，就可以根据一些单词的特征进行判断推理进行解密，因此普通的移位加密并不是一种好的加密方法。维吉尼亚密码就可以很好的解决这样的问题。 下一章将介绍维吉尼亚密码的解密。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"密码学","slug":"课程笔记/密码学","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"古典密码","slug":"古典密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"维吉尼亚密码","slug":"维吉尼亚密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Linux/"},{"name":"生产力工具","slug":"生产力工具","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"生产力工具/git","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/git/"},{"name":"编程语言","slug":"编程语言","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"运维","slug":"运维","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/"},{"name":"配置","slug":"运维/配置","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/%E9%85%8D%E7%BD%AE/"},{"name":"GDB","slug":"生产力工具/GDB","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/GDB/"},{"name":"C/C++","slug":"编程语言/C-C","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"},{"name":"脚本","slug":"生产力工具/脚本","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"},{"name":"代码规范","slug":"生产力工具/代码规范","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"计算机原理知识","slug":"计算机原理知识","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/"},{"name":"OpenSSD","slug":"OpenSSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/"},{"name":"文档","slug":"OpenSSD/文档","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/%E6%96%87%E6%A1%A3/"},{"name":"组会","slug":"OpenSSD/组会","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/%E7%BB%84%E4%BC%9A/"},{"name":"SSD","slug":"OpenSSD/SSD","permalink":"https://cherryyang05.github.io/hexo-blog/categories/OpenSSD/SSD/"},{"name":"课程笔记","slug":"课程笔记","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"体系结构","slug":"课程笔记/体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"Markdown","slug":"Markdown","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Markdown/"},{"name":"刷题","slug":"刷题","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/PTA/"},{"name":"LeetCode","slug":"刷题/LeetCode","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%88%B7%E9%A2%98/LeetCode/"},{"name":"工作","slug":"工作","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"博弈论","slug":"课程笔记/博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"计算机网络/TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://cherryyang05.github.io/hexo-blog/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"密码学","slug":"课程笔记/密码学","permalink":"https://cherryyang05.github.io/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux/"},{"name":"glibc","slug":"glibc","permalink":"https://cherryyang05.github.io/hexo-blog/tags/glibc/"},{"name":"git","slug":"git","permalink":"https://cherryyang05.github.io/hexo-blog/tags/git/"},{"name":"Rust","slug":"Rust","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Rust/"},{"name":"log4rs","slug":"log4rs","permalink":"https://cherryyang05.github.io/hexo-blog/tags/log4rs/"},{"name":"yum","slug":"yum","permalink":"https://cherryyang05.github.io/hexo-blog/tags/yum/"},{"name":"配置","slug":"配置","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E9%85%8D%E7%BD%AE/"},{"name":"Centos","slug":"Centos","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Centos/"},{"name":"GDB","slug":"GDB","permalink":"https://cherryyang05.github.io/hexo-blog/tags/GDB/"},{"name":"C","slug":"C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C/"},{"name":"宏","slug":"宏","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%AE%8F/"},{"name":"小工具","slug":"小工具","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"脚本","slug":"脚本","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%84%9A%E6%9C%AC/"},{"name":"Makefile","slug":"Makefile","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Makefile/"},{"name":"重构","slug":"重构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E9%87%8D%E6%9E%84/"},{"name":"代码架构","slug":"代码架构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"},{"name":"Java","slug":"Java","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Java/"},{"name":"并发多核","slug":"并发多核","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%B9%B6%E5%8F%91%E5%A4%9A%E6%A0%B8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"lib","slug":"lib","permalink":"https://cherryyang05.github.io/hexo-blog/tags/lib/"},{"name":"文档","slug":"文档","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%96%87%E6%A1%A3/"},{"name":"代码规范","slug":"代码规范","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"组会","slug":"组会","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BB%84%E4%BC%9A/"},{"name":"SSD","slug":"SSD","permalink":"https://cherryyang05.github.io/hexo-blog/tags/SSD/"},{"name":"sed","slug":"sed","permalink":"https://cherryyang05.github.io/hexo-blog/tags/sed/"},{"name":"awk","slug":"awk","permalink":"https://cherryyang05.github.io/hexo-blog/tags/awk/"},{"name":"grep","slug":"grep","permalink":"https://cherryyang05.github.io/hexo-blog/tags/grep/"},{"name":"Linux命令","slug":"Linux命令","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"Git","slug":"Git","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Git/"},{"name":"体系结构","slug":"体系结构","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编译器","slug":"编译器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"编译原理","slug":"编译原理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"markdown语法","slug":"markdown语法","permalink":"https://cherryyang05.github.io/hexo-blog/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"PTA","slug":"PTA","permalink":"https://cherryyang05.github.io/hexo-blog/tags/PTA/"},{"name":"上机","slug":"上机","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E4%B8%8A%E6%9C%BA/"},{"name":"算法","slug":"算法","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hot 100","slug":"Hot-100","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Hot-100/"},{"name":"可变参数","slug":"可变参数","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"},{"name":"笔试题","slug":"笔试题","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"},{"name":"makefile","slug":"makefile","permalink":"https://cherryyang05.github.io/hexo-blog/tags/makefile/"},{"name":"STL函数","slug":"STL函数","permalink":"https://cherryyang05.github.io/hexo-blog/tags/STL%E5%87%BD%E6%95%B0/"},{"name":"C/C++","slug":"C-C","permalink":"https://cherryyang05.github.io/hexo-blog/tags/C-C/"},{"name":"博弈论","slug":"博弈论","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TFTP协议","slug":"TFTP协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/TFTP%E5%8D%8F%E8%AE%AE/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"DNS协议","slug":"DNS协议","permalink":"https://cherryyang05.github.io/hexo-blog/tags/DNS%E5%8D%8F%E8%AE%AE/"},{"name":"Linux服务器","slug":"Linux服务器","permalink":"https://cherryyang05.github.io/hexo-blog/tags/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"JVM","slug":"JVM","permalink":"https://cherryyang05.github.io/hexo-blog/tags/JVM/"},{"name":"DHCP","slug":"DHCP","permalink":"https://cherryyang05.github.io/hexo-blog/tags/DHCP/"},{"name":"BAT","slug":"BAT","permalink":"https://cherryyang05.github.io/hexo-blog/tags/BAT/"},{"name":"批处理","slug":"批处理","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"密码学","slug":"密码学","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"古典密码","slug":"古典密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"维吉尼亚密码","slug":"维吉尼亚密码","permalink":"https://cherryyang05.github.io/hexo-blog/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"}]}