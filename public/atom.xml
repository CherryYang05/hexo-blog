<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北极熊不吃企鹅宝宝</title>
  
  <subtitle>为什么呢？</subtitle>
  <link href="http://cherryyang05.github.io/atom.xml" rel="self"/>
  
  <link href="http://cherryyang05.github.io/"/>
  <updated>2023-08-08T12:35:27.400Z</updated>
  <id>http://cherryyang05.github.io/</id>
  
  <author>
    <name>Cherry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust入门教程（八）：编写和运行测试</title>
    <link href="http://cherryyang05.github.io/290a7a7a.html"/>
    <id>http://cherryyang05.github.io/290a7a7a.html</id>
    <published>2023-08-08T12:35:27.400Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust入门教程（八）：编写和运行测试"><a href="#Rust入门教程（八）：编写和运行测试" class="headerlink" title="Rust入门教程（八）：编写和运行测试"></a>Rust入门教程（八）：编写和运行测试</h1><blockquote><p>这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。</p></blockquote><blockquote><p>测试函数体通常执行下面三个操作，也称 <code>3a</code> 操作：</p><ol><li>准备数据或状态（arrange）；</li><li>运行被测试的代码（act）；</li><li>断言结果（assert）。</li></ol></blockquote><span id="more"></span><h2 id="一、测试的使用及演示"><a href="#一、测试的使用及演示" class="headerlink" title="一、测试的使用及演示"></a>一、测试的使用及演示</h2><ul><li>测试函数需要使用 <code>test</code> 属性（attribute）进行标注<ul><li>attribute 就是一段代码的元数据</li><li>在函数紧接着上面一行添加 <code>#[test]</code>，就将函数变成测试函数了</li></ul></li><li>运行测试<ul><li>使用 <code>cargo test</code> 命令运行所有测试<ul><li>Rust 会构建一个 Test Runner 可执行文件，会运行标注的 test 函数，并报告运行是否成功</li></ul></li><li>当使用 cargo 创建 library 项目时，会生成一个 test module，里面有默认的 test 函数<ul><li>可以添加任意数量的 test module 和 test 函数</li></ul></li></ul></li></ul><h3 id="1-1-测试演示"><a href="#1-1-测试演示" class="headerlink" title="1.1 测试演示"></a>1.1 测试演示</h3><p>我们输入命令 <code>cargo new test_demo --lib</code> 创建一个项目，在 <code>lib.rs</code> 文件中看到这样的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>assert_eq!</code> 是一个断言的宏，判断两个数是否相等。</p><p>然后运行 <code>cargo test</code>，结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test               </span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">2.33</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests test_demo</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h3 id="1-2-测试失败"><a href="#1-2-测试失败" class="headerlink" title="1.2 测试失败"></a>1.2 测试失败</h3><ul><li>测试函数 panic 就表示测试失败</li><li>每个测试都运行在一个新线程中</li><li>当主线程看到测试线程挂掉后，那个测试就被标记为失败</li></ul><p>我们单独编写一个带有 panic 的测试函数，测试结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">another</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Test Failed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::another ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::another stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::another&#x27; panicked at <span class="symbol">&#x27;Test</span> Failed!&#x27;, src/lib.rs:<span class="number">11</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::another</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">1</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure><h2 id="二、断言"><a href="#二、断言" class="headerlink" title="二、断言"></a>二、断言</h2><h3 id="2-1-使用-assert-宏检查测试结果"><a href="#2-1-使用-assert-宏检查测试结果" class="headerlink" title="2.1 使用 assert! 宏检查测试结果"></a>2.1 使用 assert! 宏检查测试结果</h3><ul><li>assert! 来自于标准库，用来确定某个状态是否为 true<ul><li>如果为 true，表示测试通过</li><li>如果为 false，则调用 panic! 宏，测试失败</li></ul></li></ul><p>我们用之前写的一个小例子，判断矩形 r1 是否能容纳矩形 r2（为了简单起见，只判断正着放，而不考虑斜着放进去）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> other.x &gt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> other.x &lt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">self</span>.x &gt; x &amp;&amp; <span class="keyword">self</span>.y &gt; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rect &#123; x: <span class="number">12</span>, y: <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rect &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(r1.<span class="title function_ invoke__">can_hold</span>(&amp;r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然返回是 true，测试通过。</p><h3 id="2-2-使用-assert-eq-和-assert-ne-测试相等性"><a href="#2-2-使用-assert-eq-和-assert-ne-测试相等性" class="headerlink" title="2.2 使用 assert_eq! 和 assert_ne! 测试相等性"></a>2.2 使用 assert_eq! 和 assert_ne! 测试相等性</h3><ul><li>都来自标准库</li><li>判断两个参数是否相等或不等</li><li>实际上，它们使用的就是 <code>==</code> 和 <code>!=</code> 运算符</li><li>如果断言失败，该宏会自动打印出两个参数的值<ul><li>使用 debug 格式打印参数</li><li>要求参数实现 PartialEq 和 Debug Traits（所有基本类型和标准库里大部分类型基本都实现了）</li><li>如果使用 <code>assert!</code> 宏，则只会告知测试结果而不会打印出两个参数的值</li></ul></li></ul><p>我们再写一个简单的例子，将一个数加 2，判断两个值是否相等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">it_add_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显然是正确的，若我们更改函数逻辑，把加 2 改成加 3，则运行测试结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.39</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">3</span> tests</span><br><span class="line">test tests::it_add_two ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line">test tests::larger_can_hold_smaller ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::it_add_two stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_add_two&#x27; panicked at <span class="symbol">&#x27;assertion</span> failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">4</span>`,</span><br><span class="line"> right: `<span class="number">5</span>`&#x27;, src/lib.rs:<span class="number">37</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::it_add_two</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">2</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure><p>编译器将会自动给出两个参数的值（左值和右值），若将宏改成 <code>assert_ne!</code> 测试结果又将变成正确。</p><h2 id="三、自定义错误消息"><a href="#三、自定义错误消息" class="headerlink" title="三、自定义错误消息"></a>三、自定义错误消息</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust入门教程（八）：编写和运行测试&quot;&gt;&lt;a href=&quot;#Rust入门教程（八）：编写和运行测试&quot; class=&quot;headerlink&quot; title=&quot;Rust入门教程（八）：编写和运行测试&quot;&gt;&lt;/a&gt;Rust入门教程（八）：编写和运行测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;测试函数体通常执行下面三个操作，也称 &lt;code&gt;3a&lt;/code&gt; 操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备数据或状态（arrange）；&lt;/li&gt;
&lt;li&gt;运行被测试的代码（act）；&lt;/li&gt;
&lt;li&gt;断言结果（assert）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>用 gdb 调试程序</title>
    <link href="http://cherryyang05.github.io/1ea0c606.html"/>
    <id>http://cherryyang05.github.io/1ea0c606.html</id>
    <published>2023-07-08T14:29:49.000Z</published>
    <updated>2023-08-08T12:35:27.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～</p></blockquote><span id="more"></span><h2 id="1-gdb-调试-run-和-start-的区别"><a href="#1-gdb-调试-run-和-start-的区别" class="headerlink" title="1. gdb 调试 run 和 start 的区别"></a>1. gdb 调试 run 和 start 的区别</h2><p>一般来说，在启动 gdb 之后，执行 <code>r</code> 或者 <code>run</code> 之后，就开始执行程序了，直到遇到第一个断点。</p><p><code>start</code> 指令会执行程序至 <code>main()</code> 主函数的起始位置，即在主函数的第一行停止执行（改行代码还没有执行）。</p><p>另外，程序执行过程中使用 <code>run</code> 或 <code>start</code> 指令，表示重新启动程序。</p><h2 id="2-gdb-tui：在-gdb-中显示程序源码"><a href="#2-gdb-tui：在-gdb-中显示程序源码" class="headerlink" title="2. gdb tui：在 gdb 中显示程序源码"></a>2. gdb tui：在 gdb 中显示程序源码</h2><p>我们使用 gdb 的时候，想要看源码，需要输入 <code>list</code> 命令查看断点前后的代码，但是 <code>list</code> 没有代码高亮，也无法实时跟踪。用 gdb tui 自带的界面可以方便的查看并跟踪源码。输入命令 <code>gdb -tui</code> 打开窗口。</p><p>gdb 还有其他窗口类型，输入如下命令可以打开相应的窗口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout cmd  // 命令窗口，可以输入调试命令</span><br><span class="line">layout src  // 源代码窗口，显示当前行、断点等信息</span><br><span class="line">layout asm  // 汇编代码窗口</span><br><span class="line">layout reg  // 寄存器窗口</span><br></pre></td></tr></table></figure><p>要想使用这些窗口，需要通过源码编译 gdb，在编译时添加参数 <code>--enable-tui</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/gdb-11.2</span><br><span class="line">make -j32</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在编译安装时可能会出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: no enhanced curses library found; disable TUI</span><br></pre></td></tr></table></figure><p>在 CentOS 下需要安装 <code>ncurses-devel</code> 包，Ubuntu 下安装 <code>libncurses5-dev</code></p><h1 id="Log-的使用"><a href="#Log-的使用" class="headerlink" title="Log 的使用"></a>Log 的使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ logger <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">➜  ~ <span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line">2022-10-04 22:42:30.438584+0800 0x81a171   Default     0x0                  47131  0    logger: Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="GDB" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/GDB/"/>
    
    
    <category term="GDB" scheme="http://cherryyang05.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>C 语言预处理器和宏的高级用法</title>
    <link href="http://cherryyang05.github.io/aaaac292.html"/>
    <id>http://cherryyang05.github.io/aaaac292.html</id>
    <published>2023-01-22T14:27:45.000Z</published>
    <updated>2023-08-08T12:35:27.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章介绍 C 语言中类似 <code>#define</code>, <code>#if</code>, <code>#ifdef</code> 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。<br>本篇文章将不会介绍简单的宏用法，例如 <code>#define ADD(a, b) ((a)+(b))</code><br>本篇文章大部分参考《C Primer Plus 第六版》第 16 章</p></blockquote><span id="more"></span><h2 id="一、预处理及宏"><a href="#一、预处理及宏" class="headerlink" title="一、预处理及宏"></a>一、预处理及宏</h2><h3 id="1-1-“-”-运算符"><a href="#1-1-“-”-运算符" class="headerlink" title="1.1 “#” 运算符"></a>1.1 “#” 运算符</h3><p><code>#</code> 是一个预处理运算符，可以将记号转化成字符串。例如 <code>#define TYPE(x) #x</code>，若使用宏 <code>TYPE(int)</code>，则将其替换成<strong>字符串</strong> <code>&quot;int&quot;</code>，<code>#x</code> 就是转换为 <code>x</code> 的形参名。</p><p>下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The num 3 is an &quot;</span>TYPE(<span class="type">int</span>)<span class="string">&quot; type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<code>The num 3 is an int type</code></p><h3 id="1-2-“-”-运算符"><a href="#1-2-“-”-运算符" class="headerlink" title="1.2 “##” 运算符"></a>1.2 “##” 运算符</h3><p>与 <code>#</code> 运算符类似，<code>##</code> 运算符可以用于类函数宏的替换部分，而且还可以用于对象宏的替换部分。<code>##</code> 运算符将两个记号组合成一个记号，例如 <code>#define TEST(n) TEST_##n</code>，然后宏 <code>TEST1</code> 将其展开为 <code>TEST_1</code>。</p><p>下面是一个具体的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_XN(n) printf(<span class="string">&quot;x&quot;</span>#n<span class="string">&quot; = %d\n&quot;</span>, x##n) </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">14</span>;      <span class="comment">// 展开成 int x1 = 14;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">2</span>)</span> = <span class="number">20</span>;      <span class="comment">// 展开成 int x2 = 20;</span></span><br><span class="line">    <span class="type">int</span> x3 = <span class="number">30</span>;</span><br><span class="line">    PRINT_XN(<span class="number">1</span>);            <span class="comment">// 展开成 printf(&quot;x1 = %d\n&quot;, x1);</span></span><br><span class="line">    PRINT_XN(<span class="number">2</span>);            <span class="comment">// 展开成 printf(&quot;x2 = %d\n&quot;, x2);</span></span><br><span class="line">    PRINT_XN(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>#</code> 运算符组合成<strong>字符串</strong>，而 <code>##</code> 运算符组合成为一个新的<strong>标识符</strong>。</p></blockquote><h3 id="1-3-undef-指令"><a href="#1-3-undef-指令" class="headerlink" title="1.3 #undef 指令"></a>1.3 #undef 指令</h3><p><code>#undef</code> 指令用于取消已定义的 <code>#define</code> 指令。若之前没有定义某个宏，取消对其的定义也是有效的，如果想使用一个名称，但不确定之前是否已经用过，使用 <code>#undef</code> 先取消定义是一个安全的方法。</p><h3 id="1-4-条件编译指令"><a href="#1-4-条件编译指令" class="headerlink" title="1.4 条件编译指令"></a>1.4 条件编译指令</h3><h4 id="1-4-1-ifdef、-else-和-endif-指令"><a href="#1-4-1-ifdef、-else-和-endif-指令" class="headerlink" title="1.4.1 #ifdef、#else 和 #endif 指令"></a>1.4.1 #ifdef、#else 和 #endif 指令</h4><p>先用一个简单的例子来说明这三个条件编译指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;horse.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cow.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述代码理解起来应该挺简单，若用 <code>#define</code> 定义了 <code>MAVIS</code>，就引入 <code>horse.h</code> 头文件，若没有定义 <code>MAVIS</code> 就引入头文件 <code>cow.h</code>。</p><p><code>#ifdef</code> 测试的宏可以是对象宏，也可以是函数宏。</p><h4 id="1-4-2-ifndef"><a href="#1-4-2-ifndef" class="headerlink" title="1.4.2 #ifndef"></a>1.4.2 #ifndef</h4><p><code>#ifndef</code> 用法和 <code>#ifdef</code> 类似，但是意思相反。除此之外 <code>#ifndef</code> 还可以防止相同的宏被重复定义，例如下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MATH_H_</span></span><br></pre></td></tr></table></figure><p>通过 <code>#ifndef</code> 也可以避免头文件被引入多次。</p><h4 id="1-4-3-if、-elif"><a href="#1-4-3-if、-elif" class="headerlink" title="1.4.3 #if、#elif"></a>1.4.3 #if、#elif</h4><p><code>#if</code> 和 <code>#elif</code> 后面跟一个常量表达式，如果表达式的值为非零，则表达式为真，类似于 C 语言中的 if else，可以使用关系运算符和逻辑运算符。</p><p><code>#if</code> 和 <code>#elif</code> 后面的宏只能是对象宏，不能是函数宏。</p><h4 id="1-4-4-defined"><a href="#1-4-4-defined" class="headerlink" title="1.4.4 #defined"></a>1.4.4 #defined</h4><p><code>#defined</code> 用于判断宏是否已经被定义，可以是对象宏，也可以是函数宏，可以和 <code>#elif</code> 嵌套使用。</p><p>条件编译可以让程序更容易移植，改变文件开头的几个关键定义，可以根据不同的架构或系统设置不同的值和包含不同的文件。</p><h3 id="1-5-预定义宏"><a href="#1-5-预定义宏" class="headerlink" title="1.5 预定义宏"></a>1.5 预定义宏</h3><p>C 标准规定了一些预定义宏，如下列表格所示。</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td>预处理的日期（“Mmm dd yyyy”形式的字面量，如 Nov 12 2023）</td></tr><tr><td><strong>FILE</strong></td><td>表示当前源代码文件名的字符串字面量</td></tr><tr><td><strong>LINE</strong></td><td>表示当前源代码文件中行号的整型量</td></tr><tr><td><strong>STDC</strong></td><td>设置为 1 时表示遵循 C 标准</td></tr><tr><td><strong>STDC_HOSTED</strong></td><td>本机环境设置为 1，否则设置为 0</td></tr><tr><td><strong>STDC_VERSION</strong></td><td>支持 C99 标准，设置为 199901L；支持 C11标准，设置为 201112L</td></tr><tr><td><strong>TIME</strong></td><td>翻译代码的时间，格式为 “hh:mm:ss”</td></tr></tbody></table><h3 id="1-6-line-和-error"><a href="#1-6-line-和-error" class="headerlink" title="1.6 #line 和 #error"></a>1.6 #line 和 #error</h3><p><code>#line</code> 指令重置 <code>__LINE__</code> 和 <code>__FILE__</code> 宏报告的行号和文件名，用法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 1000          <span class="comment">// 将当前行号重置为 1000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 cool.c     <span class="comment">// 将当前行号重置为 10，文件名重置为 cool.c</span></span></span><br></pre></td></tr></table></figure><p><code>#error</code> 指令让预处理器发出一条错误信息，该消息包含指令中的文本，用法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编译上述代码将会产生 error，并且提示 <code>Not C11</code>。</p><h3 id="1-7-变参宏-…-和-VA-ARGS"><a href="#1-7-变参宏-…-和-VA-ARGS" class="headerlink" title="1.7 变参宏 … 和 __VA_ARGS__"></a>1.7 变参宏 … 和 __VA_ARGS__</h3><p>一些函数可以接受数量可变的参数，例如 <code>printf</code>，在头文件 <code>stdvar.h</code> 中提供了相关操作。</p><p>同样，宏定义中也可以实现可变参数，通过将宏列表中最后的参数写成 <code>...</code> 来实现这一功能。这样，预定义宏 <code>__VA_ARGS__</code> 可用在替换部分中，用来表示省略号代表什么。例如定义 <code>#define PRINT(...) printf(__VA_ARGS__)</code>，调用宏 <code>PRINT(&quot;Hello&quot;)</code>，<code>__VA_ARGS__</code> 展开为一个参数 <code>Hello</code>，调用宏 <code>PRINT(&quot;My name is %s&quot;, name)</code>，<code>__VA_ARGS__</code> 展开为两个参数 <code>&quot;My name is %s&quot;</code> 和 <code>name</code>。</p><h3 id="1-8-attribute"><a href="#1-8-attribute" class="headerlink" title="1.8 attribute"></a>1.8 <strong>attribute</strong></h3><p>GNU C 的一大特色就是 <code>__attribute__</code> 机制。<code>__attribute__</code> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute）。</p><p>具体内容请参见链接 <a href="https://blog.csdn.net/qlexcel/article/details/92656797">C语言__attribute__的使用</a>、<a href="https://blog.csdn.net/weaiken/article/details/88085360"><strong>attribute</strong> 机制详解</a></p><h2 id="二、宏模板"><a href="#二、宏模板" class="headerlink" title="二、宏模板"></a>二、宏模板</h2><p>由于 C 语言中库比较少，而一些比较基础的操作又无需通过函数实现，因此可以将一些基础功能写成宏进行展开，并集成到头文件中，在今后的项目中可以很方便的进行调用。</p><p>在这里我自己总结并整理了若干个常用的宏。</p><table><thead><tr><th>宏名称</th><th>功能</th></tr></thead><tbody><tr><td>LOG</td><td>打印调试信息（带颜色）</td></tr><tr><td>UPPERCASE</td><td>转化为大写字母</td></tr><tr><td>LOWERCASE</td><td>转化为小写字母</td></tr><tr><td>FPOS</td><td>获取结构体成员偏移量</td></tr><tr><td>FSIZ</td><td>获取结构体成员所占用字节数</td></tr><tr><td>container_of</td><td>根据成员指针、结构体类型、结构体成员名称获取结构体起始地址</td></tr><tr><td>offsetof</td><td>获取结构体成员偏移量</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-1-打印调试信息"><a href="#2-1-打印调试信息" class="headerlink" title="2.1 打印调试信息"></a>2.1 打印调试信息</h3><p>调试信息是任何项目必不可少的内容，下面的宏可以在终端中输出带颜色的调试标签，方便观察错误和警告信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LOG_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR_STYLE <span class="string">&quot;\x1b[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO_STYLE <span class="string">&quot;\x1b[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING_STYLE <span class="string">&quot;\x1b[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_STYLE_CLEAR <span class="string">&quot;\x1b[0m &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) printf(LOG_ERROR_STYLE<span class="string">&quot;[ERROR]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) printf(LOG_INFO_STYLE<span class="string">&quot;[INFO]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING(...) printf(LOG_WARNING_STYLE<span class="string">&quot;[WARN]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(TYPE, ...) LOG_##TYPE(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>调用上面的 <code>LOG</code> 宏，可以看到结果如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LOG(ERROR, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is an error msg...\n&quot;</span>);</span><br><span class="line">    LOG(INFO, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is an info msg...\n&quot;</span>);</span><br><span class="line">    LOG(WARNING, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is a warning msg...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/20230122232752.png" alt="LOG宏实现效果"></p><h3 id="2-2-大小写转化"><a href="#2-2-大小写转化" class="headerlink" title="2.2 大小写转化"></a>2.2 大小写转化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UPPERCASE(c) (c &amp; 0xdf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWERCASE(c) (c | 0x20)</span></span><br></pre></td></tr></table></figure><h3 id="2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量"><a href="#2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量" class="headerlink" title="2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量"></a>2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FPOS(type, member) (&amp;((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-得到一个结构体中某个成员字段-member-所占用的字节数"><a href="#2-4-得到一个结构体中某个成员字段-member-所占用的字节数" class="headerlink" title="2.4 得到一个结构体中某个成员字段 member 所占用的字节数"></a>2.4 得到一个结构体中某个成员字段 member 所占用的字节数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSIZ(type, member) sizeof(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-container-of"><a href="#2-5-container-of" class="headerlink" title="2.5 container_of"></a>2.5 container_of</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;              \</span></span><br><span class="line"><span class="meta">const typeof(((type *)0)-&gt;member) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">(type *)((char *)__mptr - __offsetof(type,member)); &#125;)</span></span><br></pre></td></tr></table></figure><p><code>container_of</code> 宏函数的作用是 <strong>已知结构体 type 的成员 member 的地址 ptr，得到结构体 type 的起始地址</strong>。</p><p>第一行用于“类型检查”。它确保 type 有一个名为 member 的成员（不过我认为这也是由 offsetof 宏完成的），并且如果 ptr 不是指向正确类型（成员的类型）的指针，编译器将打印警告，这对调试很有用。</p><p>在上述宏的第三行，用了 <code>char *</code> 进行指针转化，这是因为 <code>offsetof</code> 指针偏移量是按照字节计算的，同时 <code>char *</code> 的指针也是以字节计算的，若转化为例如 <code>int *</code> 等类型，则 C 的指针算法将会计算 <code>sizeof(int) * offsetof</code> 作为最终的结果，也就是 4 字节乘以偏移量。</p><p>具体说明参考链接 <a href="https://blog.csdn.net/s2603898260/article/details/79371024">container of()函数简介</a> 和 <a href="https://zhuanlan.zhihu.com/p/54932270">linux 内核宏container_of剖析</a></p><h3 id="2-6-offsetof"><a href="#2-6-offsetof" class="headerlink" title="2.6 offsetof"></a>2.6 offsetof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp; ((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p><code>offsetof</code> 宏函数的作用是 <strong>得到结构体 type 的成员 member 所在的内存偏移量</strong></p><p>对于 <code>container of</code> 以及 <code>offsetof</code> 我会单独用一篇博客进行详细讲解。</p><h3 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h3><h3 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h3><h3 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h3><h3 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h3><h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章介绍 C 语言中类似 &lt;code&gt;#define&lt;/code&gt;, &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。&lt;br&gt;本篇文章将不会介绍简单的宏用法，例如 &lt;code&gt;#define ADD(a, b) ((a)+(b))&lt;/code&gt;&lt;br&gt;本篇文章大部分参考《C Primer Plus 第六版》第 16 章&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C/C++" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
    <category term="C" scheme="http://cherryyang05.github.io/tags/C/"/>
    
    <category term="宏" scheme="http://cherryyang05.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>Rust实现进度条功能</title>
    <link href="http://cherryyang05.github.io/84b8101e.html"/>
    <id>http://cherryyang05.github.io/84b8101e.html</id>
    <published>2023-01-12T07:57:27.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。</p></blockquote><span id="more"></span><h2 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h2><p>先上代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bar_show</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> BAR_FRONT: &amp;<span class="type">str</span> = <span class="string">&quot;-\\|/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">index</span> <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(</span><br><span class="line">            <span class="string">&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</span>,</span><br><span class="line">            BAR_FRONT.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">nth</span>(index % <span class="number">4</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(index / <span class="number">3</span>),</span><br><span class="line">            index</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为终端输出的进度条是带颜色的，在这里没法显示，只能通过截图看。</p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230112160436.png" alt="进度条显示"></p><h2 id="二、代码解释"><a href="#二、代码解释" class="headerlink" title="二、代码解释"></a>二、代码解释</h2><p>进度条前面的指示字符是 <code>&quot;-\\|/&quot;</code> 交替显示，呈现出动态效果，因为 <code>\</code> 需要转义，所以是两个反斜杠 <code>\\</code>。</p><p>然后就是进度条从 0-100 开始，每一次循环输出指示字符(模 4)，空白字符重复 (index &#x2F; times) 次，根据进度条长度进行调整除数。然后刷新输出流，要不然输出会在缓存中，每隔一段时间才会输出到设备，不会实时显示进度条进度，最后再睡眠 30ms，让进度条缓慢加载。</p><p>最重要的是这一句：<code>&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</code>。</p><p>首先，<code>\r</code> 表示将光标置于本行行首，使用 <code>print!</code> 可以使得每次输出覆盖之前输出的行。然后 <code>\u</code> 表示输出后面的 <code>UniCode</code> 字符，<code>&#123;&#125;</code> 就不用说了，是 Rust 里用来控制格式化输出的。</p><blockquote><p>注：Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows 系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\n\r”；Mac 系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix&#x2F;Mac 系统下的文件在 Windows里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix&#x2F;Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。所以，如果你需要跨平台处理文本文件，可能会被回车换行搅得有点头大。<br>0x0D（ascii 码是 13） 指的是“回车”   \r 是把光标置于本行行首<br>0x0A（ascii 码是 10） 指的是“换行”   \n 是把光标置于下一行的同一列<br>0x0D + 0x0A         回车换行       \r\n 是把光标置于下一行行首 </p></blockquote><p><code>\u&#123;1b&#125;[42m</code> 这句的格式是 <code>\x1b[&lt;代码&gt;;&lt;代码&gt;</code>，其中 <code>\x1b[</code> 是十六进制 1b，写成八进制 <code>\033</code> 也行，然后一个左中括号，是特殊的终端控制符，格式固定。然后后面跟上一个数字和一个字母，这里 <code>42m</code> 就是将背景设置为绿色，字母 m 表示设置的属性类别，数字代表属性值。</p><p>下面是一些其他属性，可以设置文本的颜色，背景色，设置是否加粗，下划线等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">\033[0m 关闭所有属性</span><br><span class="line">\033[1m 设置加粗</span><br><span class="line">\033[2m 设置模糊，有的终端可能不支持</span><br><span class="line">\033[3m 设置斜体，有的终端可能不支持</span><br><span class="line">\033[4m 下划线（单线）</span><br><span class="line">\033[5m 闪烁（慢）</span><br><span class="line">\033[5m 闪烁（快），有的终端可能不支持</span><br><span class="line">\033[7m 交换背景色与前景色</span><br><span class="line">\033[8m 隐藏所有</span><br><span class="line">\033[30m 至 \033[37m 设置前景色</span><br><span class="line">\033[40m 至 \033[47m 设置背景色</span><br><span class="line">\033[nA 光标上移n行 </span><br><span class="line">\033[nB 光标下移n行</span><br><span class="line">\033[nC 光标右移n行</span><br><span class="line">\033[nD 光标左移n行</span><br><span class="line">\033[y;xH 设置光标位置</span><br><span class="line">\033[2J 清屏</span><br><span class="line">\033[K 清除从光标到行尾的内容</span><br><span class="line">\033[s 保存光标位置 </span><br><span class="line">\033[u 恢复光标位置</span><br><span class="line">\033[?25l 隐藏光标</span><br><span class="line">\033[?25h 显示光标</span><br></pre></td></tr></table></figure><p>各个数字代表的颜色如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">字背景颜色范围:40--49</span><br><span class="line">    40:黑</span><br><span class="line">    41:深红</span><br><span class="line">    42:绿</span><br><span class="line">    43:黄色</span><br><span class="line">    44:蓝色</span><br><span class="line">    45:紫色</span><br><span class="line">    46:深绿</span><br><span class="line">    47:白色</span><br><span class="line">字颜色: 30--39</span><br><span class="line">    30:黑</span><br><span class="line">    31:红</span><br><span class="line">    32:绿</span><br><span class="line">    33:黄</span><br><span class="line">    34:蓝色</span><br><span class="line">    35:紫色</span><br><span class="line">    36:深绿 </span><br><span class="line">    37:白色</span><br></pre></td></tr></table></figure><p>另外，同类的多种设置项可以组合在一起，中间用分号 <code>;</code> 隔开。</p><p>例如 <code>print!(&quot;\u&#123;1b&#125;[31;1;3;4m&#123;&#125;\u&#123;1b&#125;[0m&quot;, &quot;Rosa&quot;);</code>，其中 <code>\u&#123;1b&#125;[31;1;3;4m</code> 中，<code>31</code> 表示前景色（字的颜色）是红色，<code>1</code> 表示加粗，<code>3</code> 表示设置斜体，<code>4</code> 表示设置下划线。则上述代码输出的是一个红色加粗加下划线的斜体字符串 <code>Rosa</code>。最后的 <code>\u&#123;1b&#125;[0m</code> 表示将格式清除掉，否则下面输出的任何字符都将使用刚刚的样式。</p><p>同样，在 C 语言中也可以实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> color = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[20;1H\033[1;4;%dmHello, world.\033[0m&quot;</span>, color);</span><br></pre></td></tr></table></figure><p>这行命令首先 <code>\033[20;1H</code> 将光标移动到终端第 20 行第 1 列，之后的 <code>\033[1;4;32m</code> 将文本属性设置为高亮、带下划线且颜色为绿色，然后输出 <code>Hello,world</code>，最后 <code>\033[0m</code> 将终端属性恢复为默认值。</p><h2 id="三、一些参考实现"><a href="#三、一些参考实现" class="headerlink" title="三、一些参考实现"></a>三、一些参考实现</h2><h3 id="3-1-bash-中输出带样式的字符"><a href="#3-1-bash-中输出带样式的字符" class="headerlink" title="3.1 bash 中输出带样式的字符"></a>3.1 bash 中输出带样式的字符</h3><p>在 bash 中，通常我们可以使用 <code>echo</code> 命令加 <code>-e</code> 选项输出各种颜色的文本，<code>echo -e</code> 表示处理特殊字符，开启转义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;\033[31mRed Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[32mGreen Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[33mYellow Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[34mBlue Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[35mMagenta Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[36mCyan Text\033[0m&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-C-语言中输出颜色表"><a href="#3-2-C-语言中输出颜色表" class="headerlink" title="3.2 C 语言中输出颜色表"></a>3.2 C 语言中输出颜色表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            n = <span class="number">10</span> * i + j;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">108</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[%dm %3d\033[m&quot;</span>, n, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、参考文档"><a href="#四、参考文档" class="headerlink" title="四、参考文档"></a>四、参考文档</h2><p><a href="https://www.cnblogs.com/goloving/p/15015053.html">浅析 <code>\x1B[1;3;31mxterm.js\x1B[0m</code> 是什么？如何在终端输出带颜色等格式的字符串 </a></p><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI escape code</a></p><p><a href="https://www.cnblogs.com/opangle/p/4082692.html">控制台终端输出颜色</a></p><p>Rust 官方有进度条实现的 <a href="https://crates.io/crates/indicatif">indicatif crate</a>，用法比较全面，这里是 <a href="http://wilson-blog.cn/post/2021/02/20/rust.indicatif.html#indicatifmultiprogress">源码解析</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
    <category term="小工具" scheme="http://cherryyang05.github.io/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Makefile的简单使用</title>
    <link href="http://cherryyang05.github.io/31dce7e5.html"/>
    <id>http://cherryyang05.github.io/31dce7e5.html</id>
    <published>2023-01-05T07:50:03.000Z</published>
    <updated>2023-08-08T12:35:27.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-的简单使用"><a href="#Makefile-的简单使用" class="headerlink" title="Makefile 的简单使用"></a>Makefile 的简单使用</h2><blockquote><p>makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。</p></blockquote><span id="more"></span><h3 id="一、环境及样例源代码"><a href="#一、环境及样例源代码" class="headerlink" title="一、环境及样例源代码"></a>一、环境及样例源代码</h3><p>本机环境： MacBook M1<br>测试用源代码：</p><ul><li>main.cpp</li><li>print.cpp</li><li>add.cpp</li><li>func.h</li><li>makefile</li></ul><p><strong>main.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printHappyNewYear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_one</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>print.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Happy New Year!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>func.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _FUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="二、编译方式"><a href="#二、编译方式" class="headerlink" title="二、编译方式"></a>二、编译方式</h3><h4 id="2-1-手动编译"><a href="#2-1-手动编译" class="headerlink" title="2.1 手动编译"></a>2.1 手动编译</h4><p>这种方式很简单，直接输入下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp add.cpp print.cpp -o main</span><br></pre></td></tr></table></figure><p>但这种显然不是我们想要的。</p><h4 id="2-2-makefile-脚本编译"><a href="#2-2-makefile-脚本编译" class="headerlink" title="2.2 makefile 脚本编译"></a>2.2 makefile 脚本编译</h4><p>如果我们只让他编译但是不链接，可以使用 <code>-c</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -c</span><br></pre></td></tr></table></figure><p>结果可以看到生成一个 <code>main.o</code> 文件，<code>.o</code> 文件便是 Unix 下的中间目标文件（Objective File）</p><p>然后我们逐个编译每个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ add.cpp -c</span><br><span class="line">g++ print.cpp -c</span><br></pre></td></tr></table></figure><p>然后将所有 <code>.o</code> 文件链接到一起，生成可执行文件 <code>main</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure><p>当我们只修改某个源文件时，只需要单独编译某个文件而不需要重新编译所有文件。最后重新链接即可。但是当源文件太多的时候，这样也是不方便的，于是使用 makefile 脚本实现自动化。</p><h4 id="Makefile（Version-1）"><a href="#Makefile（Version-1）" class="headerlink" title="Makefile（Version 1）"></a>Makefile（Version 1）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 1</span></span><br><span class="line">main: main.cpp print.cpp add.cpp</span><br><span class="line">@g++ main.cpp add.cpp print.cpp -o main</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> *.o main</span><br></pre></td></tr></table></figure><p>语法格式：main 这个文件依赖于后面的三个 cpp 文件，下一行的命令前面必须是一个 tab，否则语法错误。</p><p>运行 <code>make</code> 运行 <code>makefile</code> 脚本，或 <code>make -f Makefile</code> 根据指定文件名运行脚本。</p><p>首先脚本先去找 main，如果 main 不存在，则尝试生成 main。若已经生成了 main，则根据后面的依赖项判断该 main 是不是最新的，若不是最新的，则重新生成，否则不做任何操作。</p><p>第一个版本的缺点是若源文件太多，则命令显得很冗长。</p><h4 id="Makefile（Version-2）"><a href="#Makefile（Version-2）" class="headerlink" title="Makefile（Version 2）"></a>Makefile（Version 2）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $(OBJ) -o $(TARGET)</span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line">$(CXX) -c main.cpp</span><br><span class="line">print.o: print.cpp</span><br><span class="line">$(CXX) -c print.cpp</span><br><span class="line">add.o: add.cpp</span><br><span class="line">$(CXX) -c add.cpp</span><br></pre></td></tr></table></figure><p>第二个版本中使用了 <code>CXX</code>，<code>TARGET</code>，<code>OBJ</code> 变量，依次查找依赖，只编译已经修改过的文件，而不会编译所有文件。</p><h4 id="Makefile（Version-3）"><a href="#Makefile（Version-3）" class="headerlink" title="Makefile（Version 3）"></a>Makefile（Version 3）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure><p>符号说明：</p><p><code>$@</code>: 目标文件，<code>$^</code>: 所有的依赖文件，<code>$&lt;</code>: 第一个依赖文件</p><p><code>.PHONY</code> 表示的意思：若在该目录下有一个名叫 <code>clean</code> 的文件，那么脚本便无需生成该文件，也就不会执行相应的命令，但是这跟我们期望的不一致。加上 <code>.PHONY</code> 之后，依赖 <code>clean</code>，因此就会去执行 <code>clean</code>。</p><p><code>.PHONY</code> 是一个伪目标，可以有效防止在 Makefile 文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突的问题。</p><p>第三个版本中，若将来有其他新的源文件加入之后，只需要在 <code>OBJ</code> 变量后面加入新的源文件即可。</p><h4 id="Makefile（Version-4）"><a href="#Makefile（Version-4）" class="headerlink" title="Makefile（Version 4）"></a>Makefile（Version 4）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">SRC = $(wildcard *.cpp)</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o, $(SRC))</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure><p>在 Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code>，它的用法是：<code>$(wildcard PATTERN...)</code></p><p><code>wildcard</code>: 扩展通配符<br><code>patsubst</code>：替换通配符<br><code>notdir</code>：去除路径</p><p><code>SRC = $(wildcard *.cpp)</code> 表示获得工作目录下所有 <code>.cpp</code> 文件并生成列表 <code>SRC</code>。<br><code>OBJ = $(patsubst %.cpp, %.o, $(SRC))</code> 表示将所有 <code>.cpp</code> 后缀替换为 <code>.o</code> 并生成文件列表 <code>OBJ</code>。</p><p>这样下来，makefile 文件就相对比较智能化了，新增加文件之后也无需修改脚本了，</p><p>总之，脚本使你越懒惰，这个脚本的功能就越强大。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile-的简单使用&quot;&gt;&lt;a href=&quot;#Makefile-的简单使用&quot; class=&quot;headerlink&quot; title=&quot;Makefile 的简单使用&quot;&gt;&lt;/a&gt;Makefile 的简单使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="脚本" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="脚本" scheme="http://cherryyang05.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Makefile" scheme="http://cherryyang05.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>重构：改善既有代码的设计 学习笔记</title>
    <link href="http://cherryyang05.github.io/ea380076.html"/>
    <id>http://cherryyang05.github.io/ea380076.html</id>
    <published>2023-01-05T06:09:07.000Z</published>
    <updated>2023-08-08T12:35:27.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重构：改善既有代码的设计-学习笔记"><a href="#重构：改善既有代码的设计-学习笔记" class="headerlink" title="重构：改善既有代码的设计 学习笔记"></a>重构：改善既有代码的设计 学习笔记</h2><blockquote><p>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。</p></blockquote><span id="more"></span><h3 id="一、重构是什么以及为什么"><a href="#一、重构是什么以及为什么" class="headerlink" title="一、重构是什么以及为什么"></a>一、重构是什么以及为什么</h3><ol><li>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。</li><li>重构是一种经济适用行为，而非道德使然，如果它不能让我们更快更好的开发，那么它是毫无意义。</li><li>代码的写法应该使别人理解它所需要的时间最小化，进而变更代码需要的时间也会最小化。</li><li>重构对个体程序员的意义是提高ROI。</li><li>更快速的定位问题，节省调试时间。</li><li>最小化变更风险，提高代码质量，减少修复事故的时间。</li><li>得到程序员同行的认可，更好的发展机会。</li><li>重构对整个研发团队的意义是战斗力的提升。</li></ol><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230105141740.png?token=AJSITSOUMKEAVRFBFDZNT7DDWZV4E" alt="重构与不重构"></p><p>尽管重构会让我们的开发变慢，但是可以让我们将来的开发变快。如果我们要对一个项目进行长期跟进，那么重构是必不可少的。</p><h3 id="二、重构的原则"><a href="#二、重构的原则" class="headerlink" title="二、重构的原则"></a>二、重构的原则</h3><ol><li>重构的目标: 提高迭代效率，如果你确定这段代码你将来只会用到一次，且别人也不会去看你的代码，那么就没有重构的必要。</li><li>获得同行认可的方法: 每一次提交代码，都应该使代码变得更好，先重构，再开发。</li><li>增量式重构 &#x3D; 自动化测试 + 持续集成 + TDD驱动重构。</li></ol><h3 id="三、代码的坏味道"><a href="#三、代码的坏味道" class="headerlink" title="三、代码的坏味道"></a>三、代码的坏味道</h3><p><a href="https://github.com/a1029563229/blogs/tree/master/Introduction/refactor">24重代码的坏味道和例子</a></p><p>一般我们能接触到的一些常见的问题：</p><ul><li>命名不规范</li><li>代码重复</li><li>代码过长</li><li>函数参数列表不易理解</li><li>相关联的一些数据没有成组（数据泥团）</li></ul><h3 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a>四、一些例子</h3><h4 id="4-1-依赖传递"><a href="#4-1-依赖传递" class="headerlink" title="4.1 依赖传递"></a>4.1 依赖传递</h4><p>变更放大：一次迭代需要修改 N 个位置，容易遗漏或失误。</p><p>关注放大：为完成修改任务，需要通读修改点上下文若干行代码，而由于依赖被传递，附近的代码会牵扯出更多需要关注的代码，往往阅读的代码量是本身要修改部分的若干倍。演化到最后就会导致不知道该次修改会不会导致问题。</p><h4 id="4-2-神秘命名"><a href="#4-2-神秘命名" class="headerlink" title="4.2 神秘命名"></a>4.2 神秘命名</h4><p>代码&#x2F;注释都是一堆符号的集合，如果这些符合不能被人或者因为其信息的冗余无效性增加了阅读负担就会降低可理解性。<br>好的命名应该有三种境界:  信，达，雅。<br>信:  准确无误地表达清楚行为的意义，做到见名之意。<br>达: 考虑命名对整体架构的影响，与架构的设计哲学风格统一。<br>雅: 生动形象，看到名字即可准确理解其在整个程序之中的作用，并能产生辅助理解的形象。</p><p><a href="https://ggithub.com/dgraph-io/dgraph">坏的例子</a></p><h4 id="4-3-过度设计"><a href="#4-3-过度设计" class="headerlink" title="4.3 过度设计"></a>4.3 过度设计</h4><p>当过分的考虑程序未来所要面对的需求时，将陷入过度设计的陷阱，为了未来用不上的能力，而使当下的程序变得复杂。</p><p>设计变得复杂，是因为考虑了过多的设计约束，而这些约束很可能是现在和未来都不需要的，错把这些约束条件当作了目的，而使得目标被放大，设计出没有解决实际问题的系统。</p><p>过分放大未来的某行风险，这些风险发生的概率过低，在项目可见的生命周期内都不可能遇到，因此也没必要进行设计。</p><h4 id="4-4-结构泥团"><a href="#4-4-结构泥团" class="headerlink" title="4.4 结构泥团"></a>4.4 结构泥团</h4><p>对于核心的数据结构，没有规范化的设计将导致混乱</p><h5 id="4-4-1-艰难引用"><a href="#4-4-1-艰难引用" class="headerlink" title="4.4.1 艰难引用"></a>4.4.1 艰难引用</h5><p>未充分的考虑数据结构的读取场景，导致在需要使用某些数据的时候无法简单的获得其引用，或者为了使用某个字段，需要了解一堆中间封装的数据结构。</p><p>例如：<code>a.b.c.d.e();</code></p><h5 id="4-4-2-全局盲区"><a href="#4-4-2-全局盲区" class="headerlink" title="4.4.2 全局盲区"></a>4.4.2 全局盲区</h5><p>大型项目的开发中，由于大家缺乏全局视角，对数据结构或者接口的设计不可避免的造成冗余或混乱，接口与结构的设计充满局部最优解，但从项目整体上看却成为一团泥球。</p><h3 id="五、什么时候需要重构"><a href="#五、什么时候需要重构" class="headerlink" title="五、什么时候需要重构"></a>五、什么时候需要重构</h3><ol><li>Code review: 在给别人 code review 时嗅出坏味道，在不失礼貌的前提下提出建议。</li><li>每次 commit 代码时: 每一次经你之手提交的代码都应该比之前更加干净。</li><li>当你接手一个异常难读的项目时: 说服项目组将重构作为一项需求任务来做。</li><li>当迭代效率低于预期时: 将重构当作一个项任务专门来做，必要的时候停下来迭代需求。</li></ol><h3 id="六、重构的基本步骤"><a href="#六、重构的基本步骤" class="headerlink" title="六、重构的基本步骤"></a>六、重构的基本步骤</h3><h4 id="6-1-代码分析"><a href="#6-1-代码分析" class="headerlink" title="6.1 代码分析"></a>6.1 代码分析</h4><blockquote><p>通读代码，分析现状，找到代码在各个层面的坏味道。</p></blockquote><h4 id="6-2-重构计划"><a href="#6-2-重构计划" class="headerlink" title="6.2 重构计划"></a>6.2 重构计划</h4><blockquote><p>重构应该永远是一种经济驱动的决定。</p></blockquote><ul><li>对坏味道进行宣讲，并向团队给出重构的理由，以及重构的计划。</li><li>确定重构的目标，明确的描述出重构后能达到的预期是什么。</li><li>重构计划中必须给出测试验证方案，保证重构前与重构后软件的行为一致。</li><li>如果没有这样的方案，那就必须先让软件具有可测试性。</li><li>如果无法得到团队的认可,那就偷偷进行,因为重构始终是对自己有利的(减少工作量以及获得同事的认可)</li><li>将重构任务当作项目来管理，对指定任务的人明确的排期和进度同步。</li></ul><h4 id="6-3-小步子策略"><a href="#6-3-小步子策略" class="headerlink" title="6.3 小步子策略"></a>6.3 小步子策略</h4><ul><li>将重构任务拆分成每周都能见到一点效果的小任务。</li><li>每一步重构都要具有收益，并且可测试，不能阻断当前需求的迭代。</li><li>重构任务必须被跟踪，要定期的开会同步进度，来不断加强团队的重构意识。</li></ul><h4 id="6-4-测试驱动"><a href="#6-4-测试驱动" class="headerlink" title="6.4 测试驱动"></a>6.4 测试驱动</h4><ul><li>对于小型软件，需要先补充单元测试再进行重构。</li><li>对于大型软件，先搭建自动化测试流程，再进行重构。</li><li>对于复杂的不确定性业务，也可以使用ab test来验证重构对指标的影响，避免造成效果&#x2F;广告的损失。</li><li>要保证测试的完备性与可复用性，尽可能的做到团队级的复用。</li><li>保证测试环境与生产环境的一致性也是测试驱动的重要环节。</li></ul><h4 id="6-5-提交规范"><a href="#6-5-提交规范" class="headerlink" title="6.5 提交规范"></a>6.5 提交规范</h4><ul><li>每次提交尽量控制在2分钟可以给code review的同事讲明白的程度</li><li>重构应该被当作一次专门的commit中完成，在commit中写清楚改动点&amp;测试点</li><li>提交规范有助于定位bug，也是代码可读性的一个重要环节</li></ul><h4 id="6-6-自动化测试"><a href="#6-6-自动化测试" class="headerlink" title="6.6 自动化测试"></a>6.6 自动化测试</h4><ul><li>构建可测试的软件，首先要构建可测试的环境。</li><li>对于简单应用软件可以使用单元测试，mock数据进行测试，并与ci&#x2F;cd流程集成。</li><li>对于复杂应用软件可以采样收集线上真实用户行为日志，mock数据周期性巡检测试。</li><li>对于幂等性业务，可以mock user进行全方位的端到端自动化巡检测试。</li><li>每一次功能的提交应该对应一套完整的自动化测试的策略脚本以及&amp;监控指标与报警规则</li></ul><h4 id="6-7-调试BUG"><a href="#6-7-调试BUG" class="headerlink" title="6.7 调试BUG"></a>6.7 调试BUG</h4><ol><li>亲自复现问题，关注第一现场，确定是必现还是偶现?</li><li>区分是人的问题还是环境的问题?</li><li>如果是人的问题，那是配置参数的问题还是代码逻辑的问题?</li><li>如果是配置参数的问题，则通过对比正常运行的配置参数发现问题</li><li>如果是代码逻辑的问题，则通过cimmit的历史二分查找缩小出现问题的逻辑范围</li><li>如果是机器的问题，确定是单机问题还是集群问题。</li><li>如果是单机问题，则替换机器，如果是集群问题则考虑升级硬件设备。</li></ol><h3 id="七、一些实际的问题"><a href="#七、一些实际的问题" class="headerlink" title="七、一些实际的问题"></a>七、一些实际的问题</h3><h4 id="7-1-代码所有权"><a href="#7-1-代码所有权" class="headerlink" title="7.1 代码所有权"></a>7.1 代码所有权</h4><p>代码仓库的所有权会阻碍重构，调用方难以重构被调用方的代码(接口)，进而导致自身重构的受阻，使得效率降低，为提高开发的效能，允许代码仓库在内部开源化，其他团队的工程师可以通过 pr 自己来实现代码，并提交给仓库的 onwer，来 code review 即可。</p><h4 id="7-2-没有时间重构"><a href="#7-2-没有时间重构" class="headerlink" title="7.2 没有时间重构"></a>7.2 没有时间重构</h4><p>这是重构所面临最多的借口，是自己也是团队的借口。 为此必须要明确重构是经济行为而不是一种道德行为，重构使得开发效率变得更高，因此仅对必要的代码进行重构，某个工作行为如果重复三次就可以认为未来也会存在重复，因此通过重构使得下次工作更加高效，这是一种务实的作法，而重构不一定是需要大规模的展开的任务，重构应该是不断持续进行的，将任务拆解为多个具有完备性的任务，每周完成一个，每个任务的上线都不会引起问题，并使项目变得更好，这是一种持续重构的精神态度，是高效能程序员最应该具有的工作习惯。</p><p>如果你在给项目添加新的特性，发现当前的代码不能高效的完成这个任务，并且同样的任务出现三次以上，那么这时你应该先重构，再开发新特性。</p><h4 id="7-3-重构导致-bug"><a href="#7-3-重构导致-bug" class="headerlink" title="7.3 重构导致 bug"></a>7.3 重构导致 bug</h4><p>历史遗留的代码实在太多，难以阅读理解，如果无法理解谁也不敢轻易重构，害怕招致 bug 引起线上事故，因此在重构之前必须有一套相对完备的测试流程，他能给予程序员信心，也是重构的开始，反过来想对于谁也不愿意重构的代码进行重构，将收益巨大(这个项目还会继续迭代时)。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重构：改善既有代码的设计-学习笔记&quot;&gt;&lt;a href=&quot;#重构：改善既有代码的设计-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;重构：改善既有代码的设计 学习笔记&quot;&gt;&lt;/a&gt;重构：改善既有代码的设计 学习笔记&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="代码规范" scheme="http://cherryyang05.github.io/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="重构" scheme="http://cherryyang05.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
    <category term="代码架构" scheme="http://cherryyang05.github.io/tags/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁</title>
    <link href="http://cherryyang05.github.io/6d00129c.html"/>
    <id>http://cherryyang05.github.io/6d00129c.html</id>
    <published>2022-10-30T12:12:56.000Z</published>
    <updated>2023-08-08T12:35:27.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><blockquote><p>该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 <a href="https://github.com/CherryYang05/MultiProcessor">GitHub 仓库</a> 中查看。</p></blockquote><span id="more"></span><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><p>关于自旋锁的内容，需要有以下几个方面的基础知识：基本数据结构（链表，队列）、操作系统中进程调度、锁及死锁、计算机体系结构中 cache 一致性、计算机组成原理中 cache 结构、Java 基本语法及 concurrent 包的基本用法。</p><h2 id="二、背景介绍"><a href="#二、背景介绍" class="headerlink" title="二、背景介绍"></a>二、背景介绍</h2><p>在如今多线程环境下对于共享临界资源的访问，需要加锁实现互斥。拿到锁的线程获得 CPU 执行临界区代码，而未拿到锁的线程通常来说有两种处理方式，一种是该线程进入循环等待，直到它等待的那个 CPU 空闲，然后获得 CPU 开始执行；另一种便是将自己阻塞，等待操作系统重新调度。</p><p>前一种锁叫 <code>自旋锁</code>，后一种锁叫 <code>互斥锁</code>。</p><!-- 实现两个线程间互斥有 `Peterson` 算法、`Bakery` 算法等，在这里暂时不做讨论，这里主要介绍自旋锁 --><p>先举一个很容易理解的例子。有两个进程，分别为 <code>P1</code> 和 <code>P2</code>，这两个线程做的工作都是将变量 a 加 1，就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行这两个线程各 100 次，我们预期的结果是 <code>a = 200</code>，但是实际上结果并不是我们想象的这样，它有可能是 200，但是更多的情况是一个小于 200 的数。</p><p>在计算机底层上，对一个数执行加一操作，编译器会将其编译成下面三条指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, mem</span><br><span class="line">add ax, <span class="number">1</span></span><br><span class="line">mov mem, ax</span><br></pre></td></tr></table></figure><p>当多线程执行时，代码执行顺序将不可控，因此会出现一个线程还未将值写进内存的时候，其他线程就读取内存中的值，造成数据相关问题。</p><h2 id="三、TAS-锁与-TTAS-锁"><a href="#三、TAS-锁与-TTAS-锁" class="headerlink" title="三、TAS 锁与 TTAS 锁"></a>三、TAS 锁与 TTAS 锁</h2><h3 id="3-1-TAS-锁"><a href="#3-1-TAS-锁" class="headerlink" title="3.1 TAS 锁"></a>3.1 TAS 锁</h3><p><code>TAS(testAndSet)</code> 是一个原子操作，它的功能是将 <code>true</code> 原子地写入变量，然后获取变量之前的值，即用 <code>true</code> 来交换变量的值。</p><p>为什么这个操作是原子的呢？因为在 x86 汇编中有个指令叫 <code>xchg</code>，它的功能便是交换两个数。</p><p>在 Java 中，有个与其功能一致的函数叫 <code>getAndSet()</code>，下面是 <code>TASLock</code> 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (state.getAndSet(<span class="literal">true</span>)) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>AtomicBoolean</code> 是原子布尔类型，能够实现原子的赋值，来自 <code>java.util.concurrent.atomic.AtomicBoolean</code>。</p><p>这个锁通过代码很容易理解：当线程 A 获取锁时，将 <code>state</code> 置为 <code>true</code>，若线程 A 还未释放锁时，其他线程 B 若也要申请锁，便会在 <code>while (state.getAndSet(true)) &#123;&#125;</code> 空转，直到 <code>state</code> 为 <code>false</code>，然后线程 B 便可以申请到锁了。</p><p>我们先来看一下另一种形式的 <code>TAS</code> 锁，然后将两者进行比较。</p><h3 id="3-2-TTAS-锁"><a href="#3-2-TTAS-锁" class="headerlink" title="3.2 TTAS 锁"></a>3.2 TTAS 锁</h3><p>直接看具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TTAS</code> 锁并没有每次都直接调用 <code>getAndSet(boolean)</code> 方法，而是先判断 <code>state</code> 变量是否为 <code>true</code>，若为 <code>true</code> 便无需用 <code>true</code> 和原先的值进行交换。而若 <code>state</code> 变量是 <code>false</code>，则再对 <code>state</code> 执行 <code>getAndSet</code>。</p><p>因为这里有两次 test，因此该锁叫 <code>TTAS(testTestAndSet)</code> 锁。</p><p>当然从加锁的正确性来说，这两种锁是等价的，都可以保证无死锁的互斥，对于简单的情况，这两种并无明显差别。但是在多处理器上运行大量线程，这两种锁将会展现出指数级别的效率差距。</p><p>下面是 n 个线程分别执行一段临界区代码所需的时间图，在没有任何争用干扰的情况下，最下面的平直曲线应该是理想情况（实际上并不可能）。可以看出这三条曲线差距非常明显。</p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20221030211520.png" alt="n个线程执行时间图" style="zoom: 40%;"><p>上图的情况可以用多处理器的系统结构进行解释。</p><h3 id="3-3-比较两种锁的性能差距"><a href="#3-3-比较两种锁的性能差距" class="headerlink" title="3.3 比较两种锁的性能差距"></a>3.3 比较两种锁的性能差距</h3><p>首先我们要确定的是，现代处理器几乎都包含高速缓存（cache），cache 与内存的一致性问题是现代处理器研究的重要问题；CPU 访问内存的时间时间比访问 cache 的时间多 2～3 个数量级。</p><p>多处理器中的 cache 一致性问题这里不展开讲述，大致内容如下。</p><p>每个处理器都有一个自己的 cache，考虑以下情况：处理器 A 访问数据 <code>x</code>（假设 <code>x = a</code>），将 x 放入 <code>cache_A</code> 中，处理器 B 也想访问 <code>x</code>，而 <code>cache_B</code> 中没有对 x 的缓存，这个时候处理器 B 便会在 <code>cache_A</code> 中查找 <code>x</code>，找到之后将其放入自己的缓存中（此时 <code>x = a</code>）。这时处理器 A 修改了 <code>x</code> 的值（假设修改为 b），并更新自己的 cache，若此时处理器 B 再次访问 <code>x</code>，它首先会从自己的 cache 中找，而目前 <code>cache_B</code> 中存放了 <code>x = a</code>，但是目前最新的值是 <code>x = b</code>，产生了错误，这就是 cache 一致性问题。</p><p>解决 cache 一致性问题的一个解决办法便是在一个处理器更新自己的 cache 后，该处理器在总线上广播这个地址，其他处理器监听总线，如果其他处理器在自己的 cache 中发现了同样的地址，则将对应的 cache 置为无效。</p><p>然后我们再来分析 <code>TAS</code> 锁。</p><p>在 <code>TAS</code> 锁中，每个线程每次执行都将调用 <code>getAndSet</code> 方法，而这个方法需要写入变量，因此在修改变量前需要在总线上进行广播，通知其他处理器将该 cache 行置为无效。而这便会带来两种问题：一是广播占用了总线流量，当的确需要从内存中读取值时便会造成总线上的延迟；二是每次修改变量是会造成其他处理器的 cache 缺失，即其他自旋的线程每次都会遇到 cache 不命中的情况，便需要通过总线获取新的值。同时，当持有锁的线程尝试释放锁时，因为总线拥挤而不得不被迫延迟，这样的多米诺骨牌效应只会导致效率越来越低。</p><p>总结来说，<code>TAS</code> 锁存在着大量的总线占用，每个线程每一次自旋都会产生大量的总线流量，从而使得其他线程也必须延迟，最终造成了系统的效率急剧降低。</p><p>而 <code>TTAS</code> 锁中，当线程 A 持有锁时，线程 B 第一次读锁时会发生 cache 缺失，但是只要线程 A 持有锁，线程 B 便只要不断读取值，这样每次 cache 都将命中，不产生总线流量，也不会影响其他线程对总线的使用。</p><p>当然当持有锁的线程释放锁时，会导致所有正在自旋的线程的 cache 失效，从而导致大量总线流量，但是短暂过后所有线程将归于平静，又将回到本地自旋的状态。</p><h2 id="四、指数后退锁"><a href="#四、指数后退锁" class="headerlink" title="四、指数后退锁"></a>四、指数后退锁</h2><p>我们现在考虑如何改进 <code>TTAS</code> 锁的算法，这里先引出一个术语：争用，争用的意思是多个线程试图同时获得一个锁。在上面的 <code>TTAS</code> 锁中，在两个 while 循环之间可能会产生高争用现象，此时线程获得锁的几率非常小，并且还会带来极高的总线流量。我们可以考虑将某些线程推迟一段时间再去尝试获得锁，这样同时申请锁的线程将减少，实际证明这样的效果行之有效。</p><p>那么应该将线程退后多长时间呢？了解过计算机网络中 CSMA&#x2F;CD（载波监听多路访问&#x2F;碰撞检测）中的二进制指数退避应该很容易想到，这里的指数后退与其相似。线程随机在 <code>(0, limit)</code> 中后退一段时间，若还未获得锁，那么将 <code>limit</code> 加倍，再次重新在 <code>(0, limit)</code> 获取一个随机值进行后退，直到 <code>limit</code> 到达一个设定的最大值 <code>maxDelay</code>。下面是代码实现。</p><p><code>Backoff.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backoff</span> &#123;</span><br><span class="line">    <span class="type">int</span> minDelay, maxDelay;     <span class="comment">// 限定最大和最小时延，避免无意义的过小的后退以及无限制后退</span></span><br><span class="line">    <span class="type">int</span> limit;                  <span class="comment">// 当前的时延限制</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Backoff</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        minDelay = min;</span><br><span class="line">        maxDelay = max;</span><br><span class="line">        limit = min;</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 0 和 limit 之间随机选取一个值进行退避，然后倍乘 limit，但是不能超过 maxDelay</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backoff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> random.nextInt(limit);</span><br><span class="line">        limit = Math.max(maxDelay, limit * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BackoffLock.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackoffLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">minDelay</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxDelay</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Backoff</span> <span class="variable">backoff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Backoff</span>(minDelay, maxDelay);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                backoff.backoff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>BackoffLock</code> 的性能，与 <code>minDelay</code> 和 <code>maxDelay</code> 的值的选取密切相关，要根据实际任务及自身处理器及架构的情况合理设置阈值。</p><h2 id="五、队列锁"><a href="#五、队列锁" class="headerlink" title="五、队列锁"></a>五、队列锁</h2><h3 id="5-0-队列锁的介绍"><a href="#5-0-队列锁的介绍" class="headerlink" title="5.0 队列锁的介绍"></a>5.0 队列锁的介绍</h3><p>队列锁是一种易于扩展的自旋锁，尽管稍微复杂一点 <del>(亿点)</del>，但是具有更好的移植性。</p><p>在指数后退锁中，存在两个问题。</p><ul><li>一是所有线程获得锁都依赖于同一个变量 <code>state</code>，因此每个线程都在同一个共享存储单元上自旋，每一次成功的锁访问都会带来 cache 一致性流量（尽管相比之下比 TASLock 低）；</li><li>二是临界区利用率低，因为很多线程被“后退”了，因此延迟带来的开销是无法忽略的。</li></ul><p>可以将这些线程组织成一个链表（队列）来解决这些问题，在队列中，每个线程只要检测前一个线程是否已经完成来判断自己能否成功获取锁，这样每个线程就在不同存储单元上自旋了，也不会有延迟带来的开销。</p><p>下面介绍三种队列锁，基于数组的队列锁，CLH 队列锁和 MCS 队列锁。</p><h3 id="5-1-基于数组的队列锁"><a href="#5-1-基于数组的队列锁" class="headerlink" title="5.1 基于数组的队列锁"></a>5.1 基于数组的队列锁</h3><p>基于数组的队列锁 ALock，其有一个 tail 字段，初始值为 0，它被所有的线程共享，用来表示数组的下标。每个线程原子地增加 tail 字段的值，每个线程还有一个局部变量用来保存这个当前的 tail 值，称为 slot（槽）。如果 flag[j] 为 true，那么表示下标为 j 的线程有权获得锁。</p><p>初始状态时，flag 数组只有下标为 0 的那个值为 true，其他均为 false。其他线程调用 lock() 方法尝试获得锁时，会不断地在 <code>flag[slot]</code> 上旋转，直到 <code>flag[slot] == true</code>。在释放锁时，线程将对应于它自己的槽点 flag 设为 false，然后将下一个槽的 slot 设为 true。上述所有操作都要对 n 取模，n 的大小至少为最大的并发线程数。</p><p>下面用具体例子来说明基于数组的队列锁。</p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/239b8e7f91620c96909e40c1792ae9e6.png" alt="基于数组的自旋锁"></p><p>上图的 a) 中，当前获得锁的线程是 A，<code>flag[2] == true</code>，线程 B 和 C 也尝试获得锁，线程 B 和 C 在 flag[3] 和 flag[4] 上自旋等待。当线程 A 释放锁后，flag[2] 设置为 false，flag[3] 设置为 true，线程 B 获得锁。</p><p><code>ALock.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ALock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mySLotIndex 是线程的局部变量，线程局部变量无需保存在共享存储器中，无需同步，不产生一致性流量</span></span><br><span class="line">    ThreadLocal&lt;Integer&gt; mySlotIndex = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    AtomicInteger tail;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span>[] flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ALock</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        size = capacity;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[capacity];</span><br><span class="line">        <span class="comment">// 为了避免假共享现象，可以将数组开大，让每一个项独占一个 cache 行</span></span><br><span class="line">        <span class="comment">// flag = new boolean[capacity * 4];</span></span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> tail.getAndIncrement() % size;</span><br><span class="line">        mySlotIndex.set(slot);</span><br><span class="line">        <span class="keyword">while</span> (!flag[slot]) &#123;&#125;;     <span class="comment">// 当前域为 false 则表明锁被占用，陷入空转等待</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> mySlotIndex.get();</span><br><span class="line">        flag[slot] = <span class="literal">false</span>;</span><br><span class="line">        flag[(slot + <span class="number">1</span>) % size] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在基于数组的队列锁中，mySlotIndex 是线程的局部变量，局部变量不需要与其他线程共享，不需要同步，也就不会产生一致性流量，因为它只能被一个线程访问。尽管 flag 数组是被多个线程共享的，但是在任意特定的时刻，线程对应的 flag 存储单元会被存放在对应的 cache 中，线程是在本地 cache 中旋转，大大降低了无效流量，从而使得对数组的存储单元的争用大大降低。</p><p>但是值得注意的是，争用仍然可能发生，因为存在一种“假共享”现象，当相邻的数组元素在同一个 cache 行时，就会发生这样的现象。继续看上面的图 a)，假设一个 cache 行能够存放 4 个数组元素，那么 flag[0] ~ flag[3] 都将存放在同一个 cache 行中。当某一个线程对 cache 行执行写操作时，会导致当前 cache 行无效，从而导致其他在该 cache 旋转的线程产生无效流量。</p><p>一种解决办法就是上图中的 b)，于是我们将数组进行填，充让一个 cache 行只存放一个数组元素，具体实现上只需要将 <code>(i + 1) % 8</code> 改成 <code>4 * (i + 1) % 32</code> 即可。</p><h3 id="5-2-CLH-队列锁"><a href="#5-2-CLH-队列锁" class="headerlink" title="5.2 CLH 队列锁"></a>5.2 CLH 队列锁</h3><h3 id="5-3-MCS-队列锁"><a href="#5-3-MCS-队列锁" class="headerlink" title="5.3 MCS 队列锁"></a>5.3 MCS 队列锁</h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;自旋锁&quot;&gt;&lt;a href=&quot;#自旋锁&quot; class=&quot;headerlink&quot; title=&quot;自旋锁&quot;&gt;&lt;/a&gt;自旋锁&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 &lt;a href=&quot;https://github.com/CherryYang05/MultiProcessor&quot;&gt;GitHub 仓库&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机原理知识" scheme="http://cherryyang05.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="http://cherryyang05.github.io/tags/Java/"/>
    
    <category term="并发多核" scheme="http://cherryyang05.github.io/tags/%E5%B9%B6%E5%8F%91%E5%A4%9A%E6%A0%B8/"/>
    
    <category term="操作系统" scheme="http://cherryyang05.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Rust中Clap库的使用</title>
    <link href="http://cherryyang05.github.io/8ce3ab1f.html"/>
    <id>http://cherryyang05.github.io/8ce3ab1f.html</id>
    <published>2022-10-26T13:32:39.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clap-库的使用"><a href="#Clap-库的使用" class="headerlink" title="Clap 库的使用"></a>Clap 库的使用</h1><blockquote><p>Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。</p></blockquote><span id="more"></span><h2 id="一、版权及说明"><a href="#一、版权及说明" class="headerlink" title="一、版权及说明"></a>一、版权及说明</h2><p>该文参考了 Rust 语言中文社区的 <a href="https://rustcc.cn/article?id=921ad2c0-09af-4271-ae62-4b21ce281a2b">每周一库</a>，同时参考了官方 <a href="https://crates.io/crates/clap">crate</a> 以及 <a href="https://docs.rs/clap/latest/clap/">clap 官方文档</a> 的用例及介绍</p><p>对于命令行解析使用最多的库，可以在 <a href="https://crates.io/">crates.io</a> 首页搜索关键词 Command Line，下载量最多的库便是 clap</p><h2 id="二、关于命令行解析"><a href="#二、关于命令行解析" class="headerlink" title="二、关于命令行解析"></a>二、关于命令行解析</h2><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>clap 用于解析并验证用户在运行命令行程序时提供的命令行参数字符串。 你所需要做的只是提供有效参数的列表，clap 会自动处理其余的繁杂工作。 这样工程师可以把时间和精力放在实现程序功能上，而不是参数的解析和验证上。</p><p>当 clap 解析了用户提供的参数字符串，它就会返回匹配项以及任何适用的值。 如果用户输入了错误或错字，clap 会通知他们错误并退出（或返回 Result 类型，并允许您在退出前执行任何清理操作）。这样，工程师可以在代码中对参数的有效性做出合理的假设。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Clap-库的使用&quot;&gt;&lt;a href=&quot;#Clap-库的使用&quot; class=&quot;headerlink&quot; title=&quot;Clap 库的使用&quot;&gt;&lt;/a&gt;Clap 库的使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
    <category term="lib" scheme="http://cherryyang05.github.io/tags/lib/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十六）：最后的项目</title>
    <link href="http://cherryyang05.github.io/9e622d63.html"/>
    <id>http://cherryyang05.github.io/9e622d63.html</id>
    <published>2022-09-29T14:55:08.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><span id="more"></span><h2 id="一、单线程-Web-服务器"><a href="#一、单线程-Web-服务器" class="headerlink" title="一、单线程 Web 服务器"></a>一、单线程 Web 服务器</h2><h3 id="1-1-构建单线程-Web-服务器"><a href="#1-1-构建单线程-Web-服务器" class="headerlink" title="1.1 构建单线程 Web 服务器"></a>1.1 构建单线程 Web 服务器</h3><ul><li>在 socket 上监听 TCP 连接</li><li>解析少量的 HTTP 请求</li><li>创建一个合适的HTTP响应</li><li>使用线程池改进服务器的吞吐量</li><li>注意：并不是最佳实践</li></ul><p>直接放代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;net::&#123;TcpListener, TcpStream&#125;, io::&#123;Read, Write&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Request: &#123;&#125;\n&quot;</span>, <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>, contents.<span class="title function_ invoke__">len</span>(), contents);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>TcpListener::bind()</code> 方法表示监听所绑定的 IP 及端口，返回一个 Result 枚举，<code>incoming</code> 方法能够将所监听到的流转化成一个个迭代器，然后一依次处理这些流。</p><p>在 <code>handle_connection()</code> 函数中，先构造了一个 <code>buffer</code> 用于存放每个流请求的具体内容（请求头），然后写了一个 <code>hello.html</code> 页面，构造一个响应头同时写回请求的流中。在 <code>response</code> 字段中，要注意添加 <code>Content-Length:&#123;&#125;</code>，这样执行该程序，在浏览器中访问 <code>127.0.0.1:9999</code>，便可以返回刚刚写的页面。</p><p>控制台输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment">Content-Length:170</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Hello!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Hi From Rust&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器显示的页面如下：</p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929233943.png" alt="浏览器正常显示页面"></p><p>下面我们新建一个 404 页面，用于处理访问其他页面时显示的结果，我们主要修改 <code>handle_connection()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_line</span> = <span class="string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;404.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;&#125;\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            status_line,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125;</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断请求头是不是以 <code>GET / HTTP/1.1\r\n</code> 开头，这表明我们请求的是根目录的资源，这里 <code>let get = b&quot;GET / HTTP/1.1\r\n&quot;;</code> 的 <code>b</code> 表示字节字符串，可以将字符串转化成字节，这样就可以用 <code>start_with()</code> 方法进行比较。</p><p>在浏览器中访问一个非根目录的资源，控制台输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.32</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET /undefined HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Sec-Fet</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 404 NOT FOUND</span></span><br><span class="line"><span class="comment">Content-Length:201</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Oops!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Sorry,I don&#x27;t know what you&#x27; re asking for. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器页面如下：</p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929235635.png" alt="404页面"></p><p>重构一下 <code>handle_connection()</code> 函数，用元组来重构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(file_name).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;Content-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">        status_line,</span><br><span class="line">        contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        contents</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、多线程-Web-服务器"><a href="#二、多线程-Web-服务器" class="headerlink" title="二、多线程 Web 服务器"></a>二、多线程 Web 服务器</h2><h3 id="2-1-阻塞的场景"><a href="#2-1-阻塞的场景" class="headerlink" title="2.1 阻塞的场景"></a>2.1 阻塞的场景</h3><p>当前我们对于流的处理都是单线程，一旦有某个请求耗费的时间长了，那么其他请求就必须被阻塞等待。我们构造下面这样的场景：当访问 <code>sleep</code> 页面的时候，线程睡眠 5 秒钟再执行处理，运行程序后访问其他页面可以正常被处理，当访问 <code>sleep</code> 页面的时候会卡住 5 秒钟，这时访问其他页面就需要等待这 5 秒钟结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sleep</span> = <span class="string">b&quot;GET /sleep HTTP/1.1\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(sleep) &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在代码中增加了对 <code>sleep</code> 页面的访问，运行效果与预期一致。</p><p>我们用线程池来解决这一问题。</p><h3 id="2-2-线程池"><a href="#2-2-线程池" class="headerlink" title="2.2 线程池"></a>2.2 线程池</h3><p>线程池是一组预先被分配的线程，他们用于等待并随时处理可能的任务。线程池可以实现并发处理请求，当前线程执行完之后，将其放回线程池。首先考虑到使用 <code>thread::spawn()</code> 为每个请求创建线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(||&#123;</span><br><span class="line">    <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这样显然会导致一个问题：当有黑客对服务器进行洪泛攻击时，服务器的资源将会很快被耗尽，因此我们还需要对线程数量进行限制。</p><p>在该项目中，采用编译器驱动开发的方式（笑），先将可能用到的结构体或方法等先写好，再逐步完善，修改 main 如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显 <code>ThreadPool</code> 和 <code>execute</code> 是未定义的。</p><p>新建 <code>lib.rs</code>，实现未定义的部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        ThreadPool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>execute</code> 方法，我们参考 <code>thread::spawn()</code>，后者实现了 <code>FnOnce() + Send + &#39;static</code>。</p><p>然后我们给结构体 <code>ThreadPool</code> 添加一个字段 <code>threads</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    threads: <span class="type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是怎么来的呢，我们看 <code>spawn</code> 的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">spawn</span>(f).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to spawn thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它返回的是 <code>JoinHandle</code>，其中有一个范型 <code>T</code>，这个 <code>T</code> 就是传进去的闭包的返回值，但是我们实现的方法闭包没有返回值，因此返回单元类型 <code>()</code> 即可。</p><p>再次修改 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">threads</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        todo!()    </span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;threads&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看<code>spawn</code> 的实现，他会创建一个线程，立即执行接收到的代码。但是我们希望线程创建之后进入等待状态，当有代码传给他们的时候再执行线程。这里我们创建一个新的结构体，叫 <code>Worker</code>，用来管理和实现上述所说的行为。</p><p>实现 <code>Worker</code> 相关结构体和函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时将 <code>ThreadPool</code> 中的字段名改成 <code>workers</code>，更改 <code>ThreadPool</code> 的 <code>new()</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止，<code>lib.rs</code> 代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用通道"><a href="#2-3-使用通道" class="headerlink" title="2.3 使用通道"></a>2.3 使用通道</h3><p>下面我们需要考虑如何让 <code>Worker</code> 从线程池中接收任务并执行任务，这里就要使用到通道。</p><p>在 <code>ThreadPool</code> 中添加一个字段 <code>sender</code>，表示通道的发送端。线程池持有通道的发送端，而接收者应该是 <code>worker</code>。在通道中，可以有多个发送者，但是只能有一个接收者，我们希望所有线程共享同一个 <code>receiver</code>，从而能够在线程间分发任务。同时从通道队列中取出 <code>receiver</code> 也意味着这是可变的。我们可以用 “智能指针” 那一小节中的 <code>Arc</code> 和 <code>Mutex</code> 来实现线程间多所有权的可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers, sender&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 <code>Worker</code> 结构体的 <code>new</code> 的函数签名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-实现-execute-方法"><a href="#2-4-实现-execute-方法" class="headerlink" title="2.4 实现 execute 方法"></a>2.4 实现 execute 方法</h3><p>新建一个 <code>job</code>，然后通过通道的发送端将 <code>job</code> 发送出去，接收端 <code>worker</code> 的 <code>new</code> 函数接收该 <code>job</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">    <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">        (*job)(); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Worker &#123;id, thread&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>job</code> 是一个 <code>Box</code> 类型，那么实现 <code>FnOnce()</code> 的闭包要想调用就要先将其从 <code>Box</code> 取出来，但是 Rust 不允许这样做，因为不知道 <code>Box</code> 中的类型具体有多大。<code>FnOnce()</code> 中有一个 <code>call_once()</code> 方法，其中的参数便是 <code>self</code>，为了获得其所有权，但是现在不允许。我们可以将 <code>self</code> 改成 <code>Box&lt;Self&gt;</code>，这样方法就可以在类型的 <code>Box</code> 上来调用。</p><p>然后为实现了 <code>FnOnce()</code> 的类型实现 <code>FnBox</code>，<code>self</code> 的类型就是 <code>Box&lt;F&gt;</code>，而 <code>F</code> 就是实现了 <code>FnOnce()</code> 的类型，这样就可以获得 <code>Box</code> 里的所有权，再进行闭包调用，同时更改 <code>Job</code> 的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br></pre></td></tr></table></figure><p>最后在 <code>Worker</code> 的 <code>new</code> 函数中加入 loop，使得释放锁后还能继续使用该线程。</p><p>最终 <code>lib.rs</code> 文件如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, sync::&#123;mpsc, Arc, Mutex&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub struct Job &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers, sender&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">            job.<span class="title function_ invoke__">call_box</span>(); </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十三）：智能指针</title>
    <link href="http://cherryyang05.github.io/e9389bfa.html"/>
    <id>http://cherryyang05.github.io/e9389bfa.html</id>
    <published>2022-07-08T08:50:48.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 <code>&amp;</code> 了，没有其他开销。<br>智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。</p></blockquote><span id="more"></span><h2 id="一、智能指针介绍"><a href="#一、智能指针介绍" class="headerlink" title="一、智能指针介绍"></a>一、智能指针介绍</h2><p><strong>引用和智能指针的区别</strong></p><ul><li>智能指针往往基于结构体实现</li><li>引用只借用数据，而智能指针很多时候拥有其指向的数据</li></ul><p><strong>智能指针的例子</strong></p><ul><li><code>String</code> 和 <code>Vec&lt;T&gt;</code></li><li>都拥有一片内存区域，且允许用户对其操作</li><li>还拥有元数据（例如容量等）</li><li>提供额外的功能保障（String 保证其是合法的 UTF-8 数据）</li></ul><p><strong>智能指针的实现</strong></p><ul><li>智能指针通常使用 struct 实现，并且实现了 <code>Deref</code> 和 <code>Drop</code> 这两个 trait</li><li><code>Deref trait</code>：允许智能指针 struct 的实例像引用一样使用</li><li><code>Drop trait</code>：允许你自定义当智能指针实例走出作用域时的代码</li></ul><p><strong>本章内容</strong></p><ul><li>介绍标准库中常见的智能指针<ul><li><code>Box&lt;T&gt;</code>：在 heap内存上分配值</li><li><code>Rc&lt;T&gt;</code>：启用多重所有权的引用计数类型</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCelk&lt;T&gt;</code> 访问：在运行时而不是编译时强制借用规则的类型</li></ul></li><li>此外</li><li>内部可变模式（interior mutability pattern）：不可变类型暴露出可修改其内部值的 API</li><li>引用循环（reference cycles）：它们如何泄露内存，以及如何防止其发生</li></ul><h2 id="二、使用-Box-lt-T-gt"><a href="#二、使用-Box-lt-T-gt" class="headerlink" title="二、使用 Box&lt;T&gt;"></a>二、使用 Box&lt;T&gt;</h2><h3 id="2-1-Box-lt-T-gt"><a href="#2-1-Box-lt-T-gt" class="headerlink" title="2.1 Box&lt;T&gt;"></a>2.1 Box&lt;T&gt;</h3><p><code>Box&lt;T&gt;</code> 是最简单的智能指针</p><ul><li>允许你在 heap 上存储数据（而不是 stack）</li><li>stack 上是指向 heap 数据的指针</li><li>没有性能开销</li><li>没有其它额外功能</li><li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code></li></ul><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><ul><li>在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小</li><li>当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制</li><li>使用某个值时，你只关心它是否实现了特定的 trait，而不关心它的具体类型</li></ul><h4 id="2-2-1-Box-lt-T-gt-如何在-heap-上存储数据"><a href="#2-2-1-Box-lt-T-gt-如何在-heap-上存储数据" class="headerlink" title="2.2.1 Box&lt;T&gt; 如何在 heap 上存储数据"></a>2.2.1 Box&lt;T&gt; 如何在 heap 上存储数据</h4><p>来看一段简单的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用 <code>Box</code>，那么就会在栈中创建一个变量 x，而使用了 <code>Box</code> 就会在 heap 上创建一个变量。在变量 x 走出作用域时，变量 x 在 stack 上的指针和在 heap 上的值都会被释放。</p><h4 id="2-2-2-使用-Box-赋能递归类型"><a href="#2-2-2-使用-Box-赋能递归类型" class="headerlink" title="2.2.2 使用 Box 赋能递归类型"></a>2.2.2 使用 Box 赋能递归类型</h4><p>比如有这样一个枚举</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Cons 变体，里面有一个他类型本身（List），这样就会一直递归下去。但是在编译时，Rust 需要知道一个类型所占的空间大小，而这样的递归类型无法确定其大小。在递归类型中使用 Box 就可以解决上述问题。这也是函数式语言中的 Cons List</p><p><strong>关于 Cons List</strong></p><p>Cons List 是来自 Lisp 语言的一种数据结构。Cons List里每个成员由两个元素组成：</p><ul><li>当前项的值</li><li>下一个元素</li></ul><p>Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素。<strong>实际上就是 Rust 中的一种链表</strong>，但他并不是 Rust 的常用集合。</p><p><strong>Rust 如何确定非递归类型所占用的大小的？</strong></p><p>实际上是取结构体或枚举下最大空间的变体的大小作为整个结构体或枚举的大小（非常类似于 C 语言中的联合体 Union）。</p><p>因此最终应将代码改成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, </span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Box 来获得确定大小的递归类型</strong></p><ul><li><code>Box&lt;T&gt;</code> 是一个指针，Rust 知道它需要多少空间，因为<ul><li>指针的大小不会基于它指向的数据的大小变化而变化</li></ul></li><li>Box<T>:<ul><li>只提供了“间接”存储和 heap 内存分配的功能</li><li>没有其它额外功能</li><li>没有性能开销</li><li>适用于需要“间接”存储的场景，例如 Cons List</li><li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code><ul><li><code>Deref trait</code>：可以将 Box 的值当做引用来处理</li><li><code>Drop trait</code>：定义了当 Box 值走出作用域时，清理掉栈上的指针和堆上的数据</li></ul></li></ul></T></li></ul><h2 id="三、Deref-trait"><a href="#三、Deref-trait" class="headerlink" title="三、Deref trait"></a>三、Deref trait</h2><p><code>Deref</code> 就是 <code>dereference</code> 解引用的意思。</p><ul><li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符 <code>*</code> 的行为</strong></li><li>通过实现 Deref，智能指针可像常规引用一样来处理</li></ul><h3 id="3-1-解引用运算符"><a href="#3-1-解引用运算符" class="headerlink" title="3.1 解引用运算符"></a>3.1 解引用运算符</h3><p>常规引用也是指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*y, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有什么好解释的，和 C 语言一样，<code>*y</code> 表示解引用变量 y。</p><h3 id="3-2-定义自己的智能指针"><a href="#3-2-定义自己的智能指针" class="headerlink" title="3.2 定义自己的智能指针"></a>3.2 定义自己的智能指针</h3><p><code>Box&lt;T&gt;</code> 被定义成拥有一个元素的 tuple struct。下面来定义自己的 <code>MyBox&lt;T&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看定义，<code>MyBox&lt;T&gt;</code> 实际上就是一个有名称的元组（tuple），这个元组里只有一个元素。</p><p>再看第二个断言，这里的 <code>*y</code> 会报错 <code>type &#39;MyBox&lt;&#123;integer&#125;&gt;&#39; cannot be dereferenced</code>，表示 <code>MyBox</code> 类型不能被解引用，这是因为 <code>MyBox</code> 没有实现 <code>Deref trait</code>。</p><p>标准库中的 <code>Deref trait</code> 要求我们实现一个 <code>deref</code> 方法</p><ul><li>该方法借用 self</li><li>返回一个指向内部数据的引用</li></ul><p>因此我们为 <code>MyBox</code> 实现 <code>Deref</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>type Target = T;</code> 类似于 C 语言中的 <code>typedef struct Person &#123;&#125; P</code>？</p><p>而 <code>*y</code> 实际上是 <code>*(y.deref())</code>，调用 <code>*</code> 之前，先执行 <code>deref</code> 取引用，然后通过 <code>*</code> 运算符解引用。</p><h3 id="3-3-隐式解引用转化"><a href="#3-3-隐式解引用转化" class="headerlink" title="3.3 隐式解引用转化"></a>3.3 隐式解引用转化</h3><ul><li>隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性。</li><li>假设 T 实现了 Deref trait：<ul><li>Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li></ul></li><li>当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配<ul><li>Deref Coercion 就会自动发生</li><li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li><li>在编译时完成，没有额外性能开销</li></ul></li></ul><p>在上面实现 <code>MyBox</code> 和 <code>Deref</code> 的前提下，增加以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要分析 <code>hello</code> 函数中传入的参数类型，是一个字符串切片类型，而 <code>m</code> 是一个实现了 <code>Deref</code> 的结构体类型，但是为什么能传入 <code>&amp;m</code> 呢？</p><p>首先 <code>m</code> 的类型是 <code>MyBox&lt;String&gt;</code>，那么 <code>&amp;m</code> 的类型就是 <code>&amp;MyBox&lt;String&gt;</code>，由于 <code>MyBox</code> 实现了 <code>Deref</code> 方法，因此 Rust 可以调用 <code>deref()</code> 方法，来将 <code>MyBox&lt;String&gt;</code> 的引用转化成 <code>String</code> 的引用。然而在标准库中，<code>String</code> 也实现了 <code>Deref</code> 这个 trait，它返回的是一个字符串切片 <code>&amp;str</code>，因此 Rust 会继续调用 <code>deref()</code>，最终返回一个字符串切片的类型。</p><p>而如果 Rust 没有解引用转化功能，则参数应该这样传：<code>hello(&amp;(*m)[..]);</code>，而这却相当繁琐。只要类型实现了 <code>Deref</code> 这个 trait，Rust 就会自动分析类型，并不断尝试调用 <code>deref()</code> 方法来让其与函数或方法签名中的参数类型匹配，而这一切都在编译时执行，因此运行时不会产生额外的性能开销。</p><p><strong>解引用与可变性</strong></p><ul><li>可使用 <code>DerefMut trait</code> 重载可变引用的 <code>*</code> 运算符</li><li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion<ul><li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code>（即类型 <code>T</code> 实现了 <code>Deref trait</code>，而 <code>deref</code> 方法返回的类型是 <code>U</code>，那么 <code>T</code> 的引用可以转化为 <code>U</code> 的引用）</li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code>（反过来不成立，即不能将不可变引用转化为可变引用，违反借用规则）</li></ul></li></ul><h2 id="四、Drop-trait"><a href="#四、Drop-trait" class="headerlink" title="四、Drop trait"></a>四、Drop trait</h2><ul><li>实现 <code>Drop trait</code>，可以让我们自定义<strong>当值将要离开作用域的时候发生的动作</strong><ul><li>例如文件、网络资源的释放等</li><li>任何类型都可以实现 <code>Drop trait</code></li></ul></li><li><code>Drop trait</code> 只要求实现 <code>drop</code> 方法，其参数是对 <code>self</code> 的可变引用</li><li><code>Drop trait</code> 在预导入模块中，无需手动导入</li></ul><p>（个人理解：和 C++ 中的析构函数有点类似）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为如下，注意输出顺序（变量声明顺序为 s1，s2，Drop 顺序为 s2，s1）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br></pre></td></tr></table></figure><p>使用 <code>std::mem::drop</code> 来提前 drop 值</p><ul><li>很难直接禁用自动的 drop 功能，也没必要</li><li>Drop trait 的目的就是进行自动的释放处理逻辑</li><li>Rust 不允许手动调用 Drop trait 的 drop 方法</li><li>若要强行使用 <code>a.drop()</code> 这样来调用，会提示 <code>explicit destructor calls not allowed</code>，然后后面给的帮助是考虑使用 <code>drop(a)</code></li><li>但可以调用标准库中的 <code>std::mem::drop</code> 函数提前 <code>drop</code> 值</li></ul><p>我们手动 <code>drop</code> 一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br></pre></td></tr></table></figure><p>尽管手动调用了 <code>drop</code> 函数，但是和 <code>drop</code> 方法并不会冲突，不会重复释放同一块内存，设计 Rust 语言的时候显然已经考虑到了这一点。</p><h2 id="五、Rc-lt-T-gt-：引用计数智能指针"><a href="#五、Rc-lt-T-gt-：引用计数智能指针" class="headerlink" title="五、Rc&lt;T&gt;：引用计数智能指针"></a>五、Rc&lt;T&gt;：引用计数智能指针</h2><p>通常情况下，Rust 的所有权都是很清晰的，但是在某些场景中，单个值可能同时被多个所有者持有。例如一个图的数据结构，一个结点有多条边相连，那么这个结点就应该属于所有与其相连的边，只有当所有指向它的边都释放掉，该结点才会被清理，这就是多重所有权。</p><p>在 Rust 中，为了支持多重所有权，便有了 <code>Rc&lt;T&gt;</code>，即 <code>reference count（引用计数）</code>，这个类型会在实例的内部维护一个用于记录引用次数的计数器，从而判断该值是否仍然被使用，可以追踪所有对其的引用。若引用个数为 0，那么该值就会被清理掉，不会发生引用失效的问题。</p><h3 id="5-1-使用场景及实例"><a href="#5-1-使用场景及实例" class="headerlink" title="5.1 使用场景及实例"></a>5.1 使用场景及实例</h3><ul><li>需要在 heap 上分配数据，这写数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据</li><li>若在编译时能够确定哪个部分最后使用完这些数据，那么直接将这个部分程序成为这些数据的所有者即可，这样就只需要靠编译时期所有权规则，就可以保证程序的正确性</li><li><code>Rc&lt;T&gt;</code> 只能用于单线程场景，后面会介绍如何在多线程场景中使用引用计数</li><li><code>Rc&lt;T&gt;</code> 不在预导入模块中，需要手动导入 <code>use sstd::rc::Rc</code></li><li><code>Rc::clone(&amp;a)</code> 函数：增加引用计数</li><li><code>Rc::strong_count(&amp;a)</code>：获得引用计数</li><li>还有 <code>Rc::weak_count</code>函数</li></ul><p>例子如下：</p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220709214558.png" alt="两个List共享所有权"></p><p>要实现两个 List 共享一个 List 的所有权。先看下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明变量 c 处，会报错，提示不能使用被移动的值 <code>use of moved value: &#39;a&#39;</code>。因为在声明 b 时，变量 a 的所有权已经移交给了 b。我们可以改变 <code>Cons</code> 的定义，让其持有 <code>List</code> 的引用而不是所有权，并为其指定声明周期参数，这个生命周期要求 <code>List</code> 中的所有元素的存活时间至少要和 <code>List</code> 本身一样。因此借用检查器会阻止我们编译这样的代码：<code>let a = Cons(1, &amp;Nil)</code>，因为这里 <code>Nil</code> 这个变体值会在 <code>a</code> 取得其引用前就被丢弃。</p><p>另一种办法就是将 <code>Box</code> 换成 <code>Rc</code>。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 a 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 b 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;创建 c 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c 离开作用域后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出结果为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">创建 a 后的的强引用计数为 <span class="number">1</span></span><br><span class="line">创建 b 后的的强引用计数为 <span class="number">2</span></span><br><span class="line">创建 c 后的的强引用计数为 <span class="number">3</span></span><br><span class="line">c 离开作用域后的的强引用计数为 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其实在 <code>Rc&lt;T&gt;</code> 这个类型上也有一个 <code>clone</code> 方法，和 <code>Rc::clone()</code> 的区别是，后者不会对数据进行深拷贝，只会增加引用计数，速度较快。而前者是类型上的 <code>clone</code> 方法，会进行深拷贝，拷贝对象本身，比较耗时。同时 <code>Rc&lt;T&gt;</code> 也实现了 <code>Drop</code> 这个 trait，因此当变量离开作用域时，引用计数会自动减少一。</p><p>在 <code>Rc&lt;T&gt;</code> 中，通过不可变引用，使你在程序不同部分之间共享只读数据，若共享的引用可变，将会违反 Rust 的借用规则，即多个指向同一区域的可变引用会导致数据竞争以及数据的不一致。但是在某些情况下，让其共享的数据可变也是非常重要的，这就需要使用 <code>RefCell&lt;T&gt;</code>。</p><h3 id="5-2-RefCell-lt-T-gt-和内部可变性"><a href="#5-2-RefCell-lt-T-gt-和内部可变性" class="headerlink" title="5.2 RefCell&lt;T&gt; 和内部可变性"></a>5.2 RefCell&lt;T&gt; 和内部可变性</h3><p>内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改，数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则，使其可变的借用一个不可变的值。</p><p>先来回忆一下 Rust 的借用规则：在任何给定的时刻，要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用，且引用总是有效的。</p><p>与 <code>Rc&lt;T&gt;</code> 不同，<code>RefCell&lt;T&gt;</code> 类型代表了其持有数据的唯一所有权。而 <code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 的区别是：前者只会在<strong>运行时</strong>检查借用规则，否则触发 panic；而后者在编译阶段就要强制代码遵守借用规则，否则出现错误，编译不通过。</p><p><strong>借用规则在不同阶段进行检查的比较</strong></p><ul><li>编译阶段<ul><li>尽早暴露问题</li><li>没有运行时的开销</li><li>对大多数场景是最佳选择</li><li>是 Rust 的默认行为</li></ul></li><li>运行时<ul><li>问题暴露延迟，甚至到生产环境</li><li>因为借用计数器而导致性能的损失</li><li>实现某些特定的内存安全场景（不可变环境中修改自身数据）</li></ul></li></ul><p>实际上 Rust 编译器是比较保守的，有些代码并不是在编译阶段就能分析明白，针对这些代码，Rust 编译器是无法完成分析的，因此编译器就会简单的拒绝所有不符合所有权规则的代码，哪怕这些代码并没有任何问题，这就是 Rust 编译器的保守性。因为一旦 Rust 将某一段有问题的程序通过了，那么 Rust 对安全性的保证将直接破产，尽管拒绝掉某些正确的代码会对开发者带来不便，但是至少不会在生产中带来灾难性的后果。针对 Rust 编译器无法分析的代码，如果开发者能够确保代码能够满足借用规则，这时候就要用到 <code>RefCell&lt;T&gt;</code> 了。</p><p>和 <code>Rc&lt;T&gt;</code> 一样 <code>RefCell&lt;T&gt;</code> 只能用于单线程的场景。</p><ul><li><code>Box&lt;T&gt;</code><ul><li>同一个数据只有一个所有者</li><li>可变和不可变借用，在编译时检查</li></ul></li><li><code>Rc&lt;T&gt;</code><ul><li>同一个数据可以有多个所有者</li><li>不可变借用，在编译时检查</li></ul></li><li><code>RefCell&lt;T&gt;</code><ul><li>同一个数据只有一个所有者</li><li>可变和不可变借用，在运行时检查</li><li>其中，即使 <code>RefCell&lt;T&gt;</code> 本身不可变，但是仍能修改其中存储的值</li></ul></li></ul><p>对于内部可变性，可以可变的借用一个不可变的值。在某些情况下，我们需要一个值，它对外部是不可变的，但能在方法内部修改自身的值，除了这个值本身的方法，其他的方法都不能修改这个值，<code>RefCell&lt;T&gt;</code> 正是获得这种内部可变性的一种方法。但是这种方法并没有完全绕开借用规则，只是通过内部可变性通过了编译检查，但是借用检查也只是从编译阶段延后到运行阶段，如果运行阶段仍然违反了借用规则，那么将会 panic，而不是编译错误。</p><p><strong>使用 <code>RefCell&lt;T&gt;</code> 在运行时记录借用信息</strong></p><ul><li><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针：<ul><li>每次调用 borrow：不可变借用计数加1</li><li>任何一个 <code>Ref&lt;T&gt;</code> 的值离开作用域被释放时：不可变借用计数减 1</li><li>每次调用 <code>borrow_mut</code>：可变借用计数加1</li><li>任何一个 <code>RefMut&lt;T&gt;</code> 的值离开作用域被释放时：可变借用计数减 1</li></ul></li><li>以此技术来维护借用检查规则：<ul><li>任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</li></ul></li></ul><p><strong>其它可实现内部可变性的类型</strong></p><ul><li><code>Cell&lt;T&gt;</code>：通过复制来访问数据</li><li><code>Mutex&lt;T&gt;</code>：用于实现跨线程情形下的内部可变性模式</li></ul><h2 id="六、循环引用导致内存泄露"><a href="#六、循环引用导致内存泄露" class="headerlink" title="六、循环引用导致内存泄露"></a>六、循环引用导致内存泄露</h2><h3 id="6-1-Rust-可能发生内存泄漏"><a href="#6-1-Rust-可能发生内存泄漏" class="headerlink" title="6.1 Rust 可能发生内存泄漏"></a>6.1 Rust 可能发生内存泄漏</h3><ul><li>Rust 的内存安全机制可以保证很难发生内存泄漏，但不是不可能</li><li>例如使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 就可能创造出循环引用，从而发生内存泄漏：<ul><li>每个项的引用数量不会变成 0，值也不会被处理掉</li></ul></li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test02</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item is &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item is &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;a next item is &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 <code>a</code>，<code>Cons</code> 第一个元素是 5，第二个元素是 <code>Nil</code>，然后输出 a 的强引用，输出 a 的 <code>Cons</code> 的第二个元素。同理创建 b，<code>Cons</code> 第一个元素是 10，第二个元素引用 a，然后输出此时 a 的强引用和 b 的强引用。</p><p>这个时候将 a 的 Cons 第二个元素改成 b 的引用，即这个 List 的 a 和 b 收尾相连了，形成了一个类似于循环链表的结构。这时我们观察输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.25</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">a initial rc count is <span class="number">1</span></span><br><span class="line">a next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation is <span class="number">2</span></span><br><span class="line">b initial rc count is <span class="number">1</span></span><br><span class="line">b next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">a rc count after changing a is <span class="number">2</span></span><br><span class="line">b rc count after changing a is <span class="number">2</span></span><br></pre></td></tr></table></figure><p>收尾相连后 a 和 b 的强引用计数都是 2（很显然）。但是这个时候如果要输出 a 的下一个元素，就会发生栈溢出。因为 a 和 b 形成了循环，a 的下一个元素是 b，但是 b 中又包含 a，a 中又包含 b… 如此往复，b 的大小其实是无穷大的，因此会导致<strong>栈溢出</strong>。取消上面的注释行，再次运行，会得到下面的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; </span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; has overflowed its stack</span><br><span class="line">fatal runtime error: stack overflow</span><br><span class="line">[<span class="number">1</span>]    <span class="number">28287</span> abort      cargo run</span><br></pre></td></tr></table></figure><h3 id="6-2-防止内存泄漏的解决办法"><a href="#6-2-防止内存泄漏的解决办法" class="headerlink" title="6.2 防止内存泄漏的解决办法"></a>6.2 防止内存泄漏的解决办法</h3><ul><li>依靠开发者来保证，不能依靠 Rust</li><li>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权<ul><li>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</li><li>而只有所有权关系才影响值的清理</li></ul></li></ul><p><strong>防止循环引用把 <code>Rc&lt;T&gt;</code> 换成 <code>Weak&lt;T&gt;</code></strong></p><ul><li><code>Rc::clone</code> 为 <code>Rc&lt;T&gt;</code> 实例的 strong_count 加 1，<code>Rc&lt;T&gt;</code> 的实例只有在 strong_count 为 0 的时候才会被清理</li><li><code>Rc&lt;T&gt;</code> 实例通过调用 <code>Rc::downgrade</code> 方法可以创建值的 Weak Reference（弱引用）<ul><li>返回类型是 <code>Weak&lt;T&gt;</code>（智能指针）</li><li>调用 <code>Rc::downgrade</code> 会为 weak_count 加1</li></ul></li><li><code>Rc&lt;T&gt;</code> 使用 weak_count 来追踪存在多少 <code>Weak&lt;T&gt;</code></li><li>weak_count 不为 0 并不影响 <code>Rc&lt;T&gt;</code> 实例的清理</li></ul><p><strong>Strong vs Weak</strong></p><ul><li>Strong Reference（强引用）是关于如何分享 <code>Rc&lt;T&gt;</code> 实例的所有权</li><li>Weak Reference（弱引用）并不表达上述意思</li><li>使用 Weak Reference 并不会创建循环引用：<ul><li>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</li></ul></li><li>在使用 <code>Weak&lt;T&gt;</code> 前，需保证它指向的值仍然存在：<ul><li>在 <code>Weak&lt;T&gt;</code> 实例上调用 <code>upgrade</code> 方法，返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code></li></ul></li></ul><h3 id="6-3-实现树的数据结构的例子"><a href="#6-3-实现树的数据结构的例子" class="headerlink" title="6.3 实现树的数据结构的例子"></a>6.3 实现树的数据结构的例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个叶子结点值为 3，该叶子结点没有孩子结点，再创建一个分支结点，作为叶节点 3 的父节点。此时该叶子结点拥有两个强引用，即叶子结点本身和父节点拥有该叶子结点的所有权。我们可以通过分支结点访问到叶节点，因为他拥有叶节点的引用（这里也是所有权），而叶子结点无法访问到父节点，因为他没有拥有父节点的所有权或引用。</p><p>上面这种双向的引用形成了循环引用，这个时候就可以使用 <code>Weak&lt;T&gt;</code> 来避免产生循环引用。</p><p>我们修改上面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 leaf 的 parent 字段的 <code>borrow</code> 方法获取其不可变引用，然后通过 <code>upgrade</code> 方法将 <code>Weak&lt;T&gt;</code> 转化成 <code>Rc&lt;T&gt;</code>，然后再调用 leaf 的 parent 字段的 <code>borrow_mut</code> 方法获取其可变引用，然后通过调用 <code>Rc::downgrade</code> 将 branch 里的 <code>Rc&lt;Node&gt;</code> 转化成 <code>Weak&lt;Node&gt;</code> 并存在 leaf.parent 里。</p><p>输出结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf parent is <span class="title function_ invoke__">Some</span>(Node &#123; value: <span class="number">5</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: <span class="number">3</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure><p>我们通过分别打印 leaf 和 branch 的强弱引用来深入理解一下本小节内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.35</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br><span class="line">leaf strong = <span class="number">2</span>, weak = <span class="number">0</span></span><br><span class="line">branch strong = <span class="number">1</span>, weak = <span class="number">1</span></span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>刚创建 leaf 时，只有一个 leaf 的强引用，没有弱引用。然后在一个新的作用域内创建 branch，将 branch 和 leaf 关联起来，此时 branch 强引用只有一个（branch 自身），弱引用有一个（leaf）。leaf 强引用有两个，自身和 branch。然后 branch 走出了作用域，强引用计数减 1 变成 0，内存被释放，branch 便不存在了，此时通过 leaf 访问 branch 显然为 None，最后再输出 leaf 的强引用为 1，即 leaf 自身。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 &lt;code&gt;&amp;amp;&lt;/code&gt; 了，没有其他开销。&lt;br&gt;智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十二）：cargo 和 crates.io</title>
    <link href="http://cherryyang05.github.io/af9cf945.html"/>
    <id>http://cherryyang05.github.io/af9cf945.html</id>
    <published>2022-07-08T08:50:09.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章内容如下：</p><ul><li>通过 release profle 来自定义构建</li><li>在 <a href="https://crates.io/">https://crates.io/</a> 上发布库</li><li>通过 workspaces 组织大工程</li><li>从 <a href="https://crates.io/">https://crates.io/</a> 来安装库</li><li>使用自定义命令扩展 cargo</li></ul></blockquote><span id="more"></span><h2 id="一、通过-release-profle-来自定义构建"><a href="#一、通过-release-profle-来自定义构建" class="headerlink" title="一、通过 release profle 来自定义构建"></a>一、通过 release profle 来自定义构建</h2><p><strong>release profile（发布配置）</strong></p><ul><li>是预定义的</li><li>可自定义：可使用不同的配置，对代码编译拥有更多的控制</li><li>每个 profile 的配置都独立于其它的 profile</li><li>Cargo 主要的两个 profile<ul><li>dev profile：适用于开发，cargo build</li><li>release profile：适用于发布，cargo build –release</li></ul></li></ul><p><strong>自定义 profile</strong></p><ul><li>针对每个 profle，Cargo 都提供了默认的配置</li><li>如果想自定义 xxxx profile 的配置<ul><li>可以在 Cargo.toml 里添加 <code>[profile.xxxx]</code> 区域，在里面覆盖默认配置的子集</li></ul></li></ul><p>例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[profile. dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>opt-level</code> 表示编译优化等级，在开发模式下，一般希望有较快的编译速度，因此编译优化等级较低。而在发布模式下，需要多次运行程序，因此希望有较高等级的优化，从而用较长的编译时间换取较短的运行时间。</p><p>对于每个配置的默认值和完整选项，请参见：<a href="https://doc.rustlang.ora/cargo/">https://doc.rustlang.ora/cargo/</a></p><h2 id="二、发布-crate-到-crates-io"><a href="#二、发布-crate-到-crates-io" class="headerlink" title="二、发布 crate 到 crates.io"></a>二、发布 crate 到 crates.io</h2><h3 id="2-1-crates-io"><a href="#2-1-crates-io" class="headerlink" title="2.1 crates.io"></a>2.1 crates.io</h3><ul><li>可以通过发布包来共享你的代码</li><li>crate 的注册表在 <a href="https://crates.io/">https://crates.io/</a></li><li>它会分发己注册的包的源代码</li><li>主要托管开源的代码</li></ul><h3 id="2-2-文档注释"><a href="#2-2-文档注释" class="headerlink" title="2.2 文档注释"></a>2.2 文档注释</h3><h4 id="2-2-1-文档注释的使用"><a href="#2-2-1-文档注释的使用" class="headerlink" title="2.2.1 文档注释的使用"></a>2.2.1 文档注释的使用</h4><ul><li>文档注释：用于生成文档<ul><li>生成 HTML 文档</li><li>显式公共 API 的文档注释：如何使用 API</li><li>使用 <code>///</code></li><li>支持 Markdown</li><li>放置在被说明条目之前</li></ul></li></ul><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这个函数是将传入的 u32 类型的值加一，然后返回这个值的所有权</span></span><br><span class="line"><span class="comment">/// # 实例</span></span><br><span class="line"><span class="comment">/// let a = 3;</span></span><br><span class="line"><span class="comment">/// let b = add_one(a);</span></span><br><span class="line"><span class="comment">/// assert_eq!(4, b);</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(num: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-生成-HTML-文档的命令"><a href="#2-2-2-生成-HTML-文档的命令" class="headerlink" title="2.2.2 生成 HTML 文档的命令"></a>2.2.2 生成 HTML 文档的命令</h4><p><code>cargo doc</code></p><ul><li>它会运行 rustdoc 工具（Rust 安装包自带）</li><li>把生成的 HTML 文档放在 target&#x2F;doc 目录下</li></ul><p><code>cargo doc --open</code></p><ul><li>构建当前 crate 的文档（也包含 crate 依赖项的文档）</li><li>在浏览器打开文档</li></ul><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808150051.png" alt="Rust Doc"></p><h4 id="2-2-3-常用章节"><a href="#2-2-3-常用章节" class="headerlink" title="2.2.3 常用章节"></a>2.2.3 常用章节</h4><ul><li>＃ Examples</li><li>其它常用的章节<ul><li>Panics：函数可能发生 panic 的场景</li><li>Errors：如果函数返回 Result，描述可能的错误种类，以及可导致错误的条件</li><li>Safety：如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提</li></ul></li></ul><h4 id="2-2-4-文档注释作为测试"><a href="#2-2-4-文档注释作为测试" class="headerlink" title="2.2.4 文档注释作为测试"></a>2.2.4 文档注释作为测试</h4><ul><li>示例代码块的附加值：<ul><li>运行 cargo test：将把文档注释中的示例代码作为测试来运行</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo test</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.18</span>s</span><br><span class="line">     Running unittests src/lib.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-d31f5191c1eed090)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-<span class="number">8</span>c2dc60df354a71a)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests it</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test src/lib.rs - <span class="title function_ invoke__">add_one</span> (line <span class="number">3</span>) ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.16</span>s</span><br></pre></td></tr></table></figure><h4 id="2-2-5-为包含注释的项添加文档注释"><a href="#2-2-5-为包含注释的项添加文档注释" class="headerlink" title="2.2.5 为包含注释的项添加文档注释"></a>2.2.5 为包含注释的项添加文档注释</h4><ul><li>符号：<code>//!</code></li><li>这类注释通常用描述 crate 和模块：<ul><li>crate root（按惯例 src&#x2F;lib.rs)</li><li>一个模块内，将 crate 或模块作为一个整体进行记录</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808151624.png" alt="Rust Doc"></p><h3 id="2-3-pub-use"><a href="#2-3-pub-use" class="headerlink" title="2.3 pub use"></a>2.3 pub use</h3><p><strong>使用 pub use 导出方便使用的公共 API</strong></p><ul><li>问题：crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便<ul><li>开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲</li></ul></li><li>例如<ul><li>麻烦：my_crate::some_module::another_module::UsefulType；</li><li>方便：my_crate::UsefulType</li></ul></li><li>解决办法<ul><li>不需要重新组织内部代码结构</li><li>使用 pub use：可以重新导出，创建一个与内部私有结构不同的对外公共结构</li></ul></li></ul><p><code>main.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> pubuse::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> pubuse::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = PrimaryColor::Blue;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = <span class="title function_ invoke__">mix</span>(c1, c2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The mixed color is &#123;:?&#125;&quot;</span>, c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lib.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 这是测试 pub use 使用的 crate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// 色彩三原色：红黄蓝</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 两种颜色混合后的颜色</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将红黄蓝中任意两种颜色混合</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808163422.png" alt="pub use Doc"></p><p>我们从生成的文档看出，就将很深层的函数提到了 crate 的外层，方便用户查看和调用。</p><h3 id="2-4-发布-crate"><a href="#2-4-发布-crate" class="headerlink" title="2.4 发布 crate"></a>2.4 发布 crate</h3><ul><li>创建并设置 crates.io 账号</li><li>发布 crate 前，需要在 crates.io 创建账号并获得 API token</li><li>运行命令：<code>cargo login</code> [你的API token]<ul><li>通知 cargo，你的 API token 存储在本地 <code>~/.cargo/credentials</code></li></ul></li><li>API token 可以在 <a href="https://crates.io/">https://crates.io/</a> 进行撤销</li></ul><p><strong>为新的 crate 添加元数据</strong></p><ul><li>在发布 crate 之前，需要在 Cargo.toml 的 Ipackage] 区域为 crate 添加一些元数据：<ul><li>crate 需要唯一的名称：name</li><li>description：一两句话即可，会出现在 crate 搜索的结果里</li><li>license：需提供许可证标识值（可到 <a href="http://spdk.org/licenses/">http://spdk.org/licenses/</a> 查找）</li><li>可指定多个 license：用 OR</li><li>version</li><li>author</li></ul></li><li>发布：<code>cargo publish</code> 命令</li></ul><p><strong>发布到 crates.io</strong></p><ul><li>crate一旦发布，就是永久性的：该版本无法覆盖，代码无法删除</li><li>目的：依赖于该版本的项目可继续正常工作</li></ul><p><strong>发布己存在 crate 的新版本</strong></p><ul><li>修改 crate 后，需要先修改 Cargo.toml 里面的 version 值，再进行重新发布</li><li>参照 htto:&#x2F;&#x2F;semver.orgl 来使用你的语义版本</li></ul><p><strong>使用 cargo yank 从 Crates.io 撤回版本</strong></p><ul><li>不可以删除 crate 之前的版本</li><li>但可以防止其它项目把它作为新的依赖：yank（撤回）一个 crate 版本<ul><li>防止新项目依赖于该版本</li><li>己经存在项目可继续将其作为依赖（并可下载）</li></ul></li><li>yank 意味着：<ul><li>所有己经产生 Cargo.lock 的项目都不会中断</li><li>任何将来生成的 Cargo.lock 文件都不会使用被 yank 的版本。</li></ul></li><li>命令：<ul><li>yank 一个版本（不会删除任何代码）：<code>cargo yank -vers 1.0.1</code></li></ul></li></ul><h3 id="2-5-cargo-工作空间"><a href="#2-5-cargo-工作空间" class="headerlink" title="2.5 cargo 工作空间"></a>2.5 cargo 工作空间</h3><h4 id="2-5-1-创建工作空间"><a href="#2-5-1-创建工作空间" class="headerlink" title="2.5.1 创建工作空间"></a>2.5.1 创建工作空间</h4><p>随着项目越来越大，代码也会越来越臃肿，这时就需要将 crate 拆分成多个包，cargo 便提供了<strong>工作空间</strong>这个功能。</p><ul><li>cargo 工作空间：帮助管理多个相互关联且需要协同开发的 crate</li><li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li></ul><p><strong>创建工作空间</strong></p><ul><li>有多种方式来组建工作空间例：1 个二进制 crate，2 个库 crate<ul><li>二进制 crate：main 函数，依赖于其它2个库 crate</li><li>其中1个库 crate 提供 addLone 函数</li><li>另外1个库 crate 提供 add_two 函数</li></ul></li></ul><p><strong>在工作空间中依赖外部 crate</strong></p><ul><li>工作空间只有一个 Cargo.lock 文件，在工作空间的顶层目录<ul><li>保证工作空间内所有 crate 使用的依赖的版本都相同</li><li>工作空间内所有 crate 相互兼容</li></ul></li></ul><p>参数 <code>-p</code> 可以指定某个 crate 构建、运行或测试。例如 <code>cargo test -p add-one</code>。<br>发布的时候需要手动进入每个 crate 逐个发布。</p><p>以上内容参考<a href="https://www.bilibili.com/video/BV1hp4y1k7SV?p=83&spm_id_from=pageDriver&vd_source=cd979f5b9cea5f03bd91461762cdd74c">视频</a>，未做具体记录。</p><h3 id="2-6-安装二进制-crate"><a href="#2-6-安装二进制-crate" class="headerlink" title="2.6 安装二进制 crate"></a>2.6 安装二进制 crate</h3><p><strong>从 CRATES.IO 安装二进制 crate</strong></p><ul><li>命令：cargo install</li><li>来源： <a href="https://crates.io/">https://crates.io</a></li><li>限制：只能安装具有二进制目标 (binary target）的 crate</li><li>二进制目标 binary target：是一个可运行程序<ul><li>由拥有 src&#x2F;main.rs 或其它被指定为二进制文件的 crate 生成</li></ul></li><li>通常：README 里有关于 crate 的描述：<ul><li>拥有 library target</li><li>拥有 binary target</li><li>两者兼备</li></ul></li></ul><p><strong>cargo install</strong></p><ul><li>cargo install 安装的二进制存放在根目录的 bin 文件夹</li><li>如果你用 rustup 安装的 Rust，没有任何自定义配置，那么二进制存放目录是 <code>$HOME/.cargo/bin</code><ul><li>要确保该目录在环境变量 ＄PATH 中</li></ul></li></ul><p><strong>使用自定义命令扩展 cargo</strong></p><ul><li>cargo 被设计成可以使用子命令来扩展</li><li>例：如果＄PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行：<ul><li>cargo something</li></ul></li><li>类似这样的自定义命令可以通过该命令列出：cargo –list</li><li>优点：可使用 cargo install 来安装扩展，像内置工具一样来运行</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 release profle 来自定义构建&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&quot;https://crates.io/&quot;&gt;https://crates.io/&lt;/a&gt; 上发布库&lt;/li&gt;
&lt;li&gt;通过 workspaces 组织大工程&lt;/li&gt;
&lt;li&gt;从 &lt;a href=&quot;https://crates.io/&quot;&gt;https://crates.io/&lt;/a&gt; 来安装库&lt;/li&gt;
&lt;li&gt;使用自定义命令扩展 cargo&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十一）：闭包和迭代器</title>
    <link href="http://cherryyang05.github.io/1b9cba25.html"/>
    <id>http://cherryyang05.github.io/1b9cba25.html</id>
    <published>2022-07-08T08:49:31.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。<br>函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点</p></blockquote><span id="more"></span><h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a>1.1 什么是闭包</h3><ul><li>是匿名函数</li><li>保存为变量、作为参数</li><li>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li><li>可从其定义的作用域捕获值</li></ul><h3 id="1-2-例子：生成自定义运动计划的程序"><a href="#1-2-例子：生成自定义运动计划的程序" class="headerlink" title="1.2 例子：生成自定义运动计划的程序"></a>1.2 例子：生成自定义运动计划的程序</h3><ul><li>该算法的逻辑并不是重点，重点是算法中的计算过程需要几秒钟时间。</li><li>目标：不让用户发生不必要的等待<ul><li>仅在必要时调用该算法</li></ul></li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用函数 <code>simulated_expensive_calculation</code> 模拟复杂的计算，我们不希望调用多次该函数，因为非常耗时，对用户不友好，因此首先想出的优化方案就是用一个变量接收该函数值，当 <code>generate_workout</code> 进入条件语句时，便只需要执行一次即可，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity);</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, res);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这样又会产生一个新的问题：当进入 <code>else</code> 时，随机数值为 3 的时候，是无需执行复杂计算的，这时候用一个变量接收该复杂计算的函数值便会显得浪费。我们真正希望的是，函数定义单独在一个地方，等到函数真正被用到时再被执行，这就是闭包的功能。代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>expensive_closure</code> 只是定义了一个匿名函数，并没有执行。当然在条件语句中，该闭包还是执行了两次，对于这里的优化，后面会讲到。</p><h3 id="1-3-闭包的类型推断和标注"><a href="#1-3-闭包的类型推断和标注" class="headerlink" title="1.3 闭包的类型推断和标注"></a>1.3 闭包的类型推断和标注</h3><ul><li>闭包不要求标注参数和返回值的类型，和函数不同，无需对外暴露接口</li><li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li><li>可以手动添加类型标注</li><li>注意：闭包的定义最终只会为参数&#x2F;返回值推断出唯一具体的类型</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(Hello));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>变量 <code>s</code> 传给该闭包一个字符串类型，编译器便推断出来闭包中参数 <code>x</code> 是字符串类型，便与其绑定，因此变量 <code>a</code> 再传入一个整型便会报错。</p><h3 id="1-4-使用泛型参数和-Fn-Trait-来存储闭包"><a href="#1-4-使用泛型参数和-Fn-Trait-来存储闭包" class="headerlink" title="1.4 使用泛型参数和 Fn Trait 来存储闭包"></a>1.4 使用泛型参数和 Fn Trait 来存储闭包</h3><h4 id="1-4-1-继续解决-1-2-中的例子"><a href="#1-4-1-继续解决-1-2-中的例子" class="headerlink" title="1.4.1 继续解决 1.2 中的例子"></a>1.4.1 继续解决 1.2 中的例子</h4><p>除了创建局部变量存储闭包的值，还有另一种解决方案：</p><p>创建一个 struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果。<br>这个模式通常叫做<strong>记忆化（memoization）</strong>或<strong>延迟计算（lazy evaluation）</strong></p><p><strong>如何让 struct 持有闭包</strong></p><ul><li>struct 的定义需要知道所有字段的类型<ul><li>需要指明闭包的类型</li></ul></li><li>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</li><li>所以需要使用：泛型和 Trait Bound（第10章）</li></ul><p><strong>Fn Trait</strong></p><ul><li>Fn traits 由标准库提供</li><li>所有的闭包都至少实现了以下 trait 之一：<ul><li>Fn</li><li>FnMut</li><li>FnOnce</li></ul></li></ul><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: F,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F&gt; Cacher&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: F) <span class="punctuation">-&gt;</span> Cacher&lt;F&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一个结构体，该结构体泛型参数要实现 Fn trait，然后为该结构体实现 <code>new</code> 和 <code>value</code> 函数（方法），如果已经执行过该闭包，则返回值，若没有执行过则执行闭包，将值存进结构体变量中。<code>generate_workout</code> 函数实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_closure</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-使用缓存器（Cacher）实现的限制"><a href="#1-4-2-使用缓存器（Cacher）实现的限制" class="headerlink" title="1.4.2 使用缓存器（Cacher）实现的限制"></a>1.4.2 使用缓存器（Cacher）实现的限制</h4><ol><li>Cacher 实例假定针对不同的参数 arg，value 方法总会得到同样的值<ul><li>可以使用 HashMap 代替单个值：<ul><li>key: arg 参数</li><li>value：执行闭包的结果</li></ul></li></ul></li><li>只能接收一个 u32 类型的参数和 u32 类型的返回值<ul><li>引入两个或多个泛型参数</li></ul></li></ol><h3 id="1-5-使用闭包捕获环境"><a href="#1-5-使用闭包捕获环境" class="headerlink" title="1.5 使用闭包捕获环境"></a>1.5 使用闭包捕获环境</h3><h4 id="1-5-1-利用闭包捕获环境中的变量"><a href="#1-5-1-利用闭包捕获环境中的变量" class="headerlink" title="1.5.1 利用闭包捕获环境中的变量"></a>1.5.1 利用闭包捕获环境中的变量</h4><p>闭包可以捕获他们所在的环境</p><ul><li>闭包可以访问定义它的作用域内的变量，而普通函数则不能</li><li>会产生额外内存开销</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure><p>上述代码中，闭包内的变量 <code>x</code> 并不是在闭包内定义的，但是却可以访问，因为闭包可以捕获和其在<strong>同一作用域内</strong>的其他变量，而函数却没有这样的作用。</p><p><strong>闭包从所在环境捕获值的方式</strong></p><p>与函数获得参数的三种方式一样：</p><ul><li>取得所有权：<code>FnOnce</code></li><li>可变借用：<code>FnMut</code></li><li>不可变借用： <code>Fn</code></li></ul><p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 frait：</p><ul><li>所有的闭包都实现了 FnOnce</li><li>没有移动捕获变量的实现了 FnMut</li><li>无需可变访问捕获变量的闭包实现了 Fn</li></ul><p>注：实现了 <code>Fn trait</code> 的闭包一定实现了 <code>Fn Mut</code>，实现了 <code>Fn Mut</code> 一定实现了 <code>Fn Once</code>。</p><h4 id="1-5-2-move-关键字"><a href="#1-5-2-move-关键字" class="headerlink" title="1.5.2 move 关键字"></a>1.5.2 move 关键字</h4><p>在参数列表前使用 move 关键字，可以强制闭包取得它所使用的环境值的所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here：&#123;:?&#125;&quot;</span>, x);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure><p>这里便不能使用 <code>x</code> 变量了。</p><p><strong>最佳实践</strong><br>当指定 Fn trait bound 之一时，首先用 Fn，基于闭包体里的情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你。<br>（面向编译器编程实锤 o_O）</p><h2 id="二、迭代器"><a href="#二、迭代器" class="headerlink" title="二、迭代器"></a>二、迭代器</h2><p><strong>什么是迭代器</strong></p><ul><li>迭代器模式：对一系列项执行某些任务</li><li>迭代器负责：<ul><li>遍历每个项</li><li>确定序列（遍历）何时完成</li></ul></li></ul><p><strong>Rust 的迭代器：</strong></p><ul><li>懒惰的：除非调用消费迭代器的方法，否则迭代器本身没有任何效果。</li></ul><p>先用一个最简单的迭代器的例子来进入本节的学习：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">9</span>, <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run   </span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Got: <span class="number">3</span></span><br><span class="line">Got: <span class="number">9</span></span><br><span class="line">Got: <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Iterator-trait-和-next-方法"><a href="#2-1-Iterator-trait-和-next-方法" class="headerlink" title="2.1 Iterator trait 和 next 方法"></a>2.1 Iterator trait 和 next 方法</h3><ul><li>所有迭代器都实现了 Iterator trait</li><li>Iterator trait 定义于标准库，定义大致如下</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ltem</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::tem&gt;;</span><br><span class="line">        <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type Item 和 Self::Item 定义了与此该 trait 关联的类型<ul><li>实现 Iterator trait 需要你定义一个 Item 类型，它用于 next 方法的返回类型（迭代器的返回类型）</li></ul></li></ul><p><strong>Iterator trait 仅要求实现一个方法：next</strong></p><ul><li>next:<ul><li>每次返回迭代器中的一项</li><li>返回结果包裹在 Some 里</li><li>迭代结束，返回 None</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter_mut</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">9</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">100</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v1_iter_mut.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure><p>上述的例子要定义一个可变的迭代器，因为 <code>next</code> 方法会更改迭代器内部的用来标示顺序的某些值，而上面的 for 之所以不用定义迭代器为可变，是因为用 for 来进行循环，实际上是取得了该迭代器的所有权，在其内部已经将其变成可变的了。</p><p>需要注意的是，next 方法是一种消耗型行为，我们最后输出了迭代器 <code>v1_iter_mut</code> 的长度，结果为 0。</p><p><strong>几个迭代方法</strong></p><ul><li>iter 方法：在不可变引用上创建迭代器</li><li>into_iter 方法：创建的迭代器会获得所有权</li><li>iter_mut 方法：迭代可变的引用</li></ul><h3 id="2-2-消耗-x2F-产生迭代器"><a href="#2-2-消耗-x2F-产生迭代器" class="headerlink" title="2.2 消耗&#x2F;产生迭代器"></a>2.2 消耗&#x2F;产生迭代器</h3><h4 id="2-2-1-消耗迭代器的方法"><a href="#2-2-1-消耗迭代器的方法" class="headerlink" title="2.2.1 消耗迭代器的方法"></a>2.2.1 消耗迭代器的方法</h4><ul><li>在标准库中，Iterator trait 有一些带默认实现的方法</li><li>其中有一些方法会调用 next 方法<ul><li>实现 Iterator frait 时必须实现 nex† 方法的原因之一</li></ul></li><li>调用 next 的方法叫做“消耗型适配器”<ul><li>因为调用它们会把迭代器消耗尽</li></ul></li><li>例如：sum 方法（就会耗尽迭代器）<ul><li>取得迭代器的所有权</li><li>通过反复调用 next，遍历所有元素</li><li>每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sum</code> 的时候要注意显示声明类型。</p><h4 id="2-2-2-产生其它迭代器的方法-map"><a href="#2-2-2-产生其它迭代器的方法-map" class="headerlink" title="2.2.2 产生其它迭代器的方法(map)"></a>2.2.2 产生其它迭代器的方法(map)</h4><ul><li>定义在 Iterator trait 上的另外一些方法叫做“迭代器适配器”<ul><li>把迭代器转换为不同种类的迭代器</li></ul></li><li>可以通过链式调用使用多个迭代器适配器来执行复杂的操作，这种调用可读性较高。</li><li>例如：map<ul><li>接收一个闭包，闭包作用于每个元素</li><li>产生一个新的迭代器</li></ul></li><li>collect 方法：消耗型适配器，把结果收集到一个集合类型中</li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用闭包捕获环境-filter"><a href="#2-3-使用闭包捕获环境-filter" class="headerlink" title="2.3 使用闭包捕获环境(filter)"></a>2.3 使用闭包捕获环境(filter)</h3><ul><li>filter 方法：<ul><li>接收一个闭包</li><li>这个闭包在遍历迭代器的每个元素时，返回 bool 类型</li><li>如果闭包返回 true：当前元素将会包含在 filter 产生的迭代器中</li><li>如果闭包返回 false：当前元素将不会包含在 filter 产生的迭代器中</li></ul></li></ul><p>我们现在实现一个功能，取出一个迭代器中所有为偶数的元素，将取出的元素再放入一个新的迭代器，例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点要注意：<code>iter</code> 方法里的元素都是引用类型，且不可变，因此若要进行 <code>x % 2 == 0</code> 操作的话，需要解引用 <code>*x</code>。上述代码中使用 <code>into_iter</code> 方法获得了迭代器中元素的所有权。</p><h3 id="2-4-创建自定义迭代器"><a href="#2-4-创建自定义迭代器" class="headerlink" title="2.4 创建自定义迭代器"></a>2.4 创建自定义迭代器</h3><p><strong>使用 Iterator frait 来创建自定义迭代器</strong></p><ul><li>实现 next 方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123;count: <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子很容易理解，就是通过 <code>next</code> 方法不断迭代，范围是 1-5，至于为 Counter 实现 Iterator 特征，将来会介绍。</p><p>下面要对迭代器的需求进行改进，有两个迭代器，第一个迭代器就是上面所说的，第二个迭代器的元素是 <code>[2, 3, 4, 5]</code>，现在要求将两个迭代器中的元素按顺序相乘，然后将结果存入一个新的迭代器，然后过滤出能被 3 整除的数，并求和。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍一下 <code>zip</code> 方法，这个单词本意是“拉链”，这里表示将两个迭代器“捏到一起”，形成一个新的迭代器，里面的每个元素就是一个元组 ，这个元组里有两个元素，这两个元素分别来自原来的两个迭代器。这里第一个迭代器就是通过 <code>Counter::new()</code> 得到的，第二个迭代器就是 <code>zip()</code> 方法内的参数 <code>Counter::new().skip(1)</code>，表示跳过第一个元素后剩下的元素组成的迭代器。</p><p>为了更好展示每一个方法的实现过程，我们运行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v1);</span><br></pre></td></tr></table></figure><p>对于上例中的两个初始化后的迭代器，输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.20</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Zip &#123; a: Counter &#123; count: <span class="number">0</span> &#125;, b: Skip &#123; iter: Counter &#123; count: <span class="number">0</span> &#125;, n: <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>再来看官方文档中的实例就更清楚了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a1</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span> = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = a1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(a2.<span class="title function_ invoke__">iter</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">1</span>, &amp;<span class="number">4</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">2</span>, &amp;<span class="number">5</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">3</span>, &amp;<span class="number">6</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><h3 id="2-5-优化第十章的-I-x2F-O-项目"><a href="#2-5-优化第十章的-I-x2F-O-项目" class="headerlink" title="2.5 优化第十章的 I&#x2F;O 项目"></a>2.5 优化第十章的 I&#x2F;O 项目</h3><p>项目具体内容请参考 <a href="Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89.md">Rust入门教程（十）</a></p><h4 id="2-5-1-利用迭代器优化-new-函数"><a href="#2-5-1-利用迭代器优化-new-函数" class="headerlink" title="2.5.1 利用迭代器优化 new 函数"></a>2.5.1 利用迭代器优化 new 函数</h4><p>我们来看一下 <code>minigrep</code> 项目中 <code>Config</code> 函数的 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>new()</code> 函数中，传入的参数是字符串切片，为了返回 <code>Config</code> 结构体，需要获得命令行参数这两个变量的所有权，之前的解决方法是将那两个参数进行克隆，但是这样会对性能带来一定的损耗。现在我们学习完了闭包和迭代器，便可以通过迭代器获取其实例，并且可以使用迭代器所带的一些方法进行长度检查和索引。通过迭代器的 <code>next</code> 方法，便将读取具体值的功能分离了出去。</p><p>原来的 <code>main</code> 函数中，通过 <code>env::args().collect()</code> 将参数列表转化成 vector，然后将这个 vector 传到 <code>new()</code> 函数中，其实 <code>env::args()</code> 返回的就是迭代器，我们直接把它当做 <code>new()</code> 的参数即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改过后的 <code>main</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改过后的 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取要查询的字符串参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取文件名参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-利用迭代器优化-search-函数"><a href="#2-5-2-利用迭代器优化-search-函数" class="headerlink" title="2.5.2 利用迭代器优化 search 函数"></a>2.5.2 利用迭代器优化 search 函数</h4><p>原来的 <code>search()</code> 函数实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现思路是先将文本内容每一行取出来，然后手动遍历，判断当前行是否包含所要查询的字符串，将结果放入新的 vector 中，最后返回这个 vector。但是学完了迭代器适配器的知识点后，应该很容易想到 <code>filter</code> 这个方法。实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query)).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 <code>search_case_insensitive</code> 修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_uppercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query.<span class="title function_ invoke__">to_uppercase</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将原来的七行代码简化成了一行，这一行代码和之前的七行实现的功能是相同的，但是显然利用迭代器实现的这一行代码更加易读（熟悉了迭代器的使用之后，这种写法会非常简单），不仅从代码，减少了临时变量，同时消除了可变状态 <code>result</code>，这样可以使得将来通过并行来提升搜索效率，因为并行时不用再考虑并发访问 <code>result</code> 这个变量时会出现的安全问题了。</p><p>实际上，对于大多数 Rust 程序员会更喜欢使用迭代器这样的方式来实现，因为这样可以更加专注于实现逻辑本身，而不是总是浪费时间在大量的循环和维护临时变量这些细节工作上。至于两者的效率问题，并非像表面上那样，使用迭代器效率会降低，具体的我们下节再介绍。</p><h3 id="2-6-性能比较：循环-vs-迭代器"><a href="#2-6-性能比较：循环-vs-迭代器" class="headerlink" title="2.6 性能比较：循环 vs 迭代器"></a>2.6 性能比较：循环 vs 迭代器</h3><p><strong>零开销抽象 Zero-Cost Abstraction</strong></p><ul><li>使用抽象时不会引入额外的运行时开销</li></ul><p>对于迭代器，编译器会自行判断底层代码展开策略，对于某些特定次数的循环，编译器底层会手动将迭代器展开特定的次数，这样对于流水线 CPU 来说，会减少因跳转或延迟槽产生的停顿周期，使得流水线的吞吐量增大，从而使得效率提高。</p><p>因此在 Rust 中，尽量使用迭代器实现。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。&lt;br&gt;函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十）：项目实战</title>
    <link href="http://cherryyang05.github.io/461e5b43.html"/>
    <id>http://cherryyang05.github.io/461e5b43.html</id>
    <published>2022-07-03T06:37:57.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。</p></blockquote><span id="more"></span><p>要实现的 grep 命令功能很简单，就是在指定文件中查找指定文字。grep 命令接收一个文件名和字符串作为输入参数，然后读取文件内容，搜索包含指定字符串的行，最终将这些匹配的行打印输出。</p><p>下面开始实战演示。</p><h2 id="一、接收命令行参数"><a href="#一、接收命令行参数" class="headerlink" title="一、接收命令行参数"></a>一、接收命令行参数</h2><p>我们预计使用如下命令来执行该程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run &lt;string&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>因此我们首先要读取命令行中的参数，我们导入函数 <code>use std::env::args()</code>，<code>args()</code> 函数返回一个迭代器，迭代器部分的内容将在后面才会介绍。然后使用 <code>collect</code> 方法，将迭代器中的值转化成一个集合，但是该函数不能处理命令行中非 <code>Unicode</code> 的字符（这种情况可以使用 <code>env::args _os()</code> 函数，这种情况下返回的迭代器值的类型是 <code>OsString</code>，在这里不做介绍）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string filename</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.29</span>s</span><br><span class="line">     Running `target/debug/minigrep string filename`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;filename&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file filename</span><br></pre></td></tr></table></figure><p>根据程序执行结果我们能够得知：返回的第一个参数永远都是该程序的二进制文件（对应 <code>args[0]</code>），从第二个参数开始才是从命令行输入的各种参数（对应 <code>args[1]</code> …）。</p><h2 id="二、读取文件"><a href="#二、读取文件" class="headerlink" title="二、读取文件"></a>二、读取文件</h2><p>首先导入模块 <code>use std::fs</code>，用于处理和文件相关的事务，<code>read_to_string()</code> 用来读取文件中的内容，将其转化成字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string poem    </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep string poem`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;poem&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file poem</span><br><span class="line">文件内容:</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For <span class="keyword">if</span> dreams die</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">That can never fly</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For when dreams go</span><br><span class="line">Life is a barren field</span><br><span class="line">Frozen only with snow</span><br><span class="line"></span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br><span class="line">And a heaven <span class="keyword">in</span> a wild flower,</span><br><span class="line">Hold infinity <span class="keyword">in</span> the palm of your hand,</span><br><span class="line">And eternity <span class="keyword">in</span> an hour.</span><br></pre></td></tr></table></figure><p>当然目前看来所有逻辑都放在了主函数中，并且很多错误情况都没有考虑。一般情况下一个函数只做一件事，如果代码逐渐变多，代码维护将变得越来越困难。代码越少重构越简单，因此下一节将对代码进行重构。</p><h2 id="三、重构：改进模块和错误处理"><a href="#三、重构：改进模块和错误处理" class="headerlink" title="三、重构：改进模块和错误处理"></a>三、重构：改进模块和错误处理</h2><h3 id="3-1-四个问题提炼"><a href="#3-1-四个问题提炼" class="headerlink" title="3.1 四个问题提炼"></a>3.1 四个问题提炼</h3><p>我们仔细观察一下目前的代码，主要有四个方面的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>主函数负责的功能较多，既要负责命令行参数解析，又要负责读取文件。而程序编写的原则就是一个函数负责一个功能，因此要将主函数拆分；</li><li><code>search_string</code>、<code>filename</code> 和 <code>content</code> 变量，在程序越来越大之后，变量也会越来越多，将难以追踪每一个变量的实际意义。解决办法是将这些变量放入一个结构体中，从而使其用途更加清晰；</li><li>读取文件时，使用 <code>expect</code> 处理错误，但未对其读取错误的原因进行细分，因为文件打不开可能是文件不存在，文件权限不够，文件损坏等原因；</li><li>对于命令行参数的错误处理，若输入的参数没有两个，那么程序本身就会报错，并且能够预料到的错误一定是 <code>Out of bound</code> 这类的错误，但是对于使用者来说，可能并不清楚这个所谓的 <strong>越界错误</strong> 意味着什么，无法清晰解释错误的具体原因。因此最好要将所有错误处理集中到一起，将来开发者要考虑错误处理的时候，就只要处理这一处代码，这样也能保证为用户打印出有意义的错误信息，而不是只有程序员能看懂的 <code>Out of bound</code>。</li></ol><h3 id="3-2-二进制程序关注点分离的指导性原则"><a href="#3-2-二进制程序关注点分离的指导性原则" class="headerlink" title="3.2 二进制程序关注点分离的指导性原则"></a>3.2 二进制程序关注点分离的指导性原则</h3><ul><li>将程序拆分为 <code>main.rs</code> 和 <code>lib.rs</code>，将业务逻辑放入 <code>lib.rs</code></li><li>当命令行解析逻辑较少时，将它放在 <code>main.rs</code> 也行</li><li>当命令行解析逻辑变复杂时，需要将它从 <code>main.rs</code> 提取到 <code>lib.rs</code></li></ul><p>经过上述拆分，留在 <code>main</code> 的功能有：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>进行其它配置</li><li>调用 <code>lib.rs</code> 中的 <code>run</code> 函数</li><li>处理 <code>run</code> 函数可能出现的错误</li></ul><p>因此放在 <code>main.rs</code> 中的代码量应足够小，小到直接阅读代码就可以确保代码的正确性。将业务逻辑放入 <code>lib.rs</code> 中也方便进行功能测试。</p><p>针对上面说的四个方面的问题，我们逐一进行解决。</p><p><strong>1. 拆分出命令行参数提取功能</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">let</span> (search_string, filename) = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    (search_string, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>parse_config</code> 函数目前返回一个元组，但是在主函数中，又将该元组拆分出来，赋值给两个变量，这样感觉有点“脱裤子放屁”的感觉，来回折腾。实际上这种情况就说明程序中这样设计数据结构是不正确的。因此较好的做法就是将返回的元组中的变量放入一个结构体。</p><p><strong>2. 创建结构体</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建一个叫 <code>Config</code> 的结构体，将 <code>search_string</code> 和 <code>filename</code> 两个变量放入结构体。但是上面的代码会报错，这是因为在函数 <code>parse_config</code> 中，<code>args</code> 参数是切片类型，是没有所有权的（它的所有权被 <code>main</code> 函数拥有），而在最后要返回一个 <code>Config</code> 结构体对象，该结构体需要占用所有权，因此会报错。</p><p>这里用一个简单的方法来处理，就是创建 <code>args[1]</code> 和 <code>args[2]</code> 的两个副本，尽管这样会损失性能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看 <code>parse_config</code> 函数，它返回的是一个结构体，实际上是要创建一个新的结构体，因此我们最好再实现该结构体的 <code>new</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将刚刚的 <code>parse_config</code> 变成了结构体 <code>Config</code> 的函数。重构后的完整代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 错误处理</strong></p><p>我们不输入参数进行运行，不出预料的会产生下面的错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run       </span><br><span class="line">warning: field is never read: `search_string`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">19</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> |     search_string: <span class="type">String</span>,</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="meta">#[warn(dead_code)]</span>` on by default</span><br><span class="line"></span><br><span class="line">warning: `minigrep` (bin <span class="string">&quot;minigrep&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">1</span> but the index is <span class="number">1</span>&#x27;, src/main.rs:<span class="number">25</span>:<span class="number">29</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>即 <strong>越界错误</strong>，这对于用户来说是无法理解的，我们当然可以在 <code>new</code> 函数中添加这样的判断语句，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样仍然会有编译器的其他信息，一般情况下，使用 <code>panic</code> 通常是程序本身的问题，但是像这类输入参数少的问题属于程序使用的问题，因此我们还需要进行改进，可以返回 <code>Result</code> 枚举，代码如下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数个数不足，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数个数超过 2 个，则返回 <code>Err</code> 的变体，否则返回 <code>Ok</code>。主函数中，<code>unwrap_or_else</code> 函数的含义是，如果枚举返回的是 <code>Ok</code>，那么就取出 <code>Ok</code> 变体中的值返回，若枚举返回的是 <code>Err</code>，那么就调用一个闭包（匿名函数，闭包具体内容将来会介绍），然后使用 <code>process::exit(1)</code> 将程序返回，这样就不会有编译器的其他信息了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">参数解析错误：输入参数个数不足，请输入两个参数。</span><br></pre></td></tr></table></figure><p><strong>4. 功能模块化</strong></p><p>一个函数只处理一个功能，因此我们将业务逻辑（即读取文件内容）功能提取到一个新的函数中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们进行 <code>run</code> 函数的错误处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>result&lt;(), Box&lt;dyn Error&gt;&gt;</code> 中第一个参数是空，第二个参数只要理解是一个实现了 <code>Error</code> 这个 <code>trait</code> 的类型，这样函数便可以在不同场景下返回不同的错误类型。</p><p>因为 <code>expect</code> 会引起恐慌，因此将其去掉，改成 <code>?</code>，<code>?</code> 运算符遇到错误不会恐慌，它会将错误值返回给函数的调用者，如果没有发生错误，那么我们最后返回一个 <code>Ok()</code>。</p><p>这时编译器会在 <code>run(config)</code> 出给予警告：<code>this &#39;Result&#39; may be an &#39;Err&#39; variant, which should be handled</code>，这说明函数返回值是一个 <code>Result</code> 类型，那么就说明可能会产生错误，因此需要对其进行处理。</p><p><code>unwrap</code> 有打开的意思，需要从 <code>Result</code> 中提取数据，但是 <code>run</code> 函数没有返回值，因此也就不需要 <code>unwrap</code>，可以像下面这样解决这一问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将业务逻辑迁移到 <code>lib.rs</code> 中。</p><p><code>lib.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要记得所有函数和结构体以及字段前都要加 <code>pub</code>，这样才能让其他 <code>crate</code> 才能进行调用。这样 <code>lib crate</code> 就有了一套公共的可用于测试的 API。</p><p>重构到这里就基本完成了，下面就要来编写测试了。</p><h2 id="四、使用-TDD（测试驱动开发）开发库功能"><a href="#四、使用-TDD（测试驱动开发）开发库功能" class="headerlink" title="四、使用 TDD（测试驱动开发）开发库功能"></a>四、使用 TDD（测试驱动开发）开发库功能</h2><p>测试驱动开发 TDD (Test-Driven Development)</p><ul><li>编写一个会失败的测试，运行该测试，确保它是按照预期的原因失败</li><li>编写或修改刚好足够的代码，让新测试通过</li><li>重构刚刚添加或修改的代码，确保测试会始终通过</li><li>返回步骤1，继续</li></ul><p>测试驱动开发能够对代码的设计起到指导和帮助的作用，先编写测试，然后再编写能够通过测试的代码，也能保证开发过程中能够保持测试较高的覆盖率。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">use</span> super::*;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>search</code> 函数中返回的引用的生命周期与 <code>content</code> 有关，而与 <code>query</code> 无关。<code>content.lines()</code> 函数返回一个的迭代器，取出文件中的每一行。这样测试代码就完成了，运行测试也是成功的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo test        </span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.36</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">662</span>cb87b3d895995)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test test::one_result ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">33</span>abce92ed029d2f)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests minigrep</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><p>然后修改 <code>run</code> 函数并运行 <code>cargo run</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run is poem </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep is poem`</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">Life is a barren field</span><br></pre></td></tr></table></figure><h2 id="五、使用环境变量"><a href="#五、使用环境变量" class="headerlink" title="五、使用环境变量"></a>五、使用环境变量</h2><p>这一部分使用环境变量来实现配置选项（例如是否忽略大小写等）。</p><p>我们首先编写一个测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>], <span class="title function_ invoke__">search_case_insensitive</span>(query, contents));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写 <code>search_case_insensitive</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其思路就是将查询的字符串和文件中的都转化成小写。</p><p>然后我们在 <code>run</code> 函数中加入如下逻辑。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">    <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体的 <code>new</code> 函数也需要修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">        search_string,</span><br><span class="line">        filename,</span><br><span class="line">        case_sensitive</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env::var()</code> 函数返回的是 <code>Result</code> 枚举，若环境中有 <code>CASE_INSENSITIVE</code> 定义或者赋值，那么就会返回 <code>Ok</code> 中的值，我们这里只需要判断是否为 <code>Err</code> 即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ CASE_INSENSITIVE=<span class="number">1</span> cargo run to poem</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep to poem`</span><br><span class="line">Hold fast to dreams</span><br><span class="line">Hold fast to dreams</span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br></pre></td></tr></table></figure><h2 id="六、将错误消息写进标准错误而不是标准输出"><a href="#六、将错误消息写进标准错误而不是标准输出" class="headerlink" title="六、将错误消息写进标准错误而不是标准输出"></a>六、将错误消息写进标准错误而不是标准输出</h2><p>当前我们都将错误信息输出到终端上，而大多数终端提供两种输出，一个是标准输出（stdout，println!），另一个叫标准错误（stderr，eprintln!）。</p><p>我们将打印错误信息的 <code>println!</code> 改成 <code>eprintln!</code> 即可，然后运行 <code>cargo run &gt; output</code>，错误信息便不会输出到文件中，而是打印在终端了。</p><h2 id="七、完整代码"><a href="#七、完整代码" class="headerlink" title="七、完整代码"></a>七、完整代码</h2><p><strong>main.rs:</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lib.rs:</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、案例：代码统计"><a href="#七、案例：代码统计" class="headerlink" title="七、案例：代码统计"></a>七、案例：代码统计</h2><h3 id="7-1-基本功能介绍"><a href="#7-1-基本功能介绍" class="headerlink" title="7.1 基本功能介绍"></a>7.1 基本功能介绍</h3><p>代码统计以给定的输入参数作为统计对象（可以是文件或文件夹），根据文件后缀名统计代码所使用的语言（暂定只统计 C、C&#x2F;C++ 头文件、C++、Java、Python、Rust、汇编语言、makefile 脚本），然后统计每一种代码文件的有效代码行数、注释行和空行。没有后缀名的文件默认不进行统计。</p><h3 id="7-2-可拓展功能"><a href="#7-2-可拓展功能" class="headerlink" title="7.2 可拓展功能"></a>7.2 可拓展功能</h3><ul><li>丰富统计的语言种类</li><li>命令行中利用参数指定要统计的语言，只统计指定的语言</li><li>加入多线程提高文件扫描速度</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（九）：Rust 宏编程</title>
    <link href="http://cherryyang05.github.io/c3f8af28.html"/>
    <id>http://cherryyang05.github.io/c3f8af28.html</id>
    <published>2022-07-02T03:26:35.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C&#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。</p></blockquote><p>【未完】</p><span id="more"></span><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>过程宏必须定义在一个独立的 crate 中。</p><p>【解释】：过程宏是在编译一个 crate 之前，对 crate 的代码进行加工的一段程序，这段程序也是需要编译后执行的。如果定义过程宏和使用过程宏的代码写在一个 crate 中，那么就会陷入死锁：</p><ul><li>要编译的代码首先需要运行过程宏来展开，否则代码就是不完整的，没法编译 crate</li><li>不能编译 crate，那么其中的过程宏代码就没法执行，就不能展开被过程宏装饰的代码</li></ul><p>要开发 rust 过程宏，需要在 <code>Cargo.toml</code> 文件中添加必备的三个依赖包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">proc-macro2 = <span class="string">&quot;1.0.7&quot;</span></span><br><span class="line">quote = <span class="string">&quot;1&quot;</span></span><br><span class="line">syn = &#123; version = <span class="string">&quot;1.0.56&quot;</span>, features = &#123;<span class="string">&quot;full&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C&amp;#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【未完】&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（七）：生命周期</title>
    <link href="http://cherryyang05.github.io/3e05ea36.html"/>
    <id>http://cherryyang05.github.io/3e05ea36.html</id>
    <published>2022-06-12T06:34:00.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust入门教程（七）：生命周期"><a href="#Rust入门教程（七）：生命周期" class="headerlink" title="Rust入门教程（七）：生命周期"></a>Rust入门教程（七）：生命周期</h1><blockquote><p>Rust 生命周期机制是与所有权机制同等重要的资源管理机制。生命周期，简而言之就是引用的有效作用域，之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算，但引用往往导致极其复杂的资源管理问题。</p></blockquote><span id="more"></span><p>[toc]</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>Rust 的每个引用都有自己的生命周期</li><li>生命周期：引用保持有效的作用域</li><li>大多数情况：生命周期是隐式的、可被推断的</li><li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</li></ul><p>生命周期的主要目标：避免悬垂引用（dangling reference）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码会在 <code>r = &amp;x;</code> 处报错，因为当打印 <code>r</code> 的值的时候，<code>x</code> 已经离开了他的作用域，这时 <code>r</code> 指向的 <code>x</code> 的内存已经被释放，因此会报错。</p><p>Rust 实际上是通过<strong>借用检查器</strong>来检查一些变量的生命周期。</p><h3 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h3><p>Rust 编译器的借用检查器（borrow checker），用来比较作用域来判断所有的借用是否合法</p><p>在上例中，借用检查器检测到 <code>r</code> 的生命周期大于 <code>x</code>，即被引用者的生命周期小于引用者的生命周期，因此编译会报错。</p><h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/life_cycle git:(master) ✗ cargo run           </span><br><span class="line">   Compiling life_cycle v0.<span class="number">1.0</span> (/home/cherry/Code/rust/life_cycle)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">24</span>:<span class="number">33</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">24</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">   |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line"><span class="number">24</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br></pre></td></tr></table></figure><p>我们发现编译器会提示<strong>缺少一个命名的生命周期参数</strong>，这个函数返回一个借用的值，但是没有声明这个借用的值是来自 <code>x</code> 还是来自 <code>y</code>。值得说明的是，这个返回值的借用跟函数体的逻辑没有关系，要从函数签名就要看出返回值借用的值来自哪一个参数。</p><p>根据编译器提示，我们声明一个泛型生命周期 <code>&#39;a</code>，代码修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h3><ul><li>生命周期的标注不会改变引用的生命周期长度</li><li>当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用</li><li>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期</li></ul><p>生命周期参数名语法如下：</p><ul><li>以 <code>&#39;</code> 开头</li><li>通常全小写且非常短</li><li>习惯以 <code>&#39;a</code> 表示</li></ul><p>生命周期标注的位置：</p><ul><li>在引用符号 <code>&amp;</code> 后面标注</li><li>使用空格将标注和引用类型区分开</li></ul><p>生命周期标注的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>值得注意的是，单个生命周期标注本身没有意义，我们再看上面的 <code>longest</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的生命周期参数声明在函数名和参数列表之间的 <code>&lt;&gt;</code> 中。</p><p>我们仔细分析这个函数：</p><p><code>longest</code> 函数的两个参数都声明了生命周期，就要求这两个引用必须和泛型的生命周期存活相同的时间，而且函数所返回的字符串切片的存活时长也不能小于 <code>&#39;a</code> 这个生命周期。为引用指明生命周期，是要确保当引用失去了所有权后而被移出内存。当在函数参数中指明生命周期时，我们并没有改变参数和返回值的生命周期，只是向调用检查器指出了一些可用于检查非法调用的约束。而 <code>longest</code> 函数本身并不需要知道参数 <code>x</code> 和 <code>y</code> 具体的存活时长，只需要某个可以代替 <code>&#39;a</code> 的作用域，同时满足函数的签名约束。实际上，若函数引用其外部的代码或者被外部代码引用，只靠 rust 本身确定参数和返回值的生命周期时不可能的，这样的话，函数所使用的生命周期在每次调用中都会发生变化，正因为如此，我们才需要手动对生命周期进行标注。</p><p>当我们将两个引用传入函数时，<code>x</code> 和 <code>y</code> 作用域重叠的部分将用来代替 <code>&#39;a</code> 这个生命周期的作用域，换句话说，这个泛型生命周期得到的具体的生命周期就是 <code>x</code> 和 <code>y</code> 两者生命周期较短的那个，因为返回值也标注了相同的生命周期，因此返回值的引用在两者比较短的生命周期内都是有效的。</p><p>那么生命周期标注是如何对 <code>longest</code> 函数进行限制的？我么修改一下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 string1 下面三行代码放到一个单独的作用域里，string2 是一个字符串字面值（字符串切片），他的生命周期相当于是一个静态的生命周期，在整个程序运行期间都存活，而 result 引用也会在 Line 7 大括号结束之前保持有效，因此代码不会报错。</p><p>【注】：<code>&amp;str</code> 是直接在可执行文件中加载的，即这块内存直接放到可执行文件里面的，所以整个程序运行期间，这块内存比较特殊，不会由于所有权而消失，所以指这块内存的引用，一定会一直指向一个合法内存，所以其引用的生命周期是 <code>&#39;static</code>，也就是全局静态，也不可能出现什么悬垂引用。</p><p>再改一下代码，将 result 声明放到外面，然后将 print 也放到外面，将 string2 改成 String 类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;fantastic&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 Line 6 报错了。string1 的生命周期为 Line 2<del>9，string2 的生命周期为 Line 5</del>7，所以 <code>&#39;a</code> 所表示的生命周期为 Line 5<del>7，而 result 的生命周期为 Line 3</del>9，不在 <code>&#39;a</code> 的范围内，因此编译报错，我们来看一下编译具体的错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/life_cycle git:(master) ✗ cargo run</span><br><span class="line">   Compiling life_cycle v0.<span class="number">1.0</span> (/home/cherry/Code/rust/life_cycle)</span><br><span class="line">error[E0597]: `string2` does not live long enough</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">30</span>:<span class="number">44</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">30</span> |         result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">   |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough</span><br><span class="line"><span class="number">31</span> |     &#125;</span><br><span class="line">   |     - `string2` dropped here <span class="keyword">while</span> still borrowed</span><br><span class="line"><span class="number">32</span> |     <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">   |                                          ------ borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0597`.</span><br><span class="line">error: could not compile `life_cycle` due to previous error</span><br></pre></td></tr></table></figure><p>这个报错的含义是，为了让 result 这个变量在打印时是有效的，那么 string2 必须在外部作用域结束之前一直保持有效，因为在函数声明中参数和返回值都使用了相同的生命周期。</p><p>在上例中，尽管 string1 的长度大于 string2 的长度，函数返回的是 string1 的引用，但是编译器并不知道这一点，编译器只知道 <code>longest</code> 函数返回引用的生命周期是 <code>x</code> 和 <code>y</code> 生命周期比较短的那个。</p><h2 id="深入理解生命周期"><a href="#深入理解生命周期" class="headerlink" title="深入理解生命周期"></a>深入理解生命周期</h2><ul><li>指定生命周期参数的方式依赖于函数所做的事情，在上面的例子中，若 <code>longest</code> 函数改为：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，函数只返回变量 <code>x</code>，而与 <code>y</code> 无关，因此无需为 <code>y</code> 指定生命周期。</p><ul><li>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配</li><li>如果返回的引用没有指向任何参数，那么他只能引用函数内创建的值<ul><li>这就是<strong>悬垂引用</strong>，该值在函数结束时就走出了作用域，见下面的例子</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Congratulations&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;fantastic&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    res.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>longest</code> 函数中返回了局部变量 <code>res</code>，当函数执行完毕时，局部变量 <code>res</code> 所指向的内存已经被释放掉，因此 <code>test02</code> 中的 <code>result</code> 变量指向的 <code>res</code> 内存已经被清理，这就造成了<strong>悬垂引用</strong>，非常类似于 <code>C/C++</code> 的野指针。</p><p>那么我就是想返回函数中的局部变量，应该怎么办呢？解决办法也很简单，就是直接返回这个值而不是返回引用，这样就将变量的所有权移交出去了，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt; (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此从根本上讲，生命周期这种语法规则，是用来关联函数的不同参数及返回值之间的生命周期，一旦他们取得了某种联系，rust 就会获得足够的信息来支持保证内存安全的操作，并且阻止那些可能会导致悬垂指针或者其他违反内存安全的行为。</strong></p><h2 id="Struct-定义中的生命周期标注"><a href="#Struct-定义中的生命周期标注" class="headerlink" title="Struct 定义中的生命周期标注"></a>Struct 定义中的生命周期标注</h2><p>struct 里可以包括：</p><ul><li>自持有类型（类似于 i32 等）</li><li>引用：需要在每个引用上添加生命周期标注</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Today is Tuesday. And I will take part in a meeting.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Can&#x27;t find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h2><p>每个引用都有生命周期，需要为使用生命周期的函数或 struct 指定生命周期参数</p><p>但是下面这个例子，没有任何生命周期的标注，仍然可以通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> byte.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照原来的 rust 规范，函数声明、参数和返回类型前都是要加上生命周期标注的，但是 rust 团队发现程序员总是一遍又一遍地标注同样的生命周期，而且这些场景是可以预测的，有着明确的模式，因此 rust 团队就将这些模式写入了编译器，使得借用检查器可以自动对这些模式进行推导而无需显式标注。</p><p><strong>生命周期省略规则</strong></p><ul><li>在 Rust 引用分析中所编入的模式称为<strong>生命周期省略规则</strong><ul><li>这些规则无需开发者来遵守</li><li>它们是一些特殊情况，由编译器来考虑</li><li>如果你的代码符合这些情况，那么就无需显式标注生命周期</li></ul></li><li>生命周期省略规则不会提供完整的推断：<ul><li>如果应用规则后，引用的生命周期仍然模糊不清→编译错误</li><li>解决办法：添加生命周期标注，表明引用间的相互关系</li></ul></li></ul><h3 id="输入、输出生命周期"><a href="#输入、输出生命周期" class="headerlink" title="输入、输出生命周期"></a>输入、输出生命周期</h3><p>生命周期在：</p><ul><li>函数&#x2F;方法的参数中，叫做输入生命周期</li><li>函数&#x2F;方法的返回值中，叫输出生命周期</li></ul><h3 id="生命周期省略的三个规则"><a href="#生命周期省略的三个规则" class="headerlink" title="生命周期省略的三个规则"></a>生命周期省略的三个规则</h3><p>编译器使用三个规则在没有显式标注生命周期的情况下，来确定引用的生命周期</p><ul><li>规则 1 应用于输入生命周期</li><li>规则 2、3 应用于输出生命周期</li><li>如果编译器应用完三个规则后，仍然无法确定有效的生命周期，则报错</li><li>这些规则适用于 fn 和 impl 块</li></ul><p><strong>规则 1：</strong> 每个引用类型都有自己的生命周期<br><strong>规则 2：</strong> 如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数<br><strong>规则 3：</strong> 如果有多个输入生命周期参数，但其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期会被赋给所有的输出生命周期参数</p><p><strong>生命周期省略的三个规则-例子</strong></p><p>假设我们是编译器:</p><p><code>fn first_word(s: &amp;str) -&gt; &amp;str &#123;&#125;</code><br><code>fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str &#123;&#125;</code><br><code>fn first_word&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;&#125;</code></p><p><code>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;&#125;</code><br><code>fn longest&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str &#123;&#125;</code></p><h3 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h3><ul><li>在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样</li><li>在哪声明和使用生命周期参数，依赖于：<ul><li>生命周期参数是否和字段、方法的参数或返回值有关</li></ul></li><li>struct 字段的生命周期名：<ul><li>在 impl 后声明</li><li>在 struct 名后使用</li><li>这些生命周期是 struct 类型的一部分</li></ul></li><li>impl 块内的方法签名中<ul><li>引用必须绑定于 struct 字段引用的生命周期，或者引用是独立的也可以</li><li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">printSome</span>(&amp;<span class="keyword">self</span>, words: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;There are some words: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.part);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><ul><li><code>&#39;static</code> 是一个特殊的生命周期：整个程序的持续时间<ul><li>例如：所有的字符串字面值都拥有 <code>&#39;static</code> 生命周期<ul><li><code>let s: &amp;&#39;static str = &quot;I have a static lifetime.&quot;;</code></li><li>字符串字面值是存在二进制程序中，总是可用</li></ul></li></ul></li><li>为引用指定 <code>&#39;static</code> 之前要三思<ul><li>是否需要引用在整个生命周期内都存活</li></ul></li></ul><h3 id="一个泛型参数类型，Trait-Bound-和生命周期的综合例子"><a href="#一个泛型参数类型，Trait-Bound-和生命周期的综合例子" class="headerlink" title="一个泛型参数类型，Trait Bound 和生命周期的综合例子"></a>一个泛型参数类型，Trait Bound 和生命周期的综合例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an</span> announcement&lt;<span class="symbol">&#x27;a</span>,T&gt;</span><br><span class="line">    (x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> <span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span> (<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意的是，生命周期也是泛型的一种。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust入门教程（七）：生命周期&quot;&gt;&lt;a href=&quot;#Rust入门教程（七）：生命周期&quot; class=&quot;headerlink&quot; title=&quot;Rust入门教程（七）：生命周期&quot;&gt;&lt;/a&gt;Rust入门教程（七）：生命周期&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Rust 生命周期机制是与所有权机制同等重要的资源管理机制。生命周期，简而言之就是引用的有效作用域，之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算，但引用往往导致极其复杂的资源管理问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>l2p cache 优化方案</title>
    <link href="http://cherryyang05.github.io/32e63730.html"/>
    <id>http://cherryyang05.github.io/32e63730.html</id>
    <published>2022-06-09T06:46:03.000Z</published>
    <updated>2023-08-08T12:35:27.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="l2p-cache-优化方案"><a href="#l2p-cache-优化方案" class="headerlink" title="l2p cache 优化方案"></a>l2p cache 优化方案</h2><p>根据已有的 cache 方案，在 SLC 模式下，由于映射表大小不到 400MB，因此将整个映射表存储在 DRAM 中。</p><p>先对这种情况的地址映射进行分析。</p><span id="more"></span><h3 id="1-映射表和全局映射目录"><a href="#1-映射表和全局映射目录" class="headerlink" title="1. 映射表和全局映射目录"></a>1. 映射表和全局映射目录</h3><p>在原先的方案中有两种映射表，一种是存放每一个 page 表项的映射表，每个表项大小为 4B，这个表项用一维数组来存储，数组的下标记录对应表项的逻辑地址。另一种表存放第一种映射表所在 page 的映射，称为 GTD（Global Table Directory，全局表目录），非常类似于二级页表。GTD 表每个表项也是 4B，也用一维数组来表示。数组下标指明逻辑页号的范围，数组元素存放对应的 page 位置。</p><p>根据 page 所设定的大小和项目所采用的硬件参数，一个 page 为 16KB，一个表项为 4B，则一个 page 可以存放 16KB&#x2F;4KB&#x3D;4K 个表项，GTD 的第一个表项指向存放逻辑地址从 0 到 4K-1 的表项所存储的页的物理地址，GTD 第二个表项则指向存放逻辑地址从 4K 到 8K-1 的表项所存储的页的物理地址。。。以此类推，最后大约需要 7 个 page 即可存储所有 GTD。</p><h3 id="2-物理地址的分配"><a href="#2-物理地址的分配" class="headerlink" title="2. 物理地址的分配"></a>2. 物理地址的分配</h3><p>先对每个逻辑页分配可用的物理页，（首先确保该逻辑地址是有效的，不能重复分配逻辑地址）若该逻辑页被写过，则覆盖对应的物理页。</p><p>同时以块为单位，对每个 page 进行管理，用 <code>free</code>, <code>valid</code>, <code>invalid</code> 标记 page 的三种状态</p><h3 id="3-cache-优化方案"><a href="#3-cache-优化方案" class="headerlink" title="3. cache 优化方案"></a>3. cache 优化方案</h3><p>优化思路为：只将一部分最近使用的映射表以及全部 GTD 放进 DRAM，完整的映射表存放在 flash 中。采用 TPFTL 方案，DRAM 中使用两级 LRU 进行管理。基本思路如下：</p><p>缓存中的每个表项根据翻译页进行聚类，即同属于一个翻译页的表项聚合在一个 TP 结点下，TP 结点用一个 LRU 列表进行管理，而每一个 TP 结点下的所有表项也用 LRU 列表进行管理，这样便形成了两级 LRU。</p><p>用来管理 TP 结点的 LRU 列表称为页级 LRU，管理每个 TP 结点下表项的 LRU 列表被称为条目级 LRU。每个 TP 结点的热度由该结点下所有表项的平均热度所计算得出，根据这个热度值来决定该 TP 结点在页级 LRU 列表中的位置。</p><p>进行 LRU 替换时，先找出页级 LRU 中热度最低的 TP 结点，再从该结点中找出热度最低的表项进行替换，尽管其他 TP 结点中可能有比被替换的热度更低的表项。</p><p>另外缓存中还有一个计数器来维护 TP 结点的数量。</p><h4 id="DFTL-优化方案"><a href="#DFTL-优化方案" class="headerlink" title="DFTL 优化方案"></a>DFTL 优化方案</h4><p>实现步骤：</p><ol><li>首先获得要访问的逻辑页号，检查 cache 中是否已经存在该页</li><li>若存在，直接访问对应的物理页号，将该表项标记为最近使用过，转到 10</li><li>若不存在，则进行 4</li><li>若 CMT（cached mapping table，即 DRAM 存储的部分映射表）中表项没满，转到 6</li><li>若 CMT 表项已满，则在 CMT 中使用 LRU 替换算法，找到要替换的表项，转到 7</li><li>根据逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，将其放入 DRAM 的 CMT 中，标记该表项为最近使用过，转到 10</li><li>检查该页是否被修改过</li><li>若修改过则将其写回 flash 同时修改 GTD 表，转到 6</li><li>若没有修改过，删除该表项，转到 6</li><li>完成一次逻辑页到物理页的转换，重复 1</li></ol><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220609221501.png" alt="DFTL流程图"></p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220609181254.png" alt="优化后访问flash的示意图"></p><h4 id="TPFTL-优化方案"><a href="#TPFTL-优化方案" class="headerlink" title="TPFTL 优化方案"></a>TPFTL 优化方案</h4><ol><li>首先获得要访问的逻辑页号，根据页号检查对应的 TP 结点是否被缓存</li><li>若已缓存，检查该结点下的表项，若存在该页，转到 4，若不存在该页，转到 5</li><li>若没有缓存，则缓存不命中，转到 5</li><li>访问对应的物理页号，将该表项标记为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11</li><li>若 LRU 列表没满，转到 7</li><li>若 LRU 列表已满，则先在页级 LRU 列表中选出热度最低的 TP 结点，然后再在 TP 结点下找到热度最低的表项，转到 8</li><li>根据请求的逻辑页号找到对应 GTD 中的对应表项，然后取出对应的映射页，再从映射页中找到对应逻辑页的物理地址，若 DRAM 中没有缓存该 TP 结点，则创建新 TP 结点，若有 TP 结点而没有表项，则创建新表项，标记该表项为最近使用过，更新页级 LRU 和条目级 LRU 列表，转到 11</li><li>检查该页是否被修改过</li><li>若修改过则将其写回 flash 同时修改 GTD 表，转到 7</li><li>若没有修改过，删除该表项，转到 7</li><li>完成一次逻辑页到物理页的转换，重复 1</li></ol><p><strong>流程图如下所示：</strong></p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220615143024.png" alt="TPFTL流程图"></p><h4 id="两级-LRU-算法实现思路"><a href="#两级-LRU-算法实现思路" class="headerlink" title="两级 LRU 算法实现思路"></a>两级 LRU 算法实现思路</h4><p><strong>1. 时间戳</strong></p><p>通过设置一个全局时间戳，在每次替换新表项时，将表项中的流行度字段设置为当前时间戳，每个 TP 结点的平均热度由其下的所有表项的热度的平均值决定。</p><p>但是这样会导致两个严重的问题：</p><ol><li>全局时间戳是一个有范围的整型，系统到一定阶段一定会溢出，这时时间戳就会归零。归零之后表项记录热度所表示的时间戳较小，但是却是最近使用过的；</li><li>当时间戳较大时（快要到整型所表示的范围时），需要计算 TP 结点的平均热度，这时需要将结点下所有表项的热度相加再取平均，在相加求和的过程中，采用一般的直接相加的方法将会导致溢出。</li></ol><p><strong>2. 访问次数</strong></p><p>将每个表项的时间戳字段改成访问次数，即根据访问次数来进行替换，先替换访问次数少的，当访问次数相同时，再根据先后次序进行替换。</p><p>这样仍然会产生两个问题：</p><ol><li>只能体现 “最久” 未使用，而不能体现出 “最近”，若一个刚刚被访问的新的表项，访问次数显然为 1，但是它却是刚来的，显然不能被替换；</li><li>对于两级 LRU，需要计算 TP 结点的平均热度，通过平均访问次数也无法体现出 “最近”，即若一个 TP 结点下频繁发生替换（即命中率不高），那么平均访问次数偏低，但是该 TP 结点却是最近访问的。</li></ol><p><strong>3. 命中或替换一个表项时将该表项计数器清零</strong></p><p>另一种实现思路是命中或替换一个表项时，将该表项的计数器清零，其余的表项加一，TP 结点下所有表项的计数器平均值越低说明该 TP 结点热度越高。</p><p>尽管这样不会出现计数器溢出，但是会导致一个问题：</p><p>若命中 TP1 结点下的某一表项，将该表项清零后只将该 TP1 结点的其他表项计数器加一，这样仍然会导致算法不能体现出 “最近”（即频繁访问的 TP 结点由于很多计数器被加了一从而导致该 TP 结点计数器平均值较高）。</p><p>提出两种解决方案：</p><ol><li>在将命中或替换的表项计数器归零时，遍历所有 TP 结点和 TP 结点下的所有表项，将内存中所有表项的计数器全部加一，但是这样可能会导致极大的时间开销（具体的时间开销占比还不清楚，不知道系统是否能容忍这样的时间开销）；</li><li>在 TP 结点上再增加一个字段，用来记录在下一次命中自己之前，其他 TP 结点中命中或替换的次数，等待下次自己被命中时，再将 TP 结点下所有表项的计数器加上该字段值。</li></ol><p><strong>最终解决方案</strong></p><p>综合考虑后，最终的解决方案在访问次数的基础上进行改进。表项级 LRU 列表以访问的先后顺序进行排序，最新访问的表项插入链表的头部，同时维护一个访问次数字段，TP 结点平均热度就是访问次数的平均值。尽管这样可能会使得最近访问的表项的 TP 结点成为热度最低的结点，但这已经是相对完善且资源消耗较少的方案。每个表项的热度被页面级热度所掩盖，这导致利用时间局部性的效率较低。由于缓存空间利用率的提高，缓存命中率略有提高。</p><h3 id="4-结构体定义"><a href="#4-结构体定义" class="headerlink" title="4. 结构体定义"></a>4. 结构体定义</h3><p>在原来 l2p 模块基础上新增以下结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页级 LRU 列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tp_node_list</span> &#123;</span></span><br><span class="line">    list_node tp_list_node;             <span class="comment">// tp 链表头结点</span></span><br><span class="line">    u32 entry_per_tp_node[MAX_TP_NODE]; <span class="comment">// 存储每个 tp 结点下有多少表项的表，0 表示当前 tp 结点不存在</span></span><br><span class="line">    u32 tp_node_num;                    <span class="comment">// 有效 TP 结点数量</span></span><br><span class="line">    tp_node *lru_tp_node;               <span class="comment">// 热度最低（最近最久未使用）的 TP 结点</span></span><br><span class="line">    u32 total_entry_num;                <span class="comment">// 总表项个数，代表缓存中映射表总容量</span></span><br><span class="line">&#125; tp_node_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">tp_entry_node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* TP 结点数据结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u16 tvpn;                       <span class="comment">// 虚拟翻译页号</span></span><br><span class="line">        u16 entry_num;                  <span class="comment">// 结点下表项数量</span></span><br><span class="line">        u32 ava_popular;                <span class="comment">// 结点平均热度</span></span><br><span class="line">        list_head entry_list;           <span class="comment">// 表项链表头结点</span></span><br><span class="line">        list_node tp_node;              <span class="comment">// tp 链表结点</span></span><br><span class="line">    &#125; tp_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个 TP 结点下的表项结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        list_node entry_node;           <span class="comment">// 表项链表结点</span></span><br><span class="line">        psa_entry entry;                <span class="comment">// psa 结构体，存储 l2p 映射表项</span></span><br><span class="line">        u32 popular;                    <span class="comment">// 表项热度</span></span><br><span class="line">        u32 reserve;                    <span class="comment">// 填充空间，为了结构体和 tp_node 占用空间一样</span></span><br><span class="line">    &#125; entry_node;</span><br><span class="line">&#125; tp_entry_node;</span><br></pre></td></tr></table></figure><p><strong>下面是结构体之间的关系图。</strong></p><p><img src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220621183034.png" alt="结点关系图"></p><h3 id="5-函数定义"><a href="#5-函数定义" class="headerlink" title="5. 函数定义"></a>5. 函数定义</h3><p>在原有 l2p 模块中函数基础上，新增以下函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得最近最久未使用的映射表项。</span></span><br><span class="line"><span class="comment"> * 在表项链表头结点的前一个结点，（即整个链表的最后一个结点）就是最近最久未使用的表项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">entry_node *<span class="title">l2p_get_least_recent_used_entry</span><span class="params">(tp_node *entry_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 DRAM 中有表项变化时，更新所有 TP 结点的流行度，更改 tp_node_list 结点信息。</span></span><br><span class="line"><span class="comment"> * 当进行替换时，表项会进行变化，同样带来 TP 结点的热度变化，调用函数获得热度最低的 TP 结点，更新字段。</span></span><br><span class="line"><span class="comment"> * 该 TP 结点的热度由 tp_node 结构体中 ava_popular 字段指定，该字段由 TP 结点下所有表项的热度之和除以表项数量得出（取整即可）。</span></span><br><span class="line"><span class="comment"> * 循环以 tp_node_list 为头结点的链表，选出热度最低的 TP 结点。（算法待定，暂时用循环解决）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_update_tp_node_list</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前的逻辑子页号所属的 TP 结点是否被缓存 */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_is_TP_node_cached</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查 tp_node_list 结点下的 total_entry_num 字段，判断当前所给内存是否已满 */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_is_DRAM_empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据物理地址从闪存中读取相应表项放到内存中 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_read_entry_from_flash</span><span class="params">(psa_entry *psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将被修改的表项写回闪存。</span></span><br><span class="line"><span class="comment"> * 有一个小问题：表项在内存中需要有热度字段，在闪存中则无需该字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">boolean <span class="title">l2p_write_the_modified_entry_back_to_flash</span><span class="params">(l2p_table_entry *l2p_entry)</span></span>;</span><br></pre></td></tr></table></figure><p>原来模块中的函数定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前 l2p 表项无效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_invalid_l2p_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前 l2p 表项有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_valid_l2p_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断当前标状态是否有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_if_l2p_entry_valid</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断两个 psa 表项所表示的 psa 是否相等 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_if_psa_equal</span><span class="params">(psa_entry *a, psa_entry *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* psa + 1 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> boolean <span class="title">l2p_inc_psa</span><span class="params">(psa_entry *psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 block 结构体的 page 状态字段中得到子页的状态 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> BIT <span class="title">l2p_get_subpage_status</span><span class="params">(<span class="type">bitmap_t</span> T, psa_entry psa)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置子页的状态 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">l2p_set_subpage_status</span><span class="params">(<span class="type">bitmap_t</span> T, psa_entry *psa, BIT bit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 block table，为其分配内存 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_block_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给 l2p_table 指针分配地址，初始化 l2p_table */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_l2p_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 global_table 指针，分配地址，初始化 global_table*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_init_global_table</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号（lsn）查找相应的 l2p 表项 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> boolean <span class="title">l2p_search_l2p_entry</span><span class="params">(l2p_table_index lsn, l2p_table_entry *l2p_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改逻辑子页号 lsn 对应的 l2p 表项，并设置该表项为有效 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">l2p_update_l2p_table</span><span class="params">(l2p_table_index lsn, l2p_table_entry l2p_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ？ */</span></span><br><span class="line"><span class="function"><span class="type">static</span> psa_entry <span class="title">l2p_get_new_psa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> psa_entry <span class="title">l2p_get_and_update_global_psa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 L2P 模块，为 global_psa 分配内存*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">l2p_init_l2p_module</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号 lsn 获得一个 l2p entry，此函数是提供给别的模块的 API*/</span></span><br><span class="line"><span class="function">l2p_table_entry <span class="title">l2p_get_l2p_entry</span><span class="params">(l2p_table_index lsn, u32 opcode, u32 is_searched)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据逻辑子页号 lsn 获得对应表项的翻译页所在的全局翻译目录（GTD） 的表项 */</span></span><br><span class="line"><span class="function">global_table_entry <span class="title">l2p_get_global_table_entry</span><span class="params">(l2p_table_index lsn)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-全局变量"><a href="#6-全局变量" class="headerlink" title="6. 全局变量"></a>6. 全局变量</h3><p>在原有 l2p 模块中全局变量的基础上，新增以下全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp_node_list *tp_list;        <span class="comment">// 管理所有 tp 结点的链表头结点</span></span><br></pre></td></tr></table></figure><p>原有的全局变量如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">psa_entry global_psa;         <span class="comment">// 记录下一个待分配地址</span></span><br><span class="line"></span><br><span class="line">block_entry *block_table;     <span class="comment">// 用来记录每个 block，指向一个一维数组的指针</span></span><br><span class="line"></span><br><span class="line">global_table_entry *g_table;  <span class="comment">// 用来记录 global_table，指向一个一维数组的首地址</span></span><br><span class="line"></span><br><span class="line">l2p_table_entry *l2p_table;   <span class="comment">// 用来记录 l2p_table，指向一个一维数组的首地址</span></span><br></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul><li><input checked disabled type="checkbox"> psa 地址更新的优先级为什么是 <code>subpage-&gt;plane-&gt;ch-&gt;ce-&gt;lun-&gt;block-&gt;page</code>?</li><li><input checked disabled type="checkbox"> 代码中有两处疑问：<ul><li><input checked disabled type="checkbox"> <code>l2p.h</code> Line: 42（lun: 1？）</li><li><input checked disabled type="checkbox"> <code>l2p.h</code> Line: 48（slc_ppa？）</li></ul></li><li><input checked disabled type="checkbox"> 为什么要记录下一个即将分配的 subpage 物理地址，记录当前的是否能够起到同样的逻辑？</li><li><input checked disabled type="checkbox"> <code>u8 free[PAGE_PER_BLOCK / 8 + 1][PAGE_SIZE / SUB_PAGE_SZ];</code> 除以 8 是什么意思？（<code>l2p.h</code> Line: 75）</li></ul><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul><li>psa：physical subpage address，物理子页地址</li><li>GTD：global table directory，全局表目录</li><li>CMT：cached mapping table，缓存的映射表，存放在 DRAM 中</li><li>TP：translation page</li></ul><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li><p><input disabled type="checkbox"> 是否要进行指令缓存，有竞争情况，是否加锁</p></li><li><p><input checked disabled type="checkbox"> DFTL 要改成 TPFTL</p></li><li><p><input disabled type="checkbox"> 更新页级 LRU 和条目级 LRU 列表算法</p></li><li><p><input checked disabled type="checkbox"> 192MB DRAM</p></li><li><p><input checked disabled type="checkbox"> 给定 TP 结点数量？TP 结点和 entry 结点总和为 8M 个</p></li><li><p><input disabled type="checkbox"> 读写 flash 步骤：先 FCL_get_free_SQ_entry(u32 ch)，返回得到 SQ index，ch 是约定的 flash 中 l2p 表地址的 channel，然后 FCL_set_SQ_entry，最后 FCL_send_SQ_entry</p></li><li><p><input checked disabled type="checkbox"> 申请一个空的 SQ_entry 之后，如何将参数写入 SQ_entry？</p></li><li><p><input checked disabled type="checkbox"> <code>void FCL_set_SQ_entry(u32 hcmd_entry_index, u32 SQ_entry_index, u32 buffer_index, u32 opcode, phy_page_addr *ppa, u32 cmd_sp)</code> 里的参数含义，怎么使用？（hcmd_entry_index、cmd_sp 为 0 即可，buffer_index 是内存中你要读写的地址，phy_page_addr 是你要写入的 flash 的地址，全部自己指定）</p></li><li><p><input checked disabled type="checkbox"> 若读取 flash 中的数据，send SQ_entry 之后，通过哪些接口取得该数据？</p></li><li><p><input checked disabled type="checkbox"> block_entry *block_table;用来记录 block 中 page 的状态，指向一个 4 维数组的首地址，访问数组元素的形式可为 <code>block_table[ch][ce][lun][plane]</code>（应该是 <code>block_table[ch][ce][lun][plane][block]</code>？）</p></li><li><p><input checked disabled type="checkbox"> 重新定义了结构体，TP 结点和 entry 结点数量总和为 8M，每个 tp 结点或 entry 结点结构体大小为 20B，总大小约为 160MB，可映射约 8MB * 4KB &#x3D; 32GB 的闪存空间。加上结点的状态位 8MB，一共占用空间约为 168MB</p></li><li><p><input checked disabled type="checkbox"> <code>block_table</code> 记录的是闪存块中每个页的状态，该数据从何处读取</p></li><li><p><input checked disabled type="checkbox"> <code>g_table</code> 和 <code>l2p</code> 表在闪存中有固定的位置，该位置由谁指定？</p></li><li><p><input checked disabled type="checkbox"> LRU 实现策略</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;l2p-cache-优化方案&quot;&gt;&lt;a href=&quot;#l2p-cache-优化方案&quot; class=&quot;headerlink&quot; title=&quot;l2p cache 优化方案&quot;&gt;&lt;/a&gt;l2p cache 优化方案&lt;/h2&gt;&lt;p&gt;根据已有的 cache 方案，在 SLC 模式下，由于映射表大小不到 400MB，因此将整个映射表存储在 DRAM 中。&lt;/p&gt;
&lt;p&gt;先对这种情况的地址映射进行分析。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenSSD" scheme="http://cherryyang05.github.io/categories/OpenSSD/"/>
    
    <category term="文档" scheme="http://cherryyang05.github.io/categories/OpenSSD/%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="文档" scheme="http://cherryyang05.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（六）：泛型和特性</title>
    <link href="http://cherryyang05.github.io/fb8de022.html"/>
    <id>http://cherryyang05.github.io/fb8de022.html</id>
    <published>2022-06-01T04:08:18.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust入门教程（六）：泛型和特性"><a href="#Rust入门教程（六）：泛型和特性" class="headerlink" title="Rust入门教程（六）：泛型和特性"></a>Rust入门教程（六）：泛型和特性</h1><blockquote><p>泛型是一个编程语言不可或缺的机制。<br>C++ 语言中用”模板”来实现泛型，而 C 语言中没有泛型的机制，这也导致 C 语言难以构建类型复杂的工程。<br>泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。</p></blockquote><span id="more"></span><p>[toc]</p><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h2><h3 id="1-1-泛型介绍"><a href="#1-1-泛型介绍" class="headerlink" title="1.1 泛型介绍"></a>1.1 泛型介绍</h3><ul><li>泛型可以提高代码复用能力，也就是处理重复代码的问题</li><li>泛型是具体类型或其它属性的抽象代替:<ul><li>你编写的代码不是最终的代码，而是一种模板，里面有一些“占位符”</li><li>编译器在编译时将<strong>占位符</strong>替换为具体的类型</li><li>例如：<code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt;T &#123;...&#125;</code></li></ul></li><li>类型参数<ul><li>很短，通常一个字母</li><li>CamelCase</li><li>T: type 的缩写</li></ul></li></ul><h3 id="1-2-在函数定义中使用泛型"><a href="#1-2-在函数定义中使用泛型" class="headerlink" title="1.2 在函数定义中使用泛型"></a>1.2 在函数定义中使用泛型</h3><p>泛型函数</p><ul><li>参数类型</li><li>返回类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">80</span>, <span class="number">2022</span>, <span class="number">36</span>, <span class="number">47</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">largest</span> = <span class="title function_ invoke__">largest</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest ele is &#123;&#125;&quot;</span>, largest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是求一个集合中最大的元素，我们定义的集合是一个 <code>i32</code> 类型，但是这时如果我们要传入 <code>f32</code> 或者字符型，还用同样的逻辑判断函数的话，是会报错的，这时我们就需要用到泛型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们声明了一个泛型 <code>T</code>，但是这样是会编译报错的，因为不是所有类型 T 都可以进行大小比较，只有实现了下面的 <code>std::cmp::PartialOrd</code> 的 trait 才能进行大小比较，所以要对 T 进行约束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/pattern git:(master) ✗ cargo run</span><br><span class="line">   Compiling pattern v0.<span class="number">1.0</span> (/home/cherry/Code/rust/pattern)</span><br><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to <span class="keyword">type</span> `T`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">17</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> |         <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">   |            ---- ^ ------- T</span><br><span class="line">   |            |</span><br><span class="line">   |            T</span><br><span class="line">   |</span><br><span class="line">help: consider restricting <span class="keyword">type</span> <span class="title class_">parameter</span> `T`</span><br><span class="line">   |</span><br><span class="line"><span class="number">7</span>  | <span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: std::cmp::<span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">   |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `pattern` due to previous error</span><br></pre></td></tr></table></figure><p>但是把 <code>std::cmp::PartialOrd</code> 这个 trait 加上又会报其他错误，这里在后面会进行介绍。</p><h3 id="1-3-结构体中的泛型"><a href="#1-3-结构体中的泛型" class="headerlink" title="1.3 结构体中的泛型"></a>1.3 结构体中的泛型</h3><p>可以使用多个泛型的类型参数，但是也不要有太多的类型，否则代码可读性将会下降。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point&#123;x: <span class="number">2022</span>, y: <span class="number">6.1</span>&#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-Enum定义中的泛型"><a href="#1-4-Enum定义中的泛型" class="headerlink" title="1.4 Enum定义中的泛型"></a>1.4 Enum定义中的泛型</h3><p>可以让枚举的变体持有泛型数据类型，例如：Option<T>, Result&lt;T, E&gt;</T></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-方法定义中使用泛型"><a href="#1-5-方法定义中使用泛型" class="headerlink" title="1.5 方法定义中使用泛型"></a>1.5 方法定义中使用泛型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point&#123;x: <span class="number">2022</span>, y: <span class="number">61</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, integer.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>把 T 放在 impl 关键字后，表示在类型 T 上实现方法<ul><li>例如：<code>impl&lt;T&gt; Point&lt;T&gt;</code></li></ul></li><li>只针对具体类型实现方法（其余类型没实现方法）<ul><li>例如: <code>impl Point&lt;f32&gt;</code></li></ul></li><li>struct 中的泛型参数可以和方法的泛型参数不同</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V,W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point&#123;x: <span class="number">61</span>, y: <span class="number">85</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point&#123;x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&quot;Rust&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现的结构体方法实际上是将第一个 Point 中的 x 和第二个 Point 的 y 结合起来形成一个新的 Point。</p><h3 id="1-6-泛型代码的性能"><a href="#1-6-泛型代码的性能" class="headerlink" title="1.6 泛型代码的性能"></a>1.6 泛型代码的性能</h3><p>使用泛型的代码和使用具体类型的代码运行速度是一样的</p><ul><li>单态化（monomorphization）<ul><li>在编译时将泛型替换为具体类型的过程</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ingeter</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f32</span>),</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2. trait"></a>2. trait</h2><ul><li>Trait 告诉 Rust 编译器<ul><li>某种类型具有哪些并且可以与其它类型共享的功能</li></ul></li><li>Trait：抽象的定义共享行为</li><li>Trait bounds（约束）：泛型类型参数指定为实现了特定行为的类型</li><li>Trait与其它语言的接口（interface）类似，但有些区别</li></ul><h3 id="2-1-定义一个-Trait"><a href="#2-1-定义一个-Trait" class="headerlink" title="2.1 定义一个 Trait"></a>2.1 定义一个 Trait</h3><p>Trait的定义：把方法签名放在一起，来定义实现某种目的所必需的一组行为。</p><ul><li>关键字：trait</li><li>只有方法签名，没有具体实现</li><li>trait 可以有多个方法：每个方法签名占一行，以 <code>;</code> 结尾</li><li>实现该 trait 的类型必须提供具体的方法实现</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-在类型上实现-trait"><a href="#2-2-在类型上实现-trait" class="headerlink" title="2.2 在类型上实现 trait"></a>2.2 在类型上实现 trait</h3><ul><li>在类型上实现 trait。与为类型实现方法类似</li><li>不同之处：<code>impl Xxxx for Tweet &#123;...&#125;</code></li><li>在 impl 的块里，需要对 Trait 里的方法签名进行具体的实现</li></ul><p>文件 <code>lib.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件 <code>main.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> trait_demo::Summary;</span><br><span class="line"><span class="keyword">use</span> trait_demo::Tweet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry_ICT&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;People in Shanghai are free today...&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Get 1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的功能很简单，不做具体解释了。</p><h3 id="2-3-实现-trait-的约束"><a href="#2-3-实现-trait-的约束" class="headerlink" title="2.3 实现 trait 的约束"></a>2.3 实现 trait 的约束</h3><ul><li>可以在某个类型上实现某个 trait 的前提条件是<ul><li>这个类型或这个 trait 是在本地 crate 里定义的</li></ul></li><li>无法为外部类型来实现外部的trait<ul><li>这个限制是程序属性的一部分（也就是一致性）</li><li>更具体地说是<strong>孤儿规则</strong>：之所以这样命名是因为父类型不存在</li><li>此规则确保其他人的代码不能破坏您的代码，反之亦然</li><li>如果没有这个规则，两个 crate 可以为同一类型实现同一个 trait，Rust 就不知道应该使用哪个实现了</li></ul></li></ul><p><strong>默认实现</strong></p><p>默认实现的方法可以调用 trait 中的其他方法，即使这些方法没有默认实现，但是注意，无法从方法的重写实现中调用默认实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125; ...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 trait 中可以有方法的默认实现，在默认实现的基础上，类型可以对该 trait 进行重载。同样，在 trait 中默认实现的方法可以实现 trait 中其他方法。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>刚刚 trait 例子的完整代码如下：</p><p><code>lib.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125; ...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.rs</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> trait_demo::Summary;</span><br><span class="line"><span class="keyword">use</span> trait_demo::Tweet;</span><br><span class="line"><span class="keyword">use</span> trait_demo::NewsArticle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry_ICT&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;People in Shanghai are free today...&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Get 1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news</span> = NewsArticle &#123;</span><br><span class="line">        headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;WWDC will be held in June 7th&quot;</span>),</span><br><span class="line">        location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;USA&quot;</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Tim Cook&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Apple will take us a lot of devices.&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You receive a news: &#123;&#125;&quot;</span>, news.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/trait_demo git:(master) ✗ cargo run</span><br><span class="line">   Compiling trait_demo v0.<span class="number">1.0</span> (/home/cherry/Code/rust/trait_demo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/trait_demo`</span><br><span class="line">Get <span class="number">1</span> new tweet: Cherry_ICT: People <span class="keyword">in</span> Shanghai are free today...</span><br><span class="line">You receive a news: WWDC will be held <span class="keyword">in</span> June <span class="number">7</span>th, by Tim <span class="title function_ invoke__">Cook</span> (USA)</span><br></pre></td></tr></table></figure><h3 id="2-4-实现-Trait-作为参数"><a href="#2-4-实现-Trait-作为参数" class="headerlink" title="2.4 实现 Trait 作为参数"></a>2.4 实现 Trait 作为参数</h3><ul><li>impl Trait 语法：适用于简单情况</li><li>Trait bound 语法：可用于复杂情况<ul><li>impl trait 语法实际上是 trait bound 语法的语法糖</li></ul></li><li>使用 <code>+</code> 指定多个 trait bound</li><li>Trait bound 使用 where 子句<ul><li>在方法签名后指定 where 子句</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是采用 impl Trait 的语法，这里的 notify 方法要求传入的参数可以是 <code>NewsArticle</code> 类型或者是 <code>Tweet</code> 类型，也就是要求参数要实现 <code>Summary</code> 这个 trait，从而使用 summarize 这个方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是采用 Trait bound 的写法，下面这个例子讲展示出这种写法的优势：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有多个参数时，采用这种写法可以使得代码相对简洁一些。</p><p>使用 <code>+</code> 指定多个 trait bound：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而如果一个函数中参数过多，那么整个函数声明就会变得非常长，不太直观，可读性差，这里可以使用 where 子句来指定 trait 的约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify2</span>&lt;T: Summary + Display, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中函数签名太长，不够直观，采用 where 子句可以使得更加直观：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify3</span>&lt;T, U&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-实现-Trait-作为返回类型"><a href="#2-5-实现-Trait-作为返回类型" class="headerlink" title="2.5 实现 Trait 作为返回类型"></a>2.5 实现 Trait 作为返回类型</h3><ul><li>impl trait 语法<ul><li>注意：impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify4</span>(flag: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        NewsArticle &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;...&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话这个函数便没有了确定的返回类型，这样便会报错。</p><h3 id="2-6-使用-trait-bound-实现之前泛型-的例子"><a href="#2-6-使用-trait-bound-实现之前泛型-的例子" class="headerlink" title="2.6 使用 trait bound 实现之前泛型 的例子"></a>2.6 使用 trait bound 实现之前泛型 的例子</h3><p>我们再来看一下<a href="#12-%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">之前的代码</a>。解决如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们说过，实际上比较大小的运算符是实现了 <code>std::cmp::PartialOrd</code> 这样一个 trait，因此我们需要指定实现这个 trait 的泛型才能进行大小比较。</p><p>但是这样改完后又会出现一个问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/pattern git:(master) ✗ cargo run </span><br><span class="line">   Compiling pattern v0.<span class="number">1.0</span> (/home/cherry/Code/rust/pattern)</span><br><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[T]`, a non-copy slice</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">19</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">10</span> | <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">   |                   ^^^^^^^</span><br><span class="line">   |                   |</span><br><span class="line">   |                   cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |                   <span class="keyword">move</span> occurs because `list[_]` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |                   help: consider borrowing here: `&amp;list[<span class="number">0</span>]`</span><br><span class="line"></span><br><span class="line">error[E0507]: cannot <span class="keyword">move</span> out of a shared reference</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">11</span>:<span class="number">18</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> |     <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">   |         -----    ^^^^</span><br><span class="line">   |         ||</span><br><span class="line">   |         |data moved here</span><br><span class="line">   |         |<span class="keyword">move</span> occurs because `item` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |         help: consider removing the `&amp;`: `item`</span><br><span class="line"></span><br><span class="line"><span class="literal">Some</span> errors have detailed explanations: E0507, E0508.</span><br><span class="line">For more information about an error, <span class="keyword">try</span> `rustc --explain E0507`.</span><br><span class="line">error: could not compile `pattern` due to <span class="number">2</span> previous errors</span><br></pre></td></tr></table></figure><p>报错原因是：无法从 list 中移除 T，因为没有实现 Copy trait，建议采用借用</p><p>因为上面两个 vector 中的元素分别为整型和字符型，这两种类型有确定的大小并且都是存储在栈中，因此都实现了 Copy trait，于是在 T 的 trait 约束中再加上 Copy 即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果将 vec 中元素类型改为 String，那么又会报错，因为 String 是存储在堆中，没有实现 Copy trait，但是实现了 Clone trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">largest</span> = <span class="title function_ invoke__">get_max_ele</span>(&amp;str_list);</span><br></pre></td></tr></table></figure><p>我们将 T 加上 Clone 约束，去掉 Copy 约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样又会出现错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0508]: cannot <span class="keyword">move</span> out of <span class="keyword">type</span> `[T]`, a non-copy slice</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |     <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">   |                       ^^^^^^^</span><br><span class="line">   |                       |</span><br><span class="line">   |                       cannot <span class="keyword">move</span> out of here</span><br><span class="line">   |                       <span class="keyword">move</span> occurs because `list[_]` has <span class="keyword">type</span> `T`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   |                       help: consider borrowing here: `&amp;list[<span class="number">0</span>]`</span><br></pre></td></tr></table></figure><p>是因为这里 list[0] 是字符串切片，是一个借用，没有所有权，因此一个借用给一个变量赋值，这个借用对应的类型必须要实现 Copy trait。因此在 list 前面加上引用，并且将 item 也设为引用，最后返回 &amp;T。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要最后还是返回 T，则可以使用 clone 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_max_ele</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-使用-Trait-Bound-有条件的实现方法"><a href="#2-7-使用-Trait-Bound-有条件的实现方法" class="headerlink" title="2.7 使用 Trait Bound 有条件的实现方法"></a>2.7 使用 Trait Bound 有条件的实现方法</h3><p>在使用泛型类型参数的 impl 块上使用 Trait bound，我们可以有条件的为实现了特定 Trait 的类型来实现方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmd_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以为实现了其它 Trait 的任意类型有条件的实现某个 Trait</li><li>为满足 Trait Bound 的所有类型上实现 Trait 叫做覆盖实现 （blanket implementations）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: fmt::Display&gt; Tostring <span class="keyword">for</span> <span class="title class_">T</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>含义为：为实现了 Display trait 的类型实现 ToString trait，而 ToString 中实现了 to_string 方法。</p><p>例如 <code>let s = 3.to_string();</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust入门教程（六）：泛型和特性&quot;&gt;&lt;a href=&quot;#Rust入门教程（六）：泛型和特性&quot; class=&quot;headerlink&quot; title=&quot;Rust入门教程（六）：泛型和特性&quot;&gt;&lt;/a&gt;Rust入门教程（六）：泛型和特性&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;泛型是一个编程语言不可或缺的机制。&lt;br&gt;C++ 语言中用”模板”来实现泛型，而 C 语言中没有泛型的机制，这也导致 C 语言难以构建类型复杂的工程。&lt;br&gt;泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C语言代码规范</title>
    <link href="http://cherryyang05.github.io/d5e60d4a.html"/>
    <id>http://cherryyang05.github.io/d5e60d4a.html</id>
    <published>2022-05-30T04:57:42.000Z</published>
    <updated>2023-08-08T12:35:27.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-语言代码规范"><a href="#C-语言代码规范" class="headerlink" title="C 语言代码规范"></a>C 语言代码规范</h2><span id="more"></span><h3 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h3><p><strong>1. 变量命名</strong></p><p>小驼峰式：<code>firstName</code>，<code>hexToBinary</code><br>下划线式：<code>first_name</code>，<code>hex_to_binary</code><br>不要使用非常见单词的缩写，类似 FTL 这种可以缩写，但是 hexToBinary 不要写成 htb</p><p><strong>2. 常量命名</strong></p><p>全部大写，单词之间用下划线分隔，<code>OUT_OF_BOUND_EXCEPTION_CODE</code>，也不要使用缩写</p><p><strong>3. 函数及结构体命名</strong></p><p>下划线式？小驼峰式？</p><p>小驼峰式：<code>firstName</code>，<code>hexToBinary</code><br>下划线式：<code>first_name</code>，<code>hex_to_binary</code></p><h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><h4 id="1-文件开头注释"><a href="#1-文件开头注释" class="headerlink" title="1. 文件开头注释"></a>1. 文件开头注释</h4><p>类似这样的注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Date: *** </span></span><br><span class="line"><span class="comment"> * Author: *** </span></span><br><span class="line"><span class="comment"> * Version: ***</span></span><br><span class="line"><span class="comment"> * Description: ***</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="2-变量声明注释"><a href="#2-变量声明注释" class="headerlink" title="2. 变量声明注释"></a>2. 变量声明注释</h4><p>和变量声明同一行，用 <code>//</code> 注释，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cacheCapacity = <span class="number">1024</span>;   <span class="comment">// cache 容量</span></span><br><span class="line"><span class="type">bool</span> isEndState = <span class="literal">false</span>;    <span class="comment">// 是否到了终止状态</span></span><br></pre></td></tr></table></figure><p>注释尽量用 tab 全对齐</p><h4 id="3-函数功能注释"><a href="#3-函数功能注释" class="headerlink" title="3. 函数功能注释"></a>3. 函数功能注释</h4><p>函数体前对函数进行注释，注明函数功能，参数类型及含义，返回值类型及含义，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数功能描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param parm1 该参数的含义</span></span><br><span class="line"><span class="comment"> * @return 若有返回值，则注明返回值含义或其他说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> parm1)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-代码块注释"><a href="#4-代码块注释" class="headerlink" title="4. 代码块注释"></a>4. 代码块注释</h4><p>在函数内对某一个代码块进行注释，使用 <code>/*</code> 注释，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代码块功能说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (statement) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当循环或条件判断嵌套过多时，在代码块的结束部分加上注释标记，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; MAX_INDEX) &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125; <span class="comment">// 结束 while (index &lt; MAX_INDEX)</span></span><br><span class="line">&#125; <span class="comment">// 结束if (...)</span></span><br></pre></td></tr></table></figure><h3 id="三、排版"><a href="#三、排版" class="headerlink" title="三、排版"></a>三、排版</h3><h4 id="1-空格和换行"><a href="#1-空格和换行" class="headerlink" title="1. 空格和换行"></a>1. 空格和换行</h4><p>if, while 等和后面的括号之间要有一个空格，当有多个参数时，逗号后面也要有一个空格。<br>所有的二元运算符，除了”.”，应该使用空格将之与操作数分开，一元操作符和操作数之间不要加空格。<br>注释和注释标记之间需要一个空格，空行中不要有空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; LinkList;             <span class="comment">// 注意这里 &#125; 后面有一个空格 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;         <span class="comment">// 注意 if 与 &#x27;(&#x27; 之间有一个空格，元素 &#x27;1&#x27; 和 num 与操作符 &#x27;==&#x27; 之间有一个空格</span></span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释与双斜杠中间需要一个空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这种类型的注释与 &#x27;/*&#x27; 中间也需要一个空格 */</span></span><br></pre></td></tr></table></figure><p>另外，函数体内逻辑相关的功能的某些代码中间可以加上空行进行区分，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> hex[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> bin[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    hex = getHex();</span><br><span class="line">    hexToBinary(hex, bin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码太长时需要换行，尽量在运算符前换行，并且缩进是八个空格（两个 tab），比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((condition1 &amp;&amp; condition2) </span><br><span class="line">        || (condition3 &amp;&amp; condition4) </span><br><span class="line">        || !(condition5 &amp;&amp; condition6)) &#123; </span><br><span class="line">    doSomethingAboutIt(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-花括号形式"><a href="#2-花括号形式" class="headerlink" title="2. 花括号形式"></a>2. 花括号形式</h4><p>花括号在函数名在同一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不在同一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><ol><li>尽量不使用全局变量，尽量将变量作用域限定到最小，例如局部变量或者静态全局变量，重要全局变量尽量使用 getter 及 setter 调用。局部变量最好要初始化。</li><li>将指针释放后要将指针置空，否则可能会导致野指针，例如</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;C-语言代码规范&quot;&gt;&lt;a href=&quot;#C-语言代码规范&quot; class=&quot;headerlink&quot; title=&quot;C 语言代码规范&quot;&gt;&lt;/a&gt;C 语言代码规范&lt;/h2&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C/C++" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
    <category term="代码规范" scheme="http://cherryyang05.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（五）：错误处理</title>
    <link href="http://cherryyang05.github.io/1bd17c37.html"/>
    <id>http://cherryyang05.github.io/1bd17c37.html</id>
    <published>2022-05-20T09:10:27.000Z</published>
    <updated>2023-08-08T12:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust入门教程（五）：错误处理"><a href="#Rust入门教程（五）：错误处理" class="headerlink" title="Rust入门教程（五）：错误处理"></a>Rust入门教程（五）：错误处理</h1><span id="more"></span><h2 id="一、panic"><a href="#一、panic" class="headerlink" title="一、panic!"></a>一、panic!</h2><h3 id="1-1-Rust-错误处理概述"><a href="#1-1-Rust-错误处理概述" class="headerlink" title="1.1 Rust 错误处理概述"></a>1.1 Rust 错误处理概述</h3><ul><li>Rust 的可靠性：错误处理<ul><li>大部分情况下：在编译时提示错误，并处理</li></ul></li><li>错误的分类<ul><li>可恢复<ul><li>例如文件未找到，可再次尝试</li></ul></li><li>不可恢复<ul><li>bug，例如访问的索引超出范围</li></ul></li></ul></li><li>Rust 没有类似异常的机制<ul><li>可恢复错误：<code>Result&lt;T, E&gt;</code></li><li>不可恢复：panic! 宏</li></ul></li></ul><h3 id="1-2-不可恢复的错误与-panic"><a href="#1-2-不可恢复的错误与-panic" class="headerlink" title="1.2 不可恢复的错误与 panic!"></a>1.2 不可恢复的错误与 panic!</h3><ul><li>当 panic! 宏执行<ul><li>你的程序会打印一个错误信息</li><li>展开（unwind）、清理调用栈（Stack）</li><li>退出程序</li></ul></li></ul><p><strong>为应对 panic，展开或中止（abort）调用栈</strong></p><ul><li>默认情况下，当 panic 发生<ul><li>程序展开调用栈（工作量大）<ul><li>Rust 沿着调用栈往回走</li><li>清理每个遇到的函数中的数据</li></ul></li><li>或立即中止调用栈<ul><li>不进行清理，直接停止程序</li><li>内存需要 OS 进行清理</li></ul></li></ul></li><li>想让二进制文件更小，把设置从“展开”改为“中止”<ul><li>在 Cargo.toml 中适当的 profile 部分设置:</li><li><code>panic = &#39;abort&#39;</code></li></ul></li></ul><p><strong>使用 panic! 产生的回溯信息</strong></p><ul><li>panic!可能出现在<ul><li>我们写的代码中</li><li>我们所依赖的代码中</li></ul></li><li>可通过调用 panic! 的函数的回溯信息来定位引起问题的代码</li><li>通过设置环境变量 <code>RUST_BACKTRACE</code> 可得到回溯信息<ul><li>Windows 下：<code>set RUST_BACKTRACE=1 &amp;&amp; cargo run</code></li><li>Unix 系下：<code>RUST_BACKTRACE=1 cargo run</code></li></ul></li><li>为了获取带有调试信息的回溯，必须启用调试符号（不带 <code>--release</code>）</li></ul><h2 id="二、Result-和可恢复的错误"><a href="#二、Result-和可恢复的错误" class="headerlink" title="二、Result 和可恢复的错误"></a>二、Result 和可恢复的错误</h2><h3 id="2-1-Result-枚举"><a href="#2-1-Result-枚举" class="headerlink" title="2.1 Result 枚举"></a>2.1 Result 枚举</h3><p>Result 枚举类型的定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T：操作成功情况下 Ok 变体里返回的数据的类型<br>E：操作失败情况下 Err 变体里返回的错误的类型</p><p>处理 Result 的一种方式：match 表达式。和 Option 枚举一样，Result 及其变体也是由 prelude 带入作用域，例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们鼠标悬停在 file 变量上，可以看到它的类型是：<code>std::result::Result&lt;std::fs::File, std::io::Error&gt;</code>，说明 open 函数返回的是一个 Result 枚举，且其第一个参数就是该文件，第二个参数是 io 下的 Error 类型，包含了错误的具体信息。</p><p>最终输出结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/panic git:(master) ✗ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (/home/cherry/Code/rust/panic)</span><br><span class="line">warning: unused variable: `f`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">17</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |     <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">   |         ^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_f`</span><br><span class="line"></span><br><span class="line">warning: `panic` (bin <span class="string">&quot;panic&quot;</span>) generated <span class="number">2</span> warnings</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.46</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;Open</span> File Error: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">20</span>:<span class="number">13</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p><strong>匹配不同的错误</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>()&#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Creating File Error: &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, other_error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Err 中也会有很多种类型的错误，我们尝试匹配不同的错误类型，例如 <code>NotFound</code>。</p><p>这里使用了很多 match，尽管很有用，但是比较原始。我们可以使用 <strong>闭包（closure）</strong> ，Result&lt;T, E&gt; 有很多方法，他们使用闭包作为参数，使用 match 进行实现，使用这些方法会使得代码更简洁</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;foo&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Creating File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体内容到后面再讲。</p><h3 id="2-2-unwrap-与-expect"><a href="#2-2-unwrap-与-expect" class="headerlink" title="2.2 unwrap 与 expect"></a>2.2 unwrap 与 expect</h3><p><strong>unwrap</strong></p><p>unwrap 是 match 表达式的一个快捷方法，如果 Result 结果是 Ok 则返回 Ok 里面的值，如果 Result 结果是 Err 则调用 panic!宏。以刚刚这段代码举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> file &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Open File Error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unwrap 的作用类似于上面这段代码，当成功打开文件时，unwrap 就会返回 Ok 里面的值，否则就会调用 Err 代码块的代码，上面那段代码用 unwrap 就可以这样写：<code>let f = File::open(&quot;foo.txt&quot;).unwrap();</code></p><p>但是发生恐慌的信息不可以自定义，这也是 unwrap 的一个缺点，而 Rust 提供了另一个方法：expect。</p><p><strong>expect</strong></p><p>和 unwrap 类似，但是可以指定错误信息：<code>let f = File::open(&quot;foo&quot;).expect(&quot;Open File Error!!!&quot;);</code>，这样得到的报错信息如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/Code/rust/panic git:(master) ✗ cargo run</span><br><span class="line">   Compiling panic v0.<span class="number">1.0</span> (/home/cherry/Code/rust/panic)</span><br><span class="line">warning: unused variable: `f`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">26</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">26</span> |     <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Open File Error!!!&quot;</span>);</span><br><span class="line">   |         ^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_f`</span><br><span class="line"></span><br><span class="line">warning: `panic` (bin <span class="string">&quot;panic&quot;</span>) generated <span class="number">1</span> warnings</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.22</span>s</span><br><span class="line">     Running `target/debug/panic`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;Open</span> File Error!!!: Os &#123; code: <span class="number">2</span>, kind: NotFound, message: <span class="string">&quot;No such file or directory&quot;</span> &#125;&#x27;, src/main.rs:<span class="number">26</span>:<span class="number">31</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><h3 id="2-3-传播错误"><a href="#2-3-传播错误" class="headerlink" title="2.3 传播错误"></a>2.3 传播错误</h3><p>当写的函数中包含可能会执行失败的调用的时候，除了可以在函数中处理这个错误，还可以将错误返回给函数的调用者，让他们来决定如何进一步处理这个错误，这就叫做 <strong>传播错误</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(error)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="title function_ invoke__">Err</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">read_text_from_file</span>();</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Result&lt;T, E&gt; 设置成函数返回值，这样就将错误传递给了调用者，若文件 foo 存在的话，最终便可以输出文件中的内容。</p><p>Rust 中还提供了 <code>?</code> 运算符，用其来简化传播错误的操作。</p><p>如果 Result 是 Ok：Ok 中的值就是表达式的结果，然后继续执行程序；<br>如果 Result 是 Err：Err 就是 <strong>整个函数</strong> 的返回值，就像使用了 return。例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file_easy</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段简化后的代码的含义就是，若 <code>?</code> 前 Result 类型的值是 Ok，那么 Ok 里的值就会作为表达式的返回值进行返回，若类型是 Err，那么 Err 就当做整个函数的返回值进行返回。而 <code>f.read_to_string(&amp;mut s)?;</code> 中，若 Result 类型是 Ok，实际上里面值为空，没有用到，因此当表达式返回 Ok 后，返回一个 Ok(s) 作为函数的返回值，若类型为 Err，则将其作为函数返回值进行返回。</p><p>上面这个例子还可以继续进行优化，使用链式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file_easist</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**值得注意的是，要使用 ? 运算符，必须保证函数返回类型为 Result&lt;T, E&gt;**，倘若我们尝试一下函数返回类型不是 Result，将会得到这样一条报错信息：<code>error[E0277]: the &#39;?&#39; operator can only be used in a function that returns &#39;Result&#39; or &#39;Option&#39; (or another type that implements &#39;FromResidual&#39;)</code></p><p>因此，? 运算符只能用于返回类型为 Result 或 Option 的函数</p><p><strong>? 运算符与 main 函数</strong></p><ul><li>main 函数返回类型是:()</li><li>main 函数的返回类型也可以是：Result&lt;T，E&gt;</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error <span class="keyword">as</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Box&lt;dyn Error&gt;</code> 是 trait 对象，可以简单理解为“任何可能的错误类型”。</p><p>这样就可以在 main 函数中使用 <code>?</code> 运算符了。</p><p>（开始玄学 o_o）</p><p><strong>? 与 from 函数</strong></p><ul><li><code>Trait std:convert::From</code> 上的 from 函数<ul><li>用于错误之间的转换</li></ul></li><li>被 ? 所应用的错误，会隐式的被 from 函数处理</li><li>当 ? 调用 from 函数时<ul><li>它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</li></ul></li><li>用于：针对不同错误原因，返回同一种错误类型<ul><li>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</li></ul></li></ul><h3 id="2-4-什么时候应该使用-panic"><a href="#2-4-什么时候应该使用-panic" class="headerlink" title="2.4 什么时候应该使用 panic!"></a>2.4 什么时候应该使用 panic!</h3><p><strong>总体原则</strong></p><p>在定义一个可能失败的函数时，优先考虑返回 Result，若你觉得这个错误一定无法恢复，那就可以代替调用者调用 panic!</p><p><strong>编写示例、原型代码、测试</strong></p><p>可以使用panic!</p><ul><li>演示某些概念: unwrap</li><li>原型代码: unwrap、expect</li><li>测试: unwrap、expect<ul><li>测试的失败是用 panic! 进行标记的</li></ul></li></ul><p><strong>有时你比编译器掌握更多的信息</strong></p><p>你可以确定 Result 就是 Ok，那么可以使用 unwrap，例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;192.168.3.110&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以确定这个 IP 地址解析出来一定是有效的，因此可以直接使用 unwrap。</p><p><strong>错误处理的指导性建议</strong></p><ul><li>当代码最终可能处于损坏状态时，最好使用 panic!</li><li>损坏状态（Bad state）：某些假设、保证、约定或不可变性被打破<ul><li>例如非法的值、矛盾的值或空缺的值被传入代码</li><li>以及下列中的一条：<ul><li>这种损坏状态并不是预期能够偶尔发生的事情</li><li>在此之后，您的代码如果处于这种损坏状态就无法运行</li><li>在您使用的类型中没有一个好的方法来将这些信息（处于损坏状态）进行编码</li></ul></li></ul></li></ul><p><strong>场景建议</strong></p><ul><li>调用你的代码，传入无意义的参数值：panic!</li><li>调用外部不可控代码，返回非法状态，你无法修复：panic!</li><li>如果失败是可预期的：Result</li><li>当你的代码对值进行操作，首先应该验证这些值：panic!</li></ul><p><strong>为验证创建自定义类型</strong></p><p>创建新的类型，把验证逻辑放在构造实例的函数里。</p><p>以第一节的猜数游戏为例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The num must between 1 and 100&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个功能就是判断输入的数是否符合 i32 类型，若符合的话表达式返回 num，然后再判断是否在 1~100 之间，如果不满足则继续循环。如果有多个函数中都需要类似这样的判断，则代码便会显得冗余，我们可以自定义一个验证逻辑：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;The guess value must between 1 and 100, got &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;value&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似 getter 方法</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">guess_game</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;32&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span> = Guess::<span class="title function_ invoke__">new</span>(guess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够成功创建 Guess 实例的话，那么就说明值通过了验证，而不需要将验证功能写在函数里了。</p><p>上述 value 方法是获得 Guess 结构体中的 value 字段值，因为结构体中的字段是私有的，外部无法直接对字段赋值。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust入门教程（五）：错误处理&quot;&gt;&lt;a href=&quot;#Rust入门教程（五）：错误处理&quot; class=&quot;headerlink&quot; title=&quot;Rust入门教程（五）：错误处理&quot;&gt;&lt;/a&gt;Rust入门教程（五）：错误处理&lt;/h1&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="http://cherryyang05.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="http://cherryyang05.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>组会纪要</title>
    <link href="http://cherryyang05.github.io/cf54ade6.html"/>
    <id>http://cherryyang05.github.io/cf54ade6.html</id>
    <published>2022-05-20T08:27:36.000Z</published>
    <updated>2023-08-08T12:35:27.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组会纪要"><a href="#组会纪要" class="headerlink" title="组会纪要"></a>组会纪要</h1><blockquote><p>对每周五开会和平时讨论内容的总结整理</p></blockquote><span id="more"></span><h2 id="8-5-组会"><a href="#8-5-组会" class="headerlink" title="8.5 组会"></a>8.5 组会</h2><h3 id="上周任务"><a href="#上周任务" class="headerlink" title="上周任务"></a>上周任务</h3><ol><li>测试 tpftl 模块</li></ol><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ol><li>因 mac 架构问题，导致无法使用模拟器</li><li>内存中表项写回 flash 时机：设置阈值即可</li><li>连接 VPN</li></ol><h3 id="下周任务"><a href="#下周任务" class="headerlink" title="下周任务"></a>下周任务</h3><ol><li>连所里服务器继续测试</li></ol><hr><h2 id="7-29-组会"><a href="#7-29-组会" class="headerlink" title="7.29 组会"></a>7.29 组会</h2><h3 id="上周任务-1"><a href="#上周任务-1" class="headerlink" title="上周任务"></a>上周任务</h3><ol><li>编写代码<ol><li>主要完成了与 flash 的读写相关逻辑</li><li>优化了读写相关逻辑</li></ol></li></ol><h3 id="问题总结-1"><a href="#问题总结-1" class="headerlink" title="问题总结"></a>问题总结</h3><ol><li><code>l2p_table_entry l2p_get_l2p_entry(l2p_table_index lsn, u32 opcode, u32 is_searched)</code><br>写操作时要在 flash 中分配一个空闲页，然后建立逻辑地址到物理地址的映射。<br>通过该 API 进行写操作时，写的数据在哪？</li></ol><h3 id="下周任务-1"><a href="#下周任务-1" class="headerlink" title="下周任务"></a>下周任务</h3><ol><li>继续编写代码</li></ol><h2 id="7-22-组会"><a href="#7-22-组会" class="headerlink" title="7.22 组会"></a>7.22 组会</h2><h3 id="上周任务-2"><a href="#上周任务-2" class="headerlink" title="上周任务"></a>上周任务</h3><ol><li>看 12 篇论文并总结</li></ol><h3 id="下周任务-2"><a href="#下周任务-2" class="headerlink" title="下周任务"></a>下周任务</h3><ol><li>继续编写代码</li></ol><hr><h2 id="7-15-组会"><a href="#7-15-组会" class="headerlink" title="7.15 组会"></a>7.15 组会</h2><h3 id="上周任务-3"><a href="#上周任务-3" class="headerlink" title="上周任务"></a>上周任务</h3><ol><li>继续编写代码</li></ol><h3 id="问题总结-2"><a href="#问题总结-2" class="headerlink" title="问题总结"></a>问题总结</h3><h3 id="下周任务-3"><a href="#下周任务-3" class="headerlink" title="下周任务"></a>下周任务</h3><hr><h2 id="7-7-组会"><a href="#7-7-组会" class="headerlink" title="7.7 组会"></a>7.7 组会</h2><p>请假</p><hr><h2 id="7-1-组会"><a href="#7-1-组会" class="headerlink" title="7.1 组会"></a>7.1 组会</h2><h3 id="上周任务-4"><a href="#上周任务-4" class="headerlink" title="上周任务"></a>上周任务</h3><ol><li>编写 tp_l2p 模块代码</li><li>学习模拟器的使用</li><li>修改文档</li></ol><h3 id="问题总结-3"><a href="#问题总结-3" class="headerlink" title="问题总结"></a>问题总结</h3><ol><li>修改了部分结构体，新增了部分函数</li><li>TP 结点数量设置为 1M 个，总结点数量最大也为 1M 个</li><li>如何读取和写入 flash（API）</li><li>LRU 的计数器问题</li></ol><ul><li>LRU 可用访问次数来实现</li></ul><h3 id="下周任务-4"><a href="#下周任务-4" class="headerlink" title="下周任务"></a>下周任务</h3><ol><li>继续编写模块代码</li></ol><hr><h2 id="6-23-组会"><a href="#6-23-组会" class="headerlink" title="6.23 组会"></a>6.23 组会</h2><h3 id="上周完成"><a href="#上周完成" class="headerlink" title="上周完成"></a>上周完成</h3><ol><li>完成 TPFTL 设计文档</li><li>文档用 Latex 完成并推送到 doc 仓库</li></ol><hr><h2 id="6-17-组会"><a href="#6-17-组会" class="headerlink" title="6.17 组会"></a>6.17 组会</h2><ol><li>完善 l2p 优化，使用 TPFTL 方案</li><li>增加函数接口设计，结构体设计和全局变量</li></ol><p>（是否要重新开分支）</p><h3 id="问题总结-4"><a href="#问题总结-4" class="headerlink" title="问题总结"></a>问题总结</h3><ul><li>用数组会浪费空间，改成链表。</li><li>list.h 链表结构体的使用</li></ul><hr><h2 id="6-10-组会"><a href="#6-10-组会" class="headerlink" title="6.10 组会"></a>6.10 组会</h2><ol><li>搜集 HPCA 2015-2022 年相关论文并上传到仓库</li><li>阅读 Eurosys2015 那篇论文，TPFTL</li><li>阅读 Handbook，了解代码整体框架</li><li>提出 cache 优化方案</li></ol><h3 id="下周工作"><a href="#下周工作" class="headerlink" title="下周工作"></a>下周工作</h3><p>将 DFTL 方案改成 TPFTL，加上函数接口设计，结构体设计，和全局变量</p><hr><h2 id="6-2-组会"><a href="#6-2-组会" class="headerlink" title="6.2 组会"></a>6.2 组会</h2><ol><li>和大家讨论 C 语言代码规范</li><li>搜集 HPCA MSST 2012-2014 年相关论文并上传到仓库</li><li>开始阅读 l2p 相关代码</li></ol><h3 id="下周工作-1"><a href="#下周工作-1" class="headerlink" title="下周工作"></a>下周工作</h3><ol><li>继续阅读 l2p 代码</li><li>阅读 Eurosys2015 那篇论文</li><li>完成 cache 设计方案</li></ol><hr><h2 id="5-30-代码规范"><a href="#5-30-代码规范" class="headerlink" title="5.30 代码规范"></a>5.30 代码规范</h2><hr><h2 id="5-27-组会"><a href="#5-27-组会" class="headerlink" title="5.27 组会"></a>5.27 组会</h2><ol><li><p>阅读相关论文，学习了解 DFTL 的结构和原理</p><ul><li>将闪存块分为<strong>数据块</strong>和<strong>翻译块</strong>，前者存放真正的数据，后者存放存放映射表，并且是在闪存的固定位置</li><li>根据工作运行情况将映射表动态调入 SRAM</li><li>先查找 SRAM 中的 CMT（Cached Mapping Table），若未找到，再根据 GTD（Global Translation Directory，类似于二级页表）将闪存中的表替换到 SRAM 中，类似于分页机制中的 TLB</li><li>Cache 采用写回法，当表项替换出去的时候将其最新值写入闪存中</li></ul></li><li><p>学习了解 SLC Cache 相关内容</p></li></ol><h3 id="下周工作-2"><a href="#下周工作-2" class="headerlink" title="下周工作"></a>下周工作</h3><ol><li>C 语言代码规范文档讨论</li><li>阅读 standard v3 仓库代码的 l2p 模块</li></ol><hr><h2 id="5-20-组会"><a href="#5-20-组会" class="headerlink" title="5.20 组会"></a>5.20 组会</h2><p><strong>进度</strong></p><ol><li><p>学习《深入浅出SSD》1.4, 2.1, 3.1 和第四章的相关内容，对 SSD 有个大致的了解，以及对 SSD 的核心 FTL 有个基本了解（<a href="/source/_posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASSD%EF%BC%88%E4%B8%80%EF%BC%89.md">深入浅出SSD（一）</a> <a href="/source/_posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASSD%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASSD%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%9AFTL.md">深入浅出SSD（二）</a>）</p></li><li><p>阅读相关论文，了解 FTL 中虚拟地址映射、垃圾回收、磨损均衡等核心技术</p></li><li><p>自己学了一点其他的知识</p></li></ol><p><strong>遇到的问题</strong>：刚开始阅读论文，速度较慢</p><p><strong>建议</strong>：论文阅读关注背景、评测部分，理解论文里的思想</p><p><strong>未来工作</strong>：L2P 优化，DFTL</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;组会纪要&quot;&gt;&lt;a href=&quot;#组会纪要&quot; class=&quot;headerlink&quot; title=&quot;组会纪要&quot;&gt;&lt;/a&gt;组会纪要&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对每周五开会和平时讨论内容的总结整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="OpenSSD" scheme="http://cherryyang05.github.io/categories/OpenSSD/"/>
    
    <category term="组会" scheme="http://cherryyang05.github.io/categories/OpenSSD/%E7%BB%84%E4%BC%9A/"/>
    
    
    <category term="组会" scheme="http://cherryyang05.github.io/tags/%E7%BB%84%E4%BC%9A/"/>
    
  </entry>
  
</feed>
