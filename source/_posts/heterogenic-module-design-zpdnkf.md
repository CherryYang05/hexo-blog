
# 异构模块设计

# 1. 背景介绍

将 SSD 和磁带组成缓存结构的异构系统，SSD 作为主要流量承担的缓存设备，磁带作为数据永久存储的容量设备，用 SSD 平衡磁带的读写性能，使得异构系统用磁带的低成本大容量，表现出近似于 SSD 的读写性能。

但是和 SSD 和 HDD 这样的块设备不同，磁带是顺序设备，只支持顺序写入。传统的以 SSD 与 HDD 为主的异构系统的缓存设计更适用于小粒度的频繁读写，而磁带设备适用于大文件的归档及备份场景，传统的缓存结构对于这种场景来说效率较低。同时传统的缓存设计对时延较为敏感，而在档案馆这种地方，读取数据耽误个几秒钟似乎并没那么重要。

我们最需要考虑的一点是，当缓存上的数据下刷到磁带上时，应该保证顺序写入，但是真实情况下用户无法保证刷下去的数据都是顺序的。于是需要设计一个地址映射层，这样在外部看来，磁带是可以随机写的。

异构模块在全局的架构图如下。

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1721715368909-6435d196-bc2f-40ee-ba16-a843639fb980.png "异构模块全局架构")​

其他需要关注的地方包括：缓存结构，替换算法。

可以进一步优化的点：高效查表，使用倒排页表，参考日志结构文件系统（LFS）将写操作先写入日志，在上层设计存储协议，数据去重和压缩，元数据管理，异步操作，预取和缓存预热，负载均衡和错误处理等。

# 2. 地址映射层（AML, Address Mapping Layer）

## 2.1. 整体介绍

地址映射层主要有两部分，第一部分位于缓存层上方，主要是为了将上层传来的逻辑地址转换成物理地址（磁带上的实际位置），以适应磁带的顺序写入特性。

第二部分位于缓存层和磁带中间，主要为了将缓存替换后的数据顺序下刷到磁带上。

地址映射层所起到的功能与操作系统中的页表机制类似，只是分配的页框从物理上随机变成物理上连续。

地址映射层在异构系统中的表现如下。

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1721714040896-1ed232ce-ac93-45f7-aca8-504ef8cf0f3d.png)​

## 2.2. 映射表的设计

### 2.2.1. 逻辑地址到物理地址的映射

逻辑地址映射为物理地址大致方式如下：

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1720704704438-4a086dd5-4d1b-4c68-8e85-0a8034b398ea.png)​

其中：

**逻辑地址**  是输入的 trace 文件中的 offset 字段

**物理地址**  是写入磁带的地址

和操作系统中的页表类似，需要维护一张表，称为**块表（Block Table）** ，用来存储逻辑地址到物理地址的映射关系。

这里的每个表项存储的是一个块，块大小为 256KB，即该异构系统最小存储单位是 256KB。磁带容量为 18T，即有![](https://cdn.nlark.com/yuque/__latex/b6f95f4de4cd5a135b26d0fdf46ede99.svg)个表项，每个表项 4B，一共需要![](https://cdn.nlark.com/yuque/__latex/81850fef59d52e524daf8a9755c4dd65.svg)，即 512MB。

【后续考虑是否需要设计多级块表】

**块表表项结构**

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1721716327392-e81b9c9e-92f0-4127-a0a6-5f78a38fe27e.png)​

映射表每个表项为 32 位，只需要高 27 位表示地址块号，第 0 位为有效位，第 1 位为修改位，2-4 位保留另作他用。

由于映射表按照块来分配，每个数据块对应一个表项，因此表项的索引可以通过逻辑地址的前 27 位块号来唯一指示，因此表项中只需存放映射的物理地址块号。

【PS：这里的页表和操作系统中的页表的不同之处在于，操作系统中的逻辑地址表示的范围远超过内存，而异构模块中逻辑地址和（磁带上的）物理地址表示范围一致】

### 2.2.2. 映射表的创建

由于需要确保映射的物理地址是连续的，因此需要一个地址分配模块来分配连续的物理地址。简便起见，确保输入的 trace 对 256KB 对齐。

**地址分配模块**

* 用变量 `pointer`​ 维护磁带上顺序的物理地址
* 根据 `length`​ 确定要写入的块表的表项数量（length / blk\_size 向上取整）
* 最后根据 `linear_phyaddr`​ 将表项填入表中

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1720704690588-6a98fefa-97b0-468b-8da7-867ad63a1330.png)​

**AML 流程示例**

地址映射层从缓存接收被逐出的数据块 B，获取到逻辑地址(二进制为：**0** **0000 0000 0000 0000 0000 0001 00**00 0000 0000 0000 0000，块号为 27 位，偏移量为 18 位，共 45 位)，长度为 1MB，pointer 字段为 `flushing_phyaddr`​，初始值为 0，表示已经下刷到磁带上的顺序物理地址。

首先取出逻辑地址的块号为 **0** **0000 0000 0000 0000 0000 0001 00**，十进制为 4，再取出数据块的长度，为 1MB，需要切分成 4 个 256KB 的块。用来指示已经下刷到磁带上的顺序物理地址当前为 0，因此块号为 4 的逻辑地址映射到物理地址 0，块号为 5 的逻辑地址映射到物理地址 1，块号为 6 的逻辑地址映射到物理地址 2，块号为 7 的逻辑地址映射到物理地址 3。具体如下图。

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1721719315323-676259ae-6bb3-4e49-a1f8-a094b61b0ab8.png)​

# 3. 缓存层（Cache Layer）

## 3.1. 整体介绍

在异构模块中，使用 SSD 承担绝大部分写入流量，当写满时便需要下刷数据到磁带中，因此缓存层主要功能是用来管理需要下刷的数据。如何增加系统的读写命中率，以及如何高效地下刷是缓存层首要考虑的事情。

对于缓存的设计，见下面文档。

[缓存的设计与实现（新增）.pdf](https://www.yuque.com/attachments/yuque/0/2024/pdf/25899876/1720769013656-116a6e61-c9ac-4e00-a27d-2b18a392a9a1.pdf)

## 3.2. 缓存组织方式

缓存组织方式暂时采用组相连策略。

## 3.3. 缓存替换策略

考虑到以顺序写为主，替换策略考虑使用 FIFO 策略。

## 3.4. 缓存数据下刷

### 3.4.1. 设计思路

由于异构模块每次读取一个请求，因此当缓存满的时候，也会在缓存中替换下与该次请求等量数据大小的数据。遗憾的是，仅仅将每次替换的数据顺序写入不会让磁带机的性能达到最大，经过我们的测试发现，在请求粒度很小时（相对于磁带这种介质来说），例如 100MB 以下，带宽甚至达不到峰值带宽的一半。因此我考虑使用写缓冲，异构模块会跟踪 SSD 中的缓冲区（将作为缓存的 SSD 划分一点空间作为缓冲区），当缓冲区收到足够数量的数据时（例如 2GB），会统一刷新到磁带上。

### 3.4.2. P2P 映射表的创建

整体的流程如下图所示。

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1721719918821-225cfd82-0c19-40cd-b72f-807891199697.png)​

首先地址映射层接收缓存替换下来的数据块![](https://cdn.nlark.com/yuque/__latex/4b46685f65a37bff105c6a14ce103f48.svg)，L 表示该数据块逻辑地址，根据 `flushing_phyaddr`​，图中为 m+1，将其物理地址映射成要下刷到磁带上的地址（图中为![](https://cdn.nlark.com/yuque/__latex/d3980096c192fa6d238544738f976fe5.svg)），然后写入缓冲区 1（图中称为 `Seq Segment 1`​），同时将映射信息写入块表（将![](https://cdn.nlark.com/yuque/__latex/4b46685f65a37bff105c6a14ce103f48.svg)映射到![](https://cdn.nlark.com/yuque/__latex/d3980096c192fa6d238544738f976fe5.svg)）。

### 3.4.3. 写缓冲要多少

写缓冲区是 SSD 中的一片区域，用来批量地聚集在缓存中替换下来的数据块。考虑到磁带如此令人担忧的性能，如果只设计单缓冲，在等待数据下刷的时候，缓存层只能被阻塞，等待数据的下刷完成，严重影响从上层接收数据的带宽。尽管磁带的顺序写带宽超过目前绝大多数的 HDD，但是我仍然想让它更高效，因此我在 3.4.2 的示意图中设置了两个写缓冲，但这只代表这不是单缓冲，毕竟从单到双和从双到多有本质区别。

那么到底要设置多少个缓冲呢？更准确的表达应该是需要一个负责下刷的缓冲（毕竟目前只有一个磁带机，而磁带是单通道设备），以及多少负责暂存缓存替换下来的数据用以抵消负责下刷的缓冲的延时。

经过朴素的理论分析，暂存缓冲区的数量受缓存中替换下来的数据块频率决定。试想如果一个负载总是没有命中缓存，那么缓存每次都要替换，那么进入写缓冲的数据就会变多，下刷到磁带的压力就会变大，整体系统的时延便会增加。反之，最理想的情况下，命中率为 100%，写缓冲就不会有数据进来。

因此写缓冲的大小至少为两个，一个下刷，另一个承接缓存中替换下来的数据块。而这样的双缓冲是否可以抵消下刷到磁带的延时，可以考虑使用配置参数给系统动态调整，当然写缓冲也不宜过多，毕竟占据了 SSD 的空间，管理起来也需要开销。

# 4. 负载的读操作随机度度量

引入随机度的动机：探究与 SSD 和 HDD 的异构性能一致的随机度的临界点

地址映射前有个读随机度，映射后有个随机度，可以比较异构模块对降低随机度的影响

## 4.1. 熵（Entropy）

​![](https://cdn.nlark.com/yuque/0/2024/png/25899876/1722950778624-501d73f6-b533-4340-92a9-4473555984e4.png)​

熵是信息论中的一个概念，用来衡量信息的不确定性或随机性。在存储系统的上下文中，熵可以反映读操作的随机性。

**计算步骤：**

1. 统计频率：对于每个数据块，计算其被访问的次数，并计算这些访问次数在所有读操作中所占的比例。

比如某个块被访问了![](https://cdn.nlark.com/yuque/__latex/77db1de84c57b9099d7206fb2c0f1ca3.svg)次，总共有 N 次读操作，那么这个块的访问比例为![](https://cdn.nlark.com/yuque/__latex/ab91acd42146db3a3a7c7f761f714dff.svg)。

2. 计算熵：根据每个块的访问比例，使用以下公式计算熵：

​![](https://cdn.nlark.com/yuque/__latex/27aadc064e81cfaf0acbe9a4fc8b7daa.svg)​

其中，m 是被访问的块的数量，![](https://cdn.nlark.com/yuque/__latex/39c69fbad0041c1d5caa9acf313cb0e6.svg)是第 i 个块的访问比例。

**熵越高，表示读操作的分布越均匀、越随机。** 最大熵发生在所有数据块被均匀访问的情况下。

**熵越低，表示读操作的分布越集中、越有规律。** 例如，如果只有少数几个块被频繁访问，而其他块很少被访问，熵值会很低。

考虑到熵的值会受访问次数的影响，因此在不同的负载下，无法直接用熵值比较其随机性。考虑使用归一化熵（normalized entropy），使得熵值能够在不同的访问次数下进行统一比较。

归一化熵通过将熵值归一化，使其范围固定在 `[0, 1]`​ 之间。归一化的过程是将实际的熵值除以其最大可能的熵值。

对于一个有 `n`​ 个数据块的系统，最大熵发生在所有数据块被均匀访问的情况下，此时熵值为：

​![](https://cdn.nlark.com/yuque/__latex/0825f86295a52b885ab499a550488ab3.svg)​

归一化熵的计算公式为：

​![](https://cdn.nlark.com/yuque/__latex/7255eb6eb60692bf285b57ffc6c40f7d.svg)​

这样，无论访问次数是多少，归一化熵都可以在 `0`​ 到 `1`​ 之间进行比较，其中 `0`​ 表示完全有规律的分布（例如完全集中于一个块），`1`​ 表示完全随机的均匀分布。

## 4.2. 平均跳跃距离 **（Average Jump Distance）**

跳跃距离指的是每一个读操作上一个请求结束后磁头所处的位置的块号之差。如果读操作是顺序的，这个差值会很小。

**计算方法：**

1. 计算相邻读操作的跳跃距离：对于每一个读操作，计算该读操作距离上一个请求结束后磁头所处的位置的块号之差，得到一系列的跳跃距离。

​![](https://cdn.nlark.com/yuque/__latex/b140cae608bfef9a9b9600f58add5dd4.svg)​

2. 求平均跳跃距离：将所有的跳跃距离取平均，得到平均跳跃距离。

​![](https://cdn.nlark.com/yuque/__latex/85703ea08de0b8027067f7188054e987.svg)​

其中，![](https://cdn.nlark.com/yuque/__latex/459f3c80a50b7be28751b0869ef5386a.svg)是读操作的总数。

平均跳跃距离越大，说明读操作的随机性越高；越小，说明读操作顺序性越高。

## 4.3. 熵和平均跳跃距离结合

熵指示了**读操作的局部性**，可以反映出是否读操作集中在某些热点区域。

平均跳跃距离指示了**读操作的顺序性**，映射到磁带机上就是磁头平均移动的距离。

使用   **(熵, 平均跳跃距离)**   的二元组来表征一个负载的随机性，可以将负载分为四个区域。

### 4.3.1. **熵高平均跳跃距离高**

**读操作分布均匀（局部性不好），随机性较高。**

这种负载的随机性是最大的，会造成最大的磁头移动和 IO 开销，性能最差。

### 4.3.2. **熵高平均跳跃距离低**

**读操作分布均匀（局部性不好），顺序性较高。**

负载在全局的顺序性都较强，不存在热点区域，可能在全局上会有较好的缓存命中率，性能最好。

### 4.3.3. **熵低平均跳跃距离高**

**读操作集中在某些热点区域（局部性好），且随机性较高。**

表明负载可能存在几个分散的热点区域，在热点区域内的操作可能比较集中，但是热点相隔较远。

这可能是由于应用程序在处理不同类型的数据时，需要访问分布在不同地址空间的几个关键区域。磁头可能需要在不同热点区域频繁移动，造成巨大开销。

缓存可能在某些热点区域表现较好，但是由于不同特点区域相距较远，导致整体缓存命中率不理想，增加 IO 开销。

### 4.3.4. **熵低平均跳跃距离低**

**读操作集中在某些热点区域（局部性好），且顺序性较高。**

负载可能在一块热点区域上或多块热点区域内有较高的顺序性。

读操作集中在某些块中会带来较低的熵值，从而对缓存系统较为友好，可能在局部带来较高的缓存命中率。因为磁带机是单通道设备，也无需担心操作过于集中在某些块上而导致并发访问的瓶颈。

## 4.4. 其他可能的参数

### 4.4.1. 基尼系数（Gini Coefficient）

基尼系数通常用来衡量收入分配的不平等性，但在存储系统中，它可以用来衡量读操作的集中度。

**计算步骤：**

1. 排序访问频率：首先将数据块按访问次数从小到大排序。
2. 计算累积频率：计算累积访问次数，并用这些数据来计算基尼系数。基尼系数的计算公式为：

​![](https://cdn.nlark.com/yuque/__latex/2cb2eb88a6168b9a5d6599126d49ba8d.svg)​

其中：

​![](https://cdn.nlark.com/yuque/__latex/ba1b6e7a2a5f6e2808e06f1b6133bb82.svg)是到第![](https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg)个块的累积访问次数。

​![](https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg)是被访问块的数量。

​![](https://cdn.nlark.com/yuque/__latex/eee2466f228c099cec8a86dec4bf6eb0.svg)是累积访问次数的总和。

3. 图形解释：基尼系数的几何解释通常使用洛伦兹曲线来表示，曲线越偏离对角线，基尼系数越高，表示分布越不平等。

基尼系数 \= 0，表示完全平等，每个块被访问的次数完全相同。

基尼系数 \= 1，表示完全不平等，所有访问都集中在一个块上，其他块没有被访问。

### 4.4.2. 局部顺序性

通过分析操作是否具有局部性来判断随机度。局部性好的操作表现为在某个短时间内集中访问相邻的块，而不是随机跳跃。

**计算方法：**

1. **窗口滑动分析**：设定一个固定大小的窗口（如 10 个操作），计算在这个窗口内访问的块的序列性。
2. **序列性得分**：为每个窗口分配一个序列性得分，如果在窗口内操作都是顺序的，则得分高，否则得分低。
3. **总体评估**：将所有窗口的得分取平均，得出整个负载的顺序性得分。

得分越低，说明操作越随机；得分越高，说明操作越顺序。

# 5. 修改意见

## 5.1. 1

* 异构模块在软件栈的什么位置
* 不同粒度大小测试
* 补充逻辑地址和物理地址在磁带和异构模块中的含义
* 缓存组相连适用于什么情况
* SSD 做 HDD 的缓存的工作
* ZNS SSD 做 Cache（HotStorage 2024）
* 设计一个方案用来标示 trace 的读操作随机度

## 5.2. 2

* 跨 wrap 代码
* ppt 和 word

## 5.3. 开题预答辩

# 6. 参考资料

**日志文件系统**

‍
