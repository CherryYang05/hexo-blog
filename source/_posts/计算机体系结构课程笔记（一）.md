---
title: 计算机体系结构课程笔记（一）
mathjax: true
tags:
  - 体系结构
  - 笔记
categories:
  - 课程笔记
  - 体系结构
abbrlink: bc5a2705
date: 2021-12-31 12:10:32
---

>本系列笔记来自于国防科技大学的计算机体系结构课程
>作者：Cherry
>时间：2022.1

<!-- more -->

# 第一章

>国防科大计算机体系结构课程第一至三章笔记

## 1.1 计算机体系结构的概念与发展

**冯诺依曼结构：**
运算器（核心）、存储器、输入/输出设备、控制器

**程序执行的过程**

- 分解程序指令，形成控制四个部分工作的控制流
- 对数据进行加工（运算），形成数据流
- 周而复始地产生指令流 / 数据流
- 并最终得到结果

**一个机器周期里面安排的操作序列**

1. 计算机从存储器中取出一条指令
2. 对这条指令进行译码

- 分解并确定这条指令所指示的操作
- 确定操作对象（操作数）所在的位置
- 某个寄存器单元、存储器单元或者输入设备

3. 取操作数并送到运算器
4. 运算器按照译码确定的操作进行运算
5. 运算结束后，将结果送到指定的位置

- 计算机准备执行下一条指令

阿姆道尔（C. M. Amdahl）首次明确

- 计算机体系结构是程序员所看到的计算机的属性，即概念性结构与功能特性
- 1964 年 4 月， Architecture of the IBM System/360 ，发表在 IBM Journal of Research and Development 上
- 计算机体系结构概念的经典定义

**程序员所看到的计算机的属性**

- 对于通用寄存器型机器，这些属性主要是指
  （1）数据表示：硬件能直接辨认和处理的数据类型
  （2）寻址规则：最小寻址单元、寻址方式及其表示
  （3）寄存器定义：寄存器的定义、数量和使用方式
  （4）指令系统：机器指令的操作类型和格式、指令间的排序和控制机构等
  （5）中断系统：中断的类型和中断响应硬件的功能等
  （6）机器工作状态的定义和切换：如管态和目态等
  （7）存储系统：程序员可用的最大存储容量
  （8）信息保护：信息保护方式和硬件的支持
  （9）I/O 结构：I/O 寻址方式、数据传送的方式等

**计算机组成关注的问题：**

指令集结构的逻辑实现

- 数据通路宽度
- 各种操作对功能部件的共享程度
- 专用功能部件的设置
- 功能部件的并行性
- 缓冲和排队技术
- 预测技术
- 可靠性技术
- 控制机构的组成，等等

计算机的实现

- 处理器、主存的物理结构
- 器件的集成度和速度
- 信号传输
- 器件、模块、插件、底板的划分与连接
- 涉及的专用器件
- 电源、冷却
- 微组装技术
- 整机装配技术，等等

**不同年代计算机体系结构研究内容的变化：**

|年代|研究内容|典型计算机|
|---|---|---|
|1940s|程序控制计算机、存储程序计算机|ENIAC、EDVAC|
|1950s|指令系统|IBM 360 系列机|
|1960s|阵列机和并行处理|ILLIAC IV|
|1970s|流水线、向量处理、微处理器|Cray-1、Intel 4004|
|1980s|RISC、cache、流水线|MIPS R1000、Power|
|1990s|SMP、CMP、指令级并行|MIPS R100000、PowerPC 604|
|2000 年以来|SMT、功耗、Multi-core，Stream|Intel i7、Power 6、ARM、GPU|

同一个功能用硬件和软件实现是等效的，但是效率不同。

**计算机系统中的多语言层次结构：**

第一级：微程序机器级

- 微程序机器级的机器语言是微指令集
- 程序员用微指令编写的微程序一般是直接由硬件解释实现的

第二级：传统机器级

- 传统机器级的语言是该机的指令集
- 机器指令程序可以由微程序进行解释(仿真)，可有多个解释程序通过仿真，实现多种指令集
- 可以没有微程序机器级

第三级：操作系统虚拟机

- 直接管理传统机器中的软硬件资源
- 是传统机器的引伸
- 提供了传统机器所没有的某些基本操作和数据结构
  - 文件系统
  - 虚拟存储系统
  - 多道程序系统
  - 多线程管理等

第四级：汇编语言虚拟机

- 用汇编语言编写的程序，首先翻译或解释成第 3 级和第 2 级语言，然后再由相应的机器执行
- 完成汇编语言翻译的程序就叫做汇编程序，又叫汇编器

第五级：高级语言虚拟机

- 机器语言就是各种高级语言
- 用这些语言所编写的程序一般是由称为编译程序翻译到第４级或第 3 级上
- 也有用解释的方法实现转化

第六级：应用语言虚拟机

- 为使计算机满足某种用途而专门设计的（人工智能、教育、行政管理、计算机设计）
- 应用语言编写的程序一般是由应用程序包翻译到第 5 级上

**翻译和解释：**

翻译（Translation）：
先把 N+1 级程序全部变换成 N 级程序后，再去执行新产生的 N 级程序，在执行过程中 N+1 级程序不再被访问

解释（Interpretation）：
每当一条 N+1 级指令被译码后，就直接去执行一串等效的 N 级指令，然后再去取下一条 N+1 级的指令，依此重复进行

一般来说，解释执行比翻译花的时间多，但存储空间较少。

### 1.1.4 系列机和兼容

- 系列机（family machine）是具有相同体系结构，但组成和实现不同的一系列不同型号的计算机系统
  - IBM 公司在推出 IBM S360 时首次提出的系列机的概念，被认为是计算机发展史上一个重要里程碑
  - 各计算机厂家仍按系列机研发产品
- 现代计算机不但系统系列化，其构成部件和软件也系列化
  - 如微处理器（ CPU ）、硬盘、操作系统、高级语言等

**兼容性**

- 向上 (下) 兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器
- 向前(后)兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前 (后) 投入市场的机器

**兼容对体系结构的影响**

计算机系统及软件设计者的“障碍”：

- 系统软件的开发难度大
- 需要保护巨大的应用软件宝库

向后兼容是才是软件兼容的根本特征，也是系列机的根本特征

- 为了保证软件的兼容，要求指令集不改变，这无疑又妨碍计算机体系结构的发展
- 向后兼容虽然削弱了系列机对体系结构发展的约束，但仍然是体系结发展的沉重包袱
- 20 世纪 80 年代具有 RISC 体系结构的微处理器在新结构、新技术应用等方面领先传统的 CISC 微处理器的主要原因之一

## 1.2 计算机体系结构的发展

![计算机体系结构的发展历史](bc5a2705/计算机体系结构的发展历史.png)



**并行技术的发展：**
概念：

1. 指令集并行
2. 线程级并行
3. 任务级/过程级并行

提高并行性的技术途径：

1. 时间重叠
2. 资源重复
3. 资源共享（提高资源的使用效率，如打印机）

并行计算的应用需求

**计算机的成本构成：**

1. 处理器板：37%
2. I/O 设备：37%
3. 附件：6%
4. 软件：20%

目前，设计者需要取得性能与成本之间的平衡

**摩尔定律**
1965 年，时任仙童公司研发实验室主任的摩尔（Gordon Mooer）在《Electronics》上撰文，认为集成电路密度大约每两年翻一番，大约成指数级增长。
40 年来，摩尔定律不但印证了集成电路技术的发展，也印证了计算机技术的发展。

## 1.3 计算机系统设计和分析

装机部件的成本的 50% 左右在显示部件上，即显示器和显卡。
成本——时间因素：学习曲线

- 产品价格随着时间下降的趋势

### 1.3.2 基准测试程序

五类测试程序

- 真实程序
- 修正的（或者脚本化）应用程序
- 核心程序
- 小测试程序
- 合成测试程序(将多个程序的核心部分提取出来)

测试程序包：选择一组各个方面有代表性的测试程序组成
如：`www.SPEC.org`

- 基于 NUIX ，诞生于 20 世纪 80 年代
- 由真实程序和核心程序构成
- 采用 C 和 Fortran 两种语言，后增加 C++
- 包括整数部分 SPECint 和浮点部分 SPECfp
- 主要版本包括 SPEC89 、 SPEC92 、 SPEC95 、 SPEC2000 和 SPEC2006 等
  - SECP2006 功能进一步细化
    - 台式计测试： SPEC CPU2000
    - 图像测试： SPECviewperf, SPECapc
    - NFS 性能测试： SPECSFS
    - Web 服务测试： SPECWeb

### 1.3.3 量化设计的基本原则

1. 大概率事件优先原则
- 追求全局的最优结果
2. Amdahl 定律
- 系统性能加速比，受限于该部件在系统中所占的重要性
- 可以定量计算
3. 程序的局部性原理
- 程序执行时所访问存储器在时-空上是相对地簇聚
- 这种簇聚包括指令和数据两部分

**大概率事件优先原则**
- 对于大概率事件（常见的事件）赋予优先的处理权和资源使用权，以获得全局的最优结果
- 要能确定什么是大概率事件，同时要说明针对该事件进行的改进将如何提高机器的性能
- “好钢用在刀刃上”，事半功倍

**Amdahl 定律**
- $$系统加速比=\dfrac{系统性能_{改进后}}{系统性能_{改进前}}=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}$$
- 核心概念：时间
- 系统加速比依赖于两个因素
  - “可改进比例”：可改进部分在原系统计算时间中所占的比例 ，它总是小于等于 1 的
  - “部件加速比”：可改进部分改进以后的性能提高，一般情况下它是大于 1 的
- Amdahl的系统执行时间：
$$=(1-可改进比例)×总执行时间_{改进前}+\dfrac{可改进比例}{部件加速比}×总执行时间_{改进前}$$
$$=总执行时间_{改进前}×(1-可改进比例+\dfrac{可改进比例}{部件加速比})$$
- 则Amdahl的系统加速比
$$=\dfrac{总执行时间_{改进前}}{总执行时间_{改进后}}$$
$$=\dfrac{1}{(1-可改进比例)+\dfrac{可改进比例}{部件加速比}}$$
- Amdahl定律的观点
  - 性能增加的递减规则
    - 仅仅对计算机中的一部分做性能改进，则改进的越多，系统获得的效果越小
  - Amdahl 定律的一个重要推论
    - 针对整个任务的一部分进行优化，则最大加速比不大于$$\frac{1}{1-可改进比例}$$
    - 通俗的说，系统的性能是由他不可加速的部分的性能决定
    - Amdahl 定律衡量一个“好”的计算机系统
      - 具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能

**程序局部性**
- 程序访问地址的分布不是随机的，而是相对地簇聚
  - 包括时间局部性和程序的空间局部性
- 程序的时间局部性
  - 程序即将用到的信息很可能就是目前正在使用的信息
- 程序的空间局部性
  - 程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近
- 其他局部性
  - 生产 - 消费局部性

### 1.3.5 CPU 性能

- 程序执行过程中所处理的指令数，记为 IC
- 每条指令执行所需要的时钟周期数 CPI(Cycles Per Instruction)
- 每条指令执行所需要的平均时钟周期数 CPI = CLK / IC

#### CPU 性能公式

例子见 PPT

# 第二章 指令系统

**大纲**
- 指令集结构概述
- 指令集结构的分类		
- 寻址方式
- 指令系统的设计和优化
- 指令系统的发展和改进	
- 操作数的类型和大小
- MIPS指令系统结构	
- 指令集结构概述
- 指令集结构的分类
---
## 2.1 指令集结构和设计技术

### 1. 指令集结构概述

### 2. 指令集结构的分类

- 一般来说，可以从如下五个因素考虑对计算机指令集结构进行分类，即：
  - 在CPU中操作数的存储方法；
  - 指令中显式表示的操作数个数；
  - 操作数的寻址方式；
  - 指令集所提供的操作类型；
  - 操作数的类型和大小。

- CPU中用来存储操作数的存储单元主要有：
  - 堆栈；
  - 累加器；
  - 一组寄存器。

 指令中的操作数可以被明确地显式给出，也可以按照某种约定隐式地给出。

**通用寄存器型指令集结构的分类**

- 通用寄存器型指令集结构的主要优点:
  - 在表达式求值方面，比其它类型指令集结构都具有更大的灵活性；
  - 寄存器可以用来存放变量；
    - 减少存储器的通信量，加快程序的执行速度（因为寄存器比存储器快）
    - 可以用更少的地址位来寻址寄存器，从而可以有效改进程序的目标代码大小。

- 两种主要的指令特性能够将通用寄存器型指令集结构（GPR）进一步细分。
  - ALU指令到底有两个或是三个操作数？
  - 在ALU指令中，有多少个操作数可以用存储器来寻址，也即有多少个存储器操作数？
- 可以将当前大多数通用寄存器型指令集结构进一步细分为三种类型：
  - 寄存器－寄存器型(R－R：register-register)
  - 寄存器－存储器型(R－M：register-memory)
  - 存储器－存储器型(M－M：memory-memory)

三种通用寄存器型指令集结构的优缺点

- 寄存器－寄存器型（0,3）
  - 优点：
    - 指令字长固定，指令结构简洁，是一种简单的代码生成模型，各种指令的执行时钟周期数相近。
  - 缺点：
    - 与指令中含存储器操作数的指令系统结构相比，指令条数多，目标代码不够紧凑，因而程序占用的空间比较大。
- 寄存器－存储器型（1,2）
  - 优点：
    - 可以在ALU指令中直接对存储器操作数进行引用，而不必先用load指令进行加载，容易对指令进行编码，目标代码比较紧凑。
  - 缺点：
    - 由于有一个操作数的内容将被破坏，所以指令中的两个操作数不对称。在一条指令中同时对寄存器操作数和存储器操作数进行编码，有可能*限制指令所能够表示的寄存器个数*。指令的执行时钟周期因操作数的来源（寄存器或存储器）的不同而差别比较大。
- 存储器－存储器型（3,3）
  - 优点：
    - 目标代码最紧凑，不需要设置存储器来保存变量。
  - 缺点：
    - 指令字长变换很大，特别是3个操作数指令。而且每条指令完成的工作也差别很大。对存储器的频率访问会使存储器成为瓶颈。这种类型的指令系统现在已经不用了。

## 2.2 指令集结构和MIPS指令集

### 3. 寻址技术

- 在通用寄存器型指令集结构中，一般是利用寻址方式指明指令中的操作数是一个常数、一个寄存器操作数，抑或是一个存储器操作数。
- 寻址实际上是从形式地址到实际地址的转换。形式地址由指令描述，实际地址也称为有效地址。
- 有效地址指明的是存储器单元的地址或寄存器地址。
- 必须加速有效地址生成。

常用的一些操作数寻址方式：
- 寄存器寻址
- 立即值寻址
- 偏移寻址
- 寄存器间接寻址
- 索引寻址
- 直接寻址或绝对寻址
- 存储器间接寻址
- 自增寻址（串操作，先寻址再加）
- 自减寻址（先减再寻址）
- 缩放寻址
  - 指令实例： Add R1, 100(R2)[R3]
  - 含义：Regs[R1]←Regs[R1]+Mem[100+Regs[R2]+Regs[R3]*d]
 
### 4. 指令系统的设计和优化

一种指令集结构中的指令到底要支持哪些类型的操作呢？这就是所谓的指令集结构功能设计问题。

|分类|功能|
|---|---|
|算术和逻辑运算|整数的算术和逻辑操作：加、减、与、或等|
|数据传输|Load/Store|
|控制|分支、跳转、过程调用和返回、自陷等|
|系统|操作系统调用、虚拟存储器管理等|
|浮点|浮点操作：加、乘等|
|十进制|十进制加、十进制乘、十进制到字符的转换|
|字符串|字符串移动、字符串比较、字符串搜索等|
|图形|像素操作、压缩/解压操作等|

控制指令

- 跳转” （Jump）：当控制指令为无条件改变控制流时，我们称之为“跳转” 。
- “分支” （Branch）：而当控制指令是有条件改变控制流时，我们称之为“分支” 。
- 控制流程的改变情况：
  - 条件分支（conditional branch）；
  - 跳转（jump）；
  - 过程调用（call）；
  - 过程返回（return）。
- 控制指令主要使用在条件分支上

条件分支指令的表示

|分支条件表示|优点|缺点|
|---|---|-----|
|条件码（CC）在程序的控制下，由ALU操作设置特殊的位|可以自由设置分支条件|必须从一条指令将分支条件信息传送到分支指令，所以CC是额外状态，条件码限制了指令执行顺序|
|条件寄存器：根据比较结果测试条件寄存器|简单|占用了一个寄存器|
|比较分支：比较操作是分支指令的一部分，比较受限制|一条指令完成了两条指令的功能|分支指令的操作增多(串行)|

**过程调用和返回的状态保存**
- 调用者保存” （caller saving）方法：如果采用调用者保存策略，那么在一个调用者调用别的过程时，必须保存调用者所要保存的寄存器，以备调用结束返回后，能够再次访问调用者。
- “被调用者保存” （callee saving）方法：如果采用被调用者保存策略，那么被调用的过程必须保存它要用的寄存器，保证不会破坏过程调用者的程序执行环境，并在过程调用结束返回时，恢复这些寄存器的内容。

### 5. 指令系统的发展和改进

- 一个方向是强化指令功能，实现软件功能向硬件功能转移，基于这种指令集结构而设计实现的计算机系统称为复杂指令集计算机（CISC）。
- 八十年代发展起来的精简指令集计算机（RISC），其目的是尽可能地降低指令集结构的复杂性，以达到简化实现，提高性能的目的。

**CISC指令集功能设计**
- 面向目标程序增强指令功能
  - 提高运算型指令功能；
  - 提高传送指令功能；
  - 增加程序控制指令功能。
- 面向高级语言和编译程序改进指令系统
  - 增加对高级语言和编译系统支持的指令功能；
  - 高级语言计算机指令系统。
- 面向操作系统的优化实现改进指令系统
  - 主要表现在对中断处理、进程管理、存储管理和保护、系统工作状态的建立与切换等的支持。
  - 可以设置支持系统工作状态和访问方式转移的指令、支持进程转移的指令、支持进程同步和互斥的指令等措施，达到优化实现操作系统的目的。

**RISC指令集功能设计**
- CISC结构存在着如下缺点：
  - 在CISC结构的指令系统中，各种指令的使用频率相差悬殊。据统计，``有20％的指令使用频率最大，占运行时间的80％``。也就是说，``有80％的指令在20％的运行时间内才会用到``。
  - CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误。
- CISC结构指令系统的复杂性给VLSI设计增加了很大负担，不利于单片集成。
- CISC结构的指令系统中，许多复杂指令需要很复杂的操作，因而运行速度慢。
- 在CISC结构的指令系统中，由于各条指令的功能不均衡性，不利于采用先进的计算机体系结构技术（如流水技术）来提高系统的性能。

**注：x86 从奔腾4开始，内部已经实现 RISC 化**

![RISC指令执行频率](bc5a2705/RISC指令集功能设计.png)

**RISC指令集功能设计原则**
- 选取使用频率最高的指令，并补充一些最有用的指令；
- 每条指令的功能应尽可能简单，并在一个机器周期内完成；
- 所有指令长度均相同；
- 只有load和store操作指令才访问存储器，其它指令操作均在寄存器之间进行；
- 以简单有效的方式支持高级语言。

### 6. 操作数的类型和大小

- 操作数类型和操作数表示也是软硬件主要界面之一。
- 操作数类型是面向应用、面向软件系统所处理的各种数据结构。
- 操作数表示是硬件结构能够识别、指令系统可以直接调用的那些结构。
- 操作数表示所表征的那些操作数类型，是应用软件和系统软件所处理的操作数类型的子集。
- 确定操作数表示实际上也是软硬件取舍折衷的问题
  - 计算机即使只具有最简单的操作数表示，如只有整数（定点）表示法，也可以通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率。
  - 如果各种复杂的操作数类型均包含在操作数表示之中，无疑会大大提高系统的效率，但是所花费的硬件代价也很高。

### 7. MIPS指令系统结构

- Load/Store型指令集结构；
- MIPS是一种多元指令集结构；
- 具有一个简单的Load/Store指令集；
- 注重指令流水效率；
- 简化指令的译码；
- 高效支持编译器。

**MIPS指令集结构：寄存器**

- 32个32位通用寄存器（GRPs）
  - 寄存器R0的内容恒为0
- 32个32位浮点寄存器（FPRs）
  - 单精度浮点数表示和双精度浮点表示

**MIPS指令集结构：数据类型**
- 整型数据：
  - 8位、 16位、 32位。
- 浮点数据：
  - 32位单精度浮点；
  - 64位双精度浮点；
  - IEEE 754标准。

**MIPS指令集结构：寻址方式**
- 寄存器寻址；如ADD R1,R2,R3
- 立即值寻址；如ADD R1,R2,#42
- 偏移寻址； 如ADD R1,R2,40(R3)
- 寄存器间接寻址。存储器地址宽度为32位。如ADD R1,R2,0(R3)

**MIPS指令集结构：指令格式**
- I类型指令
- R类型指令
- J类型指令

**MPIS指令集结构：操作类型**
- Load和Store操作；
- ALU操作；
- 分支和跳转操作；
- 浮点操作；
- 符号``<-`` 表示数据传送操作，其后附带一个下标n，也即 ``<-n`` 表示传送一个n位数据。
- 符号 ``##`` 用来表示两个域的串联操作，它可以出现在数据传送操作的任何一边。
- 域的下标用来表明从该域中选择某一位。域中位的标记是从最高位开始标记，并且起始标记为0。下标可以是一个单独的数字，也可以是一个范围；
- 上标表示复制一个域，如$0^{24}$可以得到一个24位全为0的一个域。
- 变量Mem用来表示存储器中的一个数组，存储器按照字节寻址，它可以传送任何数目的字节。

![MIPS指令集](bc5a2705/MIPS指令集结构.png)

- Load和Store操作：可以对MIPS的所有通用寄存器和浮点寄存器进行Load（载入）和Store（储存）操作， 但是对通用寄存器R0的Load操作没有任何效果。

![MIPS指令举例](bc5a2705/MIPS指令举例.png)

- ALU操作：在MIPS中，所有的ALU指令都是寄存器－寄存器型指令，其运算包含了简单的算术和逻辑运算，如加、减、AND、OR、XOR和移位。
- “设置相等”、“设置不等”“设置小于”:寄存器比较指令
- 描述目标地址的方法：
  - 其中两种类型的跳转指令用带符号位的26位偏移量加上程序计数器的值来确定跳转的目标地址；
  - 另外两种类型的跳转指令则指定一个寄存器，由寄存器中的内容决定跳转的目标地址。
- 两种跳转类型：
  - 一种是简单跳转；
  - 另一种是跳转并链接（用于过程调用），它将下一条顺序指令地址（返回地址）保存在寄存器R31中。
  
![MIPS跳转指令](bc5a2705/MIPS跳转指令.png)

- 浮点操作：浮点指令的操作数来源于浮点寄存器，同时它还指明了相应的操作是单精度
浮点操作还是双精度浮点操作。
  - 后缀D代表双精度浮点操作；
  - 而后缀F代表单精度浮点操作（如： ADDD、ADDF、 SUBD、 SUBF、 MULTD、 MULTF、DIVD、 DIVF）。
- MIPS的浮点操作有：加、减、乘、除。

**MIPS的效能分析**
- 问题的提出：
  - MIPS指令集结构的指令格式、寻址方式和操作都非常简单。也许有人会担心，这些特性会使得目标代码中指令条数增多，导致程序运行时间加长，从而使这种指令集结构的机器性能并不会太高。

# 第三章 流水线技术

## 3.1 流水线基本概念

**流水技术**
将一重复的时序过程分解为若干子过程，每个子过程都可以有效地在其专用功能段上与其它子过程同时执行，这种技术成为流水技术。

**时空图**
从时间和空间两个方面描述流水线的工作过程，横坐标表示时间，纵坐标表示各流水段。

**流水线的特点**
- 流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”。段的数目称为流水线的“深度”。
- 每个子过程由专用的功能段实现
- 各功能段的时间应基本相等，通常为1个时钟周期（1拍）
- 流水线需要经过一定的通过时间才能稳定。
- 流水技术适合于大量重复的时序过程。（流水也是一种并行，但和“并发”不一样，是处于“不同阶段”任务的并行）

### 3.1.2 流水线的分类

**1. 单功能流水线和多功能流水线**
- 按流水线所完成的功能分类
- 单功能流水线，是指只能完成一种固定功能的流水线。
  - 例如：功能单元流水线
- 多功能流水线，是指各段可以进行不同的连接，从而完成不同的功能。
  - 例如：TI ASC的多功能流水线

**2. 静态流水线和动态流水线**
- 按同一时间内流水段的连接方式划分
- 静态流水线，是指在同一时间内，流水线的各段只能按同一种功能的连接方式工作
  - 例如：TI ASC的流水线
  - 适合于处理一串相同的运算操作
- 动态流水线，是指在同一时间内，当某些段正在实现某种运算时，另一些段却在实现另一种运算
  - 会使流水线的控制变得很复杂
  - 多功能流水线才有这样的划分。

**3. 部件级、处理机级及处理机间流水线**
- 按流水的级别划分
- 部件级流水线，又叫 *运算操作流水线*，是把处理机的算术逻辑部件分段，使得各种数据类型的操作能够进行流水。
- 处理机级流水线，又叫 *指令流水线*，是把解释指令的过程按照流水方式处理。
- 处理机间流水线，又叫 *宏流水线*，是由两个以上的处理机串行地对同一数据流进行处理，每个处理机完成一项任务。 

**4. 标量流水处理机和向量流水处理机**
- 按照数据表示来进行分类
- 标量流水处理机，是指处理机不具有向量数据表示，仅对标量数据进行流水处理。
  - 例如IBM360/91，Amdahl 470V/6等 
- 向量流水处理机，是指处理机具有向量数据表示，并通过向量指令对向量的各元素进行处理。
  - 例如TI ASC、STAR-100、CYBER-205、CRAY-1、YH-1等

**5. 线性流水线和非线性流水线**
- 按照是否有反馈回路来进行分类
- 线性流水线是指流水线的各段串行连接，没有反馈回路。
- 非线性流水线是指流水线中除有串行连接的通路外，还有 *反馈回路*。
  - 存在流水线调度问题。
  - 确定什么时候向流水线引进新的输入，从而使新输入的数据和先前操作的反馈数据在流水线中不产生冲突，此即所谓 *流水线调度* 问题。 
  - 一般不采用该方式

## 3.2 MIPS基本流水线

### 3.2.1 MIPS的一种简单实现

下图给出了实现MIPS指令的一种简单数据通路
![MIPS简单数据通路](bc5a2705/MIPS简单数据通路.png)
- 这是非流水方式
- 指令执行划分为5个阶段
  - 取指（IF）
    - 根据PC值从存储器中取出指令，并将指令送入指令寄存器IR；PC值增加4，指向顺序的下一条指令，并将下一条指令的地址放入临时寄存器NPC中。
    - IR←Mem[PC]，NPC←PC+4
![取指周期](bc5a2705/取指令周期.png)
  - 译码，读寄存器（ID）
    - 进行指令译码，读IR寄存器（指令寄存器），按照相应寄存器号读寄存器文件，并将读出结果放入两个临时寄存器A和B中。同时对IR寄存器中内容的低16位进行符号扩展，然后将符号扩展之后的32位立即值保存在临时寄存器Imm中。
    - A←Regs[IR6..10]
			B←Regs[IR11..15]
			Imm←((IR16)16##IR16..31)
![译码](bc5a2705/指令译码，读寄存器周期.png)
  - 执行，有效地址计算（EX）
    - 存储器访问：		    ALUoutput←A+Imm
	  - 寄存器-寄存器ALU：	ALUoutput←A op B
  	- 寄存器-立即值ALU:	  ALUoutput←A op Imm
  	- 分支操作：		      ALUoutput←NPC+Imm
					              Cond←(A op 0)
  	- 问题：为什么执行和有效地址计算可以合并？
![执行周期](bc5a2705/执行，有效地址计算周期.png)
  - 访存（MEM）
    - 访存操作：
      - Load：	LMD←LMDMEM[ALUoutput]
      - Store：	Mem[ALUoutput]←B
    - 分支操作：	if (Cond) PC←ALUoutput else PC←NPC
  - 写回（WB）
    - 寄存器-寄存器型ALU指令： Reg[IR16..20]←ALUoutput
    - 寄存器-立即值型ALU指令： Reg[IR11..15]←ALUoutput
    - Load指令：Reg[IR11..15]←LMD
![写回周期](bc5a2705/写回周期.png)	
  - 性能分析
    - 在该数据通路上，分支指令需要4个时钟周期，其它指令需要5个时钟周期。假设分支指令占总指令数的12%，问CPI=?
    - CPI=4×12%+5×(1-12%)=4.88
    - 结论：就性能和硬件开销而言，上述实现不是一种优化实现！
  - 改进方法
    - 在Mem周期完成ALU指令
    - 假设ALU指令数占指令总数的44%，则在时钟周期时间不变的同时，CPI可以降低至4.4
    - 如要进一步降低CPI，可能会增加时钟周期时间
    - 采用单周期实现，可以将CPI降低为1，但时钟周期时间却会增加为原来的5倍。一般不采用这种方法，为什么？（因为实际上并没有提高效率）
    - 流水技术

### 3.2.2 基本MIPS流水线

**1. 一种简单的MIPS流水线**
   - 将3.2.1中的数据通路流水化，使得数据通路中的每一个周期就成为流水线的一段
   - 每个时钟周期启动一条指令——得到了一条简单的MIPS流水线。
   - 简单MIPS流水线的流水过程：
     - 时-空图
     - 按时间错开的数据通路
![简单的MIPS流水线](bc5a2705/简单的MIPS流水线.png)
注意：纵坐标不是流水段，而是指令

**2. 实现流水技术应解决的一些问题** 
- 应保证流水线各段不会在同一时钟周期内使用相同的寄存器通路资源。
  - 例如，不能要求一个ALU既做有效地址计算，又做减法操作
  - IF与Mem两个阶段都要访问存储器，怎样避免访存冲突？
    - 使用 *哈佛结构*，将指令存储器和数据存储器分离
  - ID和WB两个阶段都要访问寄存器，是否存在冲突？怎样避免？
    - 将寄存器隔离，各自使用各自的资源（？）
- PC计算问题
  - 为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获得下一条指令的地址，并将其保存在PC中。
	- 但是，分支指令会改变PC的值，而且只有在Mem段结束时，这个新值才会被写入PC，出现矛盾。
	- 解决方法：
  	- 改变数据通路，在IF段完成PC计算。但分支指令如何处理？
  	- 处理分支指令可以在流水线中加入暂停周期，或设置延迟槽
- 合理划分流水段，每段内的操作都必须在一个时钟周期内完成。
- 流水线寄存器设计
  - 为防止寄存器中的值在为流水线中某条指令所用时被流水线中其它的指令所重写，可在流水线各段之间设置流水线寄存器文件，也称锁存器。
![流水段之间的锁存器](bc5a2705/各流水段之间的锁存器.png)
（分站后站间寄存器算哪站的？都可以，但不要不一致）
  - 流水线寄存器文件的命名
![流水线寄存器的命名](bc5a2705/流水线寄存器的命名.png)
  - 段A与B之间的流水线寄存器文件称为A/B
  - 流水线寄存器的作用
![流水线寄存器的作用](bc5a2705/流水线寄存器的作用.png)
当指令在流水线中流动时，其数据和控制信息也在同步地向前流动
  - 流水线寄存器文件的构成
![流水线寄存器的构成](bc5a2705/流水线寄存器的构成.png)

**3. MIPS流水线的操作**

- 在任一时刻，流水中的指令仅在流水线中的某一段内执行操作。
- 因此，只要知道每一流水段在各指令下进行何种操作，就知道了整个流水线的操作。
![MIPS流水线每个流水段的操作](bc5a2705/MIPS流水线每个流水段的操作.png)
![MIPS流水线每个流水段的操作（续）](bc5a2705/MIPS流水线每个流水段的操作（续）.png)

**4. MIPS流水线中多路选择器的控制**
- 主要是确定如何控制那四个多路选择器：
- ALU输入端的两个MUX由ID/EX.IR所指出的指令类型控制
- IF段的MUX由EX/MEM.Cond域的值控制
- WB段的MUX由当前指令类型(Load/ALU)控制
![MUX的控制](bc5a2705/DLX流水线中对多路选择器MUX的控制.png)

### 3.2.3 流水线性能分析

**三项性能指标：吞吐率、加速比和效率**

**1. 吞吐率**
- 是衡量流水线速度的重要指标
- 吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量。
- 最大吞吐率TPmax是指流水线在达到 *稳定状态*后所得到的吞吐率。
- 设流水线由m段组成，完成n个任务的吞吐率称为实际吞吐率，记作TP。

**(1) 最大吞吐率**
- 假设流水线各段时间相等，均为 $\Delta t_{0}$，则：$TP_{max} = \frac{1}{\Delta t_{0}}$
- 假设流水线各段时间不等，第 i 段时间为$\Delta t_{i}$，则：$TP_{max} = \frac{1}{max\{\Delta t_{0}\}}$
  - 最大吞吐率取决于流水线中最慢一段所需的时间，该段成为流水线的瓶颈（不均匀的流水线才能反映出流水线瓶颈问题）
  - 消除瓶颈的方法
    - 细分瓶颈段
    - 重复设置瓶颈段

**(2) 实际吞吐率**
- 若各段时间相等（假设均为$\Delta t_{0}$），则完成时间
$T_{流水} = m\Delta t_{0}+(n-1)\Delta t_{0}$
  - 实际吞吐率 $TP=\cfrac{1}{T_{流水}}=\cfrac{n}{m\Delta t_{0}+(n-1)\Delta t_{0}}=\cfrac{1}{(1+\frac{m-1}{n})\Delta t_{0}} = \cfrac{TP_{max}}{1+\frac{m-1}{n}}$
- 若各段时间不等（假设第i段为$\Delta t_{i}$），则完成时间为：
![流水线时空图（各段时间不等）](bc5a2705/流水线时空图（各段时间不等）.png)
$T=\sum\limits_{i=1}^{m}\Delta t_{i}+(n-1)\Delta t_{j}$
这里$\Delta t_{j}=max\{\Delta t_{i}\}$
实际吞吐率 $TP=\cfrac{n}{\sum\limits_{i=1}^{m}\Delta t_{i}+(n-1)\Delta t_{j}}$
- 不均匀流水线吞吐率的影响因素：深度、任务数、瓶颈段时间。

**2. 加速比**
- 加速比是指流水线速度与等功能的非流水线速度之比，加速比一定大于1。
- 根据定义可知，加速比 $S = T_{非流水}/T_{流水}$
- 若流水线为m段，每段时间均为 $\Delta t_{0}$，则 $T_{非流水}=nm\Delta t_{0}$
$T_{流水}=m\Delta t_{0}+(n-1)\Delta t_{0}$
加速比 $S=\cfrac{mn}{m+n-1}=\cfrac{m}{1+\frac{m-1}{n}}$

**3. 效率**
- 效率指流水线的设备利用率。
- 由于流水线有 *通过时间和排空时间*，所以流水线的各段并非一直满负荷工作，$E<1$
- 若各段时间相等，则各段效率也相等，即 $e1 = e2 = e3 =...= n\Delta t_{0}/T_{流水}$
- 整个流水线效率 $E=\cfrac{n}{m+n-1}=\cfrac{1}{1+\frac{m-1}{n}}$
当 $n\ll m$ 时，$E\approx 1$
- 从时-空图上看，效率就是n个任务所占的时空区与m个段总的时空区之比
- 根据这个定义，可以计算流水线各段时间不等时的流水线效率 $E=\cfrac{n个任务占用的时空区}{m个段总的时空区}$
- 时空图上的对应关系：忙的时间和总时间的比。算出来的是所有设备的平均效率。

**4. 吞吐率、加速比和效率的关系**
- 根据加速比 $S=\dfrac{mn}{m+n-1}=\dfrac{m}{1+\frac{m-1}{n}}$
和效率 $E=\dfrac{n}{m+n-1}=\dfrac{1}{1+\frac{m-1}{n}}$
可得，效率实际上是加速比 S 和最大加速比 m 的比值，即 $E=\dfrac{S}{m}$
- $E=n\Delta t_{0}/T_{流水}=(n/T_{流水})\Delta t_{0}=TP\Delta t_{0}$
当 $\Delta t_{0}$ 不变时，流水线的效率与吞吐率呈正比。为提高效率而采取的措施，也有助于提高吞吐率

**例题 3.1** 在静态流水线上计算 $\sum\limits_{i=1}^{4}A_{i}B_{i}$，问吞吐率、加速比、效率各是多少？

![静态流水线](bc5a2705/例3.1%20静态流水线.png)
![计算过程](bc5a2705/例3.1%20计算过程.png)
![时空图](bc5a2705/例3.1%20时空图.png)
![性能计算](bc5a2705/例3.1%20性能计算.png)

**上述方案性能不高，效率仅为 0.21**
- 静态多功能流水线在对某种功能进行处理时，总有某些段处于空闲状态
- 功能切换增加了前一种功能的排空时间和后一种功能的通过时间
- 需要把输出回传到输入（相关）
- 能否通过动态流水线改进其性能？
  - 设置多功能流水线，在加法未进行完时，便进行乘法流水（可以缩短进入时间和排空时间）
![多功能流水线](bc5a2705/例3.1改进：多功能流水线.png)
  - 当需要的乘法结果出来后立即执行加法流水，也可缩短一定的进入时间和排空时间
![加法提前](bc5a2705/例3.1改进：加法流水提前.png)

实际上这样设置流水线是有问题的，只有当前两个乘法完全执行完，才能执行加法，即在t=5 时才能执行第一个加法，在 t=7 时才能执行第二个加法，最后总时间为 19$\Delta t_{0}$。

![加法提前](bc5a2705/例3.1改进：加法流水提前（正确）.png)

**例 3.3** 在 MIPS 的非流水实现和基本流水线中，5个功能单元的执行时间：10/8/10/10/7ns。流水线额外开销为 1ns，求相对于非流水指令实现而言，基本 MIPS 流水线的加速比是多少？

注：流水线额外开销包括：流水寄存器的延迟（建立时间和传输延迟）以及时钟扭曲

**6. 有关流水线性能的若干问题**
- 流水线并不能减少（而且一般是增加）单条指令的执行时间，但能够提高吞吐率
- 增加流水线的深度可以提高流水线性能
- 流水线深度受限于流水线的延迟和额外开销
- 需要用高速锁存器作为流水线寄存器——Earle 锁存器
- 指令之间存在的**相关**，限制了流水线的性能

**Earle锁存器**
- 1965 年由 J.G.Earle 发明
- 优点
  - 对时钟扭曲不敏感（相对而言），一般是两级门延迟，避免了数据通过锁存器时可能产生的时钟扭曲
  - 在锁存器中可以执行两级逻辑运算，而不会增加锁存器的延迟时间，可以隐藏锁存器产生的额外开销
  - 锁存器是流水线技术存在的基本保证

## 3.3 流水线中的相关

**1. 什么是相关？**

- 流水线中的相关是指相邻或相近的两条指令因存在某种关联，后一条指令不能在原先指定的时钟周期开始执行。
- 消除相关的基本方法——暂停（stall）
  - 暂停流水线中某条指令及其后面所有指令的执行，该指令之前的所有指令继续执行。

**2. 三种不同类型的相关**

- **结构相关**：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突时将产生“结构相关”。
- **数据相关**：因一条指令需要用到前面指令的结果，而无法与产生结果的指令重叠执行时，就发生了数据相关。
- **控制相关**：当流水线遇到分支指令和其它会改变 PC 值的指令时就发生控制相关。

### 3.3.1 流水线的结构相关

![结构相关](bc5a2705/结构相关——访存冲突.png)

- 导致结构相关的常见原因：
  - 功能部件不是全流水
  - 重复设置的资源数量不足
- 实例：当数据和指令存在同一存储器中时，访存指令会引起存储器访问冲突。
- 解决方法：
  - I. 插入暂停周期

![插入暂停周期](bc5a2705/结构相关——插入暂停周期.png)

  - II. 将指令存储器和数据存储器分离
  - 避免结构相关的方法：
    - 所有功能单元完全流水化
    - 设置足够多的硬件资源
      - 但是，硬件代价很大！
    - 有些设计方案允许结构相关存在
      - 降低成本
      - 减少功能单元的延迟

**例 3.4** 当前许多机器都没有将浮点功能单元完全流水， 比如在MIPS实现中，浮点乘需要5个时钟周期，但对该指令不流水。请分析由此引起的结构相关对 mdljdp2 基准程序在MIPS上运行的性能有何影响？为简单起见，假设浮点乘法服从均匀分布。

解：mdljdp2中浮点乘法出现的频率约为14%。
最坏情况：每个浮点乘都无法与其它操作重叠执行，都需要5个周期，此时CPI为1.56 
最好情况：可以完全重叠执行，仅需要1个周期，此时没有性能损失

### 3.3.2 流水线的数据相关

#### 1. 数据相关简介

- 实例： 

```c
ADD	R1, R2, R3
SUB	R4, R1, R5
AND	R6, R1, R7
OR	R8, R1, R9
XOR	R10, R1, R11
```
- 产生原因：当指令在流水线中重叠执行时，流水线有可能改变指令读/写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据相关。
- 消除方法：向流水线中插入暂停周期（stall）

#### 2. 通过定向技术（Forwarding）减少数据相关带来的暂停

- 定向（Forwarding），也称为旁路技术（bypassing），转发技术
- 主要思路：将计算结果从其产生的地方直接送到真正需要它的地方，就可以避免暂停。
  - 寄存器文件 EX/MEM 中的 ALU 运算结果总是回送到 ALU 的输入寄存器
  - 从定向通路得到输入数据的 ALU 操作不必从源寄存器中读取操作数
  - 进一步推广：一个结果不仅可以从某一功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。
  - 在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。
  - 两条指令访问同一存储单元，也可能引起数据相关，例如访问数据 Cache 失效时。
  - 本章只讨论寄存器数据相关！

#### 3. 数据相关的分类

- 两条指令 i 和 j，都会访问同一寄存器R，假设i 先进入流水线，则它们对R有四种不同的访问顺序：

**(1) 写后读(RAW) —— i 写 j 读**

- 如果 j 在 i 完成写之前从 R 中读出数据，将得到错误的结果！
- 最常见的数据相关，严重制约了 CPU 的性能，是程序最重要的特征之一！

**(2) 写后写(WAW) —— i 写 j 写**

- 如果 j 在 i 之前完成写操作，R 中将保存错误的结果！
- MIPS 流水线不会出现这种相关！
- 当流水线中有多个段可以写回，而且当流水线暂停某条指令的执行时，其后的指令可以继续前进时，可能引起这种类型的相关。

![写后写相关](bc5a2705/数据相关——写后写相关.png)

**(3) 读后写(WAR) —— i 读 j 写**

- 如果 j 先将数据写入 R，i 将读出错误的结果！
- MIPS流水线不会出现这种类型的相关！
- 当有些指令在流水段后半部分读源操作数，另一些指令在流水线前半部分写结果，可能引起这种类型的相关。

**(4) 读后读(RAR) —— i 读 j 读**

- 不引起数据相关！

#### 4. 需要暂停的数据相关

- 并非所有数据相关都可以通过定向技术解决。
- 例：  LW	R1，0（R2）
       SUB	R4，R1，R5
       AND	R6，R1，R7
       OR	R8，R1，R9
- 增加流水线“流水线互锁”部件，当互锁硬件发现这种相关后，就暂停流水线，直到相关消除。
- 这种情况下，暂停的时钟周期数称为**载入延迟**。
![定向技术不能解决的数据相关](bc5a2705/定向技术不能解决的数据相关.png)

#### 5. 对数据相关的编译调度方法
- 流水线中常常会遇到多种类型的暂停
- 例如，计算表达式 $A=B+C$ 时会出现暂停
- 编译器可以通过重新排列代码的顺序来消除这种暂停，这种技术就是**流水线调度**或**指令调度**
- 软件上的方法有时会使事情变得轻而易举，但这取决于编译器的智能。


**例 3.6**请为下列表达式生成没有暂停的MIPS指令序列 $a = b – c$，$d = e – f$，假设载入延迟为1个时钟周期。
分析：为了避免数据相关，需要调整指令的顺序，并合理利用 Forwarding 技术。

#### 6. 对 MIPS 流水线控制的实现
- 指令发射：指令从流水线的**译码段**进入**执行段**的过程称为指令发射。
- 检测数据相关
  - ID 段可以检测所有数据相关
  - 在使用一个操作数的时钟周期的开始(EX 和 MEM 段的开始)检测相关，并确定必需的定向
  - 流水线相关硬件可以检测到的各种相关情况
![硬件可以检测到的各种相关](bc5a2705/流水线相关检测硬件可以检测到的各种相关情况.png)

- 例：Load 互锁的检测与实现
  - 在 ID 段检测是否需要启动 Load 互锁，必须进行三种比较
  - 一旦检测到相关，控制部件必须在流水线中插入暂停周期，并使 IF 和 ID 段中的指令停止前进
    - 将 ID/EX 中控制部分清 0
    - 保持 IF/ID 的内容不变
- 定向逻辑的实现
  - 所有的定向都是从 ALU/DM 的输出到 ALU、DM 或 0 检测单元的输入
  - 形成了一个旁路网络
    - 需要比较哪些信息？
    - ALU输入端应采用多少个输入的 MUX？

![定向路径](bc5a2705/定向路径.png)

### 3.3.3 流水线的控制相关

#### 1. 分支指令的实现
- 一旦分支转移成功，正确的地址要在 Mem 段的末尾才会被写入 PC
- 一旦 ID 段检测到分支指令，就暂停执行其后的指令，直到分支指令达到 Mem 段，确定新的 PC 为止
- 分支转移成功将导致 MIPS 流水线暂停 3 个周期
- 这是引起更大暂停的另一类相关
- 没有控制流指令的指令集机器是很不好用的
- 在事务处理应用中，分支跳转等指令占有相当大的比重。
![分支成功将暂停3个时钟周期](bc5a2705/分支转移成功将导致暂停3个时钟周期.png)

#### 2. 减少分支开销的途径
- 两个基本途径：同时采用，缺一不可！
  - 在流水线中尽早判断分支转移是否成功
  - 转移成功时，尽早计算出转移目标地址
- 经改进，MIPS流水线可以将分支开销减少1拍
  - 将 $=0?$ 测试提前到 ID 段
  - 在 ID 段增加一个加法器，计算分支目标地址
  - 表 3.6 列出了改进后流水线的分支操作
  - 第一种改进，注意分支结果在 EX 段有效。
![修改DLX以减少分支开销](bc5a2705/修改DLX以减少分支开销.png)
![分支指令操作](bc5a2705/分支指令操作.png)
- 再改进，MIPS 流水线可以将分支开销再减少 1 拍
  - 将分支判断结果和目标地址提前到 ID/EX 站前
  - 第二步改进，这次分支结果在 ID 段有效！！！
![修改DLX以减少分支开销](bc5a2705/修改DLX以减少分支开销（再改进）.png)

#### 3. 程序中分支指令的行为特点
**(1) 各种能改变PC值的指令的执行频度**
- 条件分支：
  - 整数程序：14-15%
  - 浮点程序：3-12%
  - 其中，向前分支与向后分支的比：3:1
- 无条件分支：≤4%（绝大多数）

**(2) 条件分支转移成功的概率**
- 向前转移成功：60%；向后转移成功：85%
![条件分支转移成功的概率](bc5a2705/条件分支转移成功的概率.png)

#### 4. 减少流水线分支损失的方法
**(1) 冻结或排空流水线**
- 思路：在流水线中暂停或删除分支后的指令，直到得到转移目标地址
- 优点：简单

**(2) 预测分支转移失败**
- 思路：流水线继续照常流动，如果分支转移成功，将分支指令后的指令转换为空操作，并从分支目标处开始取指令执行；否则照常执行
- 实际发生的成功分支多，就应该在硬件上预测成功，反之则预测失
- 所谓预测，就是在硬件执行时把分支当作全部成功或全部失败
- MIPS流水线的处理过程
![DLX流水线对分支的处理过程](bc5a2705/DLX流水线对分支的处理过程.png)

**(3) 预测分支转移成功**
- 思路：始终假设分支成功，直接从分支目标处取指令执行
- 对 MIPS 流水线没有任何好处！

**(4) 延迟分支（delayed branch）**
- 思路：分支开销为 n 的分支指令后紧跟有 n 个延迟槽，**流水线遇到分支指令时，按正常方式处理**，顺带执行延迟槽中的指令，从而减少分支开销。
- 延迟槽指令不影响后续指令执行，编译器动态调度
- 延迟分支及指令的执行顺序
![延迟分支以及指令的执行顺序](bc5a2705/延迟分支以及指令的执行顺序.png)
- 具有一个分支延迟槽的MIPS流水线的执行过程
![具有一个分支延迟槽的MIPS流水线的执行过程](bc5a2705/具有一个分支延迟槽的MIPS流水线的执行过程.png)

- 什么样的指令能否放入分支延迟槽？
  - 三种调度方法：从前调度；从目标处调度；从失败处调度
![分支延迟指令的三种调度方法](bc5a2705/分支延迟指令的三种调度方法.png)
  - 三种方法的要求与效果，存在限制因素
    - 编译器预测分支是否成功的能力
    - 放入延迟槽中的指令
![三种调度方法的要求及效果](bc5a2705/三种调度方法的要求及效果.png)
  - 取消分支
  	- 思路：分支指令中包含预测方向，若预测正确，正常执行延迟槽中的指令，否则将其转换为空操作
![取消分支](bc5a2705/取消分支.png)

#### 5. 各种分支处理方法的性能
- 假设理想CPI=1，则加速比
$S=D/(1+C)=D/(1+f×p_{分支})$
  - 这里，D 为流水线的深度，p 分支为分支开销，C 为分支引起的流水线暂停时钟周期数(每条指令的平均值)，f 为分支的出现频度。
- 表 3.7 列出了流水线中各种处理方法的开销
![各种减少分支损失方法的效果](bc5a2705/各种减少分支损失方法的效果.png)

#### [补充] 流水线数据相关与冒险（冲突）
在组成原理中，流水线相关包含数据相关，结构相关，控制相关，这里的**相关**在体系结构中应该称作为**冲突**（或冒险），实际上相关和冲突在含义上有一些不同

在体系结构中有 3 种不同类型的相关：**数据相关**（也叫真数据相关）、**名相关**和**控制相关**

##### 数据相关

若：
- 指令 i 生成的结果可能会被指令 j 用到
- 指令 j 数据相关于指令 k，指令 k 相关于指令 i

那么指令 j 数据相关于指令 i

要说明的是，数据相关**可能**会导致数据冒险

##### 名相关（名称相关）

当两条指令使用相同的寄存器或存储器位置（称为名称），但与该名称相关的指令之间没有数据流动时，就会发生名相关

- 当指令 j 对指令 i 读取的寄存器或存储器位置执行写操作时，会发生**反相关**
- 当指令 i 和指令 j 对同一个寄存器或存储器位置执行写操作时，会发生**输出相关**

由于没有在指令之间传递值，所以反相关和输出相关都是名称相关，与真数据相关相对。因为名称相关不是真正的相关，因此如果改变这些指令中使用的名称，使这些指令不再冲突，这些指令便可以同时执行，或者重新排序。

##### 数据冒险（数据冲突）

- 写后读（RAW），与**真数据相关**对应
- 写后写（WAW），与**输出相关**对应
- 读后写（WAR），源于**反相关**，或**名称相关**
- 读后读（RAR），不是冒险

## 3.4 实例分析：MIPS R4000

### 3.4.1 MIPS R4000的整型流水线

**1. 指令集：64位MIPS-3指令集**

**2. MIPS R4000流水线结构**
- 超流水结构（superpipeling）
- 访存操作流水化

**3. 流水线各段的功能**
![R4000流水线各段功能](bc5a2705/R4000流水线各段功能.png)

**4. 指令序列在流水线中的重叠执行过程**
- 定向+插入暂停周期
- 定向不一定是相邻指令
- 结构不同，定向和暂停机制所对应的硬件结构也不同
![指令序列在R4000流水线中的重叠执行过程](bc5a2705/指令序列在R4000流水线中的重叠执行过程.png)

**5. 载入延迟为两个时钟周期**
- 实际上在 DS 阶段数据已经计算出来，后一个阶段 TC 是将数据写入存储器（WB 阶段写入寄存器），而进行旁路时，无需将其写入存储器便可以得到数据，因此载入延迟为两个时钟周期
![载入延迟为两个时钟周期](bc5a2705/载入延迟为两个时钟周期.png)

**6. 指令序列在流水线中的执行时空图**
![R4000流水线的执行时空图](bc5a2705/R4000流水线的执行时空图.png)

**7. R4000流水线的定向路径远多于MIPS流水线**
	- ALU输入端的定向源有4个：EX/DF，DF/DS，DS/TC，TC/WB
![R4000流水线ALU输入的四个定向源](bc5a2705/R4000流水线ALU输入的四个定向源.png)


**8. 分支处理**
- 在 EX 段完成分支条件的计算，基本分支延迟为3个时钟周期
![R4000流水线基本分支延迟](bc5a2705/R4000流水线基本分支延迟.png)
- 分支处理策略
  - 单周期延迟分支
  - 从失败处调度
![R4000流水线处理分支指令的时空图](bc5a2705/R4000流水线处理分支指令的时空图.png)

### 3.4.2 MIPS R4000的浮点流水线

- 包括浮点除法器、浮点乘法器和浮点加法器各1个
- 分为8段（表3.9）
![R4000浮点流水线中8个流水段](bc5a2705/R4000浮点流水线中8个流水段.png)
- 多功能非线性流水线
- 双精度浮点操作指令延迟、初始化间隔和流水段的使用情况（表3.10）
![双精度浮点操作指令延迟、初始化间隔和流水段的使用情况](bc5a2705/双精度浮点操作指令延迟、初始化间隔和流水段的使用情况.png)

### 3.4.3 MIPS R4000流水线性能分析

**1. 引起流水线暂停的四个主要原因**
- 载入暂停
- 分支暂停
- 浮点结果暂停
- 浮点结构性暂停

**2. 暂停对MIPS R4000流水线CPI的影响**
![暂停对R4000流水线CPI的影响](bc5a2705/暂停对R4000流水线CPI的影响.png)

## 3.5 向量处理机

**1. 什么是向量机？**
- 具有向量数据表示和相应向量指令的流水线处理机称为向量流水线处理机，也称向量处理机。
- 与之对应的是标量处理机，不支持向量数据表示，没有提供向量指令。

**2. 实例：一个简单的FORTRAN循环程序**
$$
  DO \quad 10 \quad i=1, N \\
	10 \quad d[i] = a[i]*(b[i]+c[i])
$$

### 3.5.1 向量处理方式和向量处理机

- 水平（横向）处理方式
- 垂直（纵向）处理方式
- 分组（纵横）处理方式
  - 将长度为N的向量分为m组，每组有n个元素，组内按纵向方式处理，依次处理各组。
  - 需要m次迭代；每次迭代执行两条向量指令，有1次数据相关，需要2次功能切换
  - 需要寄存器-寄存器型操作的运算流水线
  - 这种技术称为**向量循环**或**分段开采**

**例3.8** 设 A 和 B 是长度为N的向量，考虑在一个向量长度为 64 的向量处理机上实现如下的循环操作：
DO 10 I=1, N
10 A(I) = 5.0 * B(I) + 1.0

(1) 当N≤64时
![N<=64](bc5a2705/N小于等于64.png)
(2) 当N>64时，需要进行分段开采
![N>64](bc5a2705/N大于64.png)

**4. 向量处理机的速度评价方法**
- 由于一条指令最多得到一个结果，标量处理机通常用每秒执行多少条指令(MIPS)来衡量机器的运算速度
- 向量处理机用每秒取得多少浮点运算结果来衡量机器速度，以 MFLOPS 作为测量单位
- 采用 MFLOPS 可以忽视 Load、Store、分支、测试等类型指令的影响
- 一般认为，在标量计算机中执行一次浮点运算，平均需 3 条指令。因此，如果要把这两种速度指标放在一起比较，就应该把 MFLOPS 乘以一个系数，以得到相应的 MIPS
- 比较法：选择一台速度指标得到公认的机器作为标准机，给定一些典型的基准程序，分别在标准机和被测机上求解。 

### 3.5.2 向量处理机实例分析

**实例：Cray-I**

#### 1. 性能指标

1GFLOPS、主频80M、向量长度64

#### 2. 基本结构

- 向量运算部件
- 向量寄存器组（V0-V7）
- 向量长度寄存器
- 向量屏蔽寄存器
![CRAY-1的基本结构](bc5a2705/CRAY-1的基本结构.png)

#### 3. 向量指令类型

- $V_k ← V_i \,op \,V_j$（两个向量操作）
- $V_k ← S_i \,op \,V_j$（一个向量一个标量操作）
- $V_k ← Mem$（取数据）
- $Mem ← V_k$（存数据）
- 功能部件冲突：同一功能部件被一条以上的并行工作向量指令所使用
- $V_i$ 冲突：并行工作的各向量指令具有相同的源向量或结果向量
![CRAY-1的向量指令类型.png](bc5a2705/CRAY-1的向量指令类型.png)

#### 4. CRAY-I 体系结构特点

- 向量寄存器与功能单元的连接通路
  - 每个 $V_i$ 块都有**单独总线**可连到所有向量功能部件，而每个向量功能部件也各自都有把运算结果送回向量寄存器组的总线（寄存器组和功能部件全相连）
- 向量链接技术
  - 一个向量功能部件得到的结果直接送入另一个向量功能部件的操作数寄存器时所发生的连接过程称为链接。
![CRAY-1的链接技术](bc5a2705/CRAY-1的链接技术.png)
  - 上图中，当完成 $V_1+V_2$ 时，将值送入 $V_3$ 的同时送入下一个乘法流水线作为其中的被乘数（其实我感觉有点像处理数据相关时的 Forwarding 技术）。
- 当两条指令出现“写后读”相关时，若它们不存在功能部件冲突和向量寄存器(源或目的) 冲突，就有可能把它们所用的功能部件头尾相接，形成一个链接流水线，进行流水处理。
- 链接特性实质上是把流水线“定向”的思想引入到向量执行过程的结果

#### 5. 向量链接技术实例分析
**例3.7** 对向量运算 D=A*(B+C)，若向量长度 N≤64，向量元素为浮点数，则在B、C取到V0、V1后，就可用以下三条向量指令求解：
V3←存储器	(访存，载入A)
V2←V0＋V1	(浮点加)
V4←V2*V3	(浮点乘，将D存入V4) 

假设：向量处理机将元素从 $V_i$ 送往功能部件及把结果存入 $V_i$ 都需要1拍；浮点加法和访存操作都需要 6 拍；浮点乘操作需要 7 拍。
这样，第一个结果被存入 $V_4$ 需要经过：
- 1(送)+ 6(浮加) +1(入)+1(送)+7(浮乘)+1(入)=17(拍)
- 此后，每拍将得到一个结果送入 $V_4$。
总的完成时间为：17+（N-1）拍

#### 6. 向量链接技术应考虑的问题
- 设定合适的向量功能部件和操作数寄存器
- 链接时机问题
  - 只有在前一条向量指令的第一个结果元素送入结果向量寄存器的那一个时钟周期才可以进行链接
  - 只有当前一条向量指令全部执行完毕，释放相应的向量寄存器资源后才能执行后面的向量指令
  - 所有可以链接执行的向量指令的向量长度应相等
  - 总结链接的时机：普适的原则
---