<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo-blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo-blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo-blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo-blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo-blog/css/main.css">


<link rel="stylesheet" href="/hexo-blog/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cherryyang05.github.io","root":"/hexo-blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第六章 输入输出系统 国防科大计算机体系结构课程第六-八章笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机体系结构课程笔记（四）">
<meta property="og:url" content="https://cherryyang05.github.io/hexo-blog/767f71ea.html">
<meta property="og:site_name" content="北极熊不吃企鹅宝宝">
<meta property="og:description" content="第六章 输入输出系统 国防科大计算机体系结构课程第六-八章笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%B7%AE%E8%B7%9D.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/MM1%E6%8E%92%E9%98%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%93%E8%AE%BA.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%200.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%206.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%9B%A0%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO%E4%B8%8ECache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83.png">
<meta property="og:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E8%99%9A%E6%8B%9FDMA%E6%8A%80%E6%9C%AF.png">
<meta property="article:published_time" content="2022-01-31T22:18:17.000Z">
<meta property="article:modified_time" content="2024-09-09T16:45:04.422Z">
<meta property="article:author" content="Cherry">
<meta property="article:tag" content="体系结构">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%B7%AE%E8%B7%9D.png">

<link rel="canonical" href="https://cherryyang05.github.io/hexo-blog/767f71ea.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机体系结构课程笔记（四） | 北极熊不吃企鹅宝宝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/hexo-blog/atom.xml" title="北极熊不吃企鹅宝宝" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo-blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">北极熊不吃企鹅宝宝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">为什么呢？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo-blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/hexo-blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo-blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/hexo-blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">56</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/hexo-blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/hexo-blog/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cherryyang05.github.io/hexo-blog/767f71ea.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo-blog/images/avatar2.png">
      <meta itemprop="name" content="Cherry">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北极熊不吃企鹅宝宝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机体系结构课程笔记（四）
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-31 22:18:17" itemprop="dateCreated datePublished" datetime="2022-01-31T22:18:17+00:00">2022-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-09 16:45:04" itemprop="dateModified" datetime="2024-09-09T16:45:04+00:00">2024-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo-blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">体系结构</span></a>
                </span>
            </span>

          
            <span id="/hexo-blog/767f71ea.html" class="post-meta-item leancloud_visitors" data-flag-title="计算机体系结构课程笔记（四）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/hexo-blog/767f71ea.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/hexo-blog/767f71ea.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h1><blockquote>
<p>国防科大计算机体系结构课程第六-八章笔记</p>
</blockquote>
<span id="more"></span>

<h2 id="6-1-存储设备"><a href="#6-1-存储设备" class="headerlink" title="6.1 存储设备"></a>6.1 存储设备</h2><h3 id="6-1-1-磁盘"><a href="#6-1-1-磁盘" class="headerlink" title="6.1.1 磁盘"></a>6.1.1 磁盘</h3><ul>
<li>磁盘始终占据着后备存储器的主宰地位。原因有二：<ul>
<li>磁盘一直是虚拟存储器技术的物质基础，执行程序时，磁盘用作为交换缓冲区</li>
<li>关机时，磁盘作为操作系统和所有应用程序的非易失性的驻留介质</li>
<li>磁盘是最重要的 I&#x2F;O 设备，是存储层次中辅存的载体，发展比较平缓</li>
</ul>
</li>
<li>磁盘由一组绕轴旋转的盘片组成，盘片的数量为 1~20 片</li>
<li>磁盘系统的转速一般在每分钟 3600 转到 15000 转之间，即 3600rpm~15000rpm</li>
<li>磁道（每一个盘片有 5000~30000 条磁道）。</li>
<li>扇区（每条磁道分为 100~500 个扇区）。所有磁道具有相同数目的扇区</li>
</ul>
<h4 id="磁盘访问时间计算"><a href="#磁盘访问时间计算" class="headerlink" title="磁盘访问时间计算"></a>磁盘访问时间计算</h4><p><strong>1. 寻道时间</strong></p>
<ul>
<li>若要读写扇区，磁盘控制器发出命令首先将磁头移动到包含有所需数据的磁道上，这个过程称为“寻道”，所需要的时间叫做“寻道时间”</li>
<li>最小寻道时间、最大寻道时间和平均寻道时间。常见的平均寻道时间的公布值约为 6ms 到 20ms，实际应用当中的平均寻道时间约为公布值的 25% 到 33%<br><strong>2. 旋转时间</strong></li>
<li>所需扇区转到磁头之下所需要的时间称为旋转时间。大部分磁盘的转速在3600rpm到10,000rpm，平均延迟是磁盘转半圈的时间，所以对大部分磁盘的平均旋转时间 $T_AR&#x3D;3ms~8.3ms$<br><strong>3. 传输时间</strong></li>
<li>传输时间是指在磁头下传输一个数据块(通常是一个扇区)所需花的时间。它由块的大小、旋转速度、磁道记录密度和连接磁盘电子器件的速度确定</li>
<li>数据传输率有两个：一是从盘面到缓冲存储器的<strong>内部传输率</strong>；一是从缓冲存储器到主机的<strong>外部传输率</strong><ul>
<li>内部数据传输率：硬盘将数据从盘片上读取出，交给硬盘上的缓冲存储器的速度。也被称作硬盘的持续传输率（Sustained Transfer Rate），它取决于<strong>硬盘转速</strong>和<strong>盘片位密度</strong>。内部传输率等于磁头相对磁盘的线速度与磁盘位密度之积。外部传输率是以内部传输率为基础的，有效地提高硬盘的内部传输率才能对磁盘性能有最直接、最明显的提升</li>
<li>外部传输率：计算机通过磁盘接口从硬盘的缓存中将数据读出，交给相应的控制器的速度；被称为突发数据传输率（Burst Data Transfer Rate）。外部数据传输率和磁盘的接口有关，目前已有 IDE、EIDE、Ultra-EIDE、SCSI、Fast and Wide-SCSI、FC-AL 等接口。ATA-6 接口的速度已经达到 133MB&#x2F;s</li>
</ul>
</li>
<li>内部传输率等于记录的位密度乘以盘面旋转的线速度。外部传输率则与接口有关<br><strong>4. 控制器时间</strong></li>
<li>控制磁盘及磁盘与主存之间数据传输，需要一系列的控制器和通道来完成</li>
<li>控制器时间是控制器在执行I&#x2F;O访问时的额外开销</li>
</ul>
<p><strong>因此，磁盘访问时间&#x3D;寻道时间+旋转时间+传输时间+控制器时间</strong></p>
<p><strong>磁盘访问时间例题</strong><br>对于目前一般的磁盘而言，读或写一个 512 字节的扇区的平均时间是多少？假设此时磁盘空闲，这样没有排队延迟；公布的平均寻道时间是 9ms，传输速度是 4MB&#x2F;s，转速是 7200rpm，控制器的开销是 1ms</p>
<p><strong>[分析]</strong></p>
<ul>
<li>寻道时间 &#x3D; 9ms</li>
<li>旋转时间 &#x3D; 0.5 &#x2F; 7200rpm &#x3D; 4.2ms</li>
<li>传输时间 &#x3D; 0.5KB &#x2F; 4.0MB&#x2F;s &#x3D; 0.125ms</li>
<li>控制器时间 &#x3D; 1ms</li>
<li>因此访问时间 &#x3D; 9 + 4.2 + 0.125 + 1 &#x3D; 14.3ms</li>
</ul>
<h4 id="磁表面记录密度"><a href="#磁表面记录密度" class="headerlink" title="磁表面记录密度"></a>磁表面记录密度</h4><ul>
<li><p>磁盘记录数据的密度一般用“磁表面记录密度”来表示，也就是每平方英寸上的位数：</p>
<ul>
<li>1988年前，每年增长约 29%，即 3 年翻一番；</li>
<li>~1996年后，每年增长 60%，即 3 年翻四番。</li>
<li>~2001年，每年增长 100%，2001 年实验室中可达每平方英寸600亿位</li>
</ul>
</li>
<li><p>提高转速可以提高数据传输速率。旋转速度越高，数据就可以越快到达驱动器读写头能够接触的位置。目前硬盘最大转速为 15000RPM。但转速提高也带来一些弊端，例如工作噪音和发热量变大，工作状态下的抗冲击能力也有所下降等。</p>
</li>
<li><p>提高记录密度。目前采用的技术主要有：提高单碟容量以及改进信号处理技术。由于单碟容量越大的硬盘数据密度越高，磁头的寻道频率与移动距离可以相应的减少，从而减少了平均寻道时间，内部传输速率也得到了提高</p>
</li>
<li><p>在传统的纵向记录技术中，为了提高面密度以增加总的存储容量，必须压缩数据位并使其更紧密地排列在一起。然而，如果数据位太小，为其定位的磁能也会相应减小，小到一定程度后热能就可能会使其退磁，存储的数据就会丢失，这一现象被称为<em>超顺磁性</em>。为了避免超顺磁性效应，磁盘介质制造商一直在努力提高介质的矫顽磁性(写一个数据位所需要的‘磁场’ ) 。不过，能施加的磁场大小会受到磁头材料的限制</p>
</li>
<li><p>而在垂直记录技术(Perpendicular Magnetic Recording)中，盘片的磁化不像目前水平记录技术那样发生在盘片所在的平面上，而是发生在与盘片相垂直的平面上。这样一来，数据位就是指向上或向下的定向磁化区域。(在水平记录技术中，数据位的磁化是在磁盘平面上，在与磁头运动方向相同和相反的点之间翻转。)介质淀积在软磁衬底上，衬底的作用是作为写磁场返回路径的一部分并有效地生成记录磁头的镜像，这将使记录磁场增强一倍，故能达到比水平记录技术更高的记录密度。值得一提的是，垂直记录并不会因这项强化而提高功率消耗或产生更高热能，这对于对耗电与热量敏感的笔记本领域非常关键。此外，垂直记录也因为能够强化数据对于热衰退的阻抗能力从而提升硬盘可靠性。对于生产厂商来说，垂直记录技术将可延长磁盘储存装置的发展年限，对消费者来说，则可提供更高容量的硬盘容量</p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%B7%AE%E8%B7%9D.png" alt="磁盘和半导体存储器之间的访问时间差距"></p>
<p>磁盘在后备存储器上的地位曾受到过多次考验，主要原因就是所谓“访问时间差距”问题。磁盘与 DRAM 的性能价格比差异很大。虽然 DRAM 的数据传输率约为磁盘的 50 倍，但是其访问时间却是磁盘的十万分之一</p>
<h3 id="6-1-2-Flash-存储器和固态硬盘-SSD"><a href="#6-1-2-Flash-存储器和固态硬盘-SSD" class="headerlink" title="6.1.2 Flash 存储器和固态硬盘 SSD"></a>6.1.2 Flash 存储器和固态硬盘 SSD</h3><ul>
<li>SSD的优点是：<ul>
<li>永久性；</li>
<li>速度快；</li>
<li>高传送速率和高可靠性。</li>
</ul>
</li>
<li>SSD的最大缺点是：<ul>
<li>有限擦写次数<ul>
<li>磨损均衡（动态、静态）</li>
</ul>
</li>
<li>成本太高，每 MB 的价格大约是磁盘价格的 50 倍</li>
</ul>
</li>
</ul>
<h3 id="6-1-3-磁带"><a href="#6-1-3-磁带" class="headerlink" title="6.1.3 磁带"></a>6.1.3 磁带</h3><ul>
<li>磁盘和磁带性能价格比的差异主要取决于它们的机械构成<ul>
<li>磁盘盘片具有有限的存储面积，并且存储介质被封装在每个读部件内，提供 ms 级的随机访问</li>
<li>磁带绕在可转动轴上，一个读部件可以使用多盘磁带(没有长度限制)，但磁带需要顺序访问，每次访问都可能需要较长的反绕、退出和加载时间，等待时间较长(数秒)</li>
</ul>
</li>
<li>对磁带而言，最大的优点是容量极大、技术成熟、单位价格低廉。最大的缺点是访问时间较长。这种差异恰好使得磁带成为磁盘的备份技术。</li>
<li>宽 0.38cm<del>1.27cm;长 183m</del>731.5m;(110G 以上）</li>
<li>磁带技术的主要受限因素是在其线速度不定，为解决该问题，提出了“螺旋扫描磁带(Helical Scan Tapes)”，使磁带保持同样的线速度，这种技术以 20 到 50 的倍数增加记录密度，螺旋扫描磁带目前已被普遍使用在视频录像设备中，大大降低了磁带和读部件的开销</li>
<li>磁带的另外一个缺点是易磨损，螺旋磁带只能使用几百遍，传统的高质量磁带则可以使用几百万遍。螺旋扫描磁头同样容易磨损，通常额定指标为连续使用 2000 小时</li>
<li>为了解除操作中的负担，同时也加速换带速度，便产生了自动磁带库。自动磁带库通过机械手自动地安装和更换磁带，相当于又提供了一个新的存储器层次，这种自动化的磁带库可在无人工干预的情况下，十几秒内访问几TB的信息</li>
<li>STC 的 PowderHorn 可以处理 6000 个磁带，提供的总容量达 60TB</li>
</ul>
<h3 id="6-1-4-光盘"><a href="#6-1-4-光盘" class="headerlink" title="6.1.4 光盘"></a>6.1.4 光盘</h3><ul>
<li>只读类光盘的全称为<code>光学紧密盘(Optical Compact Disk)</code>，简称 CD-ROM。</li>
<li>特点是：<ul>
<li>容量大(640M字节)、存储寿命长；</li>
<li>成本低、读出设备价格便宜；</li>
<li>便于保管、便于携带等。</li>
</ul>
</li>
<li>最大问题是不能够写入。因此 CD-ROM 适于作为软件和资料的载体，基本已经替代了几年前广泛使用的软盘</li>
<li>可写类光盘包括两类：<ul>
<li>一次性写：称为可记录光盘 <code>CD-R(CD-Recordable)</code>，又称为 <code>WORM</code> 盘，出厂时是空白的，用户通过写入设备，将数据写入 <code>CD-R</code> 中。特性与 <code>CD-ROM</code> 相当，可以通过普通的 <code>CD-ROM</code> 读设备读出，因此特别适合于作为数据备案的存储介质。</li>
<li>多次写：称为 <code>WMRM(Write Many Read Many)</code> 盘，主要采用磁光(MO)存储技术</li>
</ul>
</li>
<li>MO光盘的容量更大(有 600MB、1.2GB、2.4GB 等规格)、保存和使用都很方便、便于携带，最大的问题是目前盘片和读写设备的价格昂贵，且各厂家的标准不统一，因此不够普及。这种 WMRM 盘作为大型软件编制、多媒体软件产品研制过程中的备案介质是非常合适的</li>
<li>多台光盘机组合在一起有三种结构：<ul>
<li>光盘库(也叫自动换盘机，即Jukebox)<ul>
<li>光盘库是一种能自动把机框中存放的许多片光盘选出并装入光盘机进行读写的设备</li>
<li>费用低；</li>
<li>可兼容性及低风险；</li>
<li>随机存取；</li>
<li>存储寿命长、保管容易、占用空间少；</li>
<li>具有多媒体功能</li>
</ul>
</li>
<li>光盘塔(CD-ROM Tower)<ul>
<li>优点：<ul>
<li>安装简便；易于管理；使用便利；</li>
<li>资源共享；远程访问；</li>
<li>寿命长；结构简单；造价也低；</li>
<li>读取光盘速度快。</li>
</ul>
</li>
<li>缺点：<ul>
<li>容量较小；光盘塔中光盘机数量受到 SCSI 设备地址数的限制</li>
</ul>
</li>
</ul>
</li>
<li>光盘阵列(CD-ROM Array)<ul>
<li>从阵列技术的基本原理来说，光盘阵列与磁盘阵列有一定的相似性。但光盘具有盘片可换、每道(柱面)只有一个读写头、寻道时间较长等特点，因此光盘阵列技术又有其特殊性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-I-x2F-O-系统分析与评价"><a href="#6-2-I-x2F-O-系统分析与评价" class="headerlink" title="6.2 I&#x2F;O 系统分析与评价"></a>6.2 I&#x2F;O 系统分析与评价</h2><h3 id="1-I-x2F-O性能与系统响应时间"><a href="#1-I-x2F-O性能与系统响应时间" class="headerlink" title="1. I&#x2F;O性能与系统响应时间"></a>1. I&#x2F;O性能与系统响应时间</h3><ul>
<li>衡量I&#x2F;O系统性能的标准<ul>
<li>I&#x2F;O系统的容量(能连几个 USB 等)</li>
<li>响应时间</li>
<li>吞吐率</li>
</ul>
</li>
<li>响应时间和吞吐率之间存在矛盾<ul>
<li>生产服务模型</li>
</ul>
</li>
</ul>
<h3 id="2-Little-定律"><a href="#2-Little-定律" class="headerlink" title="2. Little 定律"></a>2. Little 定律</h3><ul>
<li>I&#x2F;O系统的响应时间和吞吐率的计算<ul>
<li>排队论</li>
<li>黑箱(Black Box)</li>
</ul>
</li>
<li>Little定律<ul>
<li>系统中的平均任务数 &#x3D; 到达率×平均响应时间</li>
</ul>
</li>
</ul>
<h3 id="3-M-x2F-M-x2F-1-排队系统"><a href="#3-M-x2F-M-x2F-1-排队系统" class="headerlink" title="3. M&#x2F;M&#x2F;1 排队系统"></a>3. M&#x2F;M&#x2F;1 排队系统</h3><ul>
<li><p>M&#x2F;M&#x2F;1排队系统一般假设为：</p>
<ul>
<li>系统为一个平衡系统</li>
<li>连续两个到达请求的时间间隔服从<strong>指数分布</strong>，其均值为平均到达时间</li>
<li>请求的个数不受限制</li>
<li>如果排队中有任务，服务员服务完当前任务后立即服务下一个</li>
<li>队列无限长，FIFO 规则</li>
<li>系统只有一个服务员</li>
</ul>
</li>
<li><p>相关结论<br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/MM1%E6%8E%92%E9%98%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%93%E8%AE%BA.png" alt="MM1排队系统的相关结论"></p>
</li>
<li><p>M&#x2F;M&#x2F;m 排队系统</p>
<ul>
<li>基于 M&#x2F;M&#x2F;1 排队系统</li>
<li>服务员增加为 m 个</li>
<li>相关结论</li>
</ul>
</li>
</ul>
<h3 id="4-I-x2F-O-基准测试程序"><a href="#4-I-x2F-O-基准测试程序" class="headerlink" title="4. I&#x2F;O 基准测试程序"></a>4. I&#x2F;O 基准测试程序</h3><ul>
<li>使用 I&#x2F;O 基准测试程序来反映响应时间和吞吐率之间的平衡关系</li>
<li>TPC<ul>
<li>事务处理委员会</li>
<li>发布 9 个事务处理基准测试程序</li>
<li>高端商业应用中，通常采用 TPC-C 测试程序进行测试</li>
</ul>
</li>
<li>TPC具有一些独特的性质<ul>
<li>测试结果中给出系统的价格因素</li>
<li>TPC模拟的是实际系统</li>
<li>测试结果经过TPC审核后才能发布</li>
<li>吞吐率指标受到响应时间的限制</li>
<li>通过独立的机构来维护</li>
</ul>
</li>
</ul>
<h3 id="5-I-x2F-O-系统的可靠性、可用性和可信性"><a href="#5-I-x2F-O-系统的可靠性、可用性和可信性" class="headerlink" title="5. I&#x2F;O 系统的可靠性、可用性和可信性"></a>5. I&#x2F;O 系统的可靠性、可用性和可信性</h3><ul>
<li>术语<ul>
<li>故障(fault)，可以恢复</li>
<li>错误(error)，不能恢复，不一定使得机器停掉</li>
<li>失效(failure)</li>
</ul>
</li>
<li>故障产生原因<ul>
<li>硬件</li>
<li>设计</li>
<li>操作</li>
<li>环境(温度等)</li>
</ul>
</li>
<li>故障分类<ul>
<li>暂时性</li>
<li>间歇性</li>
<li>永久性</li>
</ul>
</li>
<li>存储外设可靠性参数<ul>
<li>可靠性</li>
<li>可用性</li>
<li>可信性</li>
</ul>
</li>
<li>提高系统可靠性的方法<ul>
<li>故障避免技术：通过合理构建系统来避免故障</li>
<li>故障容忍技术：采取冗余措施</li>
<li>错误消除技术：通过验证，最大限度地减少潜在的错误</li>
<li>错误预报技术：通过分析，预报错误的出现，以便提前采取应对措施</li>
</ul>
</li>
</ul>
<h2 id="6-3-RAID"><a href="#6-3-RAID" class="headerlink" title="6.3 RAID"></a>6.3 RAID</h2><p><strong>盘阵列(RAID，即 Redundant Array of Inexpensive Disks)，即廉价磁盘冗余阵列，简称盘阵列技术</strong></p>
<blockquote>
<p>1987年，由加州大学伯克利分校的Patterson、Gibson 和 Katz 提出</p>
</blockquote>
<p>既可以提高存储系统的可靠性，又可以提高存储系统的性能。这种技术可以通过使用多个磁盘驱动器（包括多个磁臂）而不是使用一个大容量的磁盘（单个磁臂）来提高磁盘的吞吐率。使用磁盘阵列可以简单地将数据分布到多个磁盘上（称为数据分块技术），这样使得一个数据的访问将导致对多个磁盘的同时访问。</p>
<p>盘阵列容量大、速度快、可靠性高、造价低廉。它是目前解决计算机I&#x2F;O瓶颈的有效方法之一，有着广阔的发展前景</p>
<h3 id="6-3-1-RAID-0"><a href="#6-3-1-RAID-0" class="headerlink" title="6.3.1 RAID 0"></a>6.3.1 RAID 0</h3><ul>
<li><p><strong>亦称数据分块（Striping）</strong>，即把数据分布在多个盘上，实际上是非冗余阵列，无冗余信息。严格地说，它不属于 RAID 系列<br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%200.png" alt="RAID 0"></p>
</li>
<li><p>优点：高性能，磁盘利用率高</p>
</li>
<li><p>缺点：系统可靠性差，没有冗余</p>
</li>
</ul>
<h3 id="6-3-2-RAID-1"><a href="#6-3-2-RAID-1" class="headerlink" title="6.3.2 RAID 1"></a>6.3.2 RAID 1</h3><ul>
<li><p><strong>亦称镜像盘，使用双备份磁盘</strong><br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%201.png" alt="RAID 1"></p>
</li>
<li><p>优点：I&#x2F;O速度快，可靠性高</p>
</li>
<li><p>缺点：代价高，可扩展性不好</p>
</li>
</ul>
<p>一个读请求可由包含请求数据的两个物理磁盘中的某一个提供，只要它的寻道时间加旋转时间延迟较小。这样 RAID 1 的读性能由镜像盘中读性能最好的磁盘决定。故在 I&#x2F;O 处理中，如果是大批的读请求，RAID 1 的性能能够达到 RAID 0 性能的两倍</p>
<h3 id="6-3-3-RAID-2"><a href="#6-3-3-RAID-2" class="headerlink" title="6.3.3 RAID 2"></a>6.3.3 RAID 2</h3><ul>
<li><p><strong>位交叉式海明编码阵列</strong><br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%202.png" alt="RAID 2"></p>
</li>
<li><p>优点：</p>
<ul>
<li>高速误差校正</li>
<li>数据传输速率高</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>校正空间较大，盘阵列利用率较低</li>
</ul>
</li>
</ul>
<p>RAID 2 的优点是使用海明编码来进行错误检测和纠正，数据传输率高。海明校验码可以检测磁盘的 2 位错误，并纠正 1 位数据错误。对于单个读，所有磁盘同时读取，请求的数据和相关的海明校验码被传送到阵列管理器。如果出现 1 位错误，则阵列管理器可以立即识别并加以纠正，因此读取时间很短，可以达到很高的数据传输率。对于单个写，所有的数据盘和校验盘都要参加写操作。RAID 2 阵列管理器的设计比后面的 RAID 级别要简单</p>
<p>RAID 2 的缺点是需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。这样，尽管 RAID 2 比 RAID 1 需要的磁盘少，RAID 2 存储容量的利用率仍然不高，尤其是在数据字长较短的情况下。另外，RAID 2 可以达到的数据传输率将受限于整个磁盘阵列中最慢的磁盘以及阵列管理器的校验速度</p>
<h3 id="6-3-4-RAID-3"><a href="#6-3-4-RAID-3" class="headerlink" title="6.3.4 RAID 3"></a>6.3.4 RAID 3</h3><ul>
<li><p><strong>位交叉奇偶校验盘阵列</strong>，是单盘容错并行传输的阵列。即数据以位或字节交叉的方式存于各盘，冗余的奇偶校验信息存储在一台专用盘上<br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%203.png" alt="RAID 3"></p>
</li>
<li><p>在RAID3中，将磁盘分组，读写要访问组中所有盘。当一个磁盘出故障时，可以通过奇偶校验磁盘中的校验和来恢复出错数据</p>
</li>
<li><p>优点：冗余代价低，传输速率高</p>
</li>
<li><p>应用领域：多媒体应用</p>
</li>
</ul>
<p>先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。一旦某一个盘失效，只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是失效的盘上的数据。冗余盘中的奇偶校验和通常是模 2 和。这种方法的缺点是恢复时间较长，但由于磁盘失效的可能性很小，因此还是可以接受的</p>
<h3 id="6-3-5-RAID-4"><a href="#6-3-5-RAID-4" class="headerlink" title="6.3.5 RAID 4"></a>6.3.5 RAID 4</h3><ul>
<li><strong>块交叉奇偶校验盘阵列</strong>，即数据以块(块大小可变)交叉的方式存于各盘，冗余的奇偶校验信息存在一台专用盘上<br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%204.png" alt="RAID 4"></li>
</ul>
<p>优点：读写速度快；冗余代价低<br>缺点：阵列控制器复杂</p>
<p>由于磁盘扇区中存在错误检测信息，使得磁盘在读数据时就可以检测数据是否正确，因此只要访问的数据以扇区为单位，则每个磁盘都可以同时独立地进行这种操作。与 RAID 3 相比，RAID 4 中对一个数据的读操作是对两个磁盘的两次读操作</p>
<h3 id="6-3-6-RAID-5"><a href="#6-3-6-RAID-5" class="headerlink" title="6.3.6 RAID 5"></a>6.3.6 RAID 5</h3><ul>
<li><p><strong>块交叉分布式奇偶校验盘阵列</strong>，即数据以块交叉的方式存于各盘，但无专用的校验盘，而是把冗余的奇偶校验信息均匀地分布在所有磁盘上<br><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%205.png" alt="RAID 5"></p>
</li>
<li><p>优点：</p>
<ul>
<li>冗余代价较小；</li>
<li>读数据速率高；</li>
<li>写数据相对较快。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>控制器设计复杂</li>
</ul>
</li>
</ul>
<p>通过将校验信息分布到多个磁盘中，这样就不会出现 RAID 4 中冗余磁盘成为写操作的瓶颈这个问题</p>
<h3 id="6-3-7-RAID-6"><a href="#6-3-7-RAID-6" class="headerlink" title="6.3.7 RAID 6"></a>6.3.7 RAID 6</h3><ul>
<li><strong>双维奇偶校验独立存取盘阵列</strong>，即数据以块(块大小可变)交叉的方式存于各盘，冗余的检、纠错信息均匀地分布在所有磁盘上。并且，每次写入数据都要访问一个数据盘和两个校验盘，可容忍双盘出错</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/RAID%206.png" alt="RAID 6"></p>
<p>目前的计算机实际上是将多种盘阵列技术综合使用</p>
<h2 id="6-4-总线"><a href="#6-4-总线" class="headerlink" title="6.4 总线"></a>6.4 总线</h2><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0.png" alt="总线概述"></p>
<p><strong>1. 总线特点</strong></p>
<ul>
<li>优点：<ul>
<li>低成本</li>
<li>多样性</li>
</ul>
</li>
<li>缺点：<ul>
<li>可能造成设备信息交换的瓶颈，从而限制了系统中总的I&#x2F;O吞吐量</li>
</ul>
</li>
</ul>
<p>总线设计存在很多技术难点，一个重要原因就是总线上信息传送的速度极大地受限于各种物理因素，如总线的长度、设备的数目、信号的强度等，这些物理因素限制了总线性能的提高。另外，对 I&#x2F;O 操作的低延迟要求以及对 I&#x2F;O 高吞吐量的要求也可能造成设计需求上的冲突</p>
<p><strong>2. 总线设计时因考虑的因素</strong></p>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E6%80%BB%E7%BA%BF%E8%AE%BE%E8%AE%A1%E6%97%B6%E5%9B%A0%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0.png" alt="总线设计时因考虑的因素"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><ul>
<li>按设备定时方式分类：<ul>
<li>同步总线；同步总线上所有设备通过统一的总线系统时钟进行同步</li>
<li>异步总线：设备之间没有统一的系统时钟，设备自己内部定时。设备之间的信息传送用总线发送器和接收器控制。但在传输时，异步总线需要额外的同步开销</li>
<li>采用独立的地址和数据线、更宽的数据总线的位数以及多字数据传输块将提高总线的性能，但同时也带来了高成本</li>
</ul>
</li>
</ul>
<p><strong>3. 总线标准</strong></p>
<ul>
<li>只要计算机和 I&#x2F;O 设备的设计都满足相应的标准，那么 I&#x2F;O 设备和计算机可以任意连接</li>
<li>I&#x2F;O 总线标准就是定义设备连接的文件</li>
</ul>
<p><strong>4. 常用的 I&#x2F;O 总线</strong></p>
<ul>
<li><p>概况</p>
</li>
<li><p>常用的 I&#x2F;O 总线标准</p>
<ul>
<li>ISA</li>
<li>EISA</li>
<li>PCI：扩展主机设备(PCIE)</li>
<li>USB(含 USB 2.0)：连接各种外部设备到主机</li>
<li>IEEE 1394、……</li>
<li>RS-485&#x2F;RS-232</li>
<li>CAN(汽车，卫星)</li>
<li>IIC(家电等)</li>
</ul>
</li>
<li><p>主要影响因素：</p>
<ul>
<li>系统中各部件的工作频率</li>
<li>传输数据和编址地址位数</li>
</ul>
</li>
</ul>
<p><strong>5. I&#x2F;O 总线的发展历程</strong></p>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO%E6%80%BB%E7%BA%BF%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="IO总线的发展历程"></p>
<p><strong>6. 设备的连接</strong></p>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5.png" alt="设备连接"></p>
<ul>
<li><p>I&#x2F;O 设备编址方式</p>
<ul>
<li>存储器映射 I&#x2F;O</li>
<li>独立编址(有单独的访问 I&#x2F;O 指令，如 in, out)</li>
</ul>
</li>
<li><p>I&#x2F;O 设备控制方式</p>
<ul>
<li>程序查询</li>
<li>中断</li>
<li>DMA(部分单片机内也开始使用这种方式)</li>
<li>I&#x2F;O 处理机(包含功能较弱的通道)</li>
</ul>
</li>
<li><p>在大型计算机系统中，采用程序控制、中断和 DMA 这三种基本的 I&#x2F;O 方式来管理外围设备，会引起如下两个问题：</p>
<ul>
<li>所有外围设备的 I&#x2F;O 工作全部都要由CPU来承担，CPU 的 I&#x2F;O 负担很重，不能专心于用户程序的计算。低速外围设备每传送一个字符都要由 CPU 执行一段程序来完成，而高速外围设备虽然使用 DMA 方式减少了 CPU 的干预，但初始化工作仍然需要 CPU 用程序来完成</li>
</ul>
</li>
</ul>
<p>（四种设备控制方式为计组重点内容，略）</p>
<h2 id="6-5-通道"><a href="#6-5-通道" class="headerlink" title="6.5 通道"></a>6.5 通道</h2><ul>
<li><p>接受 CPU 发来的 I&#x2F;O 指令，根据指令要求选择一台指定的外围设备与通道相连接</p>
</li>
<li><p>执行 CPU 为通道组织的通道程序，从主存中取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令</p>
</li>
<li><p>给出外围设备的有关地址，即进行读／写操作的数据所在的位置。如，磁盘存储器的柱面号、磁头号、扇区号等</p>
</li>
<li><p>给出主存缓冲区的首地址，这个缓冲区用来暂时存放从外围设备上输入的数据，或者暂时存放将要输出到外围设备中去的数据</p>
</li>
<li><p>控制外围设备与主存缓冲区之间数据交换的个数，对交换的数据个数进行计数，并判断数据传送工作是否结束</p>
</li>
<li><p>指定传送工作结束时要进行的操作。例如，将外围设备的中断请求及通道的中断请求送往 CPU 等</p>
</li>
<li><p>检查外围设备的工作状态，是正常或故障。根据需要将设备的状态信息送往主存指定单元保存</p>
</li>
<li><p>在数据传输过程中完成必要的格式变换，例如，把字拆卸为字节，或者把字节装配成字等</p>
</li>
<li><p>通道分为三种类型：</p>
<ul>
<li>字节多路通道：简单的共享通道，为多台低速或中速的外围设备服务。采用分时方式工作</li>
<li>选择通道：为高速外围设备（如磁盘存储器等）服务。在传送数据期间，只能为一台高速外围设备服务，在不同的时间内可以选择不同的设备，可以在一段集中的时间内完成高速设备的传输任务，比较适合高速设备</li>
<li>数组多路通道：为高速设备服务。时间片轮转、分时复用的思想，各台高速设备重迭操作，但是传输的单位不是字节，而是一块</li>
</ul>
</li>
</ul>
<h2 id="6-6-I-x2F-O-与操作系统"><a href="#6-6-I-x2F-O-与操作系统" class="headerlink" title="6.6 I&#x2F;O 与操作系统"></a>6.6 I&#x2F;O 与操作系统</h2><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/IO%E4%B8%8ECache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.png" alt="IO与Cache的一致性问题"></p>
<p>能够使处理器性能发挥的软件是编译器，而发挥存储性能的软件是操作系统，采用哪种硬件进行 I&#x2F;O 处理由操作系统决定，所以在设计 I&#x2F;O 系统时还要注意操作系统的因素</p>
<ul>
<li>数据不一致问题有两个方面<ul>
<li>存储器中可能不是 CPU 产生的最新数据，所以 I&#x2F;O 系统从存储器中取出来使用的是陈旧数据</li>
<li>I&#x2F;O 与存储器交换数据之后，在 Cache 中被 CPU 使用的可能就是陈旧数据</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E5%AF%B9%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83.png" alt="对一致性问题的思考"></p>
<p>由于 I&#x2F;O 会在两个方面导致数据不一致的问题，那么我们直接将 I&#x2F;O 总线挂接在 Cache 上，这样 I&#x2F;O 从 Cache 读取数据一定是最新的（无论 Cache 写策略是直写还是写回），CPU 访问数据时要先访问 Cache，因此 CPU 使用的数据也是最新的。<br>但是这种方式需要考虑对性能的影响。</p>
<ul>
<li>写直达 Cache 可以保证存储器和 Cache 有相同的数据<ul>
<li>但是这种方式只能解决一个方面的数据不一致问题，即 CPU 读数据时仍然读取到的是 Cache 的旧数据</li>
</ul>
</li>
<li>写回 Cache 则需操作系统帮助进行数据检查</li>
<li><strong>根据 I&#x2F;O 使用的存储器地址来清除 Cache 相应的块，确保 I&#x2F;O 使用的数据不在 Cache 中</strong><ul>
<li>这种方式貌似可行，但是相对来说增加了一点开销</li>
</ul>
</li>
<li>地址检查过程也可以使用硬件完成</li>
</ul>
<h3 id="DMA-与虚拟存储器"><a href="#DMA-与虚拟存储器" class="headerlink" title="DMA 与虚拟存储器"></a>DMA 与虚拟存储器</h3><ul>
<li>使用 DMA，I&#x2F;O 设备直接访问内存（物理地址），如果不使用虚拟存储器，则 DMA 使用物理地址来传输数据</li>
<li>若使用虚拟存储器，使用物理地址进行 DMA，存在以下两个问题：<ul>
<li>对于超过一页的数据，由于缓冲区使用的页面在物理存储器中不一定是连续的，传输会发生问题</li>
<li>DMA 正在存储器和帧缓冲器之间传输数据时，操作系统从存储器中移出一些页面(或重新分配)，DMA 将会在存储器中错误的页面上传输数据</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/%E8%99%9A%E6%8B%9FDMA%E6%8A%80%E6%9C%AF.png" alt="虚拟DMA技术"></p>
<p>允许 DMA 设备直接使用虚拟地址，在 DMA 期间由硬件将虚拟地址映射到物理地址。这样，I&#x2F;O 使用的缓冲区页面在虚拟存储器中是连续的，但物理页面可以分散在物理存储器中，并且虚拟地址提供了对 I&#x2F;O 操作的保护。如果使用虚拟 DMA 的进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表</p>
<h1 id="第七章-多处理机"><a href="#第七章-多处理机" class="headerlink" title="第七章 多处理机"></a>第七章 多处理机</h1><blockquote>
<p><strong>一个问题</strong>:<br>图书馆将一批新书上架，可以有多种方式。假定将书按类上架，而将书架依据在书库中的位置分成一些组<br><strong>解决办法</strong><br>若由一工人单独完成，不能在要求的时间内完成任务<br>若由多个工人完成， 假定每次一人仅往书架上放一本书。可以采用两种不同的方式<br>（1）将所有的书籍平均分配给每个人去完成。这种划分方法不是太有效，原因是每个工人为了将书上架必须走遍所有的书架。<br>（2）将所有书架分成一些组，且平均分配给各个工人负责，同时将所有图书平均分配给每个工人去上架。如果工人发现一本书属于自己所负责的书架上，则将其放入书架。否则，将这本书传给所在书架对应的工人。这种分法对应的效率比较高<br><strong>结论</strong><br>将一个任务划分成一些子任务，并分配给多个工人去完成，工人们相互合作、并在需要时相互传递图书，这种协调的工作方式可较快地完成任务<br><strong>并行计算就是严格地按照上述原理来完成的</strong></p>
</blockquote>
<p><strong>并行计算相关的两个概念</strong></p>
<ol>
<li><strong>任务划分</strong>(task partitioning)<br>将图书平均分配给所有工人为任务划分的一个例子。</li>
<li><strong>通信</strong>(communication)<br>工人之间传递图书为子任务通信的例子。<br>什么是并行计算？</li>
</ol>
<p>并行计算是指同时对多个任务或多条指令、或对多个数据项进行处理。完成此项处理的计算机系统称为并行计算机系统，它是将多个处理器通过网络以一定的连接方式有序地组织起来</p>
<p><strong>并行计算机的发展原因</strong>：</p>
<ul>
<li>要获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起</li>
<li>体系结构改进能否持续下去？通过复杂度和硅技术的提高得到的性能提升正在减小；</li>
<li>并行计算机应用软件已有缓慢但稳定的发展。</li>
<li>重点：中小规模的机器(处理器的个数不超过128)的多处理机设计技术</li>
</ul>
<p><strong>并行计算的研究内容:</strong><br>(1) 并行计算机设计<br>(2) 有效算法的设计<br>(3) 评价并行算法的方法<br>(4) 并行计算机语言<br>(5) 并行编程环境与工具<br>(6) 并行程序的可移植性<br>(7) 并行计算机的自动编程</p>
<p><strong>并行计算的应用领域：</strong><br>(1) 天气预报<br>(2) 卫星数据处理<br>(3) 石油数据处理（连续优化问题）<br>(4) 调度问题<br>(5) VLSI设计（离散优化问题）<br>(6) ……</p>
<p><strong>美国政府的HPCC计划公布的重大挑战性应用</strong></p>
<ol>
<li>磁记录技术：研究静磁和交互感应以降低高密度磁盘的噪音</li>
<li>新药设计：通过抑制人的免疫故障病毒蛋白酶的作用来研制治疗癌症与艾滋病的药物</li>
<li>高速民航：用计算流体动力学来研制超音速喷气发动机</li>
<li>催化作用：仿生催化剂计算机建模，分析合成过成中的酶作用</li>
<li>燃料燃烧：通过化学动力学计算，揭示流体力学的作用，设计新型发动机</li>
<li>海洋建模：对海洋活动与大气流的热交换进行整体海洋模拟</li>
<li>臭氧耗损：研究控制臭氧损耗过程中的化学与动力学机制</li>
<li>数字解析：实时临床成像、计算层析术、磁共振成像 </li>
<li>大气污染：对大气质量模型进行模拟研究，控制污染的传播，揭示其物理与化学机理</li>
<li>蛋白质结构设计：对蛋白质组成的三维结构进行计算机模拟研究</li>
<li>图像理解：实时绘制图像或动态</li>
<li>密码破译：破译由长位数组成的密码，寻找该数的两个乘积因子</li>
</ol>
<p><strong>并行计算的应用分类</strong></p>
<p>（1）计算密集型（Compute-Intensive）<br>这一类型的应用问题主要集中在大型科学工程计算与数值模拟（气象预报、地球物理勘探等）<br>（2）数据密集型 (Data-Intensive)<br>Internet的发展，为我们提供了大量的数据资源，但有效地利用这些资源，需要进行大量地处理，且对计算机的要求也相当高，这些应用包括数字图书馆、数据仓库、数据挖掘、计算可视化。<br>（3）网络密集型 (Network-Intensive)<br>通过网络进行远距离信息交互，来完成用传统方法不同的一些应用问题。如协同工作、遥控与远程医疗诊断等</p>
<h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><p>单处理机的发展正在走向尽头？<br>并行计算机在未来将会发挥更大的作用。</p>
<ul>
<li>获得超过单处理器的性能，最直接的方法就是把多个处理器连在一起；</li>
<li>自1985年以来，体系结构的改进使性能迅速提高，这种改进的速度能否持续下去还不清楚，但通过复杂度和硅技术的提高而得到的性能的提高正在减小；</li>
<li>并行计算机应用软件已有缓慢但稳定的发展。</li>
</ul>
<p>本章重点:中小规模的机器(处理器的个数＜100 多处理机设计的主流)</p>
<h3 id="7-1-1-并行计算机体系结构的分类"><a href="#7-1-1-并行计算机体系结构的分类" class="headerlink" title="7.1.1 并行计算机体系结构的分类"></a>7.1.1 并行计算机体系结构的分类</h3><ol>
<li>按Flynn分类法，可把计算机分成</li>
</ol>
<ul>
<li>单指令流单数据流（SISD）</li>
<li>单指令流多数据流（SIMD）</li>
<li>多指令流单数据流（MISD）</li>
<li>多指令流多数据流（MIMD）</li>
</ul>
<ol start="2">
<li>MIMD已成为通用多处理机体系结构的选择，原因：</li>
</ol>
<ul>
<li>MIMD具有灵活性</li>
<li>MIMD可以充分利用商品化微处理器在性能价格比方面的优势</li>
</ul>
<p><strong>MIMD的优点</strong>（灵活性&#x2F;COTS）</p>
<ul>
<li>MIMD机器分类:集中式共享存储器结构(Centralized Shared-Memory Architecture)。,也称为对称式共享存储器结构(SMP, Symmetric shared-memory MultiProcessor)机器或者UMA(Uniform Memory Access)机器。</li>
<li>分布式存储器结构的机器。支持较大数目的处理器，存储器必须分布到各个处理器上，而非采用集中式，否则存储器系统将不能满足处理器带宽的要求。系统中每个结点包含了处理器、存储器、I／O以及互连网络接口</li>
</ul>
<ol start="3">
<li>MIMD机器分为两类（每一类代表了一种存储器的结构和互连策略）</li>
</ol>
<ul>
<li><p>集中式共享存储器结构</p>
<ul>
<li>这类机器有时被称为 UMA(Uniform Memory Access)机器</li>
</ul>
</li>
<li><p>分布式存储器结构</p>
<ul>
<li>每个结点包含：处理器、存储器、I&#x2F;O</li>
<li>在许多情况下，分布式存储器结构优于采用集中式共享存储器结构。</li>
<li>分布式存储器结构需要高带宽的互连</li>
</ul>
</li>
<li><p>分布式存储器结构的优点</p>
<ul>
<li>如果大多数的访问是针对本结点的局部存储器，则可降低对存储器和互连网络的带宽要求；</li>
<li>对局部存储器的访问延迟低</li>
</ul>
</li>
<li><p>主要缺点</p>
<ul>
<li>处理器之间的通信较为复杂，且各处理器之间访问延迟较大</li>
</ul>
</li>
</ul>
<h3 id="7-1-2-通信模型和存储器的结构模型"><a href="#7-1-2-通信模型和存储器的结构模型" class="headerlink" title="7.1.2 通信模型和存储器的结构模型"></a>7.1.2 通信模型和存储器的结构模型</h3><ol>
<li>两种地址空间的组织方案</li>
</ol>
<ul>
<li>物理上分离的多个存储器可作为一个逻辑上共享的存储空间进行编址。<ul>
<li>这类机器的结构被称为分布式共享存储器(DSM)或可缩放共享存储器体系结构。</li>
<li>DSM 机器被称为 NUMA(non-uniform memory access)机器。</li>
</ul>
</li>
<li>整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址</li>
<li>每一个处理器-存储器模块实际上是一个单独的计算机，这种机器也称为多计算机</li>
</ul>
<p>两种方案：</p>
<ul>
<li>DSM：一个处理器如果具有访问权，就可以访问任何一个其他的局部存储器，<br>DSM机器被称为 NUMA(Non-Uniform Memory Access)机器，这是因为其访问时间依赖于数据在存储器中的存放位置。 </li>
<li>整个地址空间由多个独立的地址空间构成，它们在逻辑上也是独立的，远程的处理器不能对其直接寻址。在这种机器的不同处理器中，相同的物理地址指向不同存储器的不同单元</li>
</ul>
<ol start="2">
<li>两种通信模型</li>
</ol>
<ul>
<li>共享地址空间的机器（共享存储器机器）<ul>
<li>利用 Load 和 Store 指令中的地址隐含地进行数据通信</li>
</ul>
</li>
<li>多个地址空间的机器<ul>
<li>通过处理器间显式地传递消息完成 (消息传递机器)</li>
</ul>
</li>
<li>消息传递机器根据简单的网络协议，通过传递消息来请求某些服务或传输数据，从而完成通信</li>
</ul>
<p>区别：</p>
<ul>
<li>对于共享地址空间的机器，用 load 和 store 指令中的地址隐含地进行数据通讯，因而可称为 <strong>共享存储器机器</strong></li>
<li>对于多个地址空间的机器，数据通讯要通过处理器间显式地传递消息完成，因而这种机器常称为 <strong>消息传递机器</strong></li>
</ul>
<p>例如：<br>一个处理器要对远程存储器上的数据进行访问或操作<br>(1) 发送消息，请求传递数据或对数据进行操作；<br>远程进程调用(RPC， remote process call)<br>(2) 目的处理器接收到消息以后，执行相应的操 作或代替远程处理器进行访问，并发送一个   应答消息将结果返回</p>
<p>对于通信机制的性能，可以通过下面三个关键的性能指标来进行衡量：</p>
<ol>
<li>通信带宽──理想状态下的通信带宽受限于处理器、存储器和互连网络的带宽。进行通信时，结点内与通信相关的资源被占用，这种占用限制了通信速度。</li>
<li>通信延迟──理想状态下通信延迟应尽可能地小。通信延迟的构成为：<br><strong>通信延迟＝发送开销＋跨越时间＋传输延迟＋接收开销</strong>（?）<blockquote>
<p>（老师讲 “跨越时间”是指第一位数据从发送端口到接收端口所需的时间，“传输延迟”是指最后一位通信数据从发送端口到接收端口之间的延迟，我没怎么听懂，这两个有什么区别吗？这和计网里的数据包传送有什么不一样吗？）</p>
</blockquote>
</li>
<li>通讯延迟的隐藏──如何才能较好地将通信和计算或多次通信之间重叠起来，以实现通讯延迟的隐藏</li>
</ol>
<p><strong>每种通信机制各有优点，共享存储器通信主要有以下优点：</strong><br>(1) 与常用的对称式多处理机使用的通信机制兼容。<br>(2) 当处理器通信方式复杂或程序执行动态变化时易于编程，同时在简化编译器设计方面也占有优势(都统一翻译成存储指令即可)。<br>(3) 当通信数据较小时，通信开销较低，带宽利用较好。<br>(4) 通过硬件控制的 Cache 减少了远程通信的频度，减少了通信延迟以及对共享数据的访问冲突。</p>
<p><strong>消息传递通信机制的主要优点包括：</strong></p>
<ul>
<li>硬件较简单。  </li>
<li>通信是显式的，从而引起编程者和编译程序的注意，着重处理开销大的通信。<ul>
<li>当然，可在支持上面任何一种通信机制的硬件模型上建立所需的通信模式平台。</li>
<li>在共享存储器上支持消息传递相对简单，因为发送一条消息可通过将一部分地址空间的内容复制到另一部分地址空间来实现。</li>
<li>但在消息传递的硬件上支持共享存储器就困难得多</li>
</ul>
</li>
</ul>
<h3 id="7-1-3-并行处理面临的挑战"><a href="#7-1-3-并行处理面临的挑战" class="headerlink" title="7.1.3 并行处理面临的挑战"></a>7.1.3 并行处理面临的挑战</h3><ol>
<li>程序中有限的并行性</li>
</ol>
<ul>
<li>有限的并行性使机器要达到好的加速比十分困难</li>
<li>通过所给的例子，100 个处理器达到 80 的加速比，并行比例要达到 99.75%，即 0.25% 的串行比例影响了 20 的加速比。因此我们得到结论：串行对于并行处理的加速比具有至关重要的影响</li>
</ul>
<ol start="2">
<li>相对较高的通信开销（可通过 Amdahl 定律解释）</li>
</ol>
<ul>
<li>面临的第二个挑战主要是指多处理机中远程访问的较大延迟。在现有的机器中，处理器之间的数据通信大约需要 50～10000 个时钟周期</li>
</ul>
<p>并行性不足： 通过采用并行性更好的算法来解决<br>远程访问延迟的降低： 靠体系结构支持和编程技术</p>
<p>在并行处理中，负载平衡、同步和存储器访问延迟等影响性能的因素常依赖于高层应用特点，如应用程序中数据的分配，并行算法的结构以及数据在空间和时间上的访问模式等。</p>
<p>依据应用特点可把多机工作负载大致分成两类：单个程序在多处理机上的并行工作负载和多个程序在多处理机上的并行工作负载</p>
<h2 id="7-2-对称式共享存储器体系结构"><a href="#7-2-对称式共享存储器体系结构" class="headerlink" title="7.2 对称式共享存储器体系结构"></a>7.2 对称式共享存储器体系结构</h2><p>反映并行程序性能的一个重要的度量是计算与通信的比率。如果比值较高，就意味着应用程序中相对于每次数据通信要进行较多的计算。</p>
<p>通信在并行计算中的开销是很大的，因而较高的计算／通信比率十分有益。在一个并行处理环境下，当要增加处理器的数目，或增大所求解问题的规模，或者两者同时都增大时，都要对计算／通信比率的变化加以分析。</p>
<p>例如，在增加处理器数目的同时知道这个比率的变化，会对应用能获得的加速比有清楚的了解。</p>
<p>通常状况下，计算／通信比率随着处理的数据规模增大而增加，随着处理器数目的增加而降低。</p>
<p>用更多的处理器来求解一个固定大小的问题会导致不利因素的增加，因为处理器之间通信量加大了。</p>
<p>增加处理器时应该调整数据的规模，从而使通信的时间保持不变。</p>
<h3 id="7-2-1-多处理机-Cache-一致性"><a href="#7-2-1-多处理机-Cache-一致性" class="headerlink" title="7.2.1 多处理机 Cache 一致性"></a>7.2.1 多处理机 Cache 一致性</h3><ul>
<li>多个处理器共享一个存储器。</li>
<li>当处理器规模较小时，这种机器十分经济。</li>
<li>支持对共享数据和私有数据的Cache缓存。<ul>
<li>私有数据供一个单独的处理器使用，而共享数据供多个处理器使用</li>
</ul>
</li>
<li>共享数据进入Cache产生了一个新的问题：<strong>Cache 的一致性问题</strong><ul>
<li>对共享数据，不同处理器的 Cache 都保存有对应存储器单元的内容，因而在操作中就可能产生数据的不一致，称为 Cache一致性（Coherence）问题</li>
</ul>
</li>
</ul>
<h4 id="1-不一致产生的原因（Cache-一致性问题）"><a href="#1-不一致产生的原因（Cache-一致性问题）" class="headerlink" title="1. 不一致产生的原因（Cache 一致性问题）"></a>1. 不一致产生的原因（Cache 一致性问题）</h4><ul>
<li>I／O 操作<ul>
<li>Cache中的内容可能与由 I／O 子系统输入输出形成的存储器对应部分的内容不同</li>
</ul>
</li>
<li>共享数据<ul>
<li>不同处理器的 Cache 都保存有对应存储器单元的内容</li>
</ul>
</li>
</ul>
<h4 id="2-存储器是一致的（非正式地定义）"><a href="#2-存储器是一致的（非正式地定义）" class="headerlink" title="2. 存储器是一致的（非正式地定义）"></a>2. 存储器是一致的（非正式地定义）</h4><p>如果对某个数据项的任何读操作均可得到其最新写入的值，则认为这个存储系统是一致的</p>
<ul>
<li>存储系统行为的两个不同方面<ul>
<li>返回给读操作的是什么值</li>
<li>什么时候才能将已写入的值返回给读操作</li>
</ul>
</li>
<li>满足条件<ul>
<li>处理器 P 对 X 进行一次写之后又对 X 进行读，读和写之间没有其它处理器对 X 进行写，则读的返回值总是写进的值。（一个处理器）</li>
<li>一个处理器对 X 进行写之后，另一处理器对X进行读，读和写之间无其它写，则读 X 的返回值应为写进的值。（多个处理器）</li>
<li>对同一单元的写是顺序化的，即任意两个处理器对同一单元的两次写，从所有处理器看来顺序都应是相同的</li>
</ul>
</li>
</ul>
<p>假设:直到所有的处理器均看到了写的结果，一次写操作才算完成；允许处理器无序读，但必须以程序规定的顺序进行写</p>
<p>三条已充分地保证了一致性，什么时候才能获得写进去的值仍是一个重要的问题</p>
<h3 id="7-2-2-实现一致性的基本方案"><a href="#7-2-2-实现一致性的基本方案" class="headerlink" title="7.2.2 实现一致性的基本方案"></a>7.2.2 实现一致性的基本方案</h3><p>在一致的多处理机中，Cache 提供两种功能</p>
<ul>
<li>共享数据的迁移<ul>
<li>降低了对远程共享数据的访问延迟</li>
</ul>
</li>
<li>共享数据的复制<ul>
<li>不仅降低了访存的延迟，也减少了访问共享数据所产生的冲突</li>
</ul>
</li>
</ul>
<p>小规模多处理机不是采用软件而是采用硬件技术实现 Cache 一致性</p>
<p>(1) Cache 一致性协议<br>    对多个处理器维护一致性的协议<br>(2) 关键：跟踪共享数据块的状态<br>(3) 共享数据状态跟踪技术 </p>
<ul>
<li>目录<ul>
<li>物理存储器中共享数据块的状态及相关信息均被保存在目录中。</li>
</ul>
</li>
<li>监听<ul>
<li>每个 Cache 除了包含物理存储器中块的数据拷贝之外，也保存着各个块的共享状态信息</li>
<li>监听：Cache 通常连在共享存储器的总线上，各个 Cache 控制器通过监听总线来判断它们是否有总线上请求的数据块</li>
</ul>
</li>
<li>两种协议<ul>
<li>写作废协议<ul>
<li>在一个处理器写某个数据项之前保证它对该数据项有唯一的访问权，即在某个 CPU 往内存中写入数据时，将其他拥有该单元的拷贝全部作废，写完后其他处理器再从该内存单元中重新读取数据，此时便是新的数据</li>
</ul>
</li>
<li>写更新协议<ul>
<li>当一个处理器写某数据项时，通过广播使其它 Cache 中所有对应的该数据项拷贝进行更新</li>
</ul>
</li>
<li>写作废和写更新协议性能上的差别<ul>
<li>对同一数据的多个写而中间无读操作的情况，写更新协议需进行多次写广播操作，而在写作废协议下只需一次作废操作。</li>
<li>对同一块中多个字进行写，写更新协议对每个字的写均要进行一次广播，而在写作废协议下仅在对本块第一次写时进行作废操作。</li>
<li>从一个处理器写到另一个处理器读之间的延迟通常在写更新模式中较低。而在写作废协议中，需要读一个新的拷贝。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在基于总线的多处理机中，写作废协议成为绝大多数系统设计的选择</p>
<h3 id="7-2-3-监听协议及其实现"><a href="#7-2-3-监听协议及其实现" class="headerlink" title="7.2.3 监听协议及其实现"></a>7.2.3 监听协议及其实现</h3><ul>
<li>小规模多处理机中实现写作废协议的关键利用总线进行作废操作,每个块的有效位使作废机制的实现较为容易。 </li>
<li>写直达 Cache，因为所有写的数据同时被写回主存，则从主存中总可以取到最新的数据值。</li>
<li>对于写回 Cache，得到数据的最新值会困难一些，因为最新值可能在某个 Cache 中，也可能在主存中。</li>
</ul>
<p>当某个处理器进行写数据时，必须先获得总线的控制权，然后将要作废的数据块的地址放在总线上。其它处理器一直监听总线，它们检测该地址所对应的数据是否在它们的 Cache 中。若在，则作废相应的数据块。获取总线控制权的顺序性保证了写的顺序性，因为当两个处理器要同时写一个单元时，其中一个处理器必然先获得总线控制权，之后它使另一处理器上对应的拷贝作废，从而保证了写的严格顺序性</p>
<ul>
<li>在写回Cache条件下的实现技术<ul>
<li>用Cache中块的标志位实现监听过程。</li>
<li>给每个Cache块加一个特殊的状态位说明它是否为共享。</li>
<li>因为每次总线任务均要检查Cache的地址位，这可能与CPU对Cache的访问冲突。可通过下列两种技术之一降低冲突：<ul>
<li>复制标志位</li>
<li>采用多级包含 Cache</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-3-分布式共享存储器体系结构"><a href="#7-3-分布式共享存储器体系结构" class="headerlink" title="7.3 分布式共享存储器体系结构"></a>7.3 分布式共享存储器体系结构</h2><h3 id="7-3-1-基于目录的-Cache-一致性"><a href="#7-3-1-基于目录的-Cache-一致性" class="headerlink" title="7.3.1 基于目录的 Cache 一致性"></a>7.3.1 基于目录的 Cache 一致性</h3><p>存储器分布于各结点中，所有的结点通过网络互连。访  问可以是本地的，也可是远程的。</p>
<p>不支持Cache一致性：</p>
<ul>
<li>规定共享数据不进入Cache，仅私有数据才能保存在Cache中。</li>
<li>优点： 所需的硬件支持很少(因为远程访问存取量仅是一个字(或双字)而不是一个Cache块)</li>
<li>缺点：<br>(1) 实现透明的软件 Cache 一致性的编译机制能力有限<br>(2) 没有 Cache 一致性，机器就不能利用取出同一块中的多个字的,开销接近于取一个字的开销这个优点，这是因为共享数据是以 Cache 块为单位进行管理的。当每次访问要从远程存储器取一个字时，不能有效利用共享数据的空间局部性<br>(3) 诸如预取等延迟隐藏技术对于多个字的存取更为有效，比如针对一个 Cache 块的预取</li>
</ul>
<p>对远程存储器访问的巨大延迟与对本地Cache访问的短延迟相比，突出地反映出了这些缺点。例如，Cray T3E本地访问延迟为两个时钟周期，并且可被流水化，而一次远程访问则需约400个时钟周期(T3E-900, 450MHz Alpha)</p>
<p><strong>解决Cache一致性问题的关键</strong>：</p>
<ul>
<li>目录协议<ul>
<li>目录：用一种专用的存储器所记录的数据结构，它记录着可以进入Cache的每个数据块的访问状态、该块在各个处理器的共享状态以及是否修改过等信息。</li>
<li>对每个结点增加目录表后的分布式存储器的系统结构</li>
<li>而当系统的规模变大时，它又是致命的弱点。此外，监听的访问量与处理器个数的平方（N2）成正比，即使总线的带宽随系统规模线性增长（N），而实际的性能还是下降到1&#x2F;N</li>
</ul>
</li>
<li>目录协议的基本点<ul>
<li>在每个结点增加了目录存储器用于存放目录；</li>
<li>存储器的每一块在目录中对应有一项；</li>
<li>每一个目录项主要有状态和位向量两种成分。<ul>
<li>状态描述该目录所对应存储块的当前情况；</li>
<li>位向量共有N位，其每一位对应于一个处理器的局部 Cache，用于指出该Cache中有无该存储块的拷贝</li>
</ul>
</li>
</ul>
</li>
<li>目录必须跟踪每个 Cache 块的状态<ul>
<li>Cache 块状态有三种：<ul>
<li>共享：在一个或多个处理器上具有这个块的拷贝，且主存中的值是最新值(所有 Cache 均相同)。</li>
<li>未缓冲：所有处理器的Cache都没有此块的拷贝。</li>
<li>专有：仅有一个处理器上有此块的拷贝，且已对此块进行了写操作，而主存的拷贝仍是旧的。这个处理器称为此块的拥有者。</li>
</ul>
</li>
</ul>
</li>
<li>由于写作废操作的需要，还必须记录共享此块的处理器信息。<ul>
<li>方法：对每个主存块设置一个位向量。</li>
<li>当此块被共享时，每个位指出与之对应的处理器是否有此块的拷贝。</li>
<li>当此块为专有时，可根据位向量来寻找此块的拥有者。</li>
</ul>
</li>
<li>宿主结点<ul>
<li>存放有存储器块和对应地址目录项的结点</li>
</ul>
</li>
</ul>
<h3 id="7-3-2-目录协议及其实现"><a href="#7-3-2-目录协议及其实现" class="headerlink" title="7.3.2. 目录协议及其实现"></a>7.3.2. 目录协议及其实现</h3><p>基于目录的协议中，目录承担了一致性协议操作的主要功能。 </p>
<ul>
<li>(1) 发往一个目录的消息会产生两种不同类型的动作<ul>
<li>更新目录状态</li>
<li>发送消息满足请求服务</li>
</ul>
</li>
<li>(2) 目录项可能接收到三种不同的请求（注意请求的完备性）<ul>
<li>读失效</li>
<li>写失效</li>
<li>数据写回</li>
</ul>
</li>
<li>(3) 在各个状态下所接收到的请求和相应的操作<ul>
<li>①当一个块处于未缓冲状态时，对此块发出的请求及处理操作为: </li>
<li>读失效<ul>
<li>将存储器数据送往请求方处理器，且本处理器成为此块的唯一共享结点，本块的状态转换为共享</li>
</ul>
</li>
<li>写失效<ul>
<li>将存储器数据送往请求方处理器，此块成为专有</li>
</ul>
</li>
<li>②当一个块是共享状态时，存储器中的数据是其当前最新值，对此块发出的请求及处理操作为:<ul>
<li>读失效<ul>
<li>将存储器数据送往请求方处理器，并将其加入共享集合</li>
</ul>
</li>
<li>写失效<ul>
<li>将数据送往请求方处理器，对共享集合中所有的处理器发送写作废消息，且将共享集合置为仅含有此处理器，本块的状态变为专有</li>
</ul>
</li>
</ul>
</li>
<li>③当某块处于专有状态时，本块的最新值保存在共享集合指出的拥有者处理器中，从而有三种可能的目录请求<ul>
<li>读失效<ul>
<li>将“取数据”的消息发往拥有者处理器，使该块的状态转变为共享，并将数据送回目录结点写入存储器，进而把该数据返送请求方处理器，将请求方处理器加入共享集合</li>
</ul>
</li>
<li>写失效   <ul>
<li>本块将有一个新的拥有者。</li>
</ul>
</li>
<li>数据写回<ul>
<li>拥有者处理器的 Cache 要替换此块时必须将其写回，从而使存储器中有最新拷贝(宿主结点实际上成为拥有者)，此块成为非共享，共享集合为空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对基于目录的Cache一致性的多种改进<ul>
<li>有限映射目录</li>
<li>链式结构目录</li>
</ul>
</li>
</ul>
<p>基于目录的 Cache 一致性协议采取了“以空间换时间”的策略，减少了访问次数但增加了目录存储器，它的大小与系统规模 N 的平方成正比。<br>基于目录的 Cache 一致性协议是<strong>完全由硬件实现</strong>的</p>
<h2 id="7-4-互连网络"><a href="#7-4-互连网络" class="headerlink" title="7.4 互连网络"></a>7.4 互连网络</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/hexo-blog/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="tag"># 体系结构</a>
              <a href="/hexo-blog/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/hexo-blog/2a32925d.html" rel="prev" title="实现C语言编译器：三、输入及词法分析">
      <i class="fa fa-chevron-left"></i> 实现C语言编译器：三、输入及词法分析
    </a></div>
      <div class="post-nav-item">
    <a href="/hexo-blog/3645f6a9.html" rel="next" title="Git的使用">
      Git的使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">第六章 输入输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">6.1 存储设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E7%A3%81%E7%9B%98"><span class="nav-text">6.1.1 磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="nav-text">磁盘访问时间计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E8%A1%A8%E9%9D%A2%E8%AE%B0%E5%BD%95%E5%AF%86%E5%BA%A6"><span class="nav-text">磁表面记录密度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-Flash-%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98-SSD"><span class="nav-text">6.1.2 Flash 存储器和固态硬盘 SSD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-%E7%A3%81%E5%B8%A6"><span class="nav-text">6.1.3 磁带</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-%E5%85%89%E7%9B%98"><span class="nav-text">6.1.4 光盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-I-x2F-O-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%84%E4%BB%B7"><span class="nav-text">6.2 I&#x2F;O 系统分析与评价</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-I-x2F-O%E6%80%A7%E8%83%BD%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-text">1. I&#x2F;O性能与系统响应时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Little-%E5%AE%9A%E5%BE%8B"><span class="nav-text">2. Little 定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-M-x2F-M-x2F-1-%E6%8E%92%E9%98%9F%E7%B3%BB%E7%BB%9F"><span class="nav-text">3. M&#x2F;M&#x2F;1 排队系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-I-x2F-O-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-text">4. I&#x2F;O 基准测试程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-I-x2F-O-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E5%8F%AF%E4%BF%A1%E6%80%A7"><span class="nav-text">5. I&#x2F;O 系统的可靠性、可用性和可信性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-RAID"><span class="nav-text">6.3 RAID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-RAID-0"><span class="nav-text">6.3.1 RAID 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-RAID-1"><span class="nav-text">6.3.2 RAID 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-RAID-2"><span class="nav-text">6.3.3 RAID 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-RAID-3"><span class="nav-text">6.3.4 RAID 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5-RAID-4"><span class="nav-text">6.3.5 RAID 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-RAID-5"><span class="nav-text">6.3.6 RAID 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-7-RAID-6"><span class="nav-text">6.3.7 RAID 6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E6%80%BB%E7%BA%BF"><span class="nav-text">6.4 总线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">总线的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E9%80%9A%E9%81%93"><span class="nav-text">6.5 通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-I-x2F-O-%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">6.6 I&#x2F;O 与操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">DMA 与虚拟存储器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA"><span class="nav-text">第七章 多处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%BC%95%E8%A8%80"><span class="nav-text">7.1 引言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">7.1.1 并行计算机体系结构的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="nav-text">7.1.2 通信模型和存储器的结构模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-text">7.1.3 并行处理面临的挑战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%AF%B9%E7%A7%B0%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">7.2 对称式共享存储器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA-Cache-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">7.2.1 多处理机 Cache 一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88Cache-%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-text">1. 不一致产生的原因（Cache 一致性问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%88%E9%9D%9E%E6%AD%A3%E5%BC%8F%E5%9C%B0%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-text">2. 存储器是一致的（非正式地定义）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%A1%88"><span class="nav-text">7.2.2 实现一致性的基本方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E7%9B%91%E5%90%AC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">7.2.3 监听协议及其实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">7.3 分布式共享存储器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E5%9F%BA%E4%BA%8E%E7%9B%AE%E5%BD%95%E7%9A%84-Cache-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">7.3.1 基于目录的 Cache 一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E7%9B%AE%E5%BD%95%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">7.3.2. 目录协议及其实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C"><span class="nav-text">7.4 互连网络</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cherry"
      src="/hexo-blog/images/avatar2.png">
  <p class="site-author-name" itemprop="name">Cherry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo-blog/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo-blog/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/hexo-blog/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CherryYang05" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CherryYang05" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_42650988" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_42650988" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cherry版权所有</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">217k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"I0GaPlLWJSoCb0ieY9V3Vd7Q-gzGzoHsz","app_key":"sye9GNy0K7KNBHd69HYFsPzV","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/hexo-blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/hexo-blog/lib/velocity/velocity.min.js"></script>
  <script src="/hexo-blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo-blog/js/utils.js"></script>

<script src="/hexo-blog/js/motion.js"></script>


<script src="/hexo-blog/js/schemes/muse.js"></script>


<script src="/hexo-blog/js/next-boot.js"></script>

<script src="/hexo-blog/js/bookmark.js"></script>




  




  
<script src="/hexo-blog/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/hexo-blog/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://cherryyang05.github.io/hexo-blog/767f71ea.html',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'I0GaPlLWJSoCb0ieY9V3Vd7Q-gzGzoHsz',
      appKey     : 'sye9GNy0K7KNBHd69HYFsPzV',
      placeholder: "评论支持 MarkDown 语法",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '5' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
