<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>北极熊不吃企鹅宝宝</title>
  
  <subtitle>为什么呢？</subtitle>
  <link href="https://cherryyang05.github.io/hexo-blog/atom.xml" rel="self"/>
  
  <link href="https://cherryyang05.github.io/hexo-blog/"/>
  <updated>2024-10-25T18:39:01.862Z</updated>
  <id>https://cherryyang05.github.io/hexo-blog/</id>
  
  <author>
    <name>Cherry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://cherryyang05.github.io/hexo-blog/0.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/0.html</id>
    <published>2024-10-25T18:39:01.862Z</published>
    <updated>2024-10-25T18:39:01.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异构模块设计"><a href="#异构模块设计" class="headerlink" title="异构模块设计"></a>异构模块设计</h1><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h1><p>将 SSD 和磁带组成缓存结构的异构系统，SSD 作为主要流量承担的缓存设备，磁带作为数据永久存储的容量设备，用 SSD 平衡磁带的读写性能，使得异构系统用磁带的低成本大容量，表现出近似于 SSD 的读写性能。</p><p>但是和 SSD 和 HDD 这样的块设备不同，磁带是顺序设备，只支持顺序写入。传统的以 SSD 与 HDD 为主的异构系统的缓存设计更适用于小粒度的频繁读写，而磁带设备适用于大文件的归档及备份场景，传统的缓存结构对于这种场景来说效率较低。同时传统的缓存设计对时延较为敏感，而在档案馆这种地方，读取数据耽误个几秒钟似乎并没那么重要。</p><p>我们最需要考虑的一点是，当缓存上的数据下刷到磁带上时，应该保证顺序写入，但是真实情况下用户无法保证刷下去的数据都是顺序的。于是需要设计一个地址映射层，这样在外部看来，磁带是可以随机写的。</p><p>异构模块在全局的架构图如下。</p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1721715368909-6435d196-bc2f-40ee-ba16-a843639fb980.png" title="异构模块全局架构">​</p><p>其他需要关注的地方包括：缓存结构，替换算法。</p><p>可以进一步优化的点：高效查表，使用倒排页表，参考日志结构文件系统（LFS）将写操作先写入日志，在上层设计存储协议，数据去重和压缩，元数据管理，异步操作，预取和缓存预热，负载均衡和错误处理等。</p><h1 id="2-地址映射层（AML-Address-Mapping-Layer）"><a href="#2-地址映射层（AML-Address-Mapping-Layer）" class="headerlink" title="2. 地址映射层（AML, Address Mapping Layer）"></a>2. 地址映射层（AML, Address Mapping Layer）</h1><h2 id="2-1-整体介绍"><a href="#2-1-整体介绍" class="headerlink" title="2.1. 整体介绍"></a>2.1. 整体介绍</h2><p>地址映射层主要有两部分，第一部分位于缓存层上方，主要是为了将上层传来的逻辑地址转换成物理地址（磁带上的实际位置），以适应磁带的顺序写入特性。</p><p>第二部分位于缓存层和磁带中间，主要为了将缓存替换后的数据顺序下刷到磁带上。</p><p>地址映射层所起到的功能与操作系统中的页表机制类似，只是分配的页框从物理上随机变成物理上连续。</p><p>地址映射层在异构系统中的表现如下。</p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1721714040896-1ed232ce-ac93-45f7-aca8-504ef8cf0f3d.png">​</p><h2 id="2-2-映射表的设计"><a href="#2-2-映射表的设计" class="headerlink" title="2.2. 映射表的设计"></a>2.2. 映射表的设计</h2><h3 id="2-2-1-逻辑地址到物理地址的映射"><a href="#2-2-1-逻辑地址到物理地址的映射" class="headerlink" title="2.2.1. 逻辑地址到物理地址的映射"></a>2.2.1. 逻辑地址到物理地址的映射</h3><p>逻辑地址映射为物理地址大致方式如下：</p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1720704704438-4a086dd5-4d1b-4c68-8e85-0a8034b398ea.png">​</p><p>其中：</p><p><strong>逻辑地址</strong>  是输入的 trace 文件中的 offset 字段</p><p><strong>物理地址</strong>  是写入磁带的地址</p><p>和操作系统中的页表类似，需要维护一张表，称为<strong>块表（Block Table）</strong> ，用来存储逻辑地址到物理地址的映射关系。</p><p>这里的每个表项存储的是一个块，块大小为 256KB，即该异构系统最小存储单位是 256KB。磁带容量为 18T，即有<img data-src="https://cdn.nlark.com/yuque/__latex/b6f95f4de4cd5a135b26d0fdf46ede99.svg">个表项，每个表项 4B，一共需要<img data-src="https://cdn.nlark.com/yuque/__latex/81850fef59d52e524daf8a9755c4dd65.svg">，即 512MB。</p><p>【后续考虑是否需要设计多级块表】</p><p><strong>块表表项结构</strong></p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1721716327392-e81b9c9e-92f0-4127-a0a6-5f78a38fe27e.png">​</p><p>映射表每个表项为 32 位，只需要高 27 位表示地址块号，第 0 位为有效位，第 1 位为修改位，2-4 位保留另作他用。</p><p>由于映射表按照块来分配，每个数据块对应一个表项，因此表项的索引可以通过逻辑地址的前 27 位块号来唯一指示，因此表项中只需存放映射的物理地址块号。</p><p>【PS：这里的页表和操作系统中的页表的不同之处在于，操作系统中的逻辑地址表示的范围远超过内存，而异构模块中逻辑地址和（磁带上的）物理地址表示范围一致】</p><h3 id="2-2-2-映射表的创建"><a href="#2-2-2-映射表的创建" class="headerlink" title="2.2.2. 映射表的创建"></a>2.2.2. 映射表的创建</h3><p>由于需要确保映射的物理地址是连续的，因此需要一个地址分配模块来分配连续的物理地址。简便起见，确保输入的 trace 对 256KB 对齐。</p><p><strong>地址分配模块</strong></p><ul><li>用变量 <code>pointer</code>​ 维护磁带上顺序的物理地址</li><li>根据 <code>length</code>​ 确定要写入的块表的表项数量（length &#x2F; blk_size 向上取整）</li><li>最后根据 <code>linear_phyaddr</code>​ 将表项填入表中</li></ul><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1720704690588-6a98fefa-97b0-468b-8da7-867ad63a1330.png">​</p><p><strong>AML 流程示例</strong></p><p>地址映射层从缓存接收被逐出的数据块 B，获取到逻辑地址(二进制为：<strong>0</strong> <strong>0000 0000 0000 0000 0000 0001 00</strong>00 0000 0000 0000 0000，块号为 27 位，偏移量为 18 位，共 45 位)，长度为 1MB，pointer 字段为 <code>flushing_phyaddr</code>​，初始值为 0，表示已经下刷到磁带上的顺序物理地址。</p><p>首先取出逻辑地址的块号为 <strong>0</strong> <strong>0000 0000 0000 0000 0000 0001 00</strong>，十进制为 4，再取出数据块的长度，为 1MB，需要切分成 4 个 256KB 的块。用来指示已经下刷到磁带上的顺序物理地址当前为 0，因此块号为 4 的逻辑地址映射到物理地址 0，块号为 5 的逻辑地址映射到物理地址 1，块号为 6 的逻辑地址映射到物理地址 2，块号为 7 的逻辑地址映射到物理地址 3。具体如下图。</p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1721719315323-676259ae-6bb3-4e49-a1f8-a094b61b0ab8.png">​</p><h1 id="3-缓存层（Cache-Layer）"><a href="#3-缓存层（Cache-Layer）" class="headerlink" title="3. 缓存层（Cache Layer）"></a>3. 缓存层（Cache Layer）</h1><h2 id="3-1-整体介绍"><a href="#3-1-整体介绍" class="headerlink" title="3.1. 整体介绍"></a>3.1. 整体介绍</h2><p>在异构模块中，使用 SSD 承担绝大部分写入流量，当写满时便需要下刷数据到磁带中，因此缓存层主要功能是用来管理需要下刷的数据。如何增加系统的读写命中率，以及如何高效地下刷是缓存层首要考虑的事情。</p><p>对于缓存的设计，见下面文档。</p><p><a href="https://www.yuque.com/attachments/yuque/0/2024/pdf/25899876/1720769013656-116a6e61-c9ac-4e00-a27d-2b18a392a9a1.pdf">缓存的设计与实现（新增）.pdf</a></p><h2 id="3-2-缓存组织方式"><a href="#3-2-缓存组织方式" class="headerlink" title="3.2. 缓存组织方式"></a>3.2. 缓存组织方式</h2><p>缓存组织方式暂时采用组相连策略。</p><h2 id="3-3-缓存替换策略"><a href="#3-3-缓存替换策略" class="headerlink" title="3.3. 缓存替换策略"></a>3.3. 缓存替换策略</h2><p>考虑到以顺序写为主，替换策略考虑使用 FIFO 策略。</p><h2 id="3-4-缓存数据下刷"><a href="#3-4-缓存数据下刷" class="headerlink" title="3.4. 缓存数据下刷"></a>3.4. 缓存数据下刷</h2><h3 id="3-4-1-设计思路"><a href="#3-4-1-设计思路" class="headerlink" title="3.4.1. 设计思路"></a>3.4.1. 设计思路</h3><p>由于异构模块每次读取一个请求，因此当缓存满的时候，也会在缓存中替换下与该次请求等量数据大小的数据。遗憾的是，仅仅将每次替换的数据顺序写入不会让磁带机的性能达到最大，经过我们的测试发现，在请求粒度很小时（相对于磁带这种介质来说），例如 100MB 以下，带宽甚至达不到峰值带宽的一半。因此我考虑使用写缓冲，异构模块会跟踪 SSD 中的缓冲区（将作为缓存的 SSD 划分一点空间作为缓冲区），当缓冲区收到足够数量的数据时（例如 2GB），会统一刷新到磁带上。</p><h3 id="3-4-2-P2P-映射表的创建"><a href="#3-4-2-P2P-映射表的创建" class="headerlink" title="3.4.2. P2P 映射表的创建"></a>3.4.2. P2P 映射表的创建</h3><p>整体的流程如下图所示。</p><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1721719918821-225cfd82-0c19-40cd-b72f-807891199697.png">​</p><p>首先地址映射层接收缓存替换下来的数据块<img data-src="https://cdn.nlark.com/yuque/__latex/4b46685f65a37bff105c6a14ce103f48.svg">，L 表示该数据块逻辑地址，根据 <code>flushing_phyaddr</code>​，图中为 m+1，将其物理地址映射成要下刷到磁带上的地址（图中为<img data-src="https://cdn.nlark.com/yuque/__latex/d3980096c192fa6d238544738f976fe5.svg">），然后写入缓冲区 1（图中称为 <code>Seq Segment 1</code>​），同时将映射信息写入块表（将<img data-src="https://cdn.nlark.com/yuque/__latex/4b46685f65a37bff105c6a14ce103f48.svg">映射到<img data-src="https://cdn.nlark.com/yuque/__latex/d3980096c192fa6d238544738f976fe5.svg">）。</p><h3 id="3-4-3-写缓冲要多少"><a href="#3-4-3-写缓冲要多少" class="headerlink" title="3.4.3. 写缓冲要多少"></a>3.4.3. 写缓冲要多少</h3><p>写缓冲区是 SSD 中的一片区域，用来批量地聚集在缓存中替换下来的数据块。考虑到磁带如此令人担忧的性能，如果只设计单缓冲，在等待数据下刷的时候，缓存层只能被阻塞，等待数据的下刷完成，严重影响从上层接收数据的带宽。尽管磁带的顺序写带宽超过目前绝大多数的 HDD，但是我仍然想让它更高效，因此我在 3.4.2 的示意图中设置了两个写缓冲，但这只代表这不是单缓冲，毕竟从单到双和从双到多有本质区别。</p><p>那么到底要设置多少个缓冲呢？更准确的表达应该是需要一个负责下刷的缓冲（毕竟目前只有一个磁带机，而磁带是单通道设备），以及多少负责暂存缓存替换下来的数据用以抵消负责下刷的缓冲的延时。</p><p>经过朴素的理论分析，暂存缓冲区的数量受缓存中替换下来的数据块频率决定。试想如果一个负载总是没有命中缓存，那么缓存每次都要替换，那么进入写缓冲的数据就会变多，下刷到磁带的压力就会变大，整体系统的时延便会增加。反之，最理想的情况下，命中率为 100%，写缓冲就不会有数据进来。</p><p>因此写缓冲的大小至少为两个，一个下刷，另一个承接缓存中替换下来的数据块。而这样的双缓冲是否可以抵消下刷到磁带的延时，可以考虑使用配置参数给系统动态调整，当然写缓冲也不宜过多，毕竟占据了 SSD 的空间，管理起来也需要开销。</p><h1 id="4-负载的读操作随机度度量"><a href="#4-负载的读操作随机度度量" class="headerlink" title="4. 负载的读操作随机度度量"></a>4. 负载的读操作随机度度量</h1><p>引入随机度的动机：探究与 SSD 和 HDD 的异构性能一致的随机度的临界点</p><p>地址映射前有个读随机度，映射后有个随机度，可以比较异构模块对降低随机度的影响</p><h2 id="4-1-熵（Entropy）"><a href="#4-1-熵（Entropy）" class="headerlink" title="4.1. 熵（Entropy）"></a>4.1. 熵（Entropy）</h2><p>​<img data-src="https://cdn.nlark.com/yuque/0/2024/png/25899876/1722950778624-501d73f6-b533-4340-92a9-4473555984e4.png">​</p><p>熵是信息论中的一个概念，用来衡量信息的不确定性或随机性。在存储系统的上下文中，熵可以反映读操作的随机性。</p><p><strong>计算步骤：</strong></p><ol><li>统计频率：对于每个数据块，计算其被访问的次数，并计算这些访问次数在所有读操作中所占的比例。</li></ol><p>比如某个块被访问了<img data-src="https://cdn.nlark.com/yuque/__latex/77db1de84c57b9099d7206fb2c0f1ca3.svg">次，总共有 N 次读操作，那么这个块的访问比例为<img data-src="https://cdn.nlark.com/yuque/__latex/ab91acd42146db3a3a7c7f761f714dff.svg">。</p><ol start="2"><li>计算熵：根据每个块的访问比例，使用以下公式计算熵：</li></ol><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/27aadc064e81cfaf0acbe9a4fc8b7daa.svg">​</p><p>其中，m 是被访问的块的数量，<img data-src="https://cdn.nlark.com/yuque/__latex/39c69fbad0041c1d5caa9acf313cb0e6.svg">是第 i 个块的访问比例。</p><p><strong>熵越高，表示读操作的分布越均匀、越随机。</strong> 最大熵发生在所有数据块被均匀访问的情况下。</p><p><strong>熵越低，表示读操作的分布越集中、越有规律。</strong> 例如，如果只有少数几个块被频繁访问，而其他块很少被访问，熵值会很低。</p><p>考虑到熵的值会受访问次数的影响，因此在不同的负载下，无法直接用熵值比较其随机性。考虑使用归一化熵（normalized entropy），使得熵值能够在不同的访问次数下进行统一比较。</p><p>归一化熵通过将熵值归一化，使其范围固定在 <code>[0, 1]</code>​ 之间。归一化的过程是将实际的熵值除以其最大可能的熵值。</p><p>对于一个有 <code>n</code>​ 个数据块的系统，最大熵发生在所有数据块被均匀访问的情况下，此时熵值为：</p><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/0825f86295a52b885ab499a550488ab3.svg">​</p><p>归一化熵的计算公式为：</p><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/7255eb6eb60692bf285b57ffc6c40f7d.svg">​</p><p>这样，无论访问次数是多少，归一化熵都可以在 <code>0</code>​ 到 <code>1</code>​ 之间进行比较，其中 <code>0</code>​ 表示完全有规律的分布（例如完全集中于一个块），<code>1</code>​ 表示完全随机的均匀分布。</p><h2 id="4-2-平均跳跃距离-（Average-Jump-Distance）"><a href="#4-2-平均跳跃距离-（Average-Jump-Distance）" class="headerlink" title="4.2. 平均跳跃距离 （Average Jump Distance）"></a>4.2. 平均跳跃距离 <strong>（Average Jump Distance）</strong></h2><p>跳跃距离指的是每一个读操作上一个请求结束后磁头所处的位置的块号之差。如果读操作是顺序的，这个差值会很小。</p><p><strong>计算方法：</strong></p><ol><li>计算相邻读操作的跳跃距离：对于每一个读操作，计算该读操作距离上一个请求结束后磁头所处的位置的块号之差，得到一系列的跳跃距离。</li></ol><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/b140cae608bfef9a9b9600f58add5dd4.svg">​</p><ol start="2"><li>求平均跳跃距离：将所有的跳跃距离取平均，得到平均跳跃距离。</li></ol><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/85703ea08de0b8027067f7188054e987.svg">​</p><p>其中，<img data-src="https://cdn.nlark.com/yuque/__latex/459f3c80a50b7be28751b0869ef5386a.svg">是读操作的总数。</p><p>平均跳跃距离越大，说明读操作的随机性越高；越小，说明读操作顺序性越高。</p><h2 id="4-3-熵和平均跳跃距离结合"><a href="#4-3-熵和平均跳跃距离结合" class="headerlink" title="4.3. 熵和平均跳跃距离结合"></a>4.3. 熵和平均跳跃距离结合</h2><p>熵指示了<strong>读操作的局部性</strong>，可以反映出是否读操作集中在某些热点区域。</p><p>平均跳跃距离指示了<strong>读操作的顺序性</strong>，映射到磁带机上就是磁头平均移动的距离。</p><p>使用   <strong>(熵, 平均跳跃距离)</strong>   的二元组来表征一个负载的随机性，可以将负载分为四个区域。</p><h3 id="4-3-1-熵高平均跳跃距离高"><a href="#4-3-1-熵高平均跳跃距离高" class="headerlink" title="4.3.1. 熵高平均跳跃距离高"></a>4.3.1. <strong>熵高平均跳跃距离高</strong></h3><p><strong>读操作分布均匀（局部性不好），随机性较高。</strong></p><p>这种负载的随机性是最大的，会造成最大的磁头移动和 IO 开销，性能最差。</p><h3 id="4-3-2-熵高平均跳跃距离低"><a href="#4-3-2-熵高平均跳跃距离低" class="headerlink" title="4.3.2. 熵高平均跳跃距离低"></a>4.3.2. <strong>熵高平均跳跃距离低</strong></h3><p><strong>读操作分布均匀（局部性不好），顺序性较高。</strong></p><p>负载在全局的顺序性都较强，不存在热点区域，可能在全局上会有较好的缓存命中率，性能最好。</p><h3 id="4-3-3-熵低平均跳跃距离高"><a href="#4-3-3-熵低平均跳跃距离高" class="headerlink" title="4.3.3. 熵低平均跳跃距离高"></a>4.3.3. <strong>熵低平均跳跃距离高</strong></h3><p><strong>读操作集中在某些热点区域（局部性好），且随机性较高。</strong></p><p>表明负载可能存在几个分散的热点区域，在热点区域内的操作可能比较集中，但是热点相隔较远。</p><p>这可能是由于应用程序在处理不同类型的数据时，需要访问分布在不同地址空间的几个关键区域。磁头可能需要在不同热点区域频繁移动，造成巨大开销。</p><p>缓存可能在某些热点区域表现较好，但是由于不同特点区域相距较远，导致整体缓存命中率不理想，增加 IO 开销。</p><h3 id="4-3-4-熵低平均跳跃距离低"><a href="#4-3-4-熵低平均跳跃距离低" class="headerlink" title="4.3.4. 熵低平均跳跃距离低"></a>4.3.4. <strong>熵低平均跳跃距离低</strong></h3><p><strong>读操作集中在某些热点区域（局部性好），且顺序性较高。</strong></p><p>负载可能在一块热点区域上或多块热点区域内有较高的顺序性。</p><p>读操作集中在某些块中会带来较低的熵值，从而对缓存系统较为友好，可能在局部带来较高的缓存命中率。因为磁带机是单通道设备，也无需担心操作过于集中在某些块上而导致并发访问的瓶颈。</p><h2 id="4-4-其他可能的参数"><a href="#4-4-其他可能的参数" class="headerlink" title="4.4. 其他可能的参数"></a>4.4. 其他可能的参数</h2><h3 id="4-4-1-基尼系数（Gini-Coefficient）"><a href="#4-4-1-基尼系数（Gini-Coefficient）" class="headerlink" title="4.4.1. 基尼系数（Gini Coefficient）"></a>4.4.1. 基尼系数（Gini Coefficient）</h3><p>基尼系数通常用来衡量收入分配的不平等性，但在存储系统中，它可以用来衡量读操作的集中度。</p><p><strong>计算步骤：</strong></p><ol><li>排序访问频率：首先将数据块按访问次数从小到大排序。</li><li>计算累积频率：计算累积访问次数，并用这些数据来计算基尼系数。基尼系数的计算公式为：</li></ol><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/2cb2eb88a6168b9a5d6599126d49ba8d.svg">​</p><p>其中：</p><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/ba1b6e7a2a5f6e2808e06f1b6133bb82.svg">是到第<img data-src="https://cdn.nlark.com/yuque/__latex/2443fbcfeb7e85e1d62b6f5e4f27207e.svg">个块的累积访问次数。</p><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/4760e2f007e23d820825ba241c47ce3b.svg">是被访问块的数量。</p><p>​<img data-src="https://cdn.nlark.com/yuque/__latex/eee2466f228c099cec8a86dec4bf6eb0.svg">是累积访问次数的总和。</p><ol start="3"><li>图形解释：基尼系数的几何解释通常使用洛伦兹曲线来表示，曲线越偏离对角线，基尼系数越高，表示分布越不平等。</li></ol><p>基尼系数 = 0，表示完全平等，每个块被访问的次数完全相同。</p><p>基尼系数 = 1，表示完全不平等，所有访问都集中在一个块上，其他块没有被访问。</p><h3 id="4-4-2-局部顺序性"><a href="#4-4-2-局部顺序性" class="headerlink" title="4.4.2. 局部顺序性"></a>4.4.2. 局部顺序性</h3><p>通过分析操作是否具有局部性来判断随机度。局部性好的操作表现为在某个短时间内集中访问相邻的块，而不是随机跳跃。</p><p><strong>计算方法：</strong></p><ol><li><strong>窗口滑动分析</strong>：设定一个固定大小的窗口（如 10 个操作），计算在这个窗口内访问的块的序列性。</li><li><strong>序列性得分</strong>：为每个窗口分配一个序列性得分，如果在窗口内操作都是顺序的，则得分高，否则得分低。</li><li><strong>总体评估</strong>：将所有窗口的得分取平均，得出整个负载的顺序性得分。</li></ol><p>得分越低，说明操作越随机；得分越高，说明操作越顺序。</p><h1 id="5-修改意见"><a href="#5-修改意见" class="headerlink" title="5. 修改意见"></a>5. 修改意见</h1><h2 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1. 1"></a>5.1. 1</h2><ul><li>异构模块在软件栈的什么位置</li><li>不同粒度大小测试</li><li>补充逻辑地址和物理地址在磁带和异构模块中的含义</li><li>缓存组相连适用于什么情况</li><li>SSD 做 HDD 的缓存的工作</li><li>ZNS SSD 做 Cache（HotStorage 2024）</li><li>设计一个方案用来标示 trace 的读操作随机度</li></ul><h2 id="5-2-2"><a href="#5-2-2" class="headerlink" title="5.2. 2"></a>5.2. 2</h2><ul><li>跨 wrap 代码</li><li>ppt 和 word</li></ul><h2 id="5-3-开题预答辩"><a href="#5-3-开题预答辩" class="headerlink" title="5.3. 开题预答辩"></a>5.3. 开题预答辩</h2><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><p><strong>日志文件系统</strong></p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异构模块设计&quot;&gt;&lt;a href=&quot;#异构模块设计&quot; class=&quot;headerlink&quot; title=&quot;异构模块设计&quot;&gt;&lt;/a&gt;异构模块设计&lt;/h1&gt;&lt;h1 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用patchelf解决vscode远程连接不支持低版本glibc的问题</title>
    <link href="https://cherryyang05.github.io/hexo-blog/2cbef437.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/2cbef437.html</id>
    <published>2024-03-27T16:52:56.000Z</published>
    <updated>2024-10-25T18:39:01.862Z</updated>
    
    <content type="html"><![CDATA[<p>VScode 1.86 版本的 remote 要求 glibc 2.28 及以上，于是在各种旧版本服务器上就不支持了。</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/image.png" alt="不支持的 OS 版本"></p><p>新版本刚发布就在 github 上的 <a href="https://github.com/microsoft/vscode/issues/203375">issue</a> 上讨论起来了，<a href="https://code.visualstudio.com/docs/remote/faq#_can-i-run-vs-code-server-on-older-linux-distributions">VScode 官方文档</a> 中也说明了，从 VS Code 版本 1.86.1（2024 年 1 月）开始提高了远程服务器构建工具链的最低要求。VS Code 分发的预构建服务器与基于 glibc 2.28 或更高版本的 Linux 发行版兼容。</p><p>当然给服务器升级 glibc 是一个极其危险的操作，本人曾经就瞎捣鼓升级了 glibc，结果导致系统崩溃，不得已重装了系统。</p><p><strong>我们可以利用 patchelf 手动指定动态库，避免了重新编译系统的 glibc。</strong></p><span id="more"></span><h2 id="1-动态链接库下载"><a href="#1-动态链接库下载" class="headerlink" title="1. 动态链接库下载"></a>1. 动态链接库下载</h2><p>github 上有较为方便的下载 glibc 的仓库 <a href="https://github.com/matrix1001/glibc-all-in-one">glibc-all-in-one</a></p><p>根据仓库的 README，查看支持的版本：<code>cat list</code></p><p>我选择的是 <code>2.31-0ubuntu9.14_amd64</code>，然后执行 <code>./download 2.31-0ubuntu9.14_amd64</code></p><p>在当前文件夹下会生成 <code>libs</code> 文件夹，就是刚刚下载的 <code>2.31-0ubuntu9.14_amd64</code> 的动态库。</p><p>然后执行 <code>./build 2.31 arm64</code>，这一步会在根目录下编译生成 <code>/glibc</code> 文件夹，可以将其移动到 <code>glibc-all-in-one</code> 文件夹中。</p><h2 id="2-用-patchelf-修改-vscode-server-依赖的-glibc-版本"><a href="#2-用-patchelf-修改-vscode-server-依赖的-glibc-版本" class="headerlink" title="2. 用 patchelf 修改 vscode-server 依赖的 glibc 版本"></a>2. 用 patchelf 修改 vscode-server 依赖的 glibc 版本</h2><p>在执行命令前，先删除 <code>.vscode-server</code> 文件夹，用 vscode 连接服务器，让它自动重新下载 vscode-server 相关文件，这个时候在 <code>~/.vscode-server/bin</code> 中应该只有一个由数字和字母组成随机字符串的文件夹（我的服务器上是 <code>863d2581ecda6849923a2118d93a088b0745d9d6</code>，不同人应该不一样），进入这个文件夹，有一个 <code>node</code> 二进制文件，我们要重新 patch 的就是这个文件。</p><p>执行命令：</p><p><code>patchelf --set-interpreter ~/pack/glibc-all-in-one/libs/2.31-0ubuntu9.14_amd64/ld-linux-x86-64.so.2 --set-rpath ~/pack/glibc-all-in-one/libs/2.31-0ubuntu9.14_amd64/:~/pack/glibc-all-in-one/glibc/2.31/amd64/lib --force-rpath ~/.vscode-server/bin/863d2581ecda6849923a2118d93a088b0745d9d6/node</code></p><p><code>--set-interpreter</code> 后面跟的是可执行文件的解释器路径，需要指定动态链接器的路径，路径为 <code>./glibc-all-in-one/libs/[your downloaded glibc version]/ld-linux-x86-64.so.2</code>，动态链接器负责在程序运行时加载所需的共享库。</p><p><code>--set-rpath</code> 这部分设置了可执行文件的运行时搜索路径（Runtime PATH），指定了程序在运行时搜索共享库时应该查找的路径。这里指定了两个路径包含了 glibc 核心库和其他库。这里的路径为 <code>glibc-all-in-one/libs</code> 文件夹下的你下载的不同版本的 glibc 文件夹和编译生成的 <code>glibc/[version]/[arch]/lib</code> 文件夹。</p><p><code>--force-rpath</code> 后面跟的就是要修改的 vscode-server 的 node 文件。</p><p>如果执行命令时提示：<code>patchelf: open: Text file busy</code>，将本机上 vscode 运行的远程连接关掉再执行就可以了。</p><p>重新打开 vscode，就不会有操作系统版本不支持的提示了~~</p><p><a href="https://zhangjk98.xyz/patchelf/">参考链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;VScode 1.86 版本的 remote 要求 glibc 2.28 及以上，于是在各种旧版本服务器上就不支持了。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/image.png&quot; alt=&quot;不支持的 OS 版本&quot;&gt;&lt;/p&gt;
&lt;p&gt;新版本刚发布就在 github 上的 &lt;a href=&quot;https://github.com/microsoft/vscode/issues/203375&quot;&gt;issue&lt;/a&gt; 上讨论起来了，&lt;a href=&quot;https://code.visualstudio.com/docs/remote/faq#_can-i-run-vs-code-server-on-older-linux-distributions&quot;&gt;VScode 官方文档&lt;/a&gt; 中也说明了，从 VS Code 版本 1.86.1（2024 年 1 月）开始提高了远程服务器构建工具链的最低要求。VS Code 分发的预构建服务器与基于 glibc 2.28 或更高版本的 Linux 发行版兼容。&lt;/p&gt;
&lt;p&gt;当然给服务器升级 glibc 是一个极其危险的操作，本人曾经就瞎捣鼓升级了 glibc，结果导致系统崩溃，不得已重装了系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以利用 patchelf 手动指定动态库，避免了重新编译系统的 glibc。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://cherryyang05.github.io/hexo-blog/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://cherryyang05.github.io/hexo-blog/tags/Linux/"/>
    
    <category term="glibc" scheme="https://cherryyang05.github.io/hexo-blog/tags/glibc/"/>
    
  </entry>
  
  <entry>
    <title>清理git记录中的大文件</title>
    <link href="https://cherryyang05.github.io/hexo-blog/f6c73689.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/f6c73689.html</id>
    <published>2024-03-27T15:26:55.000Z</published>
    <updated>2024-10-25T18:39:01.862Z</updated>
    
    <content type="html"><![CDATA[<p>前几天我想把一个本地仓库推送到 github 仓库中时提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">remote: error: Trace: 9222dcf96227a19766567c1da4183cfef7b9ec21689a2ee21f6c1c3b2f1fab7a</span><br><span class="line">remote: error: See https://gh.io/lfs for more information.</span><br><span class="line">remote: error: File 18T.trace is 771.88 MB; this exceeds GitHub&#x27;s file size limit of 100.00 MB</span><br><span class="line">remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.</span><br><span class="line">To https://github.com/CherryYang05/DiskPine.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (pre-receive hook declined)</span><br><span class="line">错误：无法推送一些引用到 &#x27;https://github.com/CherryYang05/DiskPine.git&#x27;</span><br></pre></td></tr></table></figure><p>发现在之前的 git 记录中有一个大文件（18T.trace 771.88MB），但是在最新的提交记录中，我已经将其删除了，却依然无法推送。</p><p>经过查询资料，找到了解决方法：</p><ol><li>若文件还没有删除，并且需要将其推送到远程仓库，使用 LFS(Large File Storage) 修改文件大小的限制；</li><li>若文件已经删除，使用 BFG Repo-Cleaner 清理 git 历史记录中对大文件的引用。</li></ol><span id="more"></span><h2 id="1-LFS"><a href="#1-LFS" class="headerlink" title="1. LFS"></a>1. LFS</h2><p>Git LFS 是一个命令行扩展，用于使用 Git 管理大文件。git-lfs <a href="https://github.com/git-lfs/git-lfs">Github 链接</a></p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><ol><li>初始化 lfs：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><ol start="2"><li>添加需要上传的文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;your_big_file&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>将文件添加到暂存区：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;your_big_file&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>提交文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Add big file&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>推送到远程仓库：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="1-3-注意"><a href="#1-3-注意" class="headerlink" title="1.3 注意"></a>1.3 注意</h3><ul><li>LFS 仅支持新的提交记录，无法修改历史记录中的引用；</li><li>若需要清理历史记录中的引用，需要使用 BFG Repo-Cleaner。</li></ul><p>其他使用方式见 <a href="https://github.com/git-lfs/git-lfs?tab=readme-ov-file#example-usage">Example Usage</a>。</p><h2 id="2-BFG"><a href="#2-BFG" class="headerlink" title="2. BFG"></a>2. BFG</h2><p>BFG Repo-Cleaner 是一个由 Scala 编写的命令行工具，用于快速、精确地从 Git 仓库中删除不需要的数据。相比于 git-filter-branch 命令，BFG 的速度更快，使用也更简单。无论是大文件还是敏感数据，只需简单的命令，就能将其从所有提交历史中移除。</p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>在 <a href="https://rtyley.github.io/bfg-repo-cleaner/">这里</a> 下载 bfg-1.14.0.jar 包，或者使用 curl 下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o bfg.jar -L https://repo1.maven.org/maven2/com/madgag/bfg/1.14.0/bfg-1.14.0.jar</span><br></pre></td></tr></table></figure><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><ol><li>首先，将要清理的文件添加到 <code>.gitignore</code> 文件中，以免再次出现在提交中；</li><li>然后，使用 BFG 清理大文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M &lt;repo&gt;.git</span><br></pre></td></tr></table></figure><p>其中，<code>--strip-blobs-bigger-than 100M</code> 表示删除大于 100M 的文件。</p><ol start="3"><li>接着，清理 git 历史记录中的引用：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;repo&gt;</span><br><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></table></figure><ol start="4"><li>最后，推送到远程仓库：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h3><ul><li>BFG Repo-Cleaner 只会修改本地仓库，不会修改远程仓库；</li><li>BFG Repo-Cleaner 会修改 commit 的 hash 值，因此不要使用 <code>git pull</code> 同步远程仓库，而是使用 <code>git fetch</code>；</li><li>BFG Repo-Cleaner 会修改提交记录，因此可能会导致冲突，需要手动解决。</li></ul><h3 id="2-4-参考链接"><a href="#2-4-参考链接" class="headerlink" title="2.4 参考链接"></a>2.4 参考链接</h3><ol><li><a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG Repo-Cleaner</a></li><li>[BFG Repo-Cleaner - GitHub](</li></ol><h3 id="2-1-安装-1"><a href="#2-1-安装-1" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>jar 包<a href="https://rtyley.github.io/bfg-repo-cleaner/">下载链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天我想把一个本地仓库推送到 github 仓库中时提示：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;remote: error: Trace: 9222dcf96227a19766567c1da4183cfef7b9ec21689a2ee21f6c1c3b2f1fab7a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: See https://gh.io/lfs for more information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: File 18T.trace is 771.88 MB; this exceeds GitHub&amp;#x27;s file size limit of 100.00 MB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To https://github.com/CherryYang05/DiskPine.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ! [remote rejected] master -&amp;gt; master (pre-receive hook declined)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;错误：无法推送一些引用到 &amp;#x27;https://github.com/CherryYang05/DiskPine.git&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;发现在之前的 git 记录中有一个大文件（18T.trace 771.88MB），但是在最新的提交记录中，我已经将其删除了，却依然无法推送。&lt;/p&gt;
&lt;p&gt;经过查询资料，找到了解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若文件还没有删除，并且需要将其推送到远程仓库，使用 LFS(Large File Storage) 修改文件大小的限制；&lt;/li&gt;
&lt;li&gt;若文件已经删除，使用 BFG Repo-Cleaner 清理 git 历史记录中对大文件的引用。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="git" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/git/"/>
    
    
    <category term="Linux" scheme="https://cherryyang05.github.io/hexo-blog/tags/Linux/"/>
    
    <category term="git" scheme="https://cherryyang05.github.io/hexo-blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>执行 yum 提示CRITICAL</title>
    <link href="https://cherryyang05.github.io/hexo-blog/d74c62dc.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/d74c62dc.html</id>
    <published>2024-03-21T16:52:56.000Z</published>
    <updated>2024-10-25T18:39:01.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行-yum-命令提示-CRITICAL-yum-cli-Config-Error-Error-accessing-file-for-config-file-x2F-x2F-x2F-etc-x2F-yum-conf"><a href="#执行-yum-命令提示-CRITICAL-yum-cli-Config-Error-Error-accessing-file-for-config-file-x2F-x2F-x2F-etc-x2F-yum-conf" class="headerlink" title="执行 yum 命令提示 CRITICAL:yum.cli:Config Error: Error accessing file for config file:&#x2F;&#x2F;&#x2F;etc&#x2F;yum.conf"></a>执行 yum 命令提示 CRITICAL:yum.cli:Config Error: Error accessing file for config file:&#x2F;&#x2F;&#x2F;etc&#x2F;yum.conf</h1><p>关于这个问题，网上可以找到很多解决方案，包括但不限于：</p><ol><li>重新安装 yum</li><li>重新创建 &#x2F;etc&#x2F;yum.conf文件</li><li>使用 rpm 卸载当前安装的包</li></ol><p>但是最后仍然报同样的错误。</p><p>因为之前在更换 libc 版本，手动编译安装了 glibc，最后搜到这个<a href="https://www.silverdragon.cn/archives/7252/">博客</a>，得知是 curl 出了问题，是 libcurl 版本过低，libcurl 是 c&#x2F;cpp 使用时的链接库，常用的 http get，post 请求，http，ftp 下载等都支持</p><p>curl 的功能实现是依赖 libcurl.so 这个动态链接库的，通常位于 &#x2F;lib64 或者 &#x2F;usr&#x2F;lib64 中，4.x 版本的链接库地址为 libcurl.so.4</p><p>最后发现 libcurl 版本为 4.3.0，可能不支持 glibc-2.30 高版本的运行时，因此重新下载了高版本的 libcurl，具体操作见<a href="https://www.silverdragon.cn/archives/7252/">博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;执行-yum-命令提示-CRITICAL-yum-cli-Config-Error-Error-accessing-file-for-config-file-x2F-x2F-x2F-etc-x2F-yum-conf&quot;&gt;&lt;a href=&quot;#执行-yum-命令提示-C</summary>
      
    
    
    
    <category term="运维" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="配置" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E8%BF%90%E7%BB%B4/%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="yum" scheme="https://cherryyang05.github.io/hexo-blog/tags/yum/"/>
    
    <category term="配置" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Centos" scheme="https://cherryyang05.github.io/hexo-blog/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>log4rs日志库解析</title>
    <link href="https://cherryyang05.github.io/hexo-blog/faf96547.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/faf96547.html</id>
    <published>2023-11-28T13:44:55.000Z</published>
    <updated>2024-10-25T18:39:01.862Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/sfackler/log4rs">log4rs</a> 是rust实现的高度可配置日志库，该库配置的方式比较灵活，功能相对丰富，可以满足绝大部分的项目需要。</p><span id="more"></span><h2 id="一、用法示例"><a href="#一、用法示例" class="headerlink" title="一、用法示例"></a>一、用法示例</h2><p>首先先给个简单示例，通过这个示例就可以看出log4rs进行日志配置非常的灵活：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log4rs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    log4rs::<span class="title function_ invoke__">init_file</span>(<span class="string">&quot;log.yaml&quot;</span>,<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    info!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志配置文件如下：（文件格式不唯一，可以是yaml,json,toml等格式，下面是yaml格式的配置文件）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scan this file for changes every 30 seconds</span></span><br><span class="line"><span class="attr">refresh_rate:</span> <span class="number">30</span> <span class="string">seconds</span></span><br><span class="line"></span><br><span class="line"><span class="attr">appenders:</span></span><br><span class="line">  <span class="comment"># An appender named &quot;stdout&quot; that writes to stdout</span></span><br><span class="line">  <span class="attr">stdout:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">console</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># An appender named &quot;requests&quot; that writes to a file with a custom pattern encoder</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;log/requests.log&quot;</span></span><br><span class="line">    <span class="attr">encoder:</span></span><br><span class="line">      <span class="attr">pattern:</span> <span class="string">&quot;&#123;d&#125; - &#123;m&#125;&#123;n&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the default logging level to &quot;info&quot; and attach the &quot;stdout&quot; appender to the root</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">stdout</span></span><br><span class="line"></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="comment"># Raise the maximum log level for events sent to the &quot;app::backend::db&quot; logger to &quot;info&quot;</span></span><br><span class="line">  <span class="attr">app::backend::db:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Route log events sent to the &quot;app::requests&quot; logger to the &quot;requests&quot; appender,</span></span><br><span class="line">  <span class="comment"># and *not* the normal appenders installed at the root</span></span><br><span class="line">  <span class="attr">app::requests:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">appenders:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">requests</span></span><br><span class="line">    <span class="attr">additive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sl@Li:~/Works/study/helloworld$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.09s</span><br><span class="line">     Running `target/debug/helloworld`</span><br><span class="line">2018-12-10T10:11:45.240346970+08:00 INFO helloworld - Hello, world!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里因为appenders配置的是stdout对应的输出到控制台，所以日志信息输出在了控制台上，如果选择的是requests，则日志信息就输出在了对应路径文件上。</p><p>当然日志配置的方式除了配置文件，还可以在程序代码中进行配置，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log4rs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> log::LogLevelFilter;</span><br><span class="line"><span class="keyword">use</span> log4rs::append::console::ConsoleAppender;</span><br><span class="line"><span class="keyword">use</span> log4rs::append::file::FileAppender;</span><br><span class="line"><span class="keyword">use</span> log4rs::encode::pattern::PatternEncoder;</span><br><span class="line"><span class="keyword">use</span> log4rs::config::&#123;Appender, Config, Logger, Root&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stdout</span> = ConsoleAppender::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">requests</span> = FileAppender::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">encoder</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PatternEncoder::<span class="title function_ invoke__">new</span>(<span class="string">&quot;&#123;d&#125; - &#123;m&#125;&#123;n&#125;&quot;</span>)))</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(<span class="string">&quot;log/requests.log&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">appender</span>(Appender::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">build</span>(<span class="string">&quot;stdout&quot;</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(stdout)))</span><br><span class="line">        .<span class="title function_ invoke__">appender</span>(Appender::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">build</span>(<span class="string">&quot;requests&quot;</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(requests)))</span><br><span class="line">        .<span class="title function_ invoke__">logger</span>(Logger::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">build</span>(<span class="string">&quot;app::backend::db&quot;</span>, LogLevelFilter::Info))</span><br><span class="line">        .<span class="title function_ invoke__">logger</span>(Logger::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">appender</span>(<span class="string">&quot;requests&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">additive</span>(<span class="literal">false</span>)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(<span class="string">&quot;app::requests&quot;</span>, LogLevelFilter::Info))</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(Root::<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">appender</span>(<span class="string">&quot;stdout&quot;</span>).<span class="title function_ invoke__">build</span>(LogLevelFilter::Warn))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = log4rs::<span class="title function_ invoke__">init_config</span>(config).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">//配置完成，下面输出日志信息即可</span></span><br><span class="line">    <span class="comment">// use handle to change logger configuration at runtime</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以看到用代码的方式比较麻烦，所以推荐使用配置文件的方式，程序简洁，修改方便，配置灵活，何乐不为啊。</span></span><br></pre></td></tr></table></figure><p>log4rs有上面的两种配置形式，函数如下：</p><ul><li>init_config —— Initializes the global logger as a log4rs logger with the provided config.（通过代码配置）</li><li>init_file —— Initializes the global logger as a log4rs logger configured via a file.（通过配置文件配置）</li></ul><p>其实init_file函数实现的内部调用了init_config函数，也就是说是通过读配置文件通过序列化的方式得到config，再调用init_config。（源代码：<a href="https://docs.rs/log4rs/0.7.0/src/log4rs/priv_file.rs.html#23-51%EF%BC%89">https://docs.rs/log4rs/0.7.0/src/log4rs/priv_file.rs.html#23-51）</a></p><p>通过程序配置较好理解，通过配置文件的话，是有一定的格式及定义要求的，yaml,json,toml等要按一定的规则才能生成正确的配置文件，下面以yaml格式为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If set, log4rs will scan the file at the specified rate for changes and</span></span><br><span class="line"><span class="comment"># automatically reconfigure the logger. The input string is parsed by the</span></span><br><span class="line"><span class="comment"># humantime crate.</span></span><br><span class="line"><span class="attr">refresh_rate:</span> <span class="number">30</span> <span class="string">seconds#配置文件的刷新速率，可以理解为每隔30s重新读取一次配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The &quot;appenders&quot; map contains the set of appenders, indexed by their names.</span></span><br><span class="line"><span class="attr">appenders:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">foo:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># All appenders must specify a &quot;kind&quot;, which will be used to look up the</span></span><br><span class="line">    <span class="comment"># logic to construct the appender in the `Deserializers` passed to the</span></span><br><span class="line">    <span class="comment"># deserialization function.</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">console</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Filters attached to an appender are specified inside the &quot;filters&quot;</span></span><br><span class="line">    <span class="comment"># array.</span></span><br><span class="line">    <span class="attr">filters:</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Like appenders, filters are identified by their &quot;kind&quot;.</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">threshold</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The remainder of the configuration is passed along to the</span></span><br><span class="line">        <span class="comment"># filter&#x27;s builder, and will vary based on the kind of filter.</span></span><br><span class="line">        <span class="attr">level:</span> <span class="string">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The remainder of the configuration is passed along to the appender&#x27;s</span></span><br><span class="line">    <span class="comment"># builder, and will vary based on the kind of appender.</span></span><br><span class="line">    <span class="comment"># Appenders will commonly be associated with an encoder.</span></span><br><span class="line">    <span class="attr">encoder:</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Like appenders, encoders are identified by their &quot;kind&quot;.</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="comment"># Default: pattern</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">pattern</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The remainder of the configuration is passed along to the</span></span><br><span class="line">      <span class="comment"># encoder&#x27;s builder, and will vary based on the kind of encoder.</span></span><br><span class="line">      <span class="attr">pattern:</span> <span class="string">&quot;&#123;d&#125; [&#123;t&#125;] &#123;m&#125;&#123;n&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The root logger is configured by the &quot;root&quot; map.</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The maximum log level for the root logger.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Default: warn</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">warn</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The list of appenders attached to the root logger.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Default: empty list</span></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The &quot;loggers&quot; map contains the set of configured loggers, indexed by their</span></span><br><span class="line"><span class="comment"># names.</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">foo::bar::baz:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The maximum log level.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Default: parent logger&#x27;s level</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">trace</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The list of appenders attached to the logger.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Default: empty list</span></span><br><span class="line">    <span class="attr">appenders:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The additivity of the logger. If true, appenders attached to the logger&#x27;s</span></span><br><span class="line">    <span class="comment"># parent will also be attached to this logger.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attr">Default:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">additive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>通过上面的示例，基本用法就差不多了，下面继续深入学习一下log4rs。</p><h2 id="二、log4rs"><a href="#二、log4rs" class="headerlink" title="二、log4rs"></a>二、log4rs</h2><p>log4rs由4部分组成：appenders（输出到什么地方去）， encoders（按什么格式输出）， filters（那些可以输出，那些不能输出），loggers（日志实例）。</p><h4 id="【1】appenders"><a href="#【1】appenders" class="headerlink" title="【1】appenders"></a>【1】appenders</h4><blockquote><p>An appender takes a log record and logs it somewhere, for example, to a file, the console, or the syslog.</p></blockquote><p>appenders主要有以下三种：</p><ul><li>console  —— The console appender.（输出到控制台）</li><li>file ——The file appender.（输出到文件）</li><li>rolling_file ——  A rolling file appender.（实现文件回滚）</li></ul><p>分别实现了输出到控制台，输出到文件，实现文件回滚等功能。其中较为复杂的是rolling_file，这也是我们工程中常用到的，比如实现日志大小的控制（控制日志文件大小为10MB，到达10MB后，自动清空日志，重新开始记录），实现日志文件数量的控制(限制数量的同时限制单个文件大小)等等。下面给一个rolling_file的示例程序，说明一下它的用法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> log4rs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::default::<span class="built_in">Default</span>;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    log4rs::<span class="title function_ invoke__">init_file</span>(<span class="string">&quot;config/log4rs.yaml&quot;</span>,<span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">2</span>&#123;</span><br><span class="line">        info!(<span class="string">&quot;booting up &#123;&#125;&quot;</span>,i);</span><br><span class="line">        error!(<span class="string">&quot;error test &#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//无限循环，不断记录日志</span></span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        info!(<span class="string">&quot;booting up &quot;</span>);</span><br><span class="line">        error!(<span class="string">&quot;error test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是配置文件，通过不同的配置去实现不同功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现了限制日志文件大小为1024Byte的功能。</span></span><br><span class="line"><span class="attr">appenders:</span></span><br><span class="line">  <span class="attr">stdout:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">console</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;requests.log&quot;</span></span><br><span class="line">    <span class="attr">encoder:</span></span><br><span class="line">      <span class="attr">pattern:</span> <span class="string">&quot;&#123;d&#125; [&#123;t&#125;] &#123;l&#125; &#123;M&#125;:&#123;m&#125;&#123;n&#125;&quot;</span></span><br><span class="line"> <span class="comment">################################################## </span></span><br><span class="line">  <span class="string">roll:#定义rooling_file的appenders</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">rolling_file</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;roll.log&quot;</span></span><br><span class="line">    <span class="attr">append:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">encoder:</span> </span><br><span class="line">      <span class="attr">kind:</span> <span class="string">pattern</span></span><br><span class="line">    <span class="attr">policy:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">compound</span></span><br><span class="line">      <span class="attr">trigger:</span> </span><br><span class="line">        <span class="attr">kind:</span> <span class="string">size</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">1024</span> <span class="comment">#限制大小为1024Byte</span></span><br><span class="line">      <span class="attr">roller:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">delete#回滚方式为直接删除</span></span><br><span class="line">  <span class="comment">##################################################</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">roll#使用roll</span> <span class="string">appenders</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">  <span class="attr">app::backend::db:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">app::requests:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">appenders:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">requests</span></span><br><span class="line">    <span class="attr">additive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>另为附加限制日志文件大小的配置文件及限制日志文件数量的配置参考代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yaml文件</span></span><br><span class="line"><span class="attr">appenders:</span></span><br><span class="line">  <span class="string">foo:#限制日志文件大小的配置</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">rolling_file</span></span><br><span class="line">    <span class="attr">path:</span> &#123;<span class="number">0</span>&#125;<span class="string">/foo.log</span></span><br><span class="line">    <span class="attr">policy:</span></span><br><span class="line">      <span class="attr">trigger:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">size</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">1024</span></span><br><span class="line">      <span class="attr">roller:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">delete</span></span><br><span class="line">  <span class="string">bar:#限制日志文件数量的配置</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">rolling_file</span></span><br><span class="line">    <span class="attr">path:</span> &#123;<span class="number">0</span>&#125;<span class="string">/foo.log</span></span><br><span class="line">    <span class="attr">policy:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">compound</span></span><br><span class="line">      <span class="attr">trigger:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">size</span></span><br><span class="line">        <span class="attr">limit:</span> <span class="number">5</span> <span class="string">mb</span></span><br><span class="line">      <span class="attr">roller:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">fixed_window</span></span><br><span class="line">        <span class="attr">pattern:</span> <span class="string">&#x27;&#123;0&#125;/foo.log.<span class="template-variable">&#123;&#123;&#125;&#125;</span>&#x27;</span></span><br><span class="line">        <span class="attr">base:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">count:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>对应的配置项的解说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">///</span> <span class="comment"># Configuration</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span> <span class="string">```yaml</span></span><br><span class="line"><span class="string">///</span> <span class="attr">kind:</span> <span class="string">rolling_file</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span> <span class="comment"># The path of the log file. Required.</span></span><br><span class="line"><span class="string">///</span> <span class="attr">path:</span> <span class="string">log/foo.log</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span> <span class="comment"># Specifies if the appender should append to or truncate the log file if it</span></span><br><span class="line"><span class="string">///</span> <span class="comment"># already exists. Defaults to `true`.</span></span><br><span class="line"><span class="string">///</span> <span class="attr">append:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span> <span class="comment"># The encoder to use to format output. Defaults to `kind: pattern`.</span></span><br><span class="line"><span class="string">///</span> <span class="attr">encoder:</span></span><br><span class="line"><span class="string">///</span>   <span class="attr">kind:</span> <span class="string">pattern</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span> <span class="comment"># The policy which handles rotation of the log file. Required.</span></span><br><span class="line"><span class="string">///</span> <span class="attr">policy:</span></span><br><span class="line"><span class="string">///</span>   <span class="comment"># Identifies which policy is to be used. If no kind is specified, it will</span></span><br><span class="line"><span class="string">///</span>   <span class="comment"># default to &quot;compound&quot;.</span></span><br><span class="line"><span class="string">///</span>   <span class="attr">kind:</span> <span class="string">compound</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span>   <span class="comment"># The remainder of the configuration is passed along to the policy&#x27;s</span></span><br><span class="line"><span class="string">///</span>   <span class="comment"># deserializer, and will vary based on the kind of policy.</span></span><br><span class="line"><span class="string">///</span>   <span class="attr">trigger:</span></span><br><span class="line"><span class="string">///</span>     <span class="attr">kind:</span> <span class="string">size</span></span><br><span class="line"><span class="string">///</span>     <span class="attr">limit:</span> <span class="number">10</span> <span class="string">mb</span></span><br><span class="line"><span class="string">///</span></span><br><span class="line"><span class="string">///</span>   <span class="attr">roller:</span></span><br><span class="line"><span class="string">///</span>     <span class="attr">kind:</span> <span class="string">delete</span></span><br><span class="line"><span class="string">///</span> <span class="string">```</span></span><br></pre></td></tr></table></figure><p>为什么是这样配置呢，或者说，这些配置项是从哪里来的，就要分析源代码了，以rolling_file为例：<br>rolling_file中含有5个结构体，分别是：</p><ul><li>LogFile —— Information about the active log file.</li><li>RollingFileAppender —— An appender which archives log files in a configurable strategy.</li><li>RollingFileAppenderBuilder —— A builder for the RollingFileAppender.</li><li><strong>RollingFileAppenderConfig —— Configuration for the rolling file appender.</strong></li><li>RollingFileAppenderDeserializer —— A deserializer for the RollingFileAppender.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Configuration for the rolling file appender.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RollingFileAppenderConfig</span> &#123;</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    append: <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;,</span><br><span class="line">    encoder: <span class="type">Option</span>&lt;EncoderConfig&gt;,</span><br><span class="line">    policy: Policy,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就列出了rolling_file appender的需要的配置项，其他的配置也是在***Config中，道理是一样的。</p><h4 id="【2】encoders"><a href="#【2】encoders" class="headerlink" title="【2】encoders"></a>【2】encoders</h4><blockquote><p>An encoder is responsible for taking a log record, transforming it into the appropriate output format, and writing it out.</p></blockquote><p>encoders主要由以下三部分组成：</p><ul><li>json ——An encoder which writes a JSON object.</li><li>pattern ——A simple pattern-based encoder.</li><li>writer —— Implementations of the encode::Write trait.</li></ul><p>最常用的是pattern，所以着重分析一下pattern。这个有些类似与其他语言的格式化器或者日志属性等概念，链接：<a href="https://docs.rs/log4rs/0.7.0/log4rs/encode/pattern/index.html">https://docs.rs/log4rs/0.7.0/log4rs/encode/pattern/index.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">d, date - The current time. By default, the ISO 8601 format is used. A custom format may be provided in the syntax accepted by chrono. The timezone defaults to local, but can be specified explicitly by passing a second argument of utc for UTC or local for local time.</span><br><span class="line">&#123;d&#125; - 2016-03-20T14:22:20.644420340-08:00</span><br><span class="line">&#123;d(%Y-%m-%d %H:%M:%S)&#125; - 2016-03-20 14:22:20</span><br><span class="line">&#123;d(%Y-%m-%d %H:%M:%S %Z)(utc)&#125; - 2016-03-20 22:22:20 UTC</span><br><span class="line">f, file - The source file that the log message came from, or ??? if not provided.</span><br><span class="line">h, highlight - Styles its argument according to the log level. The style is intense red for errors, red for warnings, blue for info, and the default style for all other levels.</span><br><span class="line">&#123;h(the level is &#123;l&#125;)&#125; - the level is ERROR</span><br><span class="line">l``, level - The log level.</span><br><span class="line">L, line - The line that the log message came from, or ??? if not provided.</span><br><span class="line">m, message - The log message.</span><br><span class="line">M, module - The module that the log message came from, or ??? if not provided.</span><br><span class="line">n - A platform-specific newline.</span><br><span class="line">t, target - The target of the log message.</span><br><span class="line">T, thread - The name of the current thread.</span><br><span class="line">I, thread_id - The ID of the current thread.</span><br><span class="line">X, mdc - A value from the MDC. The first argument specifies the key, and the second argument specifies the default value if the key is not present in the MDC. The second argument is optional, and defaults to the empty string.</span><br><span class="line">&#123;X(user_id)&#125; - 123e4567-e89b-12d3-a456-426655440000</span><br><span class="line">&#123;X(nonexistent_key)(no mapping)&#125; - no mapping</span><br><span class="line">An &quot;unnamed&quot; formatter simply formats its argument, applying the format specification.</span><br><span class="line">&#123;(&#123;l&#125; &#123;m&#125;)&#125; - INFO hello</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/sfackler/log4rs&quot;&gt;log4rs&lt;/a&gt; 是rust实现的高度可配置日志库，该库配置的方式比较灵活，功能相对丰富，可以满足绝大部分的项目需要。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
    <category term="log4rs" scheme="https://cherryyang05.github.io/hexo-blog/tags/log4rs/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十四）：异步编程</title>
    <link href="https://cherryyang05.github.io/hexo-blog/1bd98bb8.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/1bd98bb8.html</id>
    <published>2023-11-02T15:54:33.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Rust 异步编程</p></blockquote><span id="more"></span><h2 id="一、异步编程介绍"><a href="#一、异步编程介绍" class="headerlink" title="一、异步编程介绍"></a>一、异步编程介绍</h2><ol><li>有两种方式调用异步函数，一种是 <code>block_on()</code>，另一种是 <code>await</code>。</li></ol><p><code>block_on()</code> 函数会阻塞，不会继续向下执行。</p><ol start="2"><li><p>在异步函数中执行异步操作需要用 <code>await</code> 来 “激活” 该函数，因为 <code>Future</code> 本身不会自己做任何事，它是一个惰性函数，需要被调用才能执行。<br>在异步函数或异步块中，通过 <code>await</code> 来执行，在非异步函数中通过执行器的 <code>block_on()</code> 来执行。</p></li><li><p>用 <code>sleep()</code> 阻塞某个函数，但是线程并不会切换到另一个函数执行。因为使用的 <code>sleep()</code> 函数是标准库中的函数，我们应该使用异步包中的函数，例如 <code>tokio</code>、<code>async-std</code>、<code>futures</code> 的 <code>crate</code>。在这些库中，实现了 <code>executor</code>、<code>reactor</code> 等功能，也实现了 <code>sleep()</code> 等函数。</p></li></ol><p>原因：</p><ol start="4"><li><code>Future</code> 会返回 <code>Ready</code> 或 <code>Pending</code> 两种状态，当一个函数执行完会通知 <code>Reactor</code>，然后 <code>Reactor</code> 通知 <code>executor</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Rust 异步编程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>用 gdb 调试程序</title>
    <link href="https://cherryyang05.github.io/hexo-blog/1ea0c606.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/1ea0c606.html</id>
    <published>2023-07-08T22:29:49.000Z</published>
    <updated>2024-10-25T18:39:01.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～</p></blockquote><span id="more"></span><h2 id="1-gdb-调试-run-和-start-的区别"><a href="#1-gdb-调试-run-和-start-的区别" class="headerlink" title="1. gdb 调试 run 和 start 的区别"></a>1. gdb 调试 run 和 start 的区别</h2><p>一般来说，在启动 gdb 之后，执行 <code>r</code> 或者 <code>run</code> 之后，就开始执行程序了，直到遇到第一个断点。</p><p><code>start</code> 指令会执行程序至 <code>main()</code> 主函数的起始位置，即在主函数的第一行停止执行（改行代码还没有执行）。</p><p>另外，程序执行过程中使用 <code>run</code> 或 <code>start</code> 指令，表示重新启动程序。</p><h2 id="2-gdb-tui：在-gdb-中显示程序源码"><a href="#2-gdb-tui：在-gdb-中显示程序源码" class="headerlink" title="2. gdb tui：在 gdb 中显示程序源码"></a>2. gdb tui：在 gdb 中显示程序源码</h2><p>我们使用 gdb 的时候，想要看源码，需要输入 <code>list</code> 命令查看断点前后的代码，但是 <code>list</code> 没有代码高亮，也无法实时跟踪。用 gdb tui 自带的界面可以方便的查看并跟踪源码。输入命令 <code>gdb -tui</code> 打开窗口。</p><p>gdb 还有其他窗口类型，输入如下命令可以打开相应的窗口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout cmd  // 命令窗口，可以输入调试命令</span><br><span class="line">layout src  // 源代码窗口，显示当前行、断点等信息</span><br><span class="line">layout asm  // 汇编代码窗口</span><br><span class="line">layout reg  // 寄存器窗口</span><br></pre></td></tr></table></figure><p>要想使用这些窗口，需要通过源码编译 gdb，在编译时添加参数 <code>--enable-tui</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/gdb-11.2 --enable-tui</span><br><span class="line">make -j32</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在编译安装时可能会出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: no enhanced curses library found; disable TUI</span><br></pre></td></tr></table></figure><p>在 CentOS 下需要安装 <code>yum install ncurses-devel</code> 包，Ubuntu 下安装 <code>libncurses5-dev</code></p><p>提示这个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GMP is missing or unusable</span><br></pre></td></tr></table></figure><p>需要安装 <code>yum install gmp-devel.x86_64</code></p><p>gcc 编译安装可能会提示：<code>致命错误： zlib.h：没有那个文件或目录</code>，需要安装 <code>yum install zlib-devel</code></p><h1 id="Log-的使用"><a href="#Log-的使用" class="headerlink" title="Log 的使用"></a>Log 的使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ logger <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">➜  ~ <span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line">2022-10-04 22:42:30.438584+0800 0x81a171   Default     0x0                  47131  0    logger: Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学计算机的人不能不会用命令行 GDB 进行调试，就像西方不能没有耶路撒冷～～&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="GDB" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/GDB/"/>
    
    
    <category term="GDB" scheme="https://cherryyang05.github.io/hexo-blog/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>C 语言预处理器和宏的高级用法</title>
    <link href="https://cherryyang05.github.io/hexo-blog/aaaac292.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/aaaac292.html</id>
    <published>2023-01-22T22:27:45.000Z</published>
    <updated>2024-10-25T18:39:01.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章介绍 C 语言中类似 <code>#define</code>, <code>#if</code>, <code>#ifdef</code> 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。<br>本篇文章将不会介绍简单的宏用法，例如 <code>#define ADD(a, b) ((a)+(b))</code><br>本篇文章大部分参考《C Primer Plus 第六版》第 16 章</p></blockquote><span id="more"></span><h2 id="一、预处理及宏"><a href="#一、预处理及宏" class="headerlink" title="一、预处理及宏"></a>一、预处理及宏</h2><h3 id="1-1-“-”-运算符"><a href="#1-1-“-”-运算符" class="headerlink" title="1.1 “#” 运算符"></a>1.1 “#” 运算符</h3><p><code>#</code> 是一个预处理运算符，可以将记号转化成字符串。例如 <code>#define TYPE(x) #x</code>，若使用宏 <code>TYPE(int)</code>，则将其替换成<strong>字符串</strong> <code>&quot;int&quot;</code>，<code>#x</code> 就是转换为 <code>x</code> 的形参名。</p><p>下面是一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The num 3 is an &quot;</span>TYPE(<span class="type">int</span>)<span class="string">&quot; type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<code>The num 3 is an int type</code></p><h3 id="1-2-“-”-运算符"><a href="#1-2-“-”-运算符" class="headerlink" title="1.2 “##” 运算符"></a>1.2 “##” 运算符</h3><p>与 <code>#</code> 运算符类似，<code>##</code> 运算符可以用于类函数宏的替换部分，而且还可以用于对象宏的替换部分。<code>##</code> 运算符将两个记号组合成一个记号，例如 <code>#define TEST(n) TEST_##n</code>，然后宏 <code>TEST1</code> 将其展开为 <code>TEST_1</code>。</p><p>下面是一个具体的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_XN(n) printf(<span class="string">&quot;x&quot;</span>#n<span class="string">&quot; = %d\n&quot;</span>, x##n) </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">14</span>;      <span class="comment">// 展开成 int x1 = 14;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">2</span>)</span> = <span class="number">20</span>;      <span class="comment">// 展开成 int x2 = 20;</span></span><br><span class="line">    <span class="type">int</span> x3 = <span class="number">30</span>;</span><br><span class="line">    PRINT_XN(<span class="number">1</span>);            <span class="comment">// 展开成 printf(&quot;x1 = %d\n&quot;, x1);</span></span><br><span class="line">    PRINT_XN(<span class="number">2</span>);            <span class="comment">// 展开成 printf(&quot;x2 = %d\n&quot;, x2);</span></span><br><span class="line">    PRINT_XN(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>#</code> 运算符组合成<strong>字符串</strong>，而 <code>##</code> 运算符组合成为一个新的<strong>标识符</strong>。</p></blockquote><h3 id="1-3-undef-指令"><a href="#1-3-undef-指令" class="headerlink" title="1.3 #undef 指令"></a>1.3 #undef 指令</h3><p><code>#undef</code> 指令用于取消已定义的 <code>#define</code> 指令。若之前没有定义某个宏，取消对其的定义也是有效的，如果想使用一个名称，但不确定之前是否已经用过，使用 <code>#undef</code> 先取消定义是一个安全的方法。</p><h3 id="1-4-条件编译指令"><a href="#1-4-条件编译指令" class="headerlink" title="1.4 条件编译指令"></a>1.4 条件编译指令</h3><h4 id="1-4-1-ifdef、-else-和-endif-指令"><a href="#1-4-1-ifdef、-else-和-endif-指令" class="headerlink" title="1.4.1 #ifdef、#else 和 #endif 指令"></a>1.4.1 #ifdef、#else 和 #endif 指令</h4><p>先用一个简单的例子来说明这三个条件编译指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;horse.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cow.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STABLES 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述代码理解起来应该挺简单，若用 <code>#define</code> 定义了 <code>MAVIS</code>，就引入 <code>horse.h</code> 头文件，若没有定义 <code>MAVIS</code> 就引入头文件 <code>cow.h</code>。</p><p><code>#ifdef</code> 测试的宏可以是对象宏，也可以是函数宏。</p><h4 id="1-4-2-ifndef"><a href="#1-4-2-ifndef" class="headerlink" title="1.4.2 #ifndef"></a>1.4.2 #ifndef</h4><p><code>#ifndef</code> 用法和 <code>#ifdef</code> 类似，但是意思相反。除此之外 <code>#ifndef</code> 还可以防止相同的宏被重复定义，例如下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MATH_H_</span></span><br></pre></td></tr></table></figure><p>通过 <code>#ifndef</code> 也可以避免头文件被引入多次。</p><h4 id="1-4-3-if、-elif"><a href="#1-4-3-if、-elif" class="headerlink" title="1.4.3 #if、#elif"></a>1.4.3 #if、#elif</h4><p><code>#if</code> 和 <code>#elif</code> 后面跟一个常量表达式，如果表达式的值为非零，则表达式为真，类似于 C 语言中的 if else，可以使用关系运算符和逻辑运算符。</p><p><code>#if</code> 和 <code>#elif</code> 后面的宏只能是对象宏，不能是函数宏。</p><h4 id="1-4-4-defined"><a href="#1-4-4-defined" class="headerlink" title="1.4.4 #defined"></a>1.4.4 #defined</h4><p><code>#defined</code> 用于判断宏是否已经被定义，可以是对象宏，也可以是函数宏，可以和 <code>#elif</code> 嵌套使用。</p><p>条件编译可以让程序更容易移植，改变文件开头的几个关键定义，可以根据不同的架构或系统设置不同的值和包含不同的文件。</p><h3 id="1-5-预定义宏"><a href="#1-5-预定义宏" class="headerlink" title="1.5 预定义宏"></a>1.5 预定义宏</h3><p>C 标准规定了一些预定义宏，如下列表格所示。</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td><strong>DATE</strong></td><td>预处理的日期（“Mmm dd yyyy”形式的字面量，如 Nov 12 2023）</td></tr><tr><td><strong>FILE</strong></td><td>表示当前源代码文件名的字符串字面量</td></tr><tr><td><strong>LINE</strong></td><td>表示当前源代码文件中行号的整型量</td></tr><tr><td><strong>STDC</strong></td><td>设置为 1 时表示遵循 C 标准</td></tr><tr><td><strong>STDC_HOSTED</strong></td><td>本机环境设置为 1，否则设置为 0</td></tr><tr><td><strong>STDC_VERSION</strong></td><td>支持 C99 标准，设置为 199901L；支持 C11标准，设置为 201112L</td></tr><tr><td><strong>TIME</strong></td><td>翻译代码的时间，格式为 “hh:mm:ss”</td></tr></tbody></table><h3 id="1-6-line-和-error"><a href="#1-6-line-和-error" class="headerlink" title="1.6 #line 和 #error"></a>1.6 #line 和 #error</h3><p><code>#line</code> 指令重置 <code>__LINE__</code> 和 <code>__FILE__</code> 宏报告的行号和文件名，用法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 1000          <span class="comment">// 将当前行号重置为 1000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 cool.c     <span class="comment">// 将当前行号重置为 10，文件名重置为 cool.c</span></span></span><br></pre></td></tr></table></figure><p><code>#error</code> 指令让预处理器发出一条错误信息，该消息包含指令中的文本，用法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编译上述代码将会产生 error，并且提示 <code>Not C11</code>。</p><h3 id="1-7-变参宏-…-和-VA-ARGS"><a href="#1-7-变参宏-…-和-VA-ARGS" class="headerlink" title="1.7 变参宏 … 和 __VA_ARGS__"></a>1.7 变参宏 … 和 __VA_ARGS__</h3><p>一些函数可以接受数量可变的参数，例如 <code>printf</code>，在头文件 <code>stdvar.h</code> 中提供了相关操作。</p><p>同样，宏定义中也可以实现可变参数，通过将宏列表中最后的参数写成 <code>...</code> 来实现这一功能。这样，预定义宏 <code>__VA_ARGS__</code> 可用在替换部分中，用来表示省略号代表什么。例如定义 <code>#define PRINT(...) printf(__VA_ARGS__)</code>，调用宏 <code>PRINT(&quot;Hello&quot;)</code>，<code>__VA_ARGS__</code> 展开为一个参数 <code>Hello</code>，调用宏 <code>PRINT(&quot;My name is %s&quot;, name)</code>，<code>__VA_ARGS__</code> 展开为两个参数 <code>&quot;My name is %s&quot;</code> 和 <code>name</code>。</p><h3 id="1-8-attribute"><a href="#1-8-attribute" class="headerlink" title="1.8 attribute"></a>1.8 <strong>attribute</strong></h3><p>GNU C 的一大特色就是 <code>__attribute__</code> 机制。<code>__attribute__</code> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute）。</p><p>具体内容请参见链接 <a href="https://blog.csdn.net/qlexcel/article/details/92656797">C语言__attribute__的使用</a>、<a href="https://blog.csdn.net/weaiken/article/details/88085360"><strong>attribute</strong> 机制详解</a></p><h2 id="二、宏模板"><a href="#二、宏模板" class="headerlink" title="二、宏模板"></a>二、宏模板</h2><p>由于 C 语言中库比较少，而一些比较基础的操作又无需通过函数实现，因此可以将一些基础功能写成宏进行展开，并集成到头文件中，在今后的项目中可以很方便的进行调用。</p><p>在这里我自己总结并整理了若干个常用的宏。</p><table><thead><tr><th>宏名称</th><th>功能</th></tr></thead><tbody><tr><td>LOG</td><td>打印调试信息（带颜色）</td></tr><tr><td>UPPERCASE</td><td>转化为大写字母</td></tr><tr><td>LOWERCASE</td><td>转化为小写字母</td></tr><tr><td>FPOS</td><td>获取结构体成员偏移量</td></tr><tr><td>FSIZ</td><td>获取结构体成员所占用字节数</td></tr><tr><td>container_of</td><td>根据成员指针、结构体类型、结构体成员名称获取结构体起始地址</td></tr><tr><td>offsetof</td><td>获取结构体成员偏移量</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-1-打印调试信息"><a href="#2-1-打印调试信息" class="headerlink" title="2.1 打印调试信息"></a>2.1 打印调试信息</h3><p>调试信息是任何项目必不可少的内容，下面的宏可以在终端中输出带颜色的调试标签，方便观察错误和警告信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LOG_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR_STYLE <span class="string">&quot;\x1b[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO_STYLE <span class="string">&quot;\x1b[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING_STYLE <span class="string">&quot;\x1b[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG_STYLE <span class="string">&quot;\x1b[34m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_STYLE_CLEAR <span class="string">&quot;\x1b[0m &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) printf(LOG_ERROR_STYLE<span class="string">&quot;[ERROR]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) printf(LOG_INFO_STYLE<span class="string">&quot;[INFO]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARNING(...) printf(LOG_WARNING_STYLE<span class="string">&quot;[WARN]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(...) printf(LOG_DEBUG_STYLE<span class="string">&quot;[DEBUG]&quot;</span>LOG_STYLE_CLEAR __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(TYPE, ...) LOG_##TYPE(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>调用上面的 <code>LOG</code> 宏，可以看到结果如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LOG(ERROR, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;This is an error msg...&quot;</span>);</span><br><span class="line">    LOG(DEBUG, <span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;This is a debug msg...&quot;</span>);</span><br><span class="line">    LOG(INFO, <span class="string">&quot; %s\n&quot;</span>, <span class="string">&quot;This is an info msg...&quot;</span>);</span><br><span class="line">    LOG(WARNING, <span class="string">&quot; %s\n&quot;</span>, <span class="string">&quot;This is a warning msg...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/20230122232752.png" alt="LOG宏实现效果"></p><h3 id="2-2-大小写转化"><a href="#2-2-大小写转化" class="headerlink" title="2.2 大小写转化"></a>2.2 大小写转化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UPPERCASE(c) (c &amp; 0xdf)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWERCASE(c) (c | 0x20)</span></span><br></pre></td></tr></table></figure><h3 id="2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量"><a href="#2-3-得到一个结构体成员-member-在结构体-struct-中的偏移量" class="headerlink" title="2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量"></a>2.3 得到一个结构体成员 member 在结构体 struct 中的偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FPOS(type, member) (&amp;((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-得到一个结构体中某个成员字段-member-所占用的字节数"><a href="#2-4-得到一个结构体中某个成员字段-member-所占用的字节数" class="headerlink" title="2.4 得到一个结构体中某个成员字段 member 所占用的字节数"></a>2.4 得到一个结构体中某个成员字段 member 所占用的字节数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSIZ(type, member) sizeof(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-container-of"><a href="#2-5-container-of" class="headerlink" title="2.5 container_of"></a>2.5 container_of</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;              \</span></span><br><span class="line"><span class="meta">const typeof(((type *)0)-&gt;member) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">(type *)((char *)__mptr - __offsetof(type,member)); &#125;)</span></span><br></pre></td></tr></table></figure><p><code>container_of</code> 宏函数的作用是 <strong>已知结构体 type 的成员 member 的地址 ptr，得到结构体 type 的起始地址</strong>。</p><p>第一行用于“类型检查”。它确保 type 有一个名为 member 的成员（不过我认为这也是由 offsetof 宏完成的），并且如果 ptr 不是指向正确类型（成员的类型）的指针，编译器将打印警告，这对调试很有用。</p><p>在上述宏的第三行，用了 <code>char *</code> 进行指针转化，这是因为 <code>offsetof</code> 指针偏移量是按照字节计算的，同时 <code>char *</code> 的指针也是以字节计算的，若转化为例如 <code>int *</code> 等类型，则 C 的指针算法将会计算 <code>sizeof(int) * offsetof</code> 作为最终的结果，也就是 4 字节乘以偏移量。</p><p>具体说明参考链接 <a href="https://blog.csdn.net/s2603898260/article/details/79371024">container of()函数简介</a> 和 <a href="https://zhuanlan.zhihu.com/p/54932270">linux 内核宏container_of剖析</a></p><h3 id="2-6-offsetof"><a href="#2-6-offsetof" class="headerlink" title="2.6 offsetof"></a>2.6 offsetof</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp; ((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p><code>offsetof</code> 宏函数的作用是 <strong>得到结构体 type 的成员 member 所在的内存偏移量</strong></p><p>对于 <code>container of</code> 以及 <code>offsetof</code> 我会单独用一篇博客进行详细讲解。</p><h3 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h3><h3 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h3><h3 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h3><h3 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h3><h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><h3 id="2-12"><a href="#2-12" class="headerlink" title="2.12"></a>2.12</h3><h3 id="2-13"><a href="#2-13" class="headerlink" title="2.13"></a>2.13</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章介绍 C 语言中类似 &lt;code&gt;#define&lt;/code&gt;, &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; 等预处理指令以及宏的高级用法，最后整理出项目中一些常用的宏，例如打印调试信息等。&lt;br&gt;本篇文章将不会介绍简单的宏用法，例如 &lt;code&gt;#define ADD(a, b) ((a)+(b))&lt;/code&gt;&lt;br&gt;本篇文章大部分参考《C Primer Plus 第六版》第 16 章&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C/C++" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
    <category term="C" scheme="https://cherryyang05.github.io/hexo-blog/tags/C/"/>
    
    <category term="宏" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>Rust实现进度条功能</title>
    <link href="https://cherryyang05.github.io/hexo-blog/84b8101e.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/84b8101e.html</id>
    <published>2023-01-12T15:57:27.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。</p></blockquote><span id="more"></span><h2 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h2><p>先上代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bar_show</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> BAR_FRONT: &amp;<span class="type">str</span> = <span class="string">&quot;-\\|/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">index</span> <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(</span><br><span class="line">            <span class="string">&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</span>,</span><br><span class="line">            BAR_FRONT.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">nth</span>(index % <span class="number">4</span>).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(index / <span class="number">3</span>),</span><br><span class="line">            index</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>()?;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为终端输出的进度条是带颜色的，在这里没法显示，只能通过截图看。</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230112160436.png" alt="进度条显示"></p><h2 id="二、代码解释"><a href="#二、代码解释" class="headerlink" title="二、代码解释"></a>二、代码解释</h2><p>进度条前面的指示字符是 <code>&quot;-\\|/&quot;</code> 交替显示，呈现出动态效果，因为 <code>\</code> 需要转义，所以是两个反斜杠 <code>\\</code>。</p><p>然后就是进度条从 0-100 开始，每一次循环输出指示字符(模 4)，空白字符重复 (index &#x2F; times) 次，根据进度条长度进行调整除数。然后刷新输出流，要不然输出会在缓存中，每隔一段时间才会输出到设备，不会实时显示进度条进度，最后再睡眠 30ms，让进度条缓慢加载。</p><p>最重要的是这一句：<code>&quot;\r&#123;&#125; \u&#123;1b&#125;[42m&#123;&#125;\u&#123;1b&#125;[0m [ &#123;&#125;% ]&quot;</code>。</p><p>首先，<code>\r</code> 表示将光标置于本行行首，使用 <code>print!</code> 可以使得每次输出覆盖之前输出的行。然后 <code>\u</code> 表示输出后面的 <code>UniCode</code> 字符，<code>&#123;&#125;</code> 就不用说了，是 Rust 里用来控制格式化输出的。</p><blockquote><p>注：Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows 系统里面，每行结尾是“&lt;换行&gt;&lt;回车 &gt;”，即“\n\r”；Mac 系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix&#x2F;Mac 系统下的文件在 Windows里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix&#x2F;Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。所以，如果你需要跨平台处理文本文件，可能会被回车换行搅得有点头大。<br>0x0D（ascii 码是 13） 指的是“回车”   \r 是把光标置于本行行首<br>0x0A（ascii 码是 10） 指的是“换行”   \n 是把光标置于下一行的同一列<br>0x0D + 0x0A         回车换行       \r\n 是把光标置于下一行行首 </p></blockquote><p><code>\u&#123;1b&#125;[42m</code> 这句的格式是 <code>\x1b[&lt;代码&gt;;&lt;代码&gt;</code>，其中 <code>\x1b[</code> 是十六进制 1b，写成八进制 <code>\033</code> 也行，然后一个左中括号，是特殊的终端控制符，格式固定。然后后面跟上一个数字和一个字母，这里 <code>42m</code> 就是将背景设置为绿色，字母 m 表示设置的属性类别，数字代表属性值。</p><p>下面是一些其他属性，可以设置文本的颜色，背景色，设置是否加粗，下划线等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">\033[0m 关闭所有属性</span><br><span class="line">\033[1m 设置加粗</span><br><span class="line">\033[2m 设置模糊，有的终端可能不支持</span><br><span class="line">\033[3m 设置斜体，有的终端可能不支持</span><br><span class="line">\033[4m 下划线（单线）</span><br><span class="line">\033[5m 闪烁（慢）</span><br><span class="line">\033[5m 闪烁（快），有的终端可能不支持</span><br><span class="line">\033[7m 交换背景色与前景色</span><br><span class="line">\033[8m 隐藏所有</span><br><span class="line">\033[30m 至 \033[37m 设置前景色</span><br><span class="line">\033[40m 至 \033[47m 设置背景色</span><br><span class="line">\033[nA 光标上移n行 </span><br><span class="line">\033[nB 光标下移n行</span><br><span class="line">\033[nC 光标右移n行</span><br><span class="line">\033[nD 光标左移n行</span><br><span class="line">\033[y;xH 设置光标位置</span><br><span class="line">\033[2J 清屏</span><br><span class="line">\033[K 清除从光标到行尾的内容</span><br><span class="line">\033[s 保存光标位置 </span><br><span class="line">\033[u 恢复光标位置</span><br><span class="line">\033[?25l 隐藏光标</span><br><span class="line">\033[?25h 显示光标</span><br></pre></td></tr></table></figure><p>各个数字代表的颜色如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">字背景颜色范围:40--49</span><br><span class="line">    40:黑</span><br><span class="line">    41:深红</span><br><span class="line">    42:绿</span><br><span class="line">    43:黄色</span><br><span class="line">    44:蓝色</span><br><span class="line">    45:紫色</span><br><span class="line">    46:深绿</span><br><span class="line">    47:白色</span><br><span class="line">字颜色: 30--39</span><br><span class="line">    30:黑</span><br><span class="line">    31:红</span><br><span class="line">    32:绿</span><br><span class="line">    33:黄</span><br><span class="line">    34:蓝色</span><br><span class="line">    35:紫色</span><br><span class="line">    36:深绿 </span><br><span class="line">    37:白色</span><br></pre></td></tr></table></figure><p>另外，同类的多种设置项可以组合在一起，中间用分号 <code>;</code> 隔开。</p><p>例如 <code>print!(&quot;\u&#123;1b&#125;[31;1;3;4m&#123;&#125;\u&#123;1b&#125;[0m&quot;, &quot;Rosa&quot;);</code>，其中 <code>\u&#123;1b&#125;[31;1;3;4m</code> 中，<code>31</code> 表示前景色（字的颜色）是红色，<code>1</code> 表示加粗，<code>3</code> 表示设置斜体，<code>4</code> 表示设置下划线。则上述代码输出的是一个红色加粗加下划线的斜体字符串 <code>Rosa</code>。最后的 <code>\u&#123;1b&#125;[0m</code> 表示将格式清除掉，否则下面输出的任何字符都将使用刚刚的样式。</p><p>同样，在 C 语言中也可以实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> color = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[20;1H\033[1;4;%dmHello, world.\033[0m&quot;</span>, color);</span><br></pre></td></tr></table></figure><p>这行命令首先 <code>\033[20;1H</code> 将光标移动到终端第 20 行第 1 列，之后的 <code>\033[1;4;32m</code> 将文本属性设置为高亮、带下划线且颜色为绿色，然后输出 <code>Hello,world</code>，最后 <code>\033[0m</code> 将终端属性恢复为默认值。</p><h2 id="三、一些参考实现"><a href="#三、一些参考实现" class="headerlink" title="三、一些参考实现"></a>三、一些参考实现</h2><h3 id="3-1-bash-中输出带样式的字符"><a href="#3-1-bash-中输出带样式的字符" class="headerlink" title="3.1 bash 中输出带样式的字符"></a>3.1 bash 中输出带样式的字符</h3><p>在 bash 中，通常我们可以使用 <code>echo</code> 命令加 <code>-e</code> 选项输出各种颜色的文本，<code>echo -e</code> 表示处理特殊字符，开启转义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;\033[31mRed Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[32mGreen Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[33mYellow Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[34mBlue Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[35mMagenta Text\033[0m&quot;</span><br><span class="line">echo -e &quot;\033[36mCyan Text\033[0m&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-C-语言中输出颜色表"><a href="#3-2-C-语言中输出颜色表" class="headerlink" title="3.2 C 语言中输出颜色表"></a>3.2 C 语言中输出颜色表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            n = <span class="number">10</span> * i + j;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">108</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[%dm %3d\033[m&quot;</span>, n, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、参考文档"><a href="#四、参考文档" class="headerlink" title="四、参考文档"></a>四、参考文档</h2><p><a href="https://www.cnblogs.com/goloving/p/15015053.html">浅析 <code>\x1B[1;3;31mxterm.js\x1B[0m</code> 是什么？如何在终端输出带颜色等格式的字符串 </a></p><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI escape code</a></p><p><a href="https://www.cnblogs.com/opangle/p/4082692.html">控制台终端输出颜色</a></p><p>Rust 官方有进度条实现的 <a href="https://crates.io/crates/indicatif">indicatif crate</a>，用法比较全面，这里是 <a href="http://wilson-blog.cn/post/2021/02/20/rust.indicatif.html#indicatifmultiprogress">源码解析</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文用 Rust 语言实现一个简单的进度条功能，并介绍通过转义码在终端打印带颜色等格式的字符串。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
    <category term="小工具" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Makefile的简单使用</title>
    <link href="https://cherryyang05.github.io/hexo-blog/31dce7e5.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/31dce7e5.html</id>
    <published>2023-01-05T15:50:03.000Z</published>
    <updated>2024-10-25T18:39:01.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-的简单使用"><a href="#Makefile-的简单使用" class="headerlink" title="Makefile 的简单使用"></a>Makefile 的简单使用</h2><blockquote><p>makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。</p></blockquote><span id="more"></span><h3 id="一、环境及样例源代码"><a href="#一、环境及样例源代码" class="headerlink" title="一、环境及样例源代码"></a>一、环境及样例源代码</h3><p>本机环境： MacBook M1<br>测试用源代码：</p><ul><li>main.cpp</li><li>print.cpp</li><li>add.cpp</li><li>func.h</li><li>makefile</li></ul><p><strong>main.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printHappyNewYear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_one</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>print.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Happy New Year!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add.cpp</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>func.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _FUNC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _FUNC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHappyNewYear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="二、编译方式"><a href="#二、编译方式" class="headerlink" title="二、编译方式"></a>二、编译方式</h3><h4 id="2-1-手动编译"><a href="#2-1-手动编译" class="headerlink" title="2.1 手动编译"></a>2.1 手动编译</h4><p>这种方式很简单，直接输入下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp add.cpp print.cpp -o main</span><br></pre></td></tr></table></figure><p>但这种显然不是我们想要的。</p><h4 id="2-2-makefile-脚本编译"><a href="#2-2-makefile-脚本编译" class="headerlink" title="2.2 makefile 脚本编译"></a>2.2 makefile 脚本编译</h4><p>如果我们只让他编译但是不链接，可以使用 <code>-c</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -c</span><br></pre></td></tr></table></figure><p>结果可以看到生成一个 <code>main.o</code> 文件，<code>.o</code> 文件便是 Unix 下的中间目标文件（Objective File）</p><p>然后我们逐个编译每个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ add.cpp -c</span><br><span class="line">g++ print.cpp -c</span><br></pre></td></tr></table></figure><p>然后将所有 <code>.o</code> 文件链接到一起，生成可执行文件 <code>main</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o main</span><br></pre></td></tr></table></figure><p>当我们只修改某个源文件时，只需要单独编译某个文件而不需要重新编译所有文件。最后重新链接即可。但是当源文件太多的时候，这样也是不方便的，于是使用 makefile 脚本实现自动化。</p><h4 id="Makefile（Version-1）"><a href="#Makefile（Version-1）" class="headerlink" title="Makefile（Version 1）"></a>Makefile（Version 1）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 1</span></span><br><span class="line">main: main.cpp print.cpp add.cpp</span><br><span class="line">@g++ main.cpp add.cpp print.cpp -o main</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> *.o main</span><br></pre></td></tr></table></figure><p>语法格式：main 这个文件依赖于后面的三个 cpp 文件，下一行的命令前面必须是一个 tab，否则语法错误。</p><p>运行 <code>make</code> 运行 <code>makefile</code> 脚本，或 <code>make -f Makefile</code> 根据指定文件名运行脚本。</p><p>首先脚本先去找 main，如果 main 不存在，则尝试生成 main。若已经生成了 main，则根据后面的依赖项判断该 main 是不是最新的，若不是最新的，则重新生成，否则不做任何操作。</p><p>第一个版本的缺点是若源文件太多，则命令显得很冗长。</p><h4 id="Makefile（Version-2）"><a href="#Makefile（Version-2）" class="headerlink" title="Makefile（Version 2）"></a>Makefile（Version 2）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $(OBJ) -o $(TARGET)</span><br><span class="line"></span><br><span class="line">main.o: main.cpp</span><br><span class="line">$(CXX) -c main.cpp</span><br><span class="line">print.o: print.cpp</span><br><span class="line">$(CXX) -c print.cpp</span><br><span class="line">add.o: add.cpp</span><br><span class="line">$(CXX) -c add.cpp</span><br></pre></td></tr></table></figure><p>第二个版本中使用了 <code>CXX</code>，<code>TARGET</code>，<code>OBJ</code> 变量，依次查找依赖，只编译已经修改过的文件，而不会编译所有文件。</p><h4 id="Makefile（Version-3）"><a href="#Makefile（Version-3）" class="headerlink" title="Makefile（Version 3）"></a>Makefile（Version 3）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">OBJ = main.o print.o add.o</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure><p>符号说明：</p><p><code>$@</code>: 目标文件，<code>$^</code>: 所有的依赖文件，<code>$&lt;</code>: 第一个依赖文件</p><p><code>.PHONY</code> 表示的意思：若在该目录下有一个名叫 <code>clean</code> 的文件，那么脚本便无需生成该文件，也就不会执行相应的命令，但是这跟我们期望的不一致。加上 <code>.PHONY</code> 之后，依赖 <code>clean</code>，因此就会去执行 <code>clean</code>。</p><p><code>.PHONY</code> 是一个伪目标，可以有效防止在 Makefile 文件中定义的可执行命令的目标规则和工作目录下的实际文件出现名称冲突的问题。</p><p>第三个版本中，若将来有其他新的源文件加入之后，只需要在 <code>OBJ</code> 变量后面加入新的源文件即可。</p><h4 id="Makefile（Version-4）"><a href="#Makefile（Version-4）" class="headerlink" title="Makefile（Version 4）"></a>Makefile（Version 4）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## VERSION 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = main</span><br><span class="line">SRC = $(wildcard *.cpp)</span><br><span class="line">OBJ = $(patsubst %.cpp, %.o, $(SRC))</span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line">$(TARGET): $(OBJ)</span><br><span class="line">$(CXX) $^ -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">%.o: %.cpp</span><br><span class="line">$(CXX) $(CXXFLAGS) $&lt; -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f *.o $(TARGET)</span><br></pre></td></tr></table></figure><p>在 Makefile 规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数 <code>wildcard</code>，它的用法是：<code>$(wildcard PATTERN...)</code></p><p><code>wildcard</code>: 扩展通配符<br><code>patsubst</code>：替换通配符<br><code>notdir</code>：去除路径</p><p><code>SRC = $(wildcard *.cpp)</code> 表示获得工作目录下所有 <code>.cpp</code> 文件并生成列表 <code>SRC</code>。<br><code>OBJ = $(patsubst %.cpp, %.o, $(SRC))</code> 表示将所有 <code>.cpp</code> 后缀替换为 <code>.o</code> 并生成文件列表 <code>OBJ</code>。</p><p>这样下来，makefile 文件就相对比较智能化了，新增加文件之后也无需修改脚本了，</p><p>总之，脚本使你越懒惰，这个脚本的功能就越强大。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile-的简单使用&quot;&gt;&lt;a href=&quot;#Makefile-的简单使用&quot; class=&quot;headerlink&quot; title=&quot;Makefile 的简单使用&quot;&gt;&lt;/a&gt;Makefile 的简单使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;makefile 脚本是类 Unix 上常用的脚本文件，通常用来自动化地构建项目。本文介绍构建一个简单的 makefile 脚本，并能够阅读和修改常见的 makefile 脚本文件。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="脚本" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="脚本" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Makefile" scheme="https://cherryyang05.github.io/hexo-blog/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>重构：改善既有代码的设计 学习笔记</title>
    <link href="https://cherryyang05.github.io/hexo-blog/ea380076.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/ea380076.html</id>
    <published>2023-01-05T14:09:07.000Z</published>
    <updated>2024-10-25T18:39:01.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重构：改善既有代码的设计-学习笔记"><a href="#重构：改善既有代码的设计-学习笔记" class="headerlink" title="重构：改善既有代码的设计 学习笔记"></a>重构：改善既有代码的设计 学习笔记</h2><blockquote><p>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。</p></blockquote><span id="more"></span><h3 id="一、重构是什么以及为什么"><a href="#一、重构是什么以及为什么" class="headerlink" title="一、重构是什么以及为什么"></a>一、重构是什么以及为什么</h3><ol><li>重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。</li><li>重构是一种经济适用行为，而非道德使然，如果它不能让我们更快更好的开发，那么它是毫无意义。</li><li>代码的写法应该使别人理解它所需要的时间最小化，进而变更代码需要的时间也会最小化。</li><li>重构对个体程序员的意义是提高ROI。</li><li>更快速的定位问题，节省调试时间。</li><li>最小化变更风险，提高代码质量，减少修复事故的时间。</li><li>得到程序员同行的认可，更好的发展机会。</li><li>重构对整个研发团队的意义是战斗力的提升。</li></ol><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20230105141740.png?token=AJSITSOUMKEAVRFBFDZNT7DDWZV4E" alt="重构与不重构"></p><p>尽管重构会让我们的开发变慢，但是可以让我们将来的开发变快。如果我们要对一个项目进行长期跟进，那么重构是必不可少的。</p><h3 id="二、重构的原则"><a href="#二、重构的原则" class="headerlink" title="二、重构的原则"></a>二、重构的原则</h3><ol><li>重构的目标: 提高迭代效率，如果你确定这段代码你将来只会用到一次，且别人也不会去看你的代码，那么就没有重构的必要。</li><li>获得同行认可的方法: 每一次提交代码，都应该使代码变得更好，先重构，再开发。</li><li>增量式重构 &#x3D; 自动化测试 + 持续集成 + TDD驱动重构。</li></ol><h3 id="三、代码的坏味道"><a href="#三、代码的坏味道" class="headerlink" title="三、代码的坏味道"></a>三、代码的坏味道</h3><p><a href="https://github.com/a1029563229/blogs/tree/master/Introduction/refactor">24重代码的坏味道和例子</a></p><p>一般我们能接触到的一些常见的问题：</p><ul><li>命名不规范</li><li>代码重复</li><li>代码过长</li><li>函数参数列表不易理解</li><li>相关联的一些数据没有成组（数据泥团）</li></ul><h3 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a>四、一些例子</h3><h4 id="4-1-依赖传递"><a href="#4-1-依赖传递" class="headerlink" title="4.1 依赖传递"></a>4.1 依赖传递</h4><p>变更放大：一次迭代需要修改 N 个位置，容易遗漏或失误。</p><p>关注放大：为完成修改任务，需要通读修改点上下文若干行代码，而由于依赖被传递，附近的代码会牵扯出更多需要关注的代码，往往阅读的代码量是本身要修改部分的若干倍。演化到最后就会导致不知道该次修改会不会导致问题。</p><h4 id="4-2-神秘命名"><a href="#4-2-神秘命名" class="headerlink" title="4.2 神秘命名"></a>4.2 神秘命名</h4><p>代码&#x2F;注释都是一堆符号的集合，如果这些符合不能被人或者因为其信息的冗余无效性增加了阅读负担就会降低可理解性。<br>好的命名应该有三种境界:  信，达，雅。<br>信:  准确无误地表达清楚行为的意义，做到见名之意。<br>达: 考虑命名对整体架构的影响，与架构的设计哲学风格统一。<br>雅: 生动形象，看到名字即可准确理解其在整个程序之中的作用，并能产生辅助理解的形象。</p><p><a href="https://ggithub.com/dgraph-io/dgraph">坏的例子</a></p><h4 id="4-3-过度设计"><a href="#4-3-过度设计" class="headerlink" title="4.3 过度设计"></a>4.3 过度设计</h4><p>当过分的考虑程序未来所要面对的需求时，将陷入过度设计的陷阱，为了未来用不上的能力，而使当下的程序变得复杂。</p><p>设计变得复杂，是因为考虑了过多的设计约束，而这些约束很可能是现在和未来都不需要的，错把这些约束条件当作了目的，而使得目标被放大，设计出没有解决实际问题的系统。</p><p>过分放大未来的某行风险，这些风险发生的概率过低，在项目可见的生命周期内都不可能遇到，因此也没必要进行设计。</p><h4 id="4-4-结构泥团"><a href="#4-4-结构泥团" class="headerlink" title="4.4 结构泥团"></a>4.4 结构泥团</h4><p>对于核心的数据结构，没有规范化的设计将导致混乱</p><h5 id="4-4-1-艰难引用"><a href="#4-4-1-艰难引用" class="headerlink" title="4.4.1 艰难引用"></a>4.4.1 艰难引用</h5><p>未充分的考虑数据结构的读取场景，导致在需要使用某些数据的时候无法简单的获得其引用，或者为了使用某个字段，需要了解一堆中间封装的数据结构。</p><p>例如：<code>a.b.c.d.e();</code></p><h5 id="4-4-2-全局盲区"><a href="#4-4-2-全局盲区" class="headerlink" title="4.4.2 全局盲区"></a>4.4.2 全局盲区</h5><p>大型项目的开发中，由于大家缺乏全局视角，对数据结构或者接口的设计不可避免的造成冗余或混乱，接口与结构的设计充满局部最优解，但从项目整体上看却成为一团泥球。</p><h3 id="五、什么时候需要重构"><a href="#五、什么时候需要重构" class="headerlink" title="五、什么时候需要重构"></a>五、什么时候需要重构</h3><ol><li>Code review: 在给别人 code review 时嗅出坏味道，在不失礼貌的前提下提出建议。</li><li>每次 commit 代码时: 每一次经你之手提交的代码都应该比之前更加干净。</li><li>当你接手一个异常难读的项目时: 说服项目组将重构作为一项需求任务来做。</li><li>当迭代效率低于预期时: 将重构当作一个项任务专门来做，必要的时候停下来迭代需求。</li></ol><h3 id="六、重构的基本步骤"><a href="#六、重构的基本步骤" class="headerlink" title="六、重构的基本步骤"></a>六、重构的基本步骤</h3><h4 id="6-1-代码分析"><a href="#6-1-代码分析" class="headerlink" title="6.1 代码分析"></a>6.1 代码分析</h4><blockquote><p>通读代码，分析现状，找到代码在各个层面的坏味道。</p></blockquote><h4 id="6-2-重构计划"><a href="#6-2-重构计划" class="headerlink" title="6.2 重构计划"></a>6.2 重构计划</h4><blockquote><p>重构应该永远是一种经济驱动的决定。</p></blockquote><ul><li>对坏味道进行宣讲，并向团队给出重构的理由，以及重构的计划。</li><li>确定重构的目标，明确的描述出重构后能达到的预期是什么。</li><li>重构计划中必须给出测试验证方案，保证重构前与重构后软件的行为一致。</li><li>如果没有这样的方案，那就必须先让软件具有可测试性。</li><li>如果无法得到团队的认可,那就偷偷进行,因为重构始终是对自己有利的(减少工作量以及获得同事的认可)</li><li>将重构任务当作项目来管理，对指定任务的人明确的排期和进度同步。</li></ul><h4 id="6-3-小步子策略"><a href="#6-3-小步子策略" class="headerlink" title="6.3 小步子策略"></a>6.3 小步子策略</h4><ul><li>将重构任务拆分成每周都能见到一点效果的小任务。</li><li>每一步重构都要具有收益，并且可测试，不能阻断当前需求的迭代。</li><li>重构任务必须被跟踪，要定期的开会同步进度，来不断加强团队的重构意识。</li></ul><h4 id="6-4-测试驱动"><a href="#6-4-测试驱动" class="headerlink" title="6.4 测试驱动"></a>6.4 测试驱动</h4><ul><li>对于小型软件，需要先补充单元测试再进行重构。</li><li>对于大型软件，先搭建自动化测试流程，再进行重构。</li><li>对于复杂的不确定性业务，也可以使用ab test来验证重构对指标的影响，避免造成效果&#x2F;广告的损失。</li><li>要保证测试的完备性与可复用性，尽可能的做到团队级的复用。</li><li>保证测试环境与生产环境的一致性也是测试驱动的重要环节。</li></ul><h4 id="6-5-提交规范"><a href="#6-5-提交规范" class="headerlink" title="6.5 提交规范"></a>6.5 提交规范</h4><ul><li>每次提交尽量控制在2分钟可以给code review的同事讲明白的程度</li><li>重构应该被当作一次专门的commit中完成，在commit中写清楚改动点&amp;测试点</li><li>提交规范有助于定位bug，也是代码可读性的一个重要环节</li></ul><h4 id="6-6-自动化测试"><a href="#6-6-自动化测试" class="headerlink" title="6.6 自动化测试"></a>6.6 自动化测试</h4><ul><li>构建可测试的软件，首先要构建可测试的环境。</li><li>对于简单应用软件可以使用单元测试，mock数据进行测试，并与ci&#x2F;cd流程集成。</li><li>对于复杂应用软件可以采样收集线上真实用户行为日志，mock数据周期性巡检测试。</li><li>对于幂等性业务，可以mock user进行全方位的端到端自动化巡检测试。</li><li>每一次功能的提交应该对应一套完整的自动化测试的策略脚本以及&amp;监控指标与报警规则</li></ul><h4 id="6-7-调试BUG"><a href="#6-7-调试BUG" class="headerlink" title="6.7 调试BUG"></a>6.7 调试BUG</h4><ol><li>亲自复现问题，关注第一现场，确定是必现还是偶现?</li><li>区分是人的问题还是环境的问题?</li><li>如果是人的问题，那是配置参数的问题还是代码逻辑的问题?</li><li>如果是配置参数的问题，则通过对比正常运行的配置参数发现问题</li><li>如果是代码逻辑的问题，则通过cimmit的历史二分查找缩小出现问题的逻辑范围</li><li>如果是机器的问题，确定是单机问题还是集群问题。</li><li>如果是单机问题，则替换机器，如果是集群问题则考虑升级硬件设备。</li></ol><h3 id="七、一些实际的问题"><a href="#七、一些实际的问题" class="headerlink" title="七、一些实际的问题"></a>七、一些实际的问题</h3><h4 id="7-1-代码所有权"><a href="#7-1-代码所有权" class="headerlink" title="7.1 代码所有权"></a>7.1 代码所有权</h4><p>代码仓库的所有权会阻碍重构，调用方难以重构被调用方的代码(接口)，进而导致自身重构的受阻，使得效率降低，为提高开发的效能，允许代码仓库在内部开源化，其他团队的工程师可以通过 pr 自己来实现代码，并提交给仓库的 onwer，来 code review 即可。</p><h4 id="7-2-没有时间重构"><a href="#7-2-没有时间重构" class="headerlink" title="7.2 没有时间重构"></a>7.2 没有时间重构</h4><p>这是重构所面临最多的借口，是自己也是团队的借口。 为此必须要明确重构是经济行为而不是一种道德行为，重构使得开发效率变得更高，因此仅对必要的代码进行重构，某个工作行为如果重复三次就可以认为未来也会存在重复，因此通过重构使得下次工作更加高效，这是一种务实的作法，而重构不一定是需要大规模的展开的任务，重构应该是不断持续进行的，将任务拆解为多个具有完备性的任务，每周完成一个，每个任务的上线都不会引起问题，并使项目变得更好，这是一种持续重构的精神态度，是高效能程序员最应该具有的工作习惯。</p><p>如果你在给项目添加新的特性，发现当前的代码不能高效的完成这个任务，并且同样的任务出现三次以上，那么这时你应该先重构，再开发新特性。</p><h4 id="7-3-重构导致-bug"><a href="#7-3-重构导致-bug" class="headerlink" title="7.3 重构导致 bug"></a>7.3 重构导致 bug</h4><p>历史遗留的代码实在太多，难以阅读理解，如果无法理解谁也不敢轻易重构，害怕招致 bug 引起线上事故，因此在重构之前必须有一套相对完备的测试流程，他能给予程序员信心，也是重构的开始，反过来想对于谁也不愿意重构的代码进行重构，将收益巨大(这个项目还会继续迭代时)。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重构：改善既有代码的设计-学习笔记&quot;&gt;&lt;a href=&quot;#重构：改善既有代码的设计-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;重构：改善既有代码的设计 学习笔记&quot;&gt;&lt;/a&gt;重构：改善既有代码的设计 学习笔记&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;重构是在不改变软件可观测行为的前提下，调整代码结构，提高软件的可理解性，降低变更成本。重构除了能够帮助我们更好的进行开发之外，没有任何意义。对于每个稍微大一点的工程项目或者有追求的程序员，都应该尽可能地去重构每一段代码。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="生产力工具" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/"/>
    
    <category term="代码规范" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="重构" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E9%87%8D%E6%9E%84/"/>
    
    <category term="代码架构" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁</title>
    <link href="https://cherryyang05.github.io/hexo-blog/6d00129c.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/6d00129c.html</id>
    <published>2022-10-30T20:12:56.000Z</published>
    <updated>2024-10-25T18:39:01.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><blockquote><p>该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 <a href="https://github.com/CherryYang05/MultiProcessor">GitHub 仓库</a> 中查看。</p></blockquote><span id="more"></span><h2 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h2><p>关于自旋锁的内容，需要有以下几个方面的基础知识：基本数据结构（链表，队列）、操作系统中进程调度、锁及死锁、计算机体系结构中 cache 一致性、计算机组成原理中 cache 结构、Java 基本语法及 concurrent 包的基本用法。</p><h2 id="二、背景介绍"><a href="#二、背景介绍" class="headerlink" title="二、背景介绍"></a>二、背景介绍</h2><p>在如今多线程环境下对于共享临界资源的访问，需要加锁实现互斥。拿到锁的线程获得 CPU 执行临界区代码，而未拿到锁的线程通常来说有两种处理方式，一种是该线程进入循环等待，直到它等待的那个 CPU 空闲，然后获得 CPU 开始执行；另一种便是将自己阻塞，等待操作系统重新调度。</p><p>前一种锁叫 <code>自旋锁</code>，后一种锁叫 <code>互斥锁</code>。</p><!-- 实现两个线程间互斥有 `Peterson` 算法、`Bakery` 算法等，在这里暂时不做讨论，这里主要介绍自旋锁 --><p>先举一个很容易理解的例子。有两个进程，分别为 <code>P1</code> 和 <code>P2</code>，这两个线程做的工作都是将变量 a 加 1，就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行这两个线程各 100 次，我们预期的结果是 <code>a = 200</code>，但是实际上结果并不是我们想象的这样，它有可能是 200，但是更多的情况是一个小于 200 的数。</p><p>在计算机底层上，对一个数执行加一操作，编译器会将其编译成下面三条指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, mem</span><br><span class="line">add ax, <span class="number">1</span></span><br><span class="line">mov mem, ax</span><br></pre></td></tr></table></figure><p>当多线程执行时，代码执行顺序将不可控，因此会出现一个线程还未将值写进内存的时候，其他线程就读取内存中的值，造成数据相关问题。</p><h2 id="三、TAS-锁与-TTAS-锁"><a href="#三、TAS-锁与-TTAS-锁" class="headerlink" title="三、TAS 锁与 TTAS 锁"></a>三、TAS 锁与 TTAS 锁</h2><h3 id="3-1-TAS-锁"><a href="#3-1-TAS-锁" class="headerlink" title="3.1 TAS 锁"></a>3.1 TAS 锁</h3><p><code>TAS(testAndSet)</code> 是一个原子操作，它的功能是将 <code>true</code> 原子地写入变量，然后获取变量之前的值，即用 <code>true</code> 来交换变量的值。</p><p>为什么这个操作是原子的呢？因为在 x86 汇编中有个指令叫 <code>xchg</code>，它的功能便是交换两个数。</p><p>在 Java 中，有个与其功能一致的函数叫 <code>getAndSet()</code>，下面是 <code>TASLock</code> 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (state.getAndSet(<span class="literal">true</span>)) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>AtomicBoolean</code> 是原子布尔类型，能够实现原子的赋值，来自 <code>java.util.concurrent.atomic.AtomicBoolean</code>。</p><p>这个锁通过代码很容易理解：当线程 A 获取锁时，将 <code>state</code> 置为 <code>true</code>，若线程 A 还未释放锁时，其他线程 B 若也要申请锁，便会在 <code>while (state.getAndSet(true)) &#123;&#125;</code> 空转，直到 <code>state</code> 为 <code>false</code>，然后线程 B 便可以申请到锁了。</p><p>我们先来看一下另一种形式的 <code>TAS</code> 锁，然后将两者进行比较。</p><h3 id="3-2-TTAS-锁"><a href="#3-2-TTAS-锁" class="headerlink" title="3.2 TTAS 锁"></a>3.2 TTAS 锁</h3><p>直接看具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTASLock</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TTAS</code> 锁并没有每次都直接调用 <code>getAndSet(boolean)</code> 方法，而是先判断 <code>state</code> 变量是否为 <code>true</code>，若为 <code>true</code> 便无需用 <code>true</code> 和原先的值进行交换。而若 <code>state</code> 变量是 <code>false</code>，则再对 <code>state</code> 执行 <code>getAndSet</code>。</p><p>因为这里有两次 test，因此该锁叫 <code>TTAS(testTestAndSet)</code> 锁。</p><p>当然从加锁的正确性来说，这两种锁是等价的，都可以保证无死锁的互斥，对于简单的情况，这两种并无明显差别。但是在多处理器上运行大量线程，这两种锁将会展现出指数级别的效率差距。</p><p>下面是 n 个线程分别执行一段临界区代码所需的时间图，在没有任何争用干扰的情况下，最下面的平直曲线应该是理想情况（实际上并不可能）。可以看出这三条曲线差距非常明显。</p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20221030211520.png" alt="n个线程执行时间图" style="zoom: 40%;"><p>上图的情况可以用多处理器的系统结构进行解释。</p><h3 id="3-3-比较两种锁的性能差距"><a href="#3-3-比较两种锁的性能差距" class="headerlink" title="3.3 比较两种锁的性能差距"></a>3.3 比较两种锁的性能差距</h3><p>首先我们要确定的是，现代处理器几乎都包含高速缓存（cache），cache 与内存的一致性问题是现代处理器研究的重要问题；CPU 访问内存的时间时间比访问 cache 的时间多 2～3 个数量级。</p><p>多处理器中的 cache 一致性问题这里不展开讲述，大致内容如下。</p><p>每个处理器都有一个自己的 cache，考虑以下情况：处理器 A 访问数据 <code>x</code>（假设 <code>x = a</code>），将 x 放入 <code>cache_A</code> 中，处理器 B 也想访问 <code>x</code>，而 <code>cache_B</code> 中没有对 x 的缓存，这个时候处理器 B 便会在 <code>cache_A</code> 中查找 <code>x</code>，找到之后将其放入自己的缓存中（此时 <code>x = a</code>）。这时处理器 A 修改了 <code>x</code> 的值（假设修改为 b），并更新自己的 cache，若此时处理器 B 再次访问 <code>x</code>，它首先会从自己的 cache 中找，而目前 <code>cache_B</code> 中存放了 <code>x = a</code>，但是目前最新的值是 <code>x = b</code>，产生了错误，这就是 cache 一致性问题。</p><p>解决 cache 一致性问题的一个解决办法便是在一个处理器更新自己的 cache 后，该处理器在总线上广播这个地址，其他处理器监听总线，如果其他处理器在自己的 cache 中发现了同样的地址，则将对应的 cache 置为无效。</p><p>然后我们再来分析 <code>TAS</code> 锁。</p><p>在 <code>TAS</code> 锁中，每个线程每次执行都将调用 <code>getAndSet</code> 方法，而这个方法需要写入变量，因此在修改变量前需要在总线上进行广播，通知其他处理器将该 cache 行置为无效。而这便会带来两种问题：一是广播占用了总线流量，当的确需要从内存中读取值时便会造成总线上的延迟；二是每次修改变量是会造成其他处理器的 cache 缺失，即其他自旋的线程每次都会遇到 cache 不命中的情况，便需要通过总线获取新的值。同时，当持有锁的线程尝试释放锁时，因为总线拥挤而不得不被迫延迟，这样的多米诺骨牌效应只会导致效率越来越低。</p><p>总结来说，<code>TAS</code> 锁存在着大量的总线占用，每个线程每一次自旋都会产生大量的总线流量，从而使得其他线程也必须延迟，最终造成了系统的效率急剧降低。</p><p>而 <code>TTAS</code> 锁中，当线程 A 持有锁时，线程 B 第一次读锁时会发生 cache 缺失，但是只要线程 A 持有锁，线程 B 便只要不断读取值，这样每次 cache 都将命中，不产生总线流量，也不会影响其他线程对总线的使用。</p><p>当然当持有锁的线程释放锁时，会导致所有正在自旋的线程的 cache 失效，从而导致大量总线流量，但是短暂过后所有线程将归于平静，又将回到本地自旋的状态。</p><h2 id="四、指数后退锁"><a href="#四、指数后退锁" class="headerlink" title="四、指数后退锁"></a>四、指数后退锁</h2><p>我们现在考虑如何改进 <code>TTAS</code> 锁的算法，这里先引出一个术语：争用，争用的意思是多个线程试图同时获得一个锁。在上面的 <code>TTAS</code> 锁中，在两个 while 循环之间可能会产生高争用现象，此时线程获得锁的几率非常小，并且还会带来极高的总线流量。我们可以考虑将某些线程推迟一段时间再去尝试获得锁，这样同时申请锁的线程将减少，实际证明这样的效果行之有效。</p><p>那么应该将线程退后多长时间呢？了解过计算机网络中 CSMA&#x2F;CD（载波监听多路访问&#x2F;碰撞检测）中的二进制指数退避应该很容易想到，这里的指数后退与其相似。线程随机在 <code>(0, limit)</code> 中后退一段时间，若还未获得锁，那么将 <code>limit</code> 加倍，再次重新在 <code>(0, limit)</code> 获取一个随机值进行后退，直到 <code>limit</code> 到达一个设定的最大值 <code>maxDelay</code>。下面是代码实现。</p><p><code>Backoff.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backoff</span> &#123;</span><br><span class="line">    <span class="type">int</span> minDelay, maxDelay;     <span class="comment">// 限定最大和最小时延，避免无意义的过小的后退以及无限制后退</span></span><br><span class="line">    <span class="type">int</span> limit;                  <span class="comment">// 当前的时延限制</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Backoff</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        minDelay = min;</span><br><span class="line">        maxDelay = max;</span><br><span class="line">        limit = min;</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 0 和 limit 之间随机选取一个值进行退避，然后倍乘 limit，但是不能超过 maxDelay</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backoff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> random.nextInt(limit);</span><br><span class="line">        limit = Math.max(maxDelay, limit * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BackoffLock.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackoffLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">minDelay</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxDelay</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Backoff</span> <span class="variable">backoff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Backoff</span>(minDelay, maxDelay);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get()) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (!state.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                backoff.backoff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>BackoffLock</code> 的性能，与 <code>minDelay</code> 和 <code>maxDelay</code> 的值的选取密切相关，要根据实际任务及自身处理器及架构的情况合理设置阈值。</p><h2 id="五、队列锁"><a href="#五、队列锁" class="headerlink" title="五、队列锁"></a>五、队列锁</h2><h3 id="5-0-队列锁的介绍"><a href="#5-0-队列锁的介绍" class="headerlink" title="5.0 队列锁的介绍"></a>5.0 队列锁的介绍</h3><p>队列锁是一种易于扩展的自旋锁，尽管稍微复杂一点 <del>(亿点)</del>，但是具有更好的移植性。</p><p>在指数后退锁中，存在两个问题。</p><ul><li>一是所有线程获得锁都依赖于同一个变量 <code>state</code>，因此每个线程都在同一个共享存储单元上自旋，每一次成功的锁访问都会带来 cache 一致性流量（尽管相比之下比 TASLock 低）；</li><li>二是临界区利用率低，因为很多线程被“后退”了，因此延迟带来的开销是无法忽略的。</li></ul><p>可以将这些线程组织成一个链表（队列）来解决这些问题，在队列中，每个线程只要检测前一个线程是否已经完成来判断自己能否成功获取锁，这样每个线程就在不同存储单元上自旋了，也不会有延迟带来的开销。</p><p>下面介绍三种队列锁，基于数组的队列锁，CLH 队列锁和 MCS 队列锁。</p><h3 id="5-1-基于数组的队列锁"><a href="#5-1-基于数组的队列锁" class="headerlink" title="5.1 基于数组的队列锁"></a>5.1 基于数组的队列锁</h3><p>基于数组的队列锁 ALock，其有一个 tail 字段，初始值为 0，它被所有的线程共享，用来表示数组的下标。每个线程原子地增加 tail 字段的值，每个线程还有一个局部变量用来保存这个当前的 tail 值，称为 slot（槽）。如果 flag[j] 为 true，那么表示下标为 j 的线程有权获得锁。</p><p>初始状态时，flag 数组只有下标为 0 的那个值为 true，其他均为 false。其他线程调用 <code>lock()</code> 方法尝试获得锁时，会不断地在 <code>flag[slot]</code> 上旋转，直到 <code>flag[slot] == true</code>。在释放锁时，线程将对应于它自己的槽点 flag 设为 false，然后将下一个槽的 slot 设为 true。上述所有操作都要对 n 取模，n 的大小至少为最大的并发线程数。</p><p>下面用具体例子来说明基于数组的队列锁。</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/239b8e7f91620c96909e40c1792ae9e6.png" alt="基于数组的自旋锁"></p><p>上图的 a) 中，当前获得锁的线程是 A，<code>flag[2] == true</code>，线程 B 和 C 也尝试获得锁，线程 B 和 C 在 flag[3] 和 flag[4] 上自旋等待。当线程 A 释放锁后，flag[2] 设置为 false，flag[3] 设置为 true，线程 B 获得锁。</p><p><code>ALock.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ALock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mySLotIndex 是线程的局部变量，线程局部变量无需保存在共享存储器中，无需同步，不产生一致性流量</span></span><br><span class="line">    ThreadLocal&lt;Integer&gt; mySlotIndex = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    AtomicInteger tail;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span>[] flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ALock</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        size = capacity;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[capacity];</span><br><span class="line">        <span class="comment">// 为了避免假共享现象，可以将数组开大，让每一个项独占一个 cache 行</span></span><br><span class="line">        <span class="comment">// flag = new boolean[capacity * 4];</span></span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> tail.getAndIncrement() % size;</span><br><span class="line">        mySlotIndex.set(slot);</span><br><span class="line">        <span class="keyword">while</span> (!flag[slot]) &#123;&#125;;     <span class="comment">// 当前域为 false 则表明锁被占用，陷入空转等待</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> mySlotIndex.get();</span><br><span class="line">        flag[(slot + <span class="number">1</span>) % size] = <span class="literal">true</span>;</span><br><span class="line">        flag[slot] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在基于数组的队列锁中，mySlotIndex 是线程的局部变量，局部变量不需要与其他线程共享，不需要同步，也就不会产生一致性流量，因为它只能被一个线程访问。尽管 flag 数组是被多个线程共享的，但是在任意特定的时刻，线程对应的 flag 存储单元会被存放在对应的 cache 中，线程是在本地 cache 中旋转，大大降低了无效流量，从而使得对数组的存储单元的争用大大降低。</p><p>但是值得注意的是，争用仍然可能发生，因为存在一种“假共享”现象，当相邻的数组元素在同一个 cache 行时，就会发生这样的现象。继续看上面的图 a)，假设一个 cache 行能够存放 4 个数组元素，那么 flag[0] ~ flag[3] 都将存放在同一个 cache 行中。当某一个线程对 cache 行执行写操作时，会导致当前 cache 行无效，从而导致其他在该 cache 旋转的线程产生无效流量。</p><p>一种解决办法就是上图中的 b)，于是我们将数组进行填，充让一个 cache 行只存放一个数组元素，具体实现上只需要将 <code>(i + 1) % 8</code> 改成 <code>4 * (i + 1) % 32</code> 即可。</p><blockquote><p>个人想法：尽管 <code>flag</code> 是 <code>volatile</code> 的，但是在释放锁时，无法保证 <code>flag[slot] = false;</code> 和 <code>flag[(slot + 1) % size] = true;</code> 这两个步骤之间进程不被调度。如果先将自己的槽设置为 <code>false</code>，然后进程被调度，那么数组所有元素都是 <code>false</code>，之后加锁的进程永远无法获得锁。因此，应该先将下一个槽设置为 <code>true</code>，尽管假设这个时候进程被调度，也会使得下一个进程成功获得锁（书上代码是先将自己的槽设置为 <code>false</code>，然后再将下一个槽设置为 <code>true</code>，我给出的示例代码将这两行调换了顺序）。</p></blockquote><h3 id="5-2-CLH-队列锁"><a href="#5-2-CLH-队列锁" class="headerlink" title="5.2 CLH 队列锁"></a>5.2 CLH 队列锁</h3><p><code>ALock</code> 是对 <code>BackoffLock</code> 的改进，因为它将⽆效性降到最低并把⼀个线程释放锁和另⼀个 线程获得该锁之间的时间间隔最⼩化。与 <code>TASLock</code> 和 <code>BackoffLock</code> 不同，该算法能够确保⽆饥饿性，同时也保证了先来先服务的公平性。</p><p>但是，<code>ALock</code> 并不是空间有效的，它限定了并发的最大线程数量 <code>n</code>，需要为每一个锁开一个至少为 <code>n</code> 的数组，因此如果有 <code>L</code> 个锁，则需要至少 <code>O(Ln)</code> 的空间。</p><p>下面介绍一种基于链表的锁，<code>CLHlock</code>。锁本身被表示为 <code>QNode</code> 对象的虚拟链表。之所以称之为“虚拟”是因为链表是隐式的，即每个线程通过⼀个线程局部变量 <code>pred</code> 指向其前驱。公共的tail域对于最近加⼊到队列的结点来说是⼀</p><p><code>CLHLock</code> 的数据结构及初始化代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;QNode&gt; tail = <span class="literal">null</span>;</span><br><span class="line">ThreadLocal&lt;QNode&gt; myPred = <span class="literal">null</span>;</span><br><span class="line">ThreadLocal&lt;QNode&gt; myNode = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CLHLock</span><span class="params">()</span> &#123;</span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">QNode</span>());</span><br><span class="line">    myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    myPred = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类在 <code>QNode</code> 对象的布尔型 <code>locked</code> 域中记录了每个线程的状态。如果该域为 <code>true</code>，则相应的线程要么已经获得锁，要么正在等待锁；如果该域为 <code>false</code>，则相应的线程已经释放了锁。</p><p>下面是 <code>lock</code> 和 <code>unlock</code> 的具体代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    qnode.locked.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">    myPred.set(pred);</span><br><span class="line">    <span class="keyword">while</span> (pred.locked.get()) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    qnode.locked.set(<span class="literal">false</span>);        <span class="comment">// 通知后继线程</span></span><br><span class="line">    myNode.set(myPred.get());       <span class="comment">// 这句非常重要，避免同一个线程重复加锁导致自旋等待而死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/202409081812141.png" alt="CLHLock 工作流程"></p><p>如上图所示，若要获得锁，线程将其 <code>QNode</code> 的 <code>locked</code> 域设<code>true</code>，表示该线程不准备释放锁。随后线程对 <code>tail</code> 域调⽤ <code>getAndSet()</code> ⽅法，使它⾃⼰的结点成为队列的尾部，同时获得⼀个指向其前驱 <code>QNode</code> 的引⽤，最后线程在其前驱的 <code>locked</code> 域上旋转，直到前驱释放该锁。</p><p>详细解释一下 <code>CLH</code> 锁的工作原理：<code>tail</code> 为全局变量，在所有线程之间共享，每个线程有两个独立的局部变量，为 <code>myPred</code> 和 myNode，表示当前自己的 <code>QNode</code> 结点和前驱 <code>QNode</code> 结点。</p><p>当 A 线程尝试获取锁时，首先获取 <code>myNode</code> 的值，表明当前的 <code>QNode</code> 结点，然后将结点内的 <code>locked</code> 字段设为 <code>true</code>，表明线程 A 不准备释放锁（即想要申请锁），然后取出 <code>tail</code> 的值（此时 <code>tail</code> 记录的是虚拟链表的尾部的 <code>QNode</code>，实际上只是一个变量，并不是链表）赋值给 <code>myPred</code>，表明当前 <code>QNode</code> 的前驱结点，并将当前结点赋值给 <code>tail</code>。在 A 线程获得锁之前，要在 <code>myPred</code> 上空转等待，等待 <code>myPred.locked</code> 为 <code>false</code> 即可获得锁。</p><p>当锁申请成功时，<code>tail</code> 存放的结点是当前的 <code>myNode</code> 结点，<code>myPred</code> 是前驱结点，<code>myNode</code> 和 <code>tail</code> 指向的是同一个结点。若要释放锁时，将当前的结点的 <code>locked</code> 字段改为 <code>false</code>，表明释放该锁，然后将当前结点用前驱结点覆盖 <code>myNode.set(myPred.get())</code>，这句话非常重要，这样可以避免同一个线程重复加锁时自旋等待，从而导致死锁。考虑以下情况：在上图中，如果在线程 A 释放锁后，线程 B 获取锁之前，线程 A 再次调用 <code>lock()</code>，那么会直接将线程 A 对应的 <code>QNode</code> 的 <code>locked</code> 字段设置为 <code>true</code>，而这个结点正是线程 B 空转等待的结点（<code>myPred</code> 结点），线程 B 的 <code>myPred</code> 是线程 A 的 <code>myNode</code>，线程 A 的 <code>myPred</code> 是线程 B 的 <code>myNode</code>，互相等待对方释放锁，于是产生了死锁。因此当一个线程释放锁时，需要将自己当前的 <code>myNode</code> 指向其他结点，可以直接指向自己的前驱结点（如上图 c 所示），或者自己再创建一个新的 <code>QNode</code>（可以但没必要）。</p><p>由于每个结点释放锁后可以被系统回收，因此 <code>CLHLock</code> 只需要 <code>O(L+n)</code> 的空间。与 <code>ALock</code> ⼀样，该算法让每个线程在不同的存储单元上旋转，这样当⼀个线程释放它的锁时，只能使其后继的 <code>cache</code> ⽆效。该算法⽐ <code>ALock</code> 类所需的空间少，且不需要知道可能使⽤锁的线程的数量。该算法和 <code>ALock</code> 类⼀样，也提供了先来先服务的公平性。</p><p>也许这种锁算法的唯⼀缺点就是它在⽆ <code>cache</code> 的 <code>NUMA</code> 系统结构下性能很差。每个线程都⾃旋等待其前驱结点的 <code>locked</code> 域变为 <code>false</code>。如果内存位置较远，那么性能将会受到损失。然⽽，在 <code>cache</code> ⼀致性的系统结构上，该⽅法⾮常有效。</p><p>完整的 <code>CLHLock</code> 代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spinlocks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;QNode&gt; tail = <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myPred = <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CLHLock</span><span class="params">()</span> &#123;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">QNode</span>());</span><br><span class="line">        myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myPred = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        qnode.locked.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        <span class="keyword">while</span> (pred.locked.get()) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        qnode.locked.set(<span class="literal">false</span>);        <span class="comment">// 通知后继线程</span></span><br><span class="line">        myNode.set(myPred.get());       <span class="comment">// 这句非常重要，避免同一个线程重复加锁导致自旋等待而死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-MCS-队列锁"><a href="#5-3-MCS-队列锁" class="headerlink" title="5.3 MCS 队列锁"></a>5.3 MCS 队列锁</h3><p><code>MCSLock</code> 也是用 <code>QNode</code> 表示，但是和 <code>CLHLock</code> 不同，它是表示为一个显式链表，通过 <code>QNode</code> 对象中的 <code>next</code> 字段体现，⽽不是由线程的局部变量所体现。</p><p><code>MCSLock</code> 的构造函数和 <code>QNode</code> 对象定义和初始化如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">QNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">AtomicReference&lt;QNode&gt; tail;</span><br><span class="line">ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MCSLock</span><span class="params">()</span> &#123;</span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展现了 <code>MCSLock</code> 的加锁与释放锁的过程。</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGoImage/master/images/202409100009815.png"></p><p><code>MCSLock</code> 释放锁的过程：检查当前结点是否为链表最后一个结点，如果不是最后一个结点，且 <code>qnode.next</code> 为空，<strong>说明下一个结点已经准备申请锁，但是结点的链接还未完成</strong>，这时当前线程释放锁需要自旋等待，直到下一个线程将链表链接完成。在任⼀种情形下，⼀旦出现了后继结点，<code>unlock()</code> ⽅法则将它的后继的 <code>locked</code> 域设置 <code>false</code>，表明⽬前锁是空闲的。</p><p>最后一句：<code>qnode.next = null</code> 是必要的。若线程释放锁后不将 <code>next</code> 指针置空，则下列这种线程执行情况将导致线程忙等：<code>A.lock() -&gt; B.lock() -&gt; A.unlock() -&gt; A.lock() -&gt; B.unlock() -&gt; A.unlock() -&gt; A.lock()</code>，即当线程队列形成回路时，释放锁时分支 <code>if (qnode.next == null)</code> 将不会进入正确的代码块执行，导致  <code>tail</code> 不会被置为 <code>null</code>，当下一次申请锁进入 <code>lock()</code> 时，就会导致无限空转。</p><p>该锁具有 <code>CLHLock</code> 的优点，特别是每个锁释放仅能使其后继的 cache 项⽆效。这种算法更适于⽆ cache 的 NUMA 系统结构，因为是由每个线程来控制它所⾃旋的存储单元的。如同 <code>CLHLock</code> ⼀样，结点能被重复使⽤。因此，该锁的空间复杂度为 <code>O(L+n)</code>。<code>MCSLock</code> 算法的⼀个缺点就是释放锁时也需要旋转，另外⼀个缺点就是它⽐ <code>CLHLock</code> 算法的读、写和 <code>compareAndSet()</code> 调⽤次数多。</p><p>完整 <code>MCS</code> 锁代码实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MCSLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">QNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;QNode&gt; tail;</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MCSLock</span><span class="params">()</span> &#123;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">        myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不能初始化为 true，避免在释放锁时但是还未将 next 域置为 null 时该线程再次申请锁，这样就会导致多个线程同时访问一个变量导致计数错误</span></span><br><span class="line">            qnode.locked.set(<span class="literal">true</span>);         </span><br><span class="line">            pred.next = qnode;</span><br><span class="line">            <span class="keyword">while</span> (qnode.locked.get()) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MCS 释放锁的过程：检查当前结点是否为链表最后一个结点，如果不是最后一个结点，且 qnode.next 为空，</span></span><br><span class="line"><span class="comment">     * 说明下一个结点已经准备申请锁，但是结点的链接还未完成，这时当前线程释放锁需要自旋等待，直到下一个线程</span></span><br><span class="line"><span class="comment">     * 将链表链接完成。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 最后一句：qnode.next = null 是必要的。若线程释放锁后不将 next 指针置空，则下列这种线程执行情况</span></span><br><span class="line"><span class="comment">     * 将导致线程忙等：A.lock() -&gt; B.lock() -&gt; A.unlock() -&gt; A.lock() -&gt; B.unlock() -&gt; A.unlock() -&gt; A.lock()，</span></span><br><span class="line"><span class="comment">     * 即当线程队列形成回路时，释放锁时分支 if (qnode.next == null) 将不会进入正确的代码块执行，</span></span><br><span class="line"><span class="comment">     * 导致 tail 不会被置为 null，当下一次申请锁时，就会导致无限空转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        <span class="keyword">if</span> (qnode.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail.compareAndSet(qnode, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果执行到这，说明 tail 指向的不是 qnode 结点，但是 qnode 结点的后继却是 null，说明有一个结点正在链接过程中还没有链接好</span></span><br><span class="line">            <span class="keyword">while</span> (qnode.next == <span class="literal">null</span>) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qnode.next.locked.set(<span class="literal">false</span>);</span><br><span class="line">        qnode.next = <span class="literal">null</span>;              <span class="comment">// 这句是必要的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;自旋锁&quot;&gt;&lt;a href=&quot;#自旋锁&quot; class=&quot;headerlink&quot; title=&quot;自旋锁&quot;&gt;&lt;/a&gt;自旋锁&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该篇博客参考了《多处理器编程的艺术》第七章——自旋锁与争用，相关代码可在 &lt;a href=&quot;https://github.com/CherryYang05/MultiProcessor&quot;&gt;GitHub 仓库&lt;/a&gt; 中查看。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机原理知识" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://cherryyang05.github.io/hexo-blog/tags/Java/"/>
    
    <category term="并发多核" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E5%B9%B6%E5%8F%91%E5%A4%9A%E6%A0%B8/"/>
    
    <category term="操作系统" scheme="https://cherryyang05.github.io/hexo-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Rust中Clap库的使用</title>
    <link href="https://cherryyang05.github.io/hexo-blog/8ce3ab1f.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/8ce3ab1f.html</id>
    <published>2022-10-26T21:32:39.000Z</published>
    <updated>2024-10-25T18:39:01.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Clap-库的使用"><a href="#Clap-库的使用" class="headerlink" title="Clap 库的使用"></a>Clap 库的使用</h1><blockquote><p>Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。</p></blockquote><span id="more"></span><h2 id="一、版权及说明"><a href="#一、版权及说明" class="headerlink" title="一、版权及说明"></a>一、版权及说明</h2><p>该文参考了 Rust 语言中文社区的 <a href="https://rustcc.cn/article?id=921ad2c0-09af-4271-ae62-4b21ce281a2b">每周一库</a>，同时参考了官方 <a href="https://crates.io/crates/clap">crate</a> 以及 <a href="https://docs.rs/clap/latest/clap/">clap 官方文档</a> 的用例及介绍</p><p>对于命令行解析使用最多的库，可以在 <a href="https://crates.io/">crates.io</a> 首页搜索关键词 Command Line，下载量最多的库便是 clap</p><h2 id="二、关于命令行解析"><a href="#二、关于命令行解析" class="headerlink" title="二、关于命令行解析"></a>二、关于命令行解析</h2><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>clap 用于解析并验证用户在运行命令行程序时提供的命令行参数字符串。 你所需要做的只是提供有效参数的列表，clap 会自动处理其余的繁杂工作。 这样工程师可以把时间和精力放在实现程序功能上，而不是参数的解析和验证上。</p><p>当 clap 解析了用户提供的参数字符串，它就会返回匹配项以及任何适用的值。 如果用户输入了错误或错字，clap 会通知他们错误并退出（或返回 Result 类型，并允许您在退出前执行任何清理操作）。这样，工程师可以在代码中对参数的有效性做出合理的假设。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Clap-库的使用&quot;&gt;&lt;a href=&quot;#Clap-库的使用&quot; class=&quot;headerlink&quot; title=&quot;Clap 库的使用&quot;&gt;&lt;/a&gt;Clap 库的使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Clap 是一个用来解析 rust 命令行参数的库。稍微有编程语言基础的人应该会觉得这个解释非常清晰明了，一些类似于“clap 库易于使用、高效且功能齐全”等场面话不会再次出现，下面我们直接进入正题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
    <category term="lib" scheme="https://cherryyang05.github.io/hexo-blog/tags/lib/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十六）：最后的项目</title>
    <link href="https://cherryyang05.github.io/hexo-blog/9e622d63.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/9e622d63.html</id>
    <published>2022-09-29T22:55:08.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><span id="more"></span><h2 id="一、单线程-Web-服务器"><a href="#一、单线程-Web-服务器" class="headerlink" title="一、单线程 Web 服务器"></a>一、单线程 Web 服务器</h2><h3 id="1-1-构建单线程-Web-服务器"><a href="#1-1-构建单线程-Web-服务器" class="headerlink" title="1.1 构建单线程 Web 服务器"></a>1.1 构建单线程 Web 服务器</h3><ul><li>在 socket 上监听 TCP 连接</li><li>解析少量的 HTTP 请求</li><li>创建一个合适的HTTP响应</li><li>使用线程池改进服务器的吞吐量</li><li>注意：并不是最佳实践</li></ul><p>直接放代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;net::&#123;TcpListener, TcpStream&#125;, io::&#123;Read, Write&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Request: &#123;&#125;\n&quot;</span>, <span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>, contents.<span class="title function_ invoke__">len</span>(), contents);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>TcpListener::bind()</code> 方法表示监听所绑定的 IP 及端口，返回一个 Result 枚举，<code>incoming</code> 方法能够将所监听到的流转化成一个个迭代器，然后一依次处理这些流。</p><p>在 <code>handle_connection()</code> 函数中，先构造了一个 <code>buffer</code> 用于存放每个流请求的具体内容（请求头），然后写了一个 <code>hello.html</code> 页面，构造一个响应头同时写回请求的流中。在 <code>response</code> 字段中，要注意添加 <code>Content-Length:&#123;&#125;</code>，这样执行该程序，在浏览器中访问 <code>127.0.0.1:9999</code>，便可以返回刚刚写的页面。</p><p>控制台输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment">Content-Length:170</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Hello!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Hi From Rust&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器显示的页面如下：</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929233943.png" alt="浏览器正常显示页面"></p><p>下面我们新建一个 404 页面，用于处理访问其他页面时显示的结果，我们主要修改 <code>handle_connection()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">response</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_line</span> = <span class="string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;404.html&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        response = <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;&#125;\r\nContent-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">            status_line,</span><br><span class="line">            contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            contents</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// println!(&quot;&#123;&#125;&quot;, response);</span></span><br><span class="line">    &#125;</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断请求头是不是以 <code>GET / HTTP/1.1\r\n</code> 开头，这表明我们请求的是根目录的资源，这里 <code>let get = b&quot;GET / HTTP/1.1\r\n&quot;;</code> 的 <code>b</code> 表示字节字符串，可以将字符串转化成字节，这样就可以用 <code>start_with()</code> 方法进行比较。</p><p>在浏览器中访问一个非根目录的资源，控制台输出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  mweb git:(master) ✗ cargo run</span><br><span class="line">   Compiling mweb v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/mweb)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.32</span>s</span><br><span class="line">     Running `target/debug/mweb`</span><br><span class="line">Request: GET /undefined HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9999</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">sec-ch-ua: <span class="string">&quot;Google Chrome&quot;</span>;v=<span class="string">&quot;105&quot;</span>, <span class="string">&quot;Not)A;Brand&quot;</span>;v=<span class="string">&quot;8&quot;</span>, <span class="string">&quot;Chromium&quot;</span>;v=<span class="string">&quot;105&quot;</span></span><br><span class="line">sec-ch-ua-mobile: ?<span class="number">0</span></span><br><span class="line">sec-ch-ua-platform: <span class="string">&quot;macOS&quot;</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_15_7</span>) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">105.0</span>.<span class="number">0.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">Sec-Fet</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HTTP/1.1 404 NOT FOUND</span></span><br><span class="line"><span class="comment">Content-Length:201</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Hello!&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;h1&gt;Oops!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;Sorry,I don&#x27;t know what you&#x27; re asking for. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器页面如下：</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220929235635.png" alt="404页面"></p><p>重构一下 <code>handle_connection()</code> 函数，用元组来重构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buffer</span> = [<span class="number">0</span>; <span class="number">512</span>];</span><br><span class="line">    stream.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buffer).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;Request: &#123;&#125;\n&quot;, String::from_utf8_lossy(&amp;buffer));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">get</span> = <span class="string">b&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(file_name).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;Content-Length:&#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">        status_line,</span><br><span class="line">        contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        contents</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, response);</span><br><span class="line">    stream.<span class="title function_ invoke__">write</span>(response.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    stream.<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、多线程-Web-服务器"><a href="#二、多线程-Web-服务器" class="headerlink" title="二、多线程 Web 服务器"></a>二、多线程 Web 服务器</h2><h3 id="2-1-阻塞的场景"><a href="#2-1-阻塞的场景" class="headerlink" title="2.1 阻塞的场景"></a>2.1 阻塞的场景</h3><p>当前我们对于流的处理都是单线程，一旦有某个请求耗费的时间长了，那么其他请求就必须被阻塞等待。我们构造下面这样的场景：当访问 <code>sleep</code> 页面的时候，线程睡眠 5 秒钟再执行处理，运行程序后访问其他页面可以正常被处理，当访问 <code>sleep</code> 页面的时候会卡住 5 秒钟，这时访问其他页面就需要等待这 5 秒钟结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sleep</span> = <span class="string">b&quot;GET /sleep HTTP/1.1\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (status_line, file_name) = <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(get) &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> buffer.<span class="title function_ invoke__">starts_with</span>(sleep) &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>, <span class="string">&quot;hello.html&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (<span class="string">&quot;HTTP/1.1 404 NOT FOUND\r\n&quot;</span>, <span class="string">&quot;404.html&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在代码中增加了对 <code>sleep</code> 页面的访问，运行效果与预期一致。</p><p>我们用线程池来解决这一问题。</p><h3 id="2-2-线程池"><a href="#2-2-线程池" class="headerlink" title="2.2 线程池"></a>2.2 线程池</h3><p>线程池是一组预先被分配的线程，他们用于等待并随时处理可能的任务。线程池可以实现并发处理请求，当前线程执行完之后，将其放回线程池。首先考虑到使用 <code>thread::spawn()</code> 为每个请求创建线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(||&#123;</span><br><span class="line">    <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这样显然会导致一个问题：当有黑客对服务器进行洪泛攻击时，服务器的资源将会很快被耗尽，因此我们还需要对线程数量进行限制。</p><p>在该项目中，采用编译器驱动开发的方式（笑），先将可能用到的结构体或方法等先写好，再逐步完善，修改 main 如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:9999&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显 <code>ThreadPool</code> 和 <code>execute</code> 是未定义的。</p><p>新建 <code>lib.rs</code>，实现未定义的部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        ThreadPool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>execute</code> 方法，我们参考 <code>thread::spawn()</code>，后者实现了 <code>FnOnce() + Send + &#39;static</code>。</p><p>然后我们给结构体 <code>ThreadPool</code> 添加一个字段 <code>threads</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    threads: <span class="type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是怎么来的呢，我们看 <code>spawn</code> 的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">spawn</span>&lt;F, T&gt;(f: F) <span class="punctuation">-&gt;</span> JoinHandle&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T,</span><br><span class="line">    F: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    Builder::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">spawn</span>(f).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to spawn thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它返回的是 <code>JoinHandle</code>，其中有一个范型 <code>T</code>，这个 <code>T</code> 就是传进去的闭包的返回值，但是我们实现的方法闭包没有返回值，因此返回单元类型 <code>()</code> 即可。</p><p>再次修改 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">threads</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        todo!()    </span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;threads&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看<code>spawn</code> 的实现，他会创建一个线程，立即执行接收到的代码。但是我们希望线程创建之后进入等待状态，当有代码传给他们的时候再执行线程。这里我们创建一个新的结构体，叫 <code>Worker</code>，用来管理和实现上述所说的行为。</p><p>实现 <code>Worker</code> 相关结构体和函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时将 <code>ThreadPool</code> 中的字段名改成 <code>workers</code>，更改 <code>ThreadPool</code> 的 <code>new()</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止，<code>lib.rs</code> 代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;&#125;);</span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用通道"><a href="#2-3-使用通道" class="headerlink" title="2.3 使用通道"></a>2.3 使用通道</h3><p>下面我们需要考虑如何让 <code>Worker</code> 从线程池中接收任务并执行任务，这里就要使用到通道。</p><p>在 <code>ThreadPool</code> 中添加一个字段 <code>sender</code>，表示通道的发送端。线程池持有通道的发送端，而接收者应该是 <code>worker</code>。在通道中，可以有多个发送者，但是只能有一个接收者，我们希望所有线程共享同一个 <code>receiver</code>，从而能够在线程间分发任务。同时从通道队列中取出 <code>receiver</code> 也意味着这是可变的。我们可以用 “智能指针” 那一小节中的 <code>Arc</code> 和 <code>Mutex</code> 来实现线程间多所有权的可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadPool &#123;workers, sender&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 <code>Worker</code> 结构体的 <code>new</code> 的函数签名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-实现-execute-方法"><a href="#2-4-实现-execute-方法" class="headerlink" title="2.4 实现 execute 方法"></a>2.4 实现 execute 方法</h3><p>新建一个 <code>job</code>，然后通过通道的发送端将 <code>job</code> 发送出去，接收端 <code>worker</code> 的 <code>new</code> 函数接收该 <code>job</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">    <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">        (*job)(); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Worker &#123;id, thread&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 <code>job</code> 是一个 <code>Box</code> 类型，那么实现 <code>FnOnce()</code> 的闭包要想调用就要先将其从 <code>Box</code> 取出来，但是 Rust 不允许这样做，因为不知道 <code>Box</code> 中的类型具体有多大。<code>FnOnce()</code> 中有一个 <code>call_once()</code> 方法，其中的参数便是 <code>self</code>，为了获得其所有权，但是现在不允许。我们可以将 <code>self</code> 改成 <code>Box&lt;Self&gt;</code>，这样方法就可以在类型的 <code>Box</code> 上来调用。</p><p>然后为实现了 <code>FnOnce()</code> 的类型实现 <code>FnBox</code>，<code>self</code> 的类型就是 <code>Box&lt;F&gt;</code>，而 <code>F</code> 就是实现了 <code>FnOnce()</code> 的类型，这样就可以获得 <code>Box</code> 里的所有权，再进行闭包调用，同时更改 <code>Job</code> 的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br></pre></td></tr></table></figure><p>最后在 <code>Worker</code> 的 <code>new</code> 函数中加入 loop，使得释放锁后还能继续使用该线程。</p><p>最终 <code>lib.rs</code> 文件如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;thread, sync::&#123;mpsc, Arc, Mutex&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pub struct Job &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 创建一个线程池</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// size 表示线程池中线程数量</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// # Panics</span></span><br><span class="line">    <span class="comment">/// </span></span><br><span class="line">    <span class="comment">/// Panic: size is zero</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程并存储到 vec 中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123;workers, sender&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: thread::JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">FnBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt; FnBox <span class="keyword">for</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call_box</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> FnBox + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;&#125; get a job; executing&quot;</span>, id);</span><br><span class="line">            job.<span class="title function_ invoke__">call_box</span>(); </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Worker &#123;id, thread&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十三）：智能指针</title>
    <link href="https://cherryyang05.github.io/hexo-blog/e9389bfa.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/e9389bfa.html</id>
    <published>2022-07-08T16:50:48.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 <code>&amp;</code> 了，没有其他开销。<br>智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。</p></blockquote><span id="more"></span><h2 id="一、智能指针介绍"><a href="#一、智能指针介绍" class="headerlink" title="一、智能指针介绍"></a>一、智能指针介绍</h2><p><strong>引用和智能指针的区别</strong></p><ul><li>智能指针往往基于结构体实现</li><li>引用只借用数据，而智能指针很多时候拥有其指向的数据</li></ul><p><strong>智能指针的例子</strong></p><ul><li><code>String</code> 和 <code>Vec&lt;T&gt;</code></li><li>都拥有一片内存区域，且允许用户对其操作</li><li>还拥有元数据（例如容量等）</li><li>提供额外的功能保障（String 保证其是合法的 UTF-8 数据）</li></ul><p><strong>智能指针的实现</strong></p><ul><li>智能指针通常使用 struct 实现，并且实现了 <code>Deref</code> 和 <code>Drop</code> 这两个 trait</li><li><code>Deref trait</code>：允许智能指针 struct 的实例像引用一样使用</li><li><code>Drop trait</code>：允许你自定义当智能指针实例走出作用域时的代码</li></ul><p><strong>本章内容</strong></p><ul><li>介绍标准库中常见的智能指针<ul><li><code>Box&lt;T&gt;</code>：在 heap内存上分配值</li><li><code>Rc&lt;T&gt;</code>：启用多重所有权的引用计数类型</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCelk&lt;T&gt;</code> 访问：在运行时而不是编译时强制借用规则的类型</li></ul></li><li>此外</li><li>内部可变模式（interior mutability pattern）：不可变类型暴露出可修改其内部值的 API</li><li>引用循环（reference cycles）：它们如何泄露内存，以及如何防止其发生</li></ul><h2 id="二、使用-Box-lt-T-gt"><a href="#二、使用-Box-lt-T-gt" class="headerlink" title="二、使用 Box&lt;T&gt;"></a>二、使用 Box&lt;T&gt;</h2><h3 id="2-1-Box-lt-T-gt"><a href="#2-1-Box-lt-T-gt" class="headerlink" title="2.1 Box&lt;T&gt;"></a>2.1 Box&lt;T&gt;</h3><p><code>Box&lt;T&gt;</code> 是最简单的智能指针</p><ul><li>允许你在 heap 上存储数据（而不是 stack）</li><li>stack 上是指向 heap 数据的指针</li><li>没有性能开销</li><li>没有其它额外功能</li><li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code></li></ul><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><ul><li>在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小</li><li>当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制</li><li>使用某个值时，你只关心它是否实现了特定的 trait，而不关心它的具体类型</li></ul><h4 id="2-2-1-Box-lt-T-gt-如何在-heap-上存储数据"><a href="#2-2-1-Box-lt-T-gt-如何在-heap-上存储数据" class="headerlink" title="2.2.1 Box&lt;T&gt; 如何在 heap 上存储数据"></a>2.2.1 Box&lt;T&gt; 如何在 heap 上存储数据</h4><p>来看一段简单的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用 <code>Box</code>，那么就会在栈中创建一个变量 x，而使用了 <code>Box</code> 就会在 heap 上创建一个变量。在变量 x 走出作用域时，变量 x 在 stack 上的指针和在 heap 上的值都会被释放。</p><h4 id="2-2-2-使用-Box-赋能递归类型"><a href="#2-2-2-使用-Box-赋能递归类型" class="headerlink" title="2.2.2 使用 Box 赋能递归类型"></a>2.2.2 使用 Box 赋能递归类型</h4><p>比如有这样一个枚举</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Cons 变体，里面有一个他类型本身（List），这样就会一直递归下去。但是在编译时，Rust 需要知道一个类型所占的空间大小，而这样的递归类型无法确定其大小。在递归类型中使用 Box 就可以解决上述问题。这也是函数式语言中的 Cons List</p><p><strong>关于 Cons List</strong></p><p>Cons List 是来自 Lisp 语言的一种数据结构。Cons List里每个成员由两个元素组成：</p><ul><li>当前项的值</li><li>下一个元素</li></ul><p>Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素。<strong>实际上就是 Rust 中的一种链表</strong>，但他并不是 Rust 的常用集合。</p><p><strong>Rust 如何确定非递归类型所占用的大小的？</strong></p><p>实际上是取结构体或枚举下最大空间的变体的大小作为整个结构体或枚举的大小（非常类似于 C 语言中的联合体 Union）。</p><p>因此最终应将代码改成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, </span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Box 来获得确定大小的递归类型</strong></p><ul><li><code>Box&lt;T&gt;</code> 是一个指针，Rust 知道它需要多少空间，因为<ul><li>指针的大小不会基于它指向的数据的大小变化而变化</li></ul></li><li>Box<T>:<ul><li>只提供了“间接”存储和 heap 内存分配的功能</li><li>没有其它额外功能</li><li>没有性能开销</li><li>适用于需要“间接”存储的场景，例如 Cons List</li><li>实现了 <code>Deref trait</code> 和 <code>Drop trait</code><ul><li><code>Deref trait</code>：可以将 Box 的值当做引用来处理</li><li><code>Drop trait</code>：定义了当 Box 值走出作用域时，清理掉栈上的指针和堆上的数据</li></ul></li></ul></T></li></ul><h2 id="三、Deref-trait"><a href="#三、Deref-trait" class="headerlink" title="三、Deref trait"></a>三、Deref trait</h2><p><code>Deref</code> 就是 <code>dereference</code> 解引用的意思。</p><ul><li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符 <code>*</code> 的行为</strong></li><li>通过实现 Deref，智能指针可像常规引用一样来处理</li></ul><h3 id="3-1-解引用运算符"><a href="#3-1-解引用运算符" class="headerlink" title="3.1 解引用运算符"></a>3.1 解引用运算符</h3><p>常规引用也是指针。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test01</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*y, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有什么好解释的，和 C 语言一样，<code>*y</code> 表示解引用变量 y。</p><h3 id="3-2-定义自己的智能指针"><a href="#3-2-定义自己的智能指针" class="headerlink" title="3.2 定义自己的智能指针"></a>3.2 定义自己的智能指针</h3><p><code>Box&lt;T&gt;</code> 被定义成拥有一个元素的 tuple struct。下面来定义自己的 <code>MyBox&lt;T&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看定义，<code>MyBox&lt;T&gt;</code> 实际上就是一个有名称的元组（tuple），这个元组里只有一个元素。</p><p>再看第二个断言，这里的 <code>*y</code> 会报错 <code>type &#39;MyBox&lt;&#123;integer&#125;&gt;&#39; cannot be dereferenced</code>，表示 <code>MyBox</code> 类型不能被解引用，这是因为 <code>MyBox</code> 没有实现 <code>Deref trait</code>。</p><p>标准库中的 <code>Deref trait</code> 要求我们实现一个 <code>deref</code> 方法</p><ul><li>该方法借用 self</li><li>返回一个指向内部数据的引用</li></ul><p>因此我们为 <code>MyBox</code> 实现 <code>Deref</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>type Target = T;</code> 类似于 C 语言中的 <code>typedef struct Person &#123;&#125; P</code>？</p><p>而 <code>*y</code> 实际上是 <code>*(y.deref())</code>，调用 <code>*</code> 之前，先执行 <code>deref</code> 取引用，然后通过 <code>*</code> 运算符解引用。</p><h3 id="3-3-隐式解引用转化"><a href="#3-3-隐式解引用转化" class="headerlink" title="3.3 隐式解引用转化"></a>3.3 隐式解引用转化</h3><ul><li>隐式解引用转化（Deref Coercion）是为函数和方法提供的一种便捷特性。</li><li>假设 T 实现了 Deref trait：<ul><li>Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li></ul></li><li>当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配<ul><li>Deref Coercion 就会自动发生</li><li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li><li>在编译时完成，没有额外性能开销</li></ul></li></ul><p>在上面实现 <code>MyBox</code> 和 <code>Deref</code> 的前提下，增加以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cherry&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要分析 <code>hello</code> 函数中传入的参数类型，是一个字符串切片类型，而 <code>m</code> 是一个实现了 <code>Deref</code> 的结构体类型，但是为什么能传入 <code>&amp;m</code> 呢？</p><p>首先 <code>m</code> 的类型是 <code>MyBox&lt;String&gt;</code>，那么 <code>&amp;m</code> 的类型就是 <code>&amp;MyBox&lt;String&gt;</code>，由于 <code>MyBox</code> 实现了 <code>Deref</code> 方法，因此 Rust 可以调用 <code>deref()</code> 方法，来将 <code>MyBox&lt;String&gt;</code> 的引用转化成 <code>String</code> 的引用。然而在标准库中，<code>String</code> 也实现了 <code>Deref</code> 这个 trait，它返回的是一个字符串切片 <code>&amp;str</code>，因此 Rust 会继续调用 <code>deref()</code>，最终返回一个字符串切片的类型。</p><p>而如果 Rust 没有解引用转化功能，则参数应该这样传：<code>hello(&amp;(*m)[..]);</code>，而这却相当繁琐。只要类型实现了 <code>Deref</code> 这个 trait，Rust 就会自动分析类型，并不断尝试调用 <code>deref()</code> 方法来让其与函数或方法签名中的参数类型匹配，而这一切都在编译时执行，因此运行时不会产生额外的性能开销。</p><p><strong>解引用与可变性</strong></p><ul><li>可使用 <code>DerefMut trait</code> 重载可变引用的 <code>*</code> 运算符</li><li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion<ul><li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code>（即类型 <code>T</code> 实现了 <code>Deref trait</code>，而 <code>deref</code> 方法返回的类型是 <code>U</code>，那么 <code>T</code> 的引用可以转化为 <code>U</code> 的引用）</li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code>（反过来不成立，即不能将不可变引用转化为可变引用，违反借用规则）</li></ul></li></ul><h2 id="四、Drop-trait"><a href="#四、Drop-trait" class="headerlink" title="四、Drop trait"></a>四、Drop trait</h2><ul><li>实现 <code>Drop trait</code>，可以让我们自定义<strong>当值将要离开作用域的时候发生的动作</strong><ul><li>例如文件、网络资源的释放等</li><li>任何类型都可以实现 <code>Drop trait</code></li></ul></li><li><code>Drop trait</code> 只要求实现 <code>drop</code> 方法，其参数是对 <code>self</code> 的可变引用</li><li><code>Drop trait</code> 在预导入模块中，无需手动导入</li></ul><p>（个人理解：和 C++ 中的析构函数有点类似）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为如下，注意输出顺序（变量声明顺序为 s1，s2，Drop 顺序为 s2，s1）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br></pre></td></tr></table></figure><p>使用 <code>std::mem::drop</code> 来提前 drop 值</p><ul><li>很难直接禁用自动的 drop 功能，也没必要</li><li>Drop trait 的目的就是进行自动的释放处理逻辑</li><li>Rust 不允许手动调用 Drop trait 的 drop 方法</li><li>若要强行使用 <code>a.drop()</code> 这样来调用，会提示 <code>explicit destructor calls not allowed</code>，然后后面给的帮助是考虑使用 <code>drop(a)</code></li><li>但可以调用标准库中的 <code>std::mem::drop</code> 函数提前 <code>drop</code> 值</li></ul><p>我们手动 <code>drop</code> 一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>)&#125;;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = CustomSmartPointer &#123;data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;vscode&quot;</span>)&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.23</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">Dropping CustomSmartPointer with data `Rust`</span><br><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `vscode`</span><br></pre></td></tr></table></figure><p>尽管手动调用了 <code>drop</code> 函数，但是和 <code>drop</code> 方法并不会冲突，不会重复释放同一块内存，设计 Rust 语言的时候显然已经考虑到了这一点。</p><h2 id="五、Rc-lt-T-gt-：引用计数智能指针"><a href="#五、Rc-lt-T-gt-：引用计数智能指针" class="headerlink" title="五、Rc&lt;T&gt;：引用计数智能指针"></a>五、Rc&lt;T&gt;：引用计数智能指针</h2><p>通常情况下，Rust 的所有权都是很清晰的，但是在某些场景中，单个值可能同时被多个所有者持有。例如一个图的数据结构，一个结点有多条边相连，那么这个结点就应该属于所有与其相连的边，只有当所有指向它的边都释放掉，该结点才会被清理，这就是多重所有权。</p><p>在 Rust 中，为了支持多重所有权，便有了 <code>Rc&lt;T&gt;</code>，即 <code>reference count（引用计数）</code>，这个类型会在实例的内部维护一个用于记录引用次数的计数器，从而判断该值是否仍然被使用，可以追踪所有对其的引用。若引用个数为 0，那么该值就会被清理掉，不会发生引用失效的问题。</p><h3 id="5-1-使用场景及实例"><a href="#5-1-使用场景及实例" class="headerlink" title="5.1 使用场景及实例"></a>5.1 使用场景及实例</h3><ul><li>需要在 heap 上分配数据，这写数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据</li><li>若在编译时能够确定哪个部分最后使用完这些数据，那么直接将这个部分程序成为这些数据的所有者即可，这样就只需要靠编译时期所有权规则，就可以保证程序的正确性</li><li><code>Rc&lt;T&gt;</code> 只能用于单线程场景，后面会介绍如何在多线程场景中使用引用计数</li><li><code>Rc&lt;T&gt;</code> 不在预导入模块中，需要手动导入 <code>use sstd::rc::Rc</code></li><li><code>Rc::clone(&amp;a)</code> 函数：增加引用计数</li><li><code>Rc::strong_count(&amp;a)</code>：获得引用计数</li><li>还有 <code>Rc::weak_count</code>函数</li></ul><p>例子如下：</p><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220709214558.png" alt="两个List共享所有权"></p><p>要实现两个 List 共享一个 List 的所有权。先看下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明变量 c 处，会报错，提示不能使用被移动的值 <code>use of moved value: &#39;a&#39;</code>。因为在声明 b 时，变量 a 的所有权已经移交给了 b。我们可以改变 <code>Cons</code> 的定义，让其持有 <code>List</code> 的引用而不是所有权，并为其指定声明周期参数，这个生命周期要求 <code>List</code> 中的所有元素的存活时间至少要和 <code>List</code> 本身一样。因此借用检查器会阻止我们编译这样的代码：<code>let a = Cons(1, &amp;Nil)</code>，因为这里 <code>Nil</code> 这个变体值会在 <code>a</code> 取得其引用前就被丢弃。</p><p>另一种办法就是将 <code>Box</code> 换成 <code>Rc</code>。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 a 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;创建 b 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;创建 c 后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c 离开作用域后的的强引用计数为 &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出结果为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/my_box git:(master) ✗ cargo run</span><br><span class="line">   Compiling my_box v0.<span class="number">1.0</span> (/home/cherry/code/rust/my_box)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running `target/debug/my_box`</span><br><span class="line">创建 a 后的的强引用计数为 <span class="number">1</span></span><br><span class="line">创建 b 后的的强引用计数为 <span class="number">2</span></span><br><span class="line">创建 c 后的的强引用计数为 <span class="number">3</span></span><br><span class="line">c 离开作用域后的的强引用计数为 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其实在 <code>Rc&lt;T&gt;</code> 这个类型上也有一个 <code>clone</code> 方法，和 <code>Rc::clone()</code> 的区别是，后者不会对数据进行深拷贝，只会增加引用计数，速度较快。而前者是类型上的 <code>clone</code> 方法，会进行深拷贝，拷贝对象本身，比较耗时。同时 <code>Rc&lt;T&gt;</code> 也实现了 <code>Drop</code> 这个 trait，因此当变量离开作用域时，引用计数会自动减少一。</p><p>在 <code>Rc&lt;T&gt;</code> 中，通过不可变引用，使你在程序不同部分之间共享只读数据，若共享的引用可变，将会违反 Rust 的借用规则，即多个指向同一区域的可变引用会导致数据竞争以及数据的不一致。但是在某些情况下，让其共享的数据可变也是非常重要的，这就需要使用 <code>RefCell&lt;T&gt;</code>。</p><h3 id="5-2-RefCell-lt-T-gt-和内部可变性"><a href="#5-2-RefCell-lt-T-gt-和内部可变性" class="headerlink" title="5.2 RefCell&lt;T&gt; 和内部可变性"></a>5.2 RefCell&lt;T&gt; 和内部可变性</h3><p>内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改，数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则，使其可变的借用一个不可变的值。</p><p>先来回忆一下 Rust 的借用规则：在任何给定的时刻，要么只能拥有一个可变的引用，要么只能拥有任意数量的不可变引用，且引用总是有效的。</p><p>与 <code>Rc&lt;T&gt;</code> 不同，<code>RefCell&lt;T&gt;</code> 类型代表了其持有数据的唯一所有权。而 <code>RefCell&lt;T&gt;</code> 与 <code>Box&lt;T&gt;</code> 的区别是：前者只会在<strong>运行时</strong>检查借用规则，否则触发 panic；而后者在编译阶段就要强制代码遵守借用规则，否则出现错误，编译不通过。</p><p><strong>借用规则在不同阶段进行检查的比较</strong></p><ul><li>编译阶段<ul><li>尽早暴露问题</li><li>没有运行时的开销</li><li>对大多数场景是最佳选择</li><li>是 Rust 的默认行为</li></ul></li><li>运行时<ul><li>问题暴露延迟，甚至到生产环境</li><li>因为借用计数器而导致性能的损失</li><li>实现某些特定的内存安全场景（不可变环境中修改自身数据）</li></ul></li></ul><p>实际上 Rust 编译器是比较保守的，有些代码并不是在编译阶段就能分析明白，针对这些代码，Rust 编译器是无法完成分析的，因此编译器就会简单的拒绝所有不符合所有权规则的代码，哪怕这些代码并没有任何问题，这就是 Rust 编译器的保守性。因为一旦 Rust 将某一段有问题的程序通过了，那么 Rust 对安全性的保证将直接破产，尽管拒绝掉某些正确的代码会对开发者带来不便，但是至少不会在生产中带来灾难性的后果。针对 Rust 编译器无法分析的代码，如果开发者能够确保代码能够满足借用规则，这时候就要用到 <code>RefCell&lt;T&gt;</code> 了。</p><p>和 <code>Rc&lt;T&gt;</code> 一样 <code>RefCell&lt;T&gt;</code> 只能用于单线程的场景。</p><ul><li><code>Box&lt;T&gt;</code><ul><li>同一个数据只有一个所有者</li><li>可变和不可变借用，在编译时检查</li></ul></li><li><code>Rc&lt;T&gt;</code><ul><li>同一个数据可以有多个所有者</li><li>不可变借用，在编译时检查</li></ul></li><li><code>RefCell&lt;T&gt;</code><ul><li>同一个数据只有一个所有者</li><li>可变和不可变借用，在运行时检查</li><li>其中，即使 <code>RefCell&lt;T&gt;</code> 本身不可变，但是仍能修改其中存储的值</li></ul></li></ul><p>对于内部可变性，可以可变的借用一个不可变的值。在某些情况下，我们需要一个值，它对外部是不可变的，但能在方法内部修改自身的值，除了这个值本身的方法，其他的方法都不能修改这个值，<code>RefCell&lt;T&gt;</code> 正是获得这种内部可变性的一种方法。但是这种方法并没有完全绕开借用规则，只是通过内部可变性通过了编译检查，但是借用检查也只是从编译阶段延后到运行阶段，如果运行阶段仍然违反了借用规则，那么将会 panic，而不是编译错误。</p><p><strong>使用 <code>RefCell&lt;T&gt;</code> 在运行时记录借用信息</strong></p><ul><li><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针：<ul><li>每次调用 borrow：不可变借用计数加1</li><li>任何一个 <code>Ref&lt;T&gt;</code> 的值离开作用域被释放时：不可变借用计数减 1</li><li>每次调用 <code>borrow_mut</code>：可变借用计数加1</li><li>任何一个 <code>RefMut&lt;T&gt;</code> 的值离开作用域被释放时：可变借用计数减 1</li></ul></li><li>以此技术来维护借用检查规则：<ul><li>任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</li></ul></li></ul><p><strong>其它可实现内部可变性的类型</strong></p><ul><li><code>Cell&lt;T&gt;</code>：通过复制来访问数据</li><li><code>Mutex&lt;T&gt;</code>：用于实现跨线程情形下的内部可变性模式</li></ul><h2 id="六、循环引用导致内存泄露"><a href="#六、循环引用导致内存泄露" class="headerlink" title="六、循环引用导致内存泄露"></a>六、循环引用导致内存泄露</h2><h3 id="6-1-Rust-可能发生内存泄漏"><a href="#6-1-Rust-可能发生内存泄漏" class="headerlink" title="6.1 Rust 可能发生内存泄漏"></a>6.1 Rust 可能发生内存泄漏</h3><ul><li>Rust 的内存安全机制可以保证很难发生内存泄漏，但不是不可能</li><li>例如使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 就可能创造出循环引用，从而发生内存泄漏：<ul><li>每个项的引用数量不会变成 0，值也不会被处理掉</li></ul></li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;rc::Rc, cell::RefCell&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test02</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item is &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item is &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a is &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!(&quot;a next item is &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 <code>a</code>，<code>Cons</code> 第一个元素是 5，第二个元素是 <code>Nil</code>，然后输出 a 的强引用，输出 a 的 <code>Cons</code> 的第二个元素。同理创建 b，<code>Cons</code> 第一个元素是 10，第二个元素引用 a，然后输出此时 a 的强引用和 b 的强引用。</p><p>这个时候将 a 的 Cons 第二个元素改成 b 的引用，即这个 List 的 a 和 b 收尾相连了，形成了一个类似于循环链表的结构。这时我们观察输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.25</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">a initial rc count is <span class="number">1</span></span><br><span class="line">a next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation is <span class="number">2</span></span><br><span class="line">b initial rc count is <span class="number">1</span></span><br><span class="line">b next item is <span class="title function_ invoke__">Some</span>(RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">a rc count after changing a is <span class="number">2</span></span><br><span class="line">b rc count after changing a is <span class="number">2</span></span><br></pre></td></tr></table></figure><p>收尾相连后 a 和 b 的强引用计数都是 2（很显然）。但是这个时候如果要输出 a 的下一个元素，就会发生栈溢出。因为 a 和 b 形成了循环，a 的下一个元素是 b，但是 b 中又包含 a，a 中又包含 b… 如此往复，b 的大小其实是无穷大的，因此会导致<strong>栈溢出</strong>。取消上面的注释行，再次运行，会得到下面的结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell &#123; value: <span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell &#123; </span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; has overflowed its stack</span><br><span class="line">fatal runtime error: stack overflow</span><br><span class="line">[<span class="number">1</span>]    <span class="number">28287</span> abort      cargo run</span><br></pre></td></tr></table></figure><h3 id="6-2-防止内存泄漏的解决办法"><a href="#6-2-防止内存泄漏的解决办法" class="headerlink" title="6.2 防止内存泄漏的解决办法"></a>6.2 防止内存泄漏的解决办法</h3><ul><li>依靠开发者来保证，不能依靠 Rust</li><li>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权<ul><li>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</li><li>而只有所有权关系才影响值的清理</li></ul></li></ul><p><strong>防止循环引用把 <code>Rc&lt;T&gt;</code> 换成 <code>Weak&lt;T&gt;</code></strong></p><ul><li><code>Rc::clone</code> 为 <code>Rc&lt;T&gt;</code> 实例的 strong_count 加 1，<code>Rc&lt;T&gt;</code> 的实例只有在 strong_count 为 0 的时候才会被清理</li><li><code>Rc&lt;T&gt;</code> 实例通过调用 <code>Rc::downgrade</code> 方法可以创建值的 Weak Reference（弱引用）<ul><li>返回类型是 <code>Weak&lt;T&gt;</code>（智能指针）</li><li>调用 <code>Rc::downgrade</code> 会为 weak_count 加1</li></ul></li><li><code>Rc&lt;T&gt;</code> 使用 weak_count 来追踪存在多少 <code>Weak&lt;T&gt;</code></li><li>weak_count 不为 0 并不影响 <code>Rc&lt;T&gt;</code> 实例的清理</li></ul><p><strong>Strong vs Weak</strong></p><ul><li>Strong Reference（强引用）是关于如何分享 <code>Rc&lt;T&gt;</code> 实例的所有权</li><li>Weak Reference（弱引用）并不表达上述意思</li><li>使用 Weak Reference 并不会创建循环引用：<ul><li>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</li></ul></li><li>在使用 <code>Weak&lt;T&gt;</code> 前，需保证它指向的值仍然存在：<ul><li>在 <code>Weak&lt;T&gt;</code> 实例上调用 <code>upgrade</code> 方法，返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code></li></ul></li></ul><h3 id="6-3-实现树的数据结构的例子"><a href="#6-3-实现树的数据结构的例子" class="headerlink" title="6.3 实现树的数据结构的例子"></a>6.3 实现树的数据结构的例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个叶子结点值为 3，该叶子结点没有孩子结点，再创建一个分支结点，作为叶节点 3 的父节点。此时该叶子结点拥有两个强引用，即叶子结点本身和父节点拥有该叶子结点的所有权。我们可以通过分支结点访问到叶节点，因为他拥有叶节点的引用（这里也是所有权），而叶子结点无法访问到父节点，因为他没有拥有父节点的所有权或引用。</p><p>上面这种双向的引用形成了循环引用，这个时候就可以使用 <code>Weak&lt;T&gt;</code> 来避免产生循环引用。</p><p>我们修改上面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)])</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 leaf 的 parent 字段的 <code>borrow</code> 方法获取其不可变引用，然后通过 <code>upgrade</code> 方法将 <code>Weak&lt;T&gt;</code> 转化成 <code>Rc&lt;T&gt;</code>，然后再调用 leaf 的 parent 字段的 <code>borrow_mut</code> 方法获取其可变引用，然后通过调用 <code>Rc::downgrade</code> 将 branch 里的 <code>Rc&lt;Node&gt;</code> 转化成 <code>Weak&lt;Node&gt;</code> 并存在 leaf.parent 里。</p><p>输出结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf parent is <span class="title function_ invoke__">Some</span>(Node &#123; value: <span class="number">5</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: <span class="number">3</span>, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure><p>我们通过分别打印 leaf 和 branch 的强弱引用来深入理解一下本小节内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent is &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  smart_pointer git:(master) ✗ cargo run</span><br><span class="line">   Compiling smart_pointer v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/smart_pointer)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.35</span>s</span><br><span class="line">     Running `target/debug/smart_pointer`</span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br><span class="line">leaf strong = <span class="number">2</span>, weak = <span class="number">0</span></span><br><span class="line">branch strong = <span class="number">1</span>, weak = <span class="number">1</span></span><br><span class="line">leaf parent is <span class="literal">None</span></span><br><span class="line">leaf strong = <span class="number">1</span>, weak = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>刚创建 leaf 时，只有一个 leaf 的强引用，没有弱引用。然后在一个新的作用域内创建 branch，将 branch 和 leaf 关联起来，此时 branch 强引用只有一个（branch 自身），弱引用有一个（leaf）。leaf 强引用有两个，自身和 branch。然后 branch 走出了作用域，强引用计数减 1 变成 0，内存被释放，branch 便不存在了，此时通过 leaf 访问 branch 显然为 None，最后再输出 leaf 的强引用为 1，即 leaf 自身。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;指针是指向一个变量在内存中的地址，在 Rust 中最常见的指针就是引用 &lt;code&gt;&amp;amp;&lt;/code&gt; 了，没有其他开销。&lt;br&gt;智能指针：引用计数智能指针。该智能指针允许你同时拥有同一个数据的多个所有权，它会跟踪每一个所有者并进行计数，当所有的所有者都归还后，该智能指针及指向的数据将自动被清理释放。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十二）：cargo 和 crates.io</title>
    <link href="https://cherryyang05.github.io/hexo-blog/af9cf945.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/af9cf945.html</id>
    <published>2022-07-08T16:50:09.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章内容如下：</p><ul><li>通过 release profle 来自定义构建</li><li>在 <a href="https://crates.io/">https://crates.io/</a> 上发布库</li><li>通过 workspaces 组织大工程</li><li>从 <a href="https://crates.io/">https://crates.io/</a> 来安装库</li><li>使用自定义命令扩展 cargo</li></ul></blockquote><span id="more"></span><h2 id="一、通过-release-profle-来自定义构建"><a href="#一、通过-release-profle-来自定义构建" class="headerlink" title="一、通过 release profle 来自定义构建"></a>一、通过 release profle 来自定义构建</h2><p><strong>release profile（发布配置）</strong></p><ul><li>是预定义的</li><li>可自定义：可使用不同的配置，对代码编译拥有更多的控制</li><li>每个 profile 的配置都独立于其它的 profile</li><li>Cargo 主要的两个 profile<ul><li>dev profile：适用于开发，cargo build</li><li>release profile：适用于发布，cargo build –release</li></ul></li></ul><p><strong>自定义 profile</strong></p><ul><li>针对每个 profle，Cargo 都提供了默认的配置</li><li>如果想自定义 xxxx profile 的配置<ul><li>可以在 Cargo.toml 里添加 <code>[profile.xxxx]</code> 区域，在里面覆盖默认配置的子集</li></ul></li></ul><p>例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[profile. dev]</span><br><span class="line">opt-level = <span class="number">0</span></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>opt-level</code> 表示编译优化等级，在开发模式下，一般希望有较快的编译速度，因此编译优化等级较低。而在发布模式下，需要多次运行程序，因此希望有较高等级的优化，从而用较长的编译时间换取较短的运行时间。</p><p>对于每个配置的默认值和完整选项，请参见：<a href="https://doc.rustlang.ora/cargo/">https://doc.rustlang.ora/cargo/</a></p><h2 id="二、发布-crate-到-crates-io"><a href="#二、发布-crate-到-crates-io" class="headerlink" title="二、发布 crate 到 crates.io"></a>二、发布 crate 到 crates.io</h2><h3 id="2-1-crates-io"><a href="#2-1-crates-io" class="headerlink" title="2.1 crates.io"></a>2.1 crates.io</h3><ul><li>可以通过发布包来共享你的代码</li><li>crate 的注册表在 <a href="https://crates.io/">https://crates.io/</a></li><li>它会分发己注册的包的源代码</li><li>主要托管开源的代码</li></ul><h3 id="2-2-文档注释"><a href="#2-2-文档注释" class="headerlink" title="2.2 文档注释"></a>2.2 文档注释</h3><h4 id="2-2-1-文档注释的使用"><a href="#2-2-1-文档注释的使用" class="headerlink" title="2.2.1 文档注释的使用"></a>2.2.1 文档注释的使用</h4><ul><li>文档注释：用于生成文档<ul><li>生成 HTML 文档</li><li>显式公共 API 的文档注释：如何使用 API</li><li>使用 <code>///</code></li><li>支持 Markdown</li><li>放置在被说明条目之前</li></ul></li></ul><p>例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 这个函数是将传入的 u32 类型的值加一，然后返回这个值的所有权</span></span><br><span class="line"><span class="comment">/// # 实例</span></span><br><span class="line"><span class="comment">/// let a = 3;</span></span><br><span class="line"><span class="comment">/// let b = add_one(a);</span></span><br><span class="line"><span class="comment">/// assert_eq!(4, b);</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(num: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    num + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-生成-HTML-文档的命令"><a href="#2-2-2-生成-HTML-文档的命令" class="headerlink" title="2.2.2 生成 HTML 文档的命令"></a>2.2.2 生成 HTML 文档的命令</h4><p><code>cargo doc</code></p><ul><li>它会运行 rustdoc 工具（Rust 安装包自带）</li><li>把生成的 HTML 文档放在 target&#x2F;doc 目录下</li></ul><p><code>cargo doc --open</code></p><ul><li>构建当前 crate 的文档（也包含 crate 依赖项的文档）</li><li>在浏览器打开文档</li></ul><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808150051.png" alt="Rust Doc"></p><h4 id="2-2-3-常用章节"><a href="#2-2-3-常用章节" class="headerlink" title="2.2.3 常用章节"></a>2.2.3 常用章节</h4><ul><li>＃ Examples</li><li>其它常用的章节<ul><li>Panics：函数可能发生 panic 的场景</li><li>Errors：如果函数返回 Result，描述可能的错误种类，以及可导致错误的条件</li><li>Safety：如果函数处于 unsafe 调用，就应该解释函数 unsafe 的原因，以及调用者确保的使用前提</li></ul></li></ul><h4 id="2-2-4-文档注释作为测试"><a href="#2-2-4-文档注释作为测试" class="headerlink" title="2.2.4 文档注释作为测试"></a>2.2.4 文档注释作为测试</h4><ul><li>示例代码块的附加值：<ul><li>运行 cargo test：将把文档注释中的示例代码作为测试来运行</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo test</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.18</span>s</span><br><span class="line">     Running unittests src/lib.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-d31f5191c1eed090)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running unittests src/main.<span class="title function_ invoke__">rs</span> (target/debug/deps/it-<span class="number">8</span>c2dc60df354a71a)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests it</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test src/lib.rs - <span class="title function_ invoke__">add_one</span> (line <span class="number">3</span>) ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.16</span>s</span><br></pre></td></tr></table></figure><h4 id="2-2-5-为包含注释的项添加文档注释"><a href="#2-2-5-为包含注释的项添加文档注释" class="headerlink" title="2.2.5 为包含注释的项添加文档注释"></a>2.2.5 为包含注释的项添加文档注释</h4><ul><li>符号：<code>//!</code></li><li>这类注释通常用描述 crate 和模块：<ul><li>crate root（按惯例 src&#x2F;lib.rs)</li><li>一个模块内，将 crate 或模块作为一个整体进行记录</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808151624.png" alt="Rust Doc"></p><h3 id="2-3-pub-use"><a href="#2-3-pub-use" class="headerlink" title="2.3 pub use"></a>2.3 pub use</h3><p><strong>使用 pub use 导出方便使用的公共 API</strong></p><ul><li>问题：crate 的程序结构在开发时对于开发者很合理，但对于它的使用者不够方便<ul><li>开发者会把程序结构分为很多层，使用者想找到这种深层结构中的某个类型很费劲</li></ul></li><li>例如<ul><li>麻烦：my_crate::some_module::another_module::UsefulType；</li><li>方便：my_crate::UsefulType</li></ul></li><li>解决办法<ul><li>不需要重新组织内部代码结构</li><li>使用 pub use：可以重新导出，创建一个与内部私有结构不同的对外公共结构</li></ul></li></ul><p><code>main.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> pubuse::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> pubuse::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = PrimaryColor::Blue;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = <span class="title function_ invoke__">mix</span>(c1, c2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The mixed color is &#123;:?&#125;&quot;</span>, c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lib.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 这是测试 pub use 使用的 crate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// 色彩三原色：红黄蓝</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 两种颜色混合后的颜色</span></span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 将红黄蓝中任意两种颜色混合</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://raw.githubusercontent.com/CherryYang05/PicGo-image/master/images/20220808163422.png" alt="pub use Doc"></p><p>我们从生成的文档看出，就将很深层的函数提到了 crate 的外层，方便用户查看和调用。</p><h3 id="2-4-发布-crate"><a href="#2-4-发布-crate" class="headerlink" title="2.4 发布 crate"></a>2.4 发布 crate</h3><ul><li>创建并设置 crates.io 账号</li><li>发布 crate 前，需要在 crates.io 创建账号并获得 API token</li><li>运行命令：<code>cargo login</code> [你的API token]<ul><li>通知 cargo，你的 API token 存储在本地 <code>~/.cargo/credentials</code></li></ul></li><li>API token 可以在 <a href="https://crates.io/">https://crates.io/</a> 进行撤销</li></ul><p><strong>为新的 crate 添加元数据</strong></p><ul><li>在发布 crate 之前，需要在 Cargo.toml 的 Ipackage] 区域为 crate 添加一些元数据：<ul><li>crate 需要唯一的名称：name</li><li>description：一两句话即可，会出现在 crate 搜索的结果里</li><li>license：需提供许可证标识值（可到 <a href="http://spdk.org/licenses/">http://spdk.org/licenses/</a> 查找）</li><li>可指定多个 license：用 OR</li><li>version</li><li>author</li></ul></li><li>发布：<code>cargo publish</code> 命令</li></ul><p><strong>发布到 crates.io</strong></p><ul><li>crate一旦发布，就是永久性的：该版本无法覆盖，代码无法删除</li><li>目的：依赖于该版本的项目可继续正常工作</li></ul><p><strong>发布己存在 crate 的新版本</strong></p><ul><li>修改 crate 后，需要先修改 Cargo.toml 里面的 version 值，再进行重新发布</li><li>参照 htto:&#x2F;&#x2F;semver.orgl 来使用你的语义版本</li></ul><p><strong>使用 cargo yank 从 Crates.io 撤回版本</strong></p><ul><li>不可以删除 crate 之前的版本</li><li>但可以防止其它项目把它作为新的依赖：yank（撤回）一个 crate 版本<ul><li>防止新项目依赖于该版本</li><li>己经存在项目可继续将其作为依赖（并可下载）</li></ul></li><li>yank 意味着：<ul><li>所有己经产生 Cargo.lock 的项目都不会中断</li><li>任何将来生成的 Cargo.lock 文件都不会使用被 yank 的版本。</li></ul></li><li>命令：<ul><li>yank 一个版本（不会删除任何代码）：<code>cargo yank -vers 1.0.1</code></li></ul></li></ul><h3 id="2-5-cargo-工作空间"><a href="#2-5-cargo-工作空间" class="headerlink" title="2.5 cargo 工作空间"></a>2.5 cargo 工作空间</h3><h4 id="2-5-1-创建工作空间"><a href="#2-5-1-创建工作空间" class="headerlink" title="2.5.1 创建工作空间"></a>2.5.1 创建工作空间</h4><p>随着项目越来越大，代码也会越来越臃肿，这时就需要将 crate 拆分成多个包，cargo 便提供了<strong>工作空间</strong>这个功能。</p><ul><li>cargo 工作空间：帮助管理多个相互关联且需要协同开发的 crate</li><li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li></ul><p><strong>创建工作空间</strong></p><ul><li>有多种方式来组建工作空间例：1 个二进制 crate，2 个库 crate<ul><li>二进制 crate：main 函数，依赖于其它2个库 crate</li><li>其中1个库 crate 提供 addLone 函数</li><li>另外1个库 crate 提供 add_two 函数</li></ul></li></ul><p><strong>在工作空间中依赖外部 crate</strong></p><ul><li>工作空间只有一个 Cargo.lock 文件，在工作空间的顶层目录<ul><li>保证工作空间内所有 crate 使用的依赖的版本都相同</li><li>工作空间内所有 crate 相互兼容</li></ul></li></ul><p>参数 <code>-p</code> 可以指定某个 crate 构建、运行或测试。例如 <code>cargo test -p add-one</code>。<br>发布的时候需要手动进入每个 crate 逐个发布。</p><p>以上内容参考<a href="https://www.bilibili.com/video/BV1hp4y1k7SV?p=83&spm_id_from=pageDriver&vd_source=cd979f5b9cea5f03bd91461762cdd74c">视频</a>，未做具体记录。</p><h3 id="2-6-安装二进制-crate"><a href="#2-6-安装二进制-crate" class="headerlink" title="2.6 安装二进制 crate"></a>2.6 安装二进制 crate</h3><p><strong>从 CRATES.IO 安装二进制 crate</strong></p><ul><li>命令：cargo install</li><li>来源： <a href="https://crates.io/">https://crates.io</a></li><li>限制：只能安装具有二进制目标 (binary target）的 crate</li><li>二进制目标 binary target：是一个可运行程序<ul><li>由拥有 src&#x2F;main.rs 或其它被指定为二进制文件的 crate 生成</li></ul></li><li>通常：README 里有关于 crate 的描述：<ul><li>拥有 library target</li><li>拥有 binary target</li><li>两者兼备</li></ul></li></ul><p><strong>cargo install</strong></p><ul><li>cargo install 安装的二进制存放在根目录的 bin 文件夹</li><li>如果你用 rustup 安装的 Rust，没有任何自定义配置，那么二进制存放目录是 <code>$HOME/.cargo/bin</code><ul><li>要确保该目录在环境变量 ＄PATH 中</li></ul></li></ul><p><strong>使用自定义命令扩展 cargo</strong></p><ul><li>cargo 被设计成可以使用子命令来扩展</li><li>例：如果＄PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行：<ul><li>cargo something</li></ul></li><li>类似这样的自定义命令可以通过该命令列出：cargo –list</li><li>优点：可使用 cargo install 来安装扩展，像内置工具一样来运行</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 release profle 来自定义构建&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&quot;https://crates.io/&quot;&gt;https://crates.io/&lt;/a&gt; 上发布库&lt;/li&gt;
&lt;li&gt;通过 workspaces 组织大工程&lt;/li&gt;
&lt;li&gt;从 &lt;a href=&quot;https://crates.io/&quot;&gt;https://crates.io/&lt;/a&gt; 来安装库&lt;/li&gt;
&lt;li&gt;使用自定义命令扩展 cargo&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十一）：闭包和迭代器</title>
    <link href="https://cherryyang05.github.io/hexo-blog/1b9cba25.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/1b9cba25.html</id>
    <published>2022-07-08T16:49:31.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。<br>函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点</p></blockquote><span id="more"></span><h2 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h2><h3 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a>1.1 什么是闭包</h3><ul><li>是匿名函数</li><li>保存为变量、作为参数</li><li>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li><li>可从其定义的作用域捕获值</li></ul><h3 id="1-2-例子：生成自定义运动计划的程序"><a href="#1-2-例子：生成自定义运动计划的程序" class="headerlink" title="1.2 例子：生成自定义运动计划的程序"></a>1.2 例子：生成自定义运动计划的程序</h3><ul><li>该算法的逻辑并不是重点，重点是算法中的计算过程需要几秒钟时间。</li><li>目标：不让用户发生不必要的等待<ul><li>仅在必要时调用该算法</li></ul></li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用函数 <code>simulated_expensive_calculation</code> 模拟复杂的计算，我们不希望调用多次该函数，因为非常耗时，对用户不友好，因此首先想出的优化方案就是用一个变量接收该函数值，当 <code>generate_workout</code> 进入条件语句时，便只需要执行一次即可，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity);</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, res);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这样又会产生一个新的问题：当进入 <code>else</code> 时，随机数值为 3 的时候，是无需执行复杂计算的，这时候用一个变量接收该复杂计算的函数值便会显得浪费。我们真正希望的是，函数定义单独在一个地方，等到函数真正被用到时再被执行，这就是闭包的功能。代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>expensive_closure</code> 只是定义了一个匿名函数，并没有执行。当然在条件语句中，该闭包还是执行了两次，对于这里的优化，后面会讲到。</p><h3 id="1-3-闭包的类型推断和标注"><a href="#1-3-闭包的类型推断和标注" class="headerlink" title="1.3 闭包的类型推断和标注"></a>1.3 闭包的类型推断和标注</h3><ul><li>闭包不要求标注参数和返回值的类型，和函数不同，无需对外暴露接口</li><li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li><li>可以手动添加类型标注</li><li>注意：闭包的定义最终只会为参数&#x2F;返回值推断出唯一具体的类型</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(Hello));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>变量 <code>s</code> 传给该闭包一个字符串类型，编译器便推断出来闭包中参数 <code>x</code> 是字符串类型，便与其绑定，因此变量 <code>a</code> 再传入一个整型便会报错。</p><h3 id="1-4-使用泛型参数和-Fn-Trait-来存储闭包"><a href="#1-4-使用泛型参数和-Fn-Trait-来存储闭包" class="headerlink" title="1.4 使用泛型参数和 Fn Trait 来存储闭包"></a>1.4 使用泛型参数和 Fn Trait 来存储闭包</h3><h4 id="1-4-1-继续解决-1-2-中的例子"><a href="#1-4-1-继续解决-1-2-中的例子" class="headerlink" title="1.4.1 继续解决 1.2 中的例子"></a>1.4.1 继续解决 1.2 中的例子</h4><p>除了创建局部变量存储闭包的值，还有另一种解决方案：</p><p>创建一个 struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果。<br>这个模式通常叫做<strong>记忆化（memoization）</strong>或<strong>延迟计算（lazy evaluation）</strong></p><p><strong>如何让 struct 持有闭包</strong></p><ul><li>struct 的定义需要知道所有字段的类型<ul><li>需要指明闭包的类型</li></ul></li><li>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</li><li>所以需要使用：泛型和 Trait Bound（第10章）</li></ul><p><strong>Fn Trait</strong></p><ul><li>Fn traits 由标准库提供</li><li>所有的闭包都至少实现了以下 trait 之一：<ul><li>Fn</li><li>FnMut</li><li>FnOnce</li></ul></li></ul><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    calculation: F,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F&gt; Cacher&lt;F&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: F) <span class="punctuation">-&gt;</span> Cacher&lt;F&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一个结构体，该结构体泛型参数要实现 Fn trait，然后为该结构体实现 <code>new</code> 和 <code>value</code> 函数（方法），如果已经执行过该闭包，则返回值，若没有执行过则执行闭包，将值存进结构体变量中。<code>generate_workout</code> 函数实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_closure</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>, expensive_closure.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-使用缓存器（Cacher）实现的限制"><a href="#1-4-2-使用缓存器（Cacher）实现的限制" class="headerlink" title="1.4.2 使用缓存器（Cacher）实现的限制"></a>1.4.2 使用缓存器（Cacher）实现的限制</h4><ol><li>Cacher 实例假定针对不同的参数 arg，value 方法总会得到同样的值<ul><li>可以使用 HashMap 代替单个值：<ul><li>key: arg 参数</li><li>value：执行闭包的结果</li></ul></li></ul></li><li>只能接收一个 u32 类型的参数和 u32 类型的返回值<ul><li>引入两个或多个泛型参数</li></ul></li></ol><h3 id="1-5-使用闭包捕获环境"><a href="#1-5-使用闭包捕获环境" class="headerlink" title="1.5 使用闭包捕获环境"></a>1.5 使用闭包捕获环境</h3><h4 id="1-5-1-利用闭包捕获环境中的变量"><a href="#1-5-1-利用闭包捕获环境中的变量" class="headerlink" title="1.5.1 利用闭包捕获环境中的变量"></a>1.5.1 利用闭包捕获环境中的变量</h4><p>闭包可以捕获他们所在的环境</p><ul><li>闭包可以访问定义它的作用域内的变量，而普通函数则不能</li><li>会产生额外内存开销</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure><p>上述代码中，闭包内的变量 <code>x</code> 并不是在闭包内定义的，但是却可以访问，因为闭包可以捕获和其在<strong>同一作用域内</strong>的其他变量，而函数却没有这样的作用。</p><p><strong>闭包从所在环境捕获值的方式</strong></p><p>与函数获得参数的三种方式一样：</p><ul><li>取得所有权：<code>FnOnce</code></li><li>可变借用：<code>FnMut</code></li><li>不可变借用： <code>Fn</code></li></ul><p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 frait：</p><ul><li>所有的闭包都实现了 FnOnce</li><li>没有移动捕获变量的实现了 FnMut</li><li>无需可变访问捕获变量的闭包实现了 Fn</li></ul><p>注：实现了 <code>Fn trait</code> 的闭包一定实现了 <code>Fn Mut</code>，实现了 <code>Fn Mut</code> 一定实现了 <code>Fn Once</code>。</p><h4 id="1-5-2-move-关键字"><a href="#1-5-2-move-关键字" class="headerlink" title="1.5.2 move 关键字"></a>1.5.2 move 关键字</h4><p>在参数列表前使用 move 关键字，可以强制闭包取得它所使用的环境值的所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here：&#123;:?&#125;&quot;</span>, x);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br></pre></td></tr></table></figure><p>这里便不能使用 <code>x</code> 变量了。</p><p><strong>最佳实践</strong><br>当指定 Fn trait bound 之一时，首先用 Fn，基于闭包体里的情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你。<br>（面向编译器编程实锤 o_O）</p><h2 id="二、迭代器"><a href="#二、迭代器" class="headerlink" title="二、迭代器"></a>二、迭代器</h2><p><strong>什么是迭代器</strong></p><ul><li>迭代器模式：对一系列项执行某些任务</li><li>迭代器负责：<ul><li>遍历每个项</li><li>确定序列（遍历）何时完成</li></ul></li></ul><p><strong>Rust 的迭代器：</strong></p><ul><li>懒惰的：除非调用消费迭代器的方法，否则迭代器本身没有任何效果。</li></ul><p>先用一个最简单的迭代器的例子来进入本节的学习：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">9</span>, <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> v1_iter &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run   </span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Got: <span class="number">3</span></span><br><span class="line">Got: <span class="number">9</span></span><br><span class="line">Got: <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Iterator-trait-和-next-方法"><a href="#2-1-Iterator-trait-和-next-方法" class="headerlink" title="2.1 Iterator trait 和 next 方法"></a>2.1 Iterator trait 和 next 方法</h3><ul><li>所有迭代器都实现了 Iterator trait</li><li>Iterator trait 定义于标准库，定义大致如下</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">ltem</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::tem&gt;;</span><br><span class="line">        <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type Item 和 Self::Item 定义了与此该 trait 关联的类型<ul><li>实现 Iterator trait 需要你定义一个 Item 类型，它用于 next 方法的返回类型（迭代器的返回类型）</li></ul></li></ul><p><strong>Iterator trait 仅要求实现一个方法：next</strong></p><ul><li>next:<ul><li>每次返回迭代器中的一项</li><li>返回结果包裹在 Some 里</li><li>迭代结束，返回 None</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter_mut</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">9</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter_mut.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">100</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v1_iter_mut.<span class="title function_ invoke__">len</span>());</span><br></pre></td></tr></table></figure><p>上述的例子要定义一个可变的迭代器，因为 <code>next</code> 方法会更改迭代器内部的用来标示顺序的某些值，而上面的 for 之所以不用定义迭代器为可变，是因为用 for 来进行循环，实际上是取得了该迭代器的所有权，在其内部已经将其变成可变的了。</p><p>需要注意的是，next 方法是一种消耗型行为，我们最后输出了迭代器 <code>v1_iter_mut</code> 的长度，结果为 0。</p><p><strong>几个迭代方法</strong></p><ul><li>iter 方法：在不可变引用上创建迭代器</li><li>into_iter 方法：创建的迭代器会获得所有权</li><li>iter_mut 方法：迭代可变的引用</li></ul><h3 id="2-2-消耗-x2F-产生迭代器"><a href="#2-2-消耗-x2F-产生迭代器" class="headerlink" title="2.2 消耗&#x2F;产生迭代器"></a>2.2 消耗&#x2F;产生迭代器</h3><h4 id="2-2-1-消耗迭代器的方法"><a href="#2-2-1-消耗迭代器的方法" class="headerlink" title="2.2.1 消耗迭代器的方法"></a>2.2.1 消耗迭代器的方法</h4><ul><li>在标准库中，Iterator trait 有一些带默认实现的方法</li><li>其中有一些方法会调用 next 方法<ul><li>实现 Iterator frait 时必须实现 nex† 方法的原因之一</li></ul></li><li>调用 next 的方法叫做“消耗型适配器”<ul><li>因为调用它们会把迭代器消耗尽</li></ul></li><li>例如：sum 方法（就会耗尽迭代器）<ul><li>取得迭代器的所有权</li><li>通过反复调用 next，遍历所有元素</li><li>每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test02</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">i32</span> = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>sum</code> 的时候要注意显示声明类型。</p><h4 id="2-2-2-产生其它迭代器的方法-map"><a href="#2-2-2-产生其它迭代器的方法-map" class="headerlink" title="2.2.2 产生其它迭代器的方法(map)"></a>2.2.2 产生其它迭代器的方法(map)</h4><ul><li>定义在 Iterator trait 上的另外一些方法叫做“迭代器适配器”<ul><li>把迭代器转换为不同种类的迭代器</li></ul></li><li>可以通过链式调用使用多个迭代器适配器来执行复杂的操作，这种调用可读性较高。</li><li>例如：map<ul><li>接收一个闭包，闭包作用于每个元素</li><li>产生一个新的迭代器</li></ul></li><li>collect 方法：消耗型适配器，把结果收集到一个集合类型中</li></ul><p>例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test03</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-使用闭包捕获环境-filter"><a href="#2-3-使用闭包捕获环境-filter" class="headerlink" title="2.3 使用闭包捕获环境(filter)"></a>2.3 使用闭包捕获环境(filter)</h3><ul><li>filter 方法：<ul><li>接收一个闭包</li><li>这个闭包在遍历迭代器的每个元素时，返回 bool 类型</li><li>如果闭包返回 true：当前元素将会包含在 filter 产生的迭代器中</li><li>如果闭包返回 false：当前元素将不会包含在 filter 产生的迭代器中</li></ul></li></ul><p>我们现在实现一个功能，取出一个迭代器中所有为偶数的元素，将取出的元素再放入一个新的迭代器，例子如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test04</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">2</span> == <span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点要注意：<code>iter</code> 方法里的元素都是引用类型，且不可变，因此若要进行 <code>x % 2 == 0</code> 操作的话，需要解引用 <code>*x</code>。上述代码中使用 <code>into_iter</code> 方法获得了迭代器中元素的所有权。</p><h3 id="2-4-创建自定义迭代器"><a href="#2-4-创建自定义迭代器" class="headerlink" title="2.4 创建自定义迭代器"></a>2.4 创建自定义迭代器</h3><p><strong>使用 Iterator frait 来创建自定义迭代器</strong></p><ul><li>实现 next 方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123;count: <span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test05</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子很容易理解，就是通过 <code>next</code> 方法不断迭代，范围是 1-5，至于为 Counter 实现 Iterator 特征，将来会介绍。</p><p>下面要对迭代器的需求进行改进，有两个迭代器，第一个迭代器就是上面所说的，第二个迭代器的元素是 <code>[2, 3, 4, 5]</code>，现在要求将两个迭代器中的元素按顺序相乘，然后将结果存入一个新的迭代器，然后过滤出能被 3 整除的数，并求和。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test06</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍一下 <code>zip</code> 方法，这个单词本意是“拉链”，这里表示将两个迭代器“捏到一起”，形成一个新的迭代器，里面的每个元素就是一个元组 ，这个元组里有两个元素，这两个元素分别来自原来的两个迭代器。这里第一个迭代器就是通过 <code>Counter::new()</code> 得到的，第二个迭代器就是 <code>zip()</code> 方法内的参数 <code>Counter::new().skip(1)</code>，表示跳过第一个元素后剩下的元素组成的迭代器。</p><p>为了更好展示每一个方法的实现过程，我们运行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v1);</span><br></pre></td></tr></table></figure><p>对于上例中的两个初始化后的迭代器，输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  it git:(master) ✗ cargo run</span><br><span class="line">   Compiling it v0.<span class="number">1.0</span> (/Users/cherry/Code/Rust/learning/it)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.20</span>s</span><br><span class="line">     Running `target/debug/it`</span><br><span class="line">Zip &#123; a: Counter &#123; count: <span class="number">0</span> &#125;, b: Skip &#123; iter: Counter &#123; count: <span class="number">0</span> &#125;, n: <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>再来看官方文档中的实例就更清楚了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a1</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span> = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = a1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(a2.<span class="title function_ invoke__">iter</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">1</span>, &amp;<span class="number">4</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">2</span>, &amp;<span class="number">5</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>((&amp;<span class="number">3</span>, &amp;<span class="number">6</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><h3 id="2-5-优化第十章的-I-x2F-O-项目"><a href="#2-5-优化第十章的-I-x2F-O-项目" class="headerlink" title="2.5 优化第十章的 I&#x2F;O 项目"></a>2.5 优化第十章的 I&#x2F;O 项目</h3><p>项目具体内容请参考 <a href="Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89.md">Rust入门教程（十）</a></p><h4 id="2-5-1-利用迭代器优化-new-函数"><a href="#2-5-1-利用迭代器优化-new-函数" class="headerlink" title="2.5.1 利用迭代器优化 new 函数"></a>2.5.1 利用迭代器优化 new 函数</h4><p>我们来看一下 <code>minigrep</code> 项目中 <code>Config</code> 函数的 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>new()</code> 函数中，传入的参数是字符串切片，为了返回 <code>Config</code> 结构体，需要获得命令行参数这两个变量的所有权，之前的解决方法是将那两个参数进行克隆，但是这样会对性能带来一定的损耗。现在我们学习完了闭包和迭代器，便可以通过迭代器获取其实例，并且可以使用迭代器所带的一些方法进行长度检查和索引。通过迭代器的 <code>next</code> 方法，便将读取具体值的功能分离了出去。</p><p>原来的 <code>main</code> 函数中，通过 <code>env::args().collect()</code> 将参数列表转化成 vector，然后将这个 vector 传到 <code>new()</code> 函数中，其实 <code>env::args()</code> 返回的就是迭代器，我们直接把它当做 <code>new()</code> 的参数即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改过后的 <code>main</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改过后的 <code>new()</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取要查询的字符串参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(args) =&gt; args,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;无法读取文件名参数&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-利用迭代器优化-search-函数"><a href="#2-5-2-利用迭代器优化-search-函数" class="headerlink" title="2.5.2 利用迭代器优化 search 函数"></a>2.5.2 利用迭代器优化 search 函数</h4><p>原来的 <code>search()</code> 函数实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现思路是先将文本内容每一行取出来，然后手动遍历，判断当前行是否包含所要查询的字符串，将结果放入新的 vector 中，最后返回这个 vector。但是学完了迭代器适配器的知识点后，应该很容易想到 <code>filter</code> 这个方法。实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query)).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 <code>search_case_insensitive</code> 修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    content.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_uppercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query.<span class="title function_ invoke__">to_uppercase</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将原来的七行代码简化成了一行，这一行代码和之前的七行实现的功能是相同的，但是显然利用迭代器实现的这一行代码更加易读（熟悉了迭代器的使用之后，这种写法会非常简单），不仅从代码，减少了临时变量，同时消除了可变状态 <code>result</code>，这样可以使得将来通过并行来提升搜索效率，因为并行时不用再考虑并发访问 <code>result</code> 这个变量时会出现的安全问题了。</p><p>实际上，对于大多数 Rust 程序员会更喜欢使用迭代器这样的方式来实现，因为这样可以更加专注于实现逻辑本身，而不是总是浪费时间在大量的循环和维护临时变量这些细节工作上。至于两者的效率问题，并非像表面上那样，使用迭代器效率会降低，具体的我们下节再介绍。</p><h3 id="2-6-性能比较：循环-vs-迭代器"><a href="#2-6-性能比较：循环-vs-迭代器" class="headerlink" title="2.6 性能比较：循环 vs 迭代器"></a>2.6 性能比较：循环 vs 迭代器</h3><p><strong>零开销抽象 Zero-Cost Abstraction</strong></p><ul><li>使用抽象时不会引入额外的运行时开销</li></ul><p>对于迭代器，编译器会自行判断底层代码展开策略，对于某些特定次数的循环，编译器底层会手动将迭代器展开特定的次数，这样对于流水线 CPU 来说，会减少因跳转或延迟槽产生的停顿周期，使得流水线的吞吐量增大，从而使得效率提高。</p><p>因此在 Rust 中，尽量使用迭代器实现。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数，即可以捕获其所在环境的匿名函数。 可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。&lt;br&gt;函数式编程的特点有：将函数作为参数或者作为其他函数的返回值，以及将函数赋值给一个变量，这些都是函数式编程的常见特点&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（十）：项目实战</title>
    <link href="https://cherryyang05.github.io/hexo-blog/461e5b43.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/461e5b43.html</id>
    <published>2022-07-03T14:37:57.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。</p></blockquote><span id="more"></span><p>要实现的 grep 命令功能很简单，就是在指定文件中查找指定文字。grep 命令接收一个文件名和字符串作为输入参数，然后读取文件内容，搜索包含指定字符串的行，最终将这些匹配的行打印输出。</p><p>下面开始实战演示。</p><h2 id="一、接收命令行参数"><a href="#一、接收命令行参数" class="headerlink" title="一、接收命令行参数"></a>一、接收命令行参数</h2><p>我们预计使用如下命令来执行该程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run &lt;string&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>因此我们首先要读取命令行中的参数，我们导入函数 <code>use std::env::args()</code>，<code>args()</code> 函数返回一个迭代器，迭代器部分的内容将在后面才会介绍。然后使用 <code>collect</code> 方法，将迭代器中的值转化成一个集合，但是该函数不能处理命令行中非 <code>Unicode</code> 的字符（这种情况可以使用 <code>env::args _os()</code> 函数，这种情况下返回的迭代器值的类型是 <code>OsString</code>，在这里不做介绍）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string filename</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.29</span>s</span><br><span class="line">     Running `target/debug/minigrep string filename`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;filename&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file filename</span><br></pre></td></tr></table></figure><p>根据程序执行结果我们能够得知：返回的第一个参数永远都是该程序的二进制文件（对应 <code>args[0]</code>），从第二个参数开始才是从命令行输入的各种参数（对应 <code>args[1]</code> …）。</p><h2 id="二、读取文件"><a href="#二、读取文件" class="headerlink" title="二、读取文件"></a>二、读取文件</h2><p>首先导入模块 <code>use std::fs</code>，用于处理和文件相关的事务，<code>read_to_string()</code> 用来读取文件中的内容，将其转化成字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run string poem    </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep string poem`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;poem&quot;</span>]</span><br><span class="line">Search <span class="type">String</span> string</span><br><span class="line">In file poem</span><br><span class="line">文件内容:</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For <span class="keyword">if</span> dreams die</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">That can never fly</span><br><span class="line">Hold fast to dreams</span><br><span class="line">For when dreams go</span><br><span class="line">Life is a barren field</span><br><span class="line">Frozen only with snow</span><br><span class="line"></span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br><span class="line">And a heaven <span class="keyword">in</span> a wild flower,</span><br><span class="line">Hold infinity <span class="keyword">in</span> the palm of your hand,</span><br><span class="line">And eternity <span class="keyword">in</span> an hour.</span><br></pre></td></tr></table></figure><p>当然目前看来所有逻辑都放在了主函数中，并且很多错误情况都没有考虑。一般情况下一个函数只做一件事，如果代码逐渐变多，代码维护将变得越来越困难。代码越少重构越简单，因此下一节将对代码进行重构。</p><h2 id="三、重构：改进模块和错误处理"><a href="#三、重构：改进模块和错误处理" class="headerlink" title="三、重构：改进模块和错误处理"></a>三、重构：改进模块和错误处理</h2><h3 id="3-1-四个问题提炼"><a href="#3-1-四个问题提炼" class="headerlink" title="3.1 四个问题提炼"></a>3.1 四个问题提炼</h3><p>我们仔细观察一下目前的代码，主要有四个方面的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Search String &#123;&#125;&quot;</span>, search_string);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>主函数负责的功能较多，既要负责命令行参数解析，又要负责读取文件。而程序编写的原则就是一个函数负责一个功能，因此要将主函数拆分；</li><li><code>search_string</code>、<code>filename</code> 和 <code>content</code> 变量，在程序越来越大之后，变量也会越来越多，将难以追踪每一个变量的实际意义。解决办法是将这些变量放入一个结构体中，从而使其用途更加清晰；</li><li>读取文件时，使用 <code>expect</code> 处理错误，但未对其读取错误的原因进行细分，因为文件打不开可能是文件不存在，文件权限不够，文件损坏等原因；</li><li>对于命令行参数的错误处理，若输入的参数没有两个，那么程序本身就会报错，并且能够预料到的错误一定是 <code>Out of bound</code> 这类的错误，但是对于使用者来说，可能并不清楚这个所谓的 <strong>越界错误</strong> 意味着什么，无法清晰解释错误的具体原因。因此最好要将所有错误处理集中到一起，将来开发者要考虑错误处理的时候，就只要处理这一处代码，这样也能保证为用户打印出有意义的错误信息，而不是只有程序员能看懂的 <code>Out of bound</code>。</li></ol><h3 id="3-2-二进制程序关注点分离的指导性原则"><a href="#3-2-二进制程序关注点分离的指导性原则" class="headerlink" title="3.2 二进制程序关注点分离的指导性原则"></a>3.2 二进制程序关注点分离的指导性原则</h3><ul><li>将程序拆分为 <code>main.rs</code> 和 <code>lib.rs</code>，将业务逻辑放入 <code>lib.rs</code></li><li>当命令行解析逻辑较少时，将它放在 <code>main.rs</code> 也行</li><li>当命令行解析逻辑变复杂时，需要将它从 <code>main.rs</code> 提取到 <code>lib.rs</code></li></ul><p>经过上述拆分，留在 <code>main</code> 的功能有：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>进行其它配置</li><li>调用 <code>lib.rs</code> 中的 <code>run</code> 函数</li><li>处理 <code>run</code> 函数可能出现的错误</li></ul><p>因此放在 <code>main.rs</code> 中的代码量应足够小，小到直接阅读代码就可以确保代码的正确性。将业务逻辑放入 <code>lib.rs</code> 中也方便进行功能测试。</p><p>针对上面说的四个方面的问题，我们逐一进行解决。</p><p><strong>1. 拆分出命令行参数提取功能</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">let</span> (search_string, filename) = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    (search_string, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>parse_config</code> 函数目前返回一个元组，但是在主函数中，又将该元组拆分出来，赋值给两个变量，这样感觉有点“脱裤子放屁”的感觉，来回折腾。实际上这种情况就说明程序中这样设计数据结构是不正确的。因此较好的做法就是将返回的元组中的变量放入一个结构体。</p><p><strong>2. 创建结构体</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建一个叫 <code>Config</code> 的结构体，将 <code>search_string</code> 和 <code>filename</code> 两个变量放入结构体。但是上面的代码会报错，这是因为在函数 <code>parse_config</code> 中，<code>args</code> 参数是切片类型，是没有所有权的（它的所有权被 <code>main</code> 函数拥有），而在最后要返回一个 <code>Config</code> 结构体对象，该结构体需要占用所有权，因此会报错。</p><p>这里用一个简单的方法来处理，就是创建 <code>args[1]</code> 和 <code>args[2]</code> 的两个副本，尽管这样会损失性能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    Config &#123; search_string, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看 <code>parse_config</code> 函数，它返回的是一个结构体，实际上是要创建一个新的结构体，因此我们最好再实现该结构体的 <code>new</code> 函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将刚刚的 <code>parse_config</code> 变成了结构体 <code>Config</code> 的函数。重构后的完整代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 错误处理</strong></p><p>我们不输入参数进行运行，不出预料的会产生下面的错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run       </span><br><span class="line">warning: field is never read: `search_string`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">19</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">19</span> |     search_string: <span class="type">String</span>,</span><br><span class="line">   |     ^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="meta">#[warn(dead_code)]</span>` on by default</span><br><span class="line"></span><br><span class="line">warning: `minigrep` (bin <span class="string">&quot;minigrep&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">thread <span class="symbol">&#x27;main</span>&#x27; panicked at <span class="symbol">&#x27;index</span> out of bounds: the len is <span class="number">1</span> but the index is <span class="number">1</span>&#x27;, src/main.rs:<span class="number">25</span>:<span class="number">29</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>即 <strong>越界错误</strong>，这对于用户来说是无法理解的，我们当然可以在 <code>new</code> 函数中添加这样的判断语句，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样仍然会有编译器的其他信息，一般情况下，使用 <code>panic</code> 通常是程序本身的问题，但是像这类输入参数少的问题属于程序使用的问题，因此我们还需要进行改进，可以返回 <code>Result</code> 枚举，代码如下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    search_string: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数个数不足，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数个数超过 2 个，则返回 <code>Err</code> 的变体，否则返回 <code>Ok</code>。主函数中，<code>unwrap_or_else</code> 函数的含义是，如果枚举返回的是 <code>Ok</code>，那么就取出 <code>Ok</code> 变体中的值返回，若枚举返回的是 <code>Err</code>，那么就调用一个闭包（匿名函数，闭包具体内容将来会介绍），然后使用 <code>process::exit(1)</code> 将程序返回，这样就不会有编译器的其他信息了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run</span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.33</span>s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">参数解析错误：输入参数个数不足，请输入两个参数。</span><br></pre></td></tr></table></figure><p><strong>4. 功能模块化</strong></p><p>一个函数只处理一个功能，因此我们将业务逻辑（即读取文件内容）功能提取到一个新的函数中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;该文件不存在&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们进行 <code>run</code> 函数的错误处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>result&lt;(), Box&lt;dyn Error&gt;&gt;</code> 中第一个参数是空，第二个参数只要理解是一个实现了 <code>Error</code> 这个 <code>trait</code> 的类型，这样函数便可以在不同场景下返回不同的错误类型。</p><p>因为 <code>expect</code> 会引起恐慌，因此将其去掉，改成 <code>?</code>，<code>?</code> 运算符遇到错误不会恐慌，它会将错误值返回给函数的调用者，如果没有发生错误，那么我们最后返回一个 <code>Ok()</code>。</p><p>这时编译器会在 <code>run(config)</code> 出给予警告：<code>this &#39;Result&#39; may be an &#39;Err&#39; variant, which should be handled</code>，这说明函数返回值是一个 <code>Result</code> 类型，那么就说明可能会产生错误，因此需要对其进行处理。</p><p><code>unwrap</code> 有打开的意思，需要从 <code>Result</code> 中提取数据，但是 <code>run</code> 函数没有返回值，因此也就不需要 <code>unwrap</code>，可以像下面这样解决这一问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们将业务逻辑迁移到 <code>lib.rs</code> 中。</p><p><code>lib.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.rs:</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要记得所有函数和结构体以及字段前都要加 <code>pub</code>，这样才能让其他 <code>crate</code> 才能进行调用。这样 <code>lib crate</code> 就有了一套公共的可用于测试的 API。</p><p>重构到这里就基本完成了，下面就要来编写测试了。</p><h2 id="四、使用-TDD（测试驱动开发）开发库功能"><a href="#四、使用-TDD（测试驱动开发）开发库功能" class="headerlink" title="四、使用 TDD（测试驱动开发）开发库功能"></a>四、使用 TDD（测试驱动开发）开发库功能</h2><p>测试驱动开发 TDD (Test-Driven Development)</p><ul><li>编写一个会失败的测试，运行该测试，确保它是按照预期的原因失败</li><li>编写或修改刚好足够的代码，让新测试通过</li><li>重构刚刚添加或修改的代码，确保测试会始终通过</li><li>返回步骤1，继续</li></ul><p>测试驱动开发能够对代码的设计起到指导和帮助的作用，先编写测试，然后再编写能够通过测试的代码，也能保证开发过程中能够保持测试较高的覆盖率。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">use</span> super::*;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>search</code> 函数中返回的引用的生命周期与 <code>content</code> 有关，而与 <code>query</code> 无关。<code>content.lines()</code> 函数返回一个的迭代器，取出文件中的每一行。这样测试代码就完成了，运行测试也是成功的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo test        </span><br><span class="line">   Compiling minigrep v0.<span class="number">1.0</span> (/home/cherry/code/rust/minigrep)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.36</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">662</span>cb87b3d895995)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test test::one_result ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/minigrep-<span class="number">33</span>abce92ed029d2f)</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests minigrep</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><p>然后修改 <code>run</code> 函数并运行 <code>cargo run</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ cargo run is poem </span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep is poem`</span><br><span class="line">Life is a broken-winged bird</span><br><span class="line">Life is a barren field</span><br></pre></td></tr></table></figure><h2 id="五、使用环境变量"><a href="#五、使用环境变量" class="headerlink" title="五、使用环境变量"></a>五、使用环境变量</h2><p>这一部分使用环境变量来实现配置选项（例如是否忽略大小写等）。</p><p>我们首先编写一个测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>], <span class="title function_ invoke__">search_case_insensitive</span>(query, contents));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写 <code>search_case_insensitive</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其思路就是将查询的字符串和文件中的都转化成小写。</p><p>然后我们在 <code>run</code> 函数中加入如下逻辑。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">    <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体的 <code>new</code> 函数也需要修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">        search_string,</span><br><span class="line">        filename,</span><br><span class="line">        case_sensitive</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>env::var()</code> 函数返回的是 <code>Result</code> 枚举，若环境中有 <code>CASE_INSENSITIVE</code> 定义或者赋值，那么就会返回 <code>Ok</code> 中的值，我们这里只需要判断是否为 <code>Err</code> 即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/minigrep git:(master) ✗ CASE_INSENSITIVE=<span class="number">1</span> cargo run to poem</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">     Running `target/debug/minigrep to poem`</span><br><span class="line">Hold fast to dreams</span><br><span class="line">Hold fast to dreams</span><br><span class="line">To see a world <span class="keyword">in</span> a grain of sand,</span><br></pre></td></tr></table></figure><h2 id="六、将错误消息写进标准错误而不是标准输出"><a href="#六、将错误消息写进标准错误而不是标准输出" class="headerlink" title="六、将错误消息写进标准错误而不是标准输出"></a>六、将错误消息写进标准错误而不是标准输出</h2><p>当前我们都将错误信息输出到终端上，而大多数终端提供两种输出，一个是标准输出（stdout，println!），另一个叫标准错误（stderr，eprintln!）。</p><p>我们将打印错误信息的 <code>println!</code> 改成 <code>eprintln!</code> 即可，然后运行 <code>cargo run &gt; output</code>，错误信息便不会输出到文件中，而是打印在终端了。</p><h2 id="七、完整代码"><a href="#七、完整代码" class="headerlink" title="七、完整代码"></a>七、完整代码</h2><p><strong>main.rs:</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;参数解析错误：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;程序运行出错：&#123;&#125;&quot;</span>, e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lib.rs:</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;文件内容:\n&#123;&#125;&quot;, content);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.search_string, &amp;content)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> search_string: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;输入参数错误，请输入两个参数。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">search_string</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            search_string,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, content: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">lines</span> <span class="keyword">in</span> content.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> lines.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(lines);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;Lakers&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;LakErS&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Rust OK,</span></span><br><span class="line"><span class="string">Paul, James, Lakers.</span></span><br><span class="line"><span class="string">What a wonderful day!</span></span><br><span class="line"><span class="string">blakers championship&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Paul, James, Lakers.&quot;</span>, <span class="string">&quot;blakers championship&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、案例：代码统计"><a href="#七、案例：代码统计" class="headerlink" title="七、案例：代码统计"></a>七、案例：代码统计</h2><h3 id="7-1-基本功能介绍"><a href="#7-1-基本功能介绍" class="headerlink" title="7.1 基本功能介绍"></a>7.1 基本功能介绍</h3><p>代码统计以给定的输入参数作为统计对象（可以是文件或文件夹），根据文件后缀名统计代码所使用的语言（暂定只统计 C、C&#x2F;C++ 头文件、C++、Java、Python、Rust、汇编语言、makefile 脚本），然后统计每一种代码文件的有效代码行数、注释行和空行。没有后缀名的文件默认不进行统计。</p><h3 id="7-2-可拓展功能"><a href="#7-2-可拓展功能" class="headerlink" title="7.2 可拓展功能"></a>7.2 可拓展功能</h3><ul><li>丰富统计的语言种类</li><li>命令行中利用参数指定要统计的语言，只统计指定的语言</li><li>加入多线程提高文件扫描速度</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章将介绍 Rust 在实际开发中的使用，并用官方文档上的项目（一个简单版本的 grep 命令）展开讲解，最后将利用之前所学，自己实现一个代码统计的 Rust 项目。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（九）：Rust 宏编程</title>
    <link href="https://cherryyang05.github.io/hexo-blog/c3f8af28.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/c3f8af28.html</id>
    <published>2022-07-02T11:26:35.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C&#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。</p></blockquote><p>【未完】</p><span id="more"></span><h2 id="声明宏"><a href="#声明宏" class="headerlink" title="声明宏"></a>声明宏</h2><p>先来看几个例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> test &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = test!();    <span class="comment">// or test![] or test!&#123;&#125;</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">10</span>, a);</span><br></pre></td></tr></table></figure><p>这是最简单的一个宏，执行的时候，从左侧小括号匹配规则，从右侧进行，这里是直接返回一个数字。使用起来也很容易，宏的使用，用小括号，中括号，大括号都可以。</p><h3 id="给宏传递参数"><a href="#给宏传递参数" class="headerlink" title="给宏传递参数"></a>给宏传递参数</h3><p>宏的匹配能力非常强，还可以匹配变量，表达式，函数等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> test &#123;</span><br><span class="line">    ($var: expr) =&gt; &#123;</span><br><span class="line">        $var</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = test!(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="number">20</span>, a);</span><br></pre></td></tr></table></figure><p>这里的 <code>$e</code> 是自己定的，写成 <code>$a</code>, <code>$b</code>, <code>$foo</code> 之类的都可以，不过还是推荐写得语义化一些。<code>expr</code> 是表达式 <code>expression</code> 的缩写，此外还有其他类型。</p><ul><li>item: 结构体，函数，mod 之类的</li><li>block: 用大括号包起来的语句或者表达式，也就是代码块</li><li>stmt: 一段 statement</li><li>pat: 一段 pattern</li><li>ty: 一个类型</li><li>ident: 标识符</li><li>path: 类似 foo::bar 这种路径</li><li>meta: 元类型，譬如 #[…], #![…] 内的东西</li><li>tt: 一个 token tree</li></ul><p>以 <code>pat</code> 为例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> test &#123;</span><br><span class="line">    ($var: expr, $pattern: pat) =&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> $var &#123;</span><br><span class="line">            $pattern =&gt; <span class="literal">true</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Some</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">d</span> = test!(c, <span class="title function_ invoke__">Some</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, d);</span><br></pre></td></tr></table></figure><p>上述的三个宏可以合到一起。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> test &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ($var: expr) =&gt; &#123;</span><br><span class="line">        $var</span><br><span class="line">    &#125;;</span><br><span class="line">    ($var: expr, $pattern: pat) =&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> $var &#123;</span><br><span class="line">            $pattern =&gt; <span class="literal">true</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>这是 Rust Book 的宏那一节的例子，<code>*</code> 表示重复使用 <code>$()</code> 包裹的内容来处理传进来的值，<code>*</code> 前的 <code>,</code> 是参数的分隔符，<code>*</code> 可以换成正则表达式中的 <code>+</code> 或 <code>?</code>。这个例子中可以处理传入的多个数字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>过程宏必须定义在一个独立的 crate 中。</p><p>【解释】：过程宏是在编译一个 crate 之前，对 crate 的代码进行加工的一段程序，这段程序也是需要编译后执行的。如果定义过程宏和使用过程宏的代码写在一个 crate 中，那么就会陷入死锁：</p><ul><li>要编译的代码首先需要运行过程宏来展开，否则代码就是不完整的，没法编译 crate</li><li>不能编译 crate，那么其中的过程宏代码就没法执行，就不能展开被过程宏装饰的代码</li></ul><p>要开发 rust 过程宏，需要在 <code>Cargo.toml</code> 文件中添加必备的三个依赖包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">proc-macro2 = <span class="string">&quot;1.0.7&quot;</span></span><br><span class="line">quote = <span class="string">&quot;1&quot;</span></span><br><span class="line">syn = &#123; version = <span class="string">&quot;1.0.56&quot;</span>, features = &#123;<span class="string">&quot;full&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; TODO</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C&amp;#x2F;C++、Rust 等语言中，宏编程一直是书本上讲解很少但是在实际开发中却及其重要的内容。宏展开在编译期发生，并没有运行期的性能损耗。Rust 宏分为声明宏和过程宏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;【未完】&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门教程（八）：编写和运行测试</title>
    <link href="https://cherryyang05.github.io/hexo-blog/290a7a7a.html"/>
    <id>https://cherryyang05.github.io/hexo-blog/290a7a7a.html</id>
    <published>2022-06-30T16:52:56.000Z</published>
    <updated>2024-10-25T18:39:01.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust入门教程（八）：编写和运行测试"><a href="#Rust入门教程（八）：编写和运行测试" class="headerlink" title="Rust入门教程（八）：编写和运行测试"></a>Rust入门教程（八）：编写和运行测试</h1><blockquote><p>这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。</p></blockquote><blockquote><p>测试函数体通常执行下面三个操作，也称 <code>3a</code> 操作：</p><ol><li>准备数据或状态（arrange）；</li><li>运行被测试的代码（act）；</li><li>断言结果（assert）。</li></ol></blockquote><span id="more"></span><h2 id="一、测试的使用及演示"><a href="#一、测试的使用及演示" class="headerlink" title="一、测试的使用及演示"></a>一、测试的使用及演示</h2><ul><li>测试函数需要使用 <code>test</code> 属性（attribute）进行标注<ul><li>attribute 就是一段代码的元数据</li><li>在函数紧接着上面一行添加 <code>#[test]</code>，就将函数变成测试函数了</li></ul></li><li>运行测试<ul><li>使用 <code>cargo test</code> 命令运行所有测试<ul><li>Rust 会构建一个 Test Runner 可执行文件，会运行标注的 test 函数，并报告运行是否成功</li></ul></li><li>当使用 cargo 创建 library 项目时，会生成一个 test module，里面有默认的 test 函数<ul><li>可以添加任意数量的 test module 和 test 函数</li></ul></li></ul></li></ul><h3 id="1-1-测试演示"><a href="#1-1-测试演示" class="headerlink" title="1.1 测试演示"></a>1.1 测试演示</h3><p>我们输入命令 <code>cargo new test_demo --lib</code> 创建一个项目，在 <code>lib.rs</code> 文件中看到这样的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>assert_eq!</code> 是一个断言的宏，判断两个数是否相等。</p><p>然后运行 <code>cargo test</code>，结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test               </span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">2.33</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">   Doc-tests test_demo</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br></pre></td></tr></table></figure><h3 id="1-2-测试失败"><a href="#1-2-测试失败" class="headerlink" title="1.2 测试失败"></a>1.2 测试失败</h3><ul><li>测试函数 panic 就表示测试失败</li><li>每个测试都运行在一个新线程中</li><li>当主线程看到测试线程挂掉后，那个测试就被标记为失败</li></ul><p>我们单独编写一个带有 panic 的测试函数，测试结果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">another</span>() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Test Failed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.28</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">2</span> tests</span><br><span class="line">test tests::another ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::another stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::another&#x27; panicked at <span class="symbol">&#x27;Test</span> Failed!&#x27;, src/lib.rs:<span class="number">11</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::another</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">1</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure><h2 id="二、断言"><a href="#二、断言" class="headerlink" title="二、断言"></a>二、断言</h2><h3 id="2-1-使用-assert-宏检查测试结果"><a href="#2-1-使用-assert-宏检查测试结果" class="headerlink" title="2.1 使用 assert! 宏检查测试结果"></a>2.1 使用 assert! 宏检查测试结果</h3><ul><li>assert! 来自于标准库，用来确定某个状态是否为 true<ul><li>如果为 true，表示测试通过</li><li>如果为 false，则调用 panic! 宏，测试失败</li></ul></li></ul><p>我们用之前写的一个小例子，判断矩形 r1 是否能容纳矩形 r2（为了简单起见，只判断正着放，而不考虑斜着放进去）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    x: <span class="type">u32</span>,</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="keyword">if</span> other.x &gt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y</span> = <span class="keyword">if</span> other.x &lt; other.y &#123; other.x &#125; <span class="keyword">else</span> &#123; other.y &#125;;</span><br><span class="line">        <span class="keyword">self</span>.x &gt; x &amp;&amp; <span class="keyword">self</span>.y &gt; y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = Rect &#123; x: <span class="number">12</span>, y: <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = Rect &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(r1.<span class="title function_ invoke__">can_hold</span>(&amp;r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然返回是 true，测试通过。</p><h3 id="2-2-使用-assert-eq-和-assert-ne-测试相等性"><a href="#2-2-使用-assert-eq-和-assert-ne-测试相等性" class="headerlink" title="2.2 使用 assert_eq! 和 assert_ne! 测试相等性"></a>2.2 使用 assert_eq! 和 assert_ne! 测试相等性</h3><ul><li>都来自标准库</li><li>判断两个参数是否相等或不等</li><li>实际上，它们使用的就是 <code>==</code> 和 <code>!=</code> 运算符</li><li>如果断言失败，该宏会自动打印出两个参数的值<ul><li>使用 debug 格式打印参数</li><li>要求参数实现 PartialEq 和 Debug Traits（所有基本类型和标准库里大部分类型基本都实现了）</li><li>如果使用 <code>assert!</code> 宏，则只会告知测试结果而不会打印出两个参数的值</li></ul></li></ul><p>我们再写一个简单的例子，将一个数加 2，判断两个值是否相等。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">it_add_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显然是正确的，若我们更改函数逻辑，把加 2 改成加 3，则运行测试结果为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  ~/code/rust/test_demo git:(master) ✗ cargo test</span><br><span class="line">   Compiling test_demo v0.<span class="number">1.0</span> (/home/cherry/code/rust/test_demo)</span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.39</span>s</span><br><span class="line">     Running <span class="title function_ invoke__">unittests</span> (target/debug/deps/test_demo-<span class="number">357</span>c557c333f0e0d)</span><br><span class="line"></span><br><span class="line">running <span class="number">3</span> tests</span><br><span class="line">test tests::it_add_two ... FAILED</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line">test tests::larger_can_hold_smaller ... ok</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::it_add_two stdout ----</span><br><span class="line">thread <span class="symbol">&#x27;tests</span>::it_add_two&#x27; panicked at <span class="symbol">&#x27;assertion</span> failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">4</span>`,</span><br><span class="line"> right: `<span class="number">5</span>`&#x27;, src/lib.rs:<span class="number">37</span>:<span class="number">9</span></span><br><span class="line">note: run with `RUST_BACKTRACE=<span class="number">1</span>` environment variable to display a backtrace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::it_add_two</span><br><span class="line"></span><br><span class="line">test result: FAILED. <span class="number">2</span> passed; <span class="number">1</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out; finished <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line"></span><br><span class="line">error: test failed, to rerun pass &#x27;--lib&#x27;</span><br></pre></td></tr></table></figure><p>编译器将会自动给出两个参数的值（左值和右值），若将宏改成 <code>assert_ne!</code> 测试结果又将变成正确。</p><h2 id="三、自定义错误消息"><a href="#三、自定义错误消息" class="headerlink" title="三、自定义错误消息"></a>三、自定义错误消息</h2><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust入门教程（八）：编写和运行测试&quot;&gt;&lt;a href=&quot;#Rust入门教程（八）：编写和运行测试&quot; class=&quot;headerlink&quot; title=&quot;Rust入门教程（八）：编写和运行测试&quot;&gt;&lt;/a&gt;Rust入门教程（八）：编写和运行测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这一章主要介绍 Rust 的测试。在 Rust 中，一个测试实际上就是一个函数，用于验证非测试代码的功能是否和预期一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;测试函数体通常执行下面三个操作，也称 &lt;code&gt;3a&lt;/code&gt; 操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备数据或状态（arrange）；&lt;/li&gt;
&lt;li&gt;运行被测试的代码（act）；&lt;/li&gt;
&lt;li&gt;断言结果（assert）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"/>
    
    
    <category term="Rust" scheme="https://cherryyang05.github.io/hexo-blog/tags/Rust/"/>
    
  </entry>
  
</feed>
